<html>
<head>
<style type="text/css">
h1              { background-color: #808080; padding: 0.2em; }
h2              { background-color: #B0B0B0; padding: 0.2em; }
h3              { background-color: #E0E0E0; padding: 0.2em; }
sheader         { }
.inlineheader   { background-color: #E8E8E8; padding: 0.1em; font-weight:bold; }
.pagecontent    { font-family: Arial; font-size: 10pt; width: 770px; text-align: justify; }
.pageheader     { width: 770px; }
.source         { font-family: "Courier New"; font-size: 10pt; }

.p_example      { margin-left: 4em; }
.p_note         { margin-left: 50px; margin-right: 50px; font-size: 80%; }
.p_att          { margin-left: 50px; margin-right: 50px; color: red; font-weight: bold; }
.p_code_head    { margin-left: 50px; margin-top: 50px; margin-bottom:    0; padding: 5px; width: 720px; font-family: "Courier New", monospace; background-color: navy; font-weight: bold; color: white;}
.p_code_body    { margin-left: 50px; margin-top:    0; margin-bottom: 50px; padding: 5px; width: 720px; font-family: "Courier New", monospace; background-color: #F0F0F0; }
.p_code         { margin-left: 50px; margin-top: 50px; margin-bottom: 50px; padding: 5px; width: 720px; font-family: "Courier New", monospace; background-color: #F0F0F0; }
.s_code         { font-family: "Courier New"; background-color: #F0F0F0; }
.s_str          { font-family: "Courier New"; color: blue; font-weight: bold; }
.s_comment      { color: navy; font-style: italic; }
.s_preprocessor { color: green; }

a               { color:#000077; text-decoration: underline; }
a:visited       { color:#000077; text-decoration: underline;}
a:hover         { color:#000077; text-decoration: underline; }

a.toc           { color:#000077; text-decoration: none; }
a.toc:visited   { color:#000077; text-decoration: none;}
a.toc:hover     { color:#000077; text-decoration: underline; }

a.nav           { color:#000077; font-weight:bold; text-decoration: none; }
a.nav:visited   { color:#000077; font-weight:bold; text-decoration: none;}
a.nav:hover     { color:#000077; font-weight:bold; text-decoration: underline; }

.cond           { color:blue; }
.const          { color:#222222; }
.func           { color:#111111; }
</style>
</head>
<body>
<pre>
<a href='#int_main'>1 Introduction</a>
    <a href='#int_license'>1.1 What is ALGLIB</a>
    <a href='#int_license'>1.2 ALGLIB license</a>
    <a href='#int_doc_license'>1.3 Documentation license</a>
    <a href='#gs_guide'>1.4 Reference Manual and User Guide</a>
    <a href='#int_ack'>1.5 Acknowledgements</a>
<a href='#gs_structure'>2 ALGLIB structure</a>
    <a href='#gs_packages'>2.1 Packages</a>
    <a href='#gs_subpackages'>2.2 Subpackages</a>
    <a href='#gs_osscomm'>2.3 Open Source and Commercial versions</a>
<a href='#gs_compatibility'>3 Compatibility</a>
<a href='#gs_compiling'>4 Compiling ALGLIB</a>
    <a href='#gs_attaching'>4.1 Adding to your project</a>
<a href='#gs_comm'>5 Working with commercial version</a>
    <a href='#gs_comm_benefits'>5.1 Benefits of commercial version</a>
    <a href='#gs_comm_smp'>5.2 Using multithreading</a>
        <a href='#gs_comm_smp'>5.2.1 SMT (CMT/hyper-threading) issues</a>
    <a href='#gs_comm_native'>5.3 Using native computational core</a>
        <a href='#gs_comm_native_intro'>5.3.1 Introduction</a>
        <a href='#gs_comm_native_link'>5.3.2 Linking with native core</a>
        <a href='#gs_comm_native_diff'>5.3.3 HPC core vs. Managed core</a>
<a href='#gs_using'>6 Using ALGLIB</a>
    <a href='#gs_using_threadsafety'>6.1 Thread-safety</a>
    <a href='#gs_global'>6.2 ALGLIB classes</a>
    <a href='#gs_datatypes'>6.3 Datatypes</a>
    <a href='#gs_stdfunctions'>6.4 Functions</a>
    <a href='#gs_functions'>6.5 Using functions: 'expert' and 'friendly' interfaces</a>
    <a href='#gs_makecopy'>6.6 Copying ALGLIB objects</a>
    <a href='#gs_csv'>6.7 Reading data from CSV files</a>
<a href='#gs_advanced'>7 Advanced topics</a>
    <a href='#gs_testing'>7.1 Testing ALGLIB</a>
    <a href='#gs_largearrays'>7.2 Working with VERY large arrays</a>
<a href='#alglib_main'>8 ALGLIB packages and subpackages</a>
    <a href='#pck_AlglibMisc'>8.1 <code>AlglibMisc</code> package</a>
    <a href='#pck_DataAnalysis'>8.2 <code>DataAnalysis</code> package</a>
    <a href='#pck_DiffEquations'>8.3 <code>DiffEquations</code> package</a>
    <a href='#pck_FastTransforms'>8.4 <code>FastTransforms</code> package</a>
    <a href='#pck_Integration'>8.5 <code>Integration</code> package</a>
    <a href='#pck_Interpolation'>8.6 <code>Interpolation</code> package</a>
    <a href='#pck_LinAlg'>8.7 <code>LinAlg</code> package</a>
    <a href='#pck_Optimization'>8.8 <code>Optimization</code> package</a>
    <a href='#pck_Solvers'>8.9 <code>Solvers</code> package</a>
    <a href='#pck_SpecialFunctions'>8.10 <code>SpecialFunctions</code> package</a>
    <a href='#pck_Statistics'>8.11 <code>Statistics</code> package</a>

</pre>
<div class=pagecontent>
<a name='int_main' class='sheader'></a><h1>1 Introduction</h1>

<a name='int_license' class='sheader'></a><h2>1.2 1.1 What is ALGLIB</h2>

<p align=justify>
ALGLIB is a cross-platform numerical analysis and data mining library.
It supports several programming languages (C++, C#, Pascal, VBA) and several operating systems (Windows, *nix family).
</p>

<p align=justify>
ALGLIB features include: 
</p>

<ul>
<li>Data analysis (classification/regression, including neural networks)</li>
<li>Optimization and nonlinear solvers</li>
<li>Interpolation and linear/nonlinear least-squares fitting</li>
<li>Linear algebra (direct algorithms, EVD/SVD), direct and iterative linear solvers, Fast Fourier Transform and many other algorithms (numerical integration, ODEs, statistics, special functions)</li>
</ul>

<p align=justify>
ALGLIB Project (the company behind ALGLIB) delivers to you several editions of ALGLIB:
</p>

<ul>
<li><i>ALGLIB Free Edition</i> - full functionality but limited performance</li>
<li><i>ALGLIB Commercial Edition</i> - high-performance version of ALGLIB</li>
</ul>

<p align=justify>
Free Edition is a serial version without multithreading support or extensive low-level optimizations (generic C or C# code).
Commercial Edition is a heavily optimized version of ALGLIB.
It supports multithreading, it was extensively optimized, and (on Intel platforms) -
our commercial users may enjoy precompiled version of ALGLIB which internally calls Intel MKL to accelerate low-level tasks.
We obtained license from Intel corp., which allows us to integrate Intel MKL into ALGLIB, so you don't have to buy separate license from Intel.
</p>

<a name='int_license' class='sheader'></a><h2>1.2 1.1 ALGLIB license</h2>

<p align=justify>
<b>ALGLIB Free Edition</b> is distributed under GPL 2+, GPL license version 2 or at your option any later version.
A copy of the GNU General Public License is available at <a href='http://www.fsf.org/licensing/licenses'>http://www.fsf.org/licensing/licenses</a>
</p>

<p align=justify>
<b>ALGLIB Commercial Edition</b> is distributed under license which is friendly to commericial users.
A copy of the commercial license can be found at <a href='http://www.alglib.net/commercial.php'>http://www.alglib.net/commercial.php</a>.
</p>

<a name='int_doc_license' class='sheader'></a><h2>1.3 Documentation license</h2>

<div style='width: 640px;'>
<p>
<U>This reference manual is licensed under BSD-like documentation license</U>:
</p>

<p>
Copyright 1994-2009 Sergey Bochkanov, ALGLIB Project. All rights reserved.
</p>

<p>
Redistribution and use of this document (ALGLIB Reference Manual) with or without modification,
are permitted provided that such redistributions will retain the above copyright notice,
this condition and the following disclaimer as the first (or last) lines of this file.
</p>

<p>
THIS DOCUMENTATION IS PROVIDED BY THE ALGLIB PROJECT "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ALGLIB PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
</div>

<a name='gs_guide' class='sheader'></a><h2>1.4 Reference Manual and User Guide</h2>

<p>
ALGLIB Project provides two sources of information: ALGLIB Reference Manual (this document) and <a href="http://www.alglib.net/#book">ALGLIB User Guide</a>.
</p>

<p>
ALGLIB Reference Manual contains full description of all publicly accessible ALGLIB units accompanied with examples.
Reference Manual is focused on the source code: it documents units, functions, structures and so on.
If you want to know what unit <code>YYY</code> can do or what subroutines unit <code>ZZZ</code> contains Reference Manual is a place to go.
Free software needs free documentation - that's why ALGLIB Reference Manual is licensed under BSD-like documentation license.
</p>

<p>
Additionally to the Reference Manual we provide you <a href="http://www.alglib.net/#book">User Guide</a>.
User Guide is focused on more general questions: how fast ALGLIB is? how reliable it is? what are the strong and weak sides of the algorithms used?
We aim to make ALGLIB User Guide an important source of information both about ALGLIB and numerical analysis algorithms in general.
We want it to be a book about algorithms, not just software documentation.
And we want it to be unique - that's why ALGLIB User Guide is distributed under less-permissive <a href="http://alglib.net.localhost/#guide_license">personal-use-only license</a>.
</p>

<a name='int_ack' class='sheader'></a><h2>1.5 Acknowledgements</h2>

<p>
ALGLIB was not possible without contribution of the next open source projects:
</p>

<ul>
<li><a href="http://www.netlib.org/lapack/">LAPACK</a></li>
<li><a href="http://www.moshier.net/">Cephes</a></li>
<li><a href="http://gmplib.org/">GNU MP</a></li>
<li><a href="http://www.mpfr.org/">MPFR</a></li>
</ul>

<p>
We also want to thank developers of the Intel's local development center (Nizhny Novgorod branch)
for their help during MKL integration.
</p>




<a name='gs_structure' class='sheader'></a><h1>2 ALGLIB structure</h1>

<a name='gs_packages' class='sheader'></a><h2>2.1 Packages</h2>

<p>
ALGLIB for C# is a pure C# 2.0 library automatically generated by code generation tools developed within ALGLIB project.
Pre-3.0 versions of ALGLIB included more than 100 units, but it was difficult to work with such large number of files.
Since ALGLIB 3.0 all units are merged into 11 <i>packages</i> and two support units:
</p>

<ul>
<li><b>alglibmisc.cs</b>&nbsp;-&nbsp;contains different algorithms which are hard to classify</li>
<li><b>dataanalysis.cs</b>&nbsp;-&nbsp;contains data mining algorithms</li>
<li><b>diffequations.cs</b>&nbsp;-&nbsp;contains differential equation solvers</li>
<li><b>fasttransforms.cs</b>&nbsp;-&nbsp;contains FFT and other related algorithms</li>
<li><b>integration.cs</b>&nbsp;-&nbsp;contains numerical integration algorithms</li>
<li><b>interpolation.cs</b>&nbsp;-&nbsp;contains interpolation algorithms</li>
<li><b>linalg.cs</b>&nbsp;-&nbsp;contains linear algebra algorithms</li>
<li><b>optimization.cs</b>&nbsp;-&nbsp;contains optimization algorithms</li>
<li><b>solvers.cs</b>&nbsp;-&nbsp;contains linear and nonlinear solvers</li>
<li><b>specialfunctions.cs</b>&nbsp;-&nbsp;contains special functions</li>
<li><b>statistics.cs</b>&nbsp;-&nbsp;statistics</li>
<li><i>alglibinternal.cs</i>&nbsp;-&nbsp;contains internal functions which are used by other packages, but not exposed to the external world</li>
<li><i>ap.cs</i>&nbsp;-&nbsp;contains publicly accessible vector/matrix classes, most important and general functions and other "basic" functionality</li>
</ul>

<p>
One package may rely on other ones, but we have tried to reduce number of dependencies.
Every package relies on <code>ap.cs</code> and many packages rely on <code>alglibinternal.cs</code>.
But many packages require only these two to work, and many other packages need significantly less than 13 packages.
For example, <code>statistics.cs</code> requires two packages mentioned above and only one additional package - <code>specialfunctions.cs</code>.
</p>

<a name='gs_subpackages' class='sheader'></a><h2>2.2 Subpackages</h2>

<p>
There is one more concept to learn - <i>subpackages</i>.
Every package was created from several source files.
For example (as of ALGLIB 3.0.0), <code>linalg.cs</code> was created by merging together 14 .cs files.
These files provide different functionality: one of them calculates triangular factorizations, another generates random matrices, and so on.
We've merged source code, but what to do with their documentation?
</p>

<p>
Of course, we can merge their documentation (as we've merged units) in one big list of functions and data structures, but such list will be hard to read.
Instead, we have decided to merge <i>source code</i>, but leave <i>documentation</i> separate.
</p>

<p>
If you look at the <a href='#alglib_packages'>list of ALGLIB packages</a>, you will see that each package includes several subpackages.
For example, <code>linalg.cs</code> includes <code>trfac</code>, <code>svd</code>, <code>evd</code> and other subpackages.
These subpackages do no exist as separate files, namespaces or other entities.
They are just subsets of one large file, one large class, which provide significantly different functionality.
They have separate documentation sections, but if you want to use <code>svd</code> subpackage, you have to compile <code>linalg.cs</code>, not <code>svd.cs</code>.
</p>

<a name='gs_osscomm' class='sheader'></a><h2>2.3 Open Source and Commercial versions</h2>

<p>
ALGLIB comes in two versions - open source (GPL-licensed) and commercial (closed source) one.
Both versions have same <i>functionality</i>, i.e. may solve same set of problems.
However, commercial version differs from open source one in following aspects:
</p>

<ul>
<li>
<b>License</b>.
Commercial ALGLIB is licensed under non-copyleft license which is friendly to commercial users.
</li>
<li>
<b>Performance</b>.
Many algorithms in commercial ALGLIB are multi-threaded.
Open source ALGLIB is single-threaded and can not efficiently use modern multicore CPU's.<br>
You have to study comments on specific functions if you want to know whether they have multithreaded versions or not.
</li>
</ul>

<p>
This documentation applies to both versions of ALGLIB.
Parts specific to commercial versions are explicitly marked as such.
</p>

<a name='gs_compatibility' class='sheader'></a><h1>3 Compatibility</h1>

<p>
ALGLIB for C# is compatible with:
</p>

<ul>
<li>any kind of optimization settings</li>
<li>any CPU which supports .NET</li>
<li>both Microsoft-provided implementation of .NET framework (2.0 or higher) and open source implementation of .NET (Mono).</li>
<li>any C# compiler which support C# 2.0 or later (MS C# compiler or Mono C# compiler)</li>
<li>any OS where .NET framework exists</li>
</ul>

<a name='gs_compiling' class='sheader'></a><h1>4 Compiling ALGLIB</h1>

<a name='gs_attaching' class='sheader'></a><h2>4.1 Adding to your project</h2>

<p>
Adding ALGLIB to your project is easy - just pick packages you need and... add them to your project!
It will work without any additional settings.
</p>

<p>
As you see, ALGLIB has no project files. Why? There are several reasons:
</p>

<ul>
<li>first, because many ALGLIB users don't need separate shared library - they prefer to integrate source code in their projects.
We have provided script-based build system before, but majority of our users prefer to build ALGLIB themselves.
</li>
<li>
second, because we want ALGLIB to be usable in any programming environment, whether it is Visual Studio or Mono.
The best solution is to write package which doesn't depend on any particular programming environment.
</li>
</ul>

<p>
In any case, compiling ALGLIB is so simple that even without project file you can do it in several minutes.
</p>

<a name='gs_comm' class='sheader'></a><h1>5 Working with commercial version</h1>

<a name='gs_comm_benefits' class='sheader'></a><h2>5.1 Benefits of commercial version</h2>

<p>
Commercial version of ALGLIB for C# features three important improvements over open source one:
</p>

<ul>
<li>
<b>License</b>.
Commercial license used by ALGLIB is friendly to closed source applications.
Unlike GPL, it does not require you to open source your application.
Thus, almost any commercial software developer is interested in obtaining commercial license.
</li>
<li>
<b>Multithreading</b>.
Commercial version of ALGLIB can utilize multicore capabilities of modern CPU's.
Large computational problems can be automatically split between different cores.
ALGLIB uses its own multithreading framework which <b>does not</b> depend on vendor/compiler support for technologies like OpenMP/MPI/...
It gives ALGLIB unprecedented portability across operating systems and compilers.
</li>
<li>
<b>High-performance native core</b>.
Commercial version of ALGLIB for C# includes two computational cores: 100% managed core and highly optimized native one.
Both cores have same functionality and identical interface, but they differ in their performance.
Managed core is written in pure C# and can be used in 100% managed environment.
Native core is written in C, supports multithreading, it was compiled with best optimization settings and linked with Intel MKL -
high performance linear algebra and FFT library from Intel.
We obtained license from Intel which allows us to integrate MKL into ALGLIB distribution.
On large-scale computational problems native computational core can be from 2x to 4x times faster than the managed one.
</li>
</ul>

<a name='gs_comm_smp' class='sheader'></a><h2>5.2 Using multithreading</h2>

<p>
Commercial version of ALGLIB includes out-of-the-box support for multithreading.
Many (<i>not all</i>) computationally intensive problems can be solved in multithreaded mode.
You should read comments on specific ALGLIB functions to determine what can be multithreaded and what can not.
</p>

<p>
ALGLIB <b>does not</b> depend on vendor/compiler support for technologies like OpenMP/MPI/...
ALGLIB uses managed threads provided by NET framework.
It gives ALGLIB unprecedented portability across operating systems and compilers.
ALGLIB does not depend on presence of <b>any</b> custom multithreading library
or compiler support for <b>any</b> multithreading technology.
</p>

<p>
If you want to use multithreaded capabilities of ALGLIB, you should:
</p>

<ol>
<li>tell ALGLIB about number of worker threads to use</li>
<li>call multithreaded versions of computational functions</li>
</ol>

<p>
Let explain it in more details...
</p>

<p>
<b>1</b>.
ALGLIB automatically determines number of cores on application startup.
By default, ALGLIB uses all available cores except for one.
Say, on 4-core system it will use three cores - unless being told to use more or less.
It will keep your system responsive during lengthy computations.
Such behavior may be changed with <code>setnworkers()</code> call:
</p>

<ul>
<li><code>alglib.setnworkers(0)</code>  = use all cores</li>
<li><code>alglib.setnworkers(-1)</code> = leave one core unused</li>
<li><code>alglib.setnworkers(-2)</code> = leave two cores unused</li>
<li><code>alglib.setnworkers(+2)</code> = use 2 cores (even if you have more)</li>
</ul>

<p>
You may want to specify maximum number of worker threads during compile time
by means of preprocessor definition <code>AE_NWORKERSX</code> (say, AE_NWORKERS2, AE_NWORKERS4, AE_NWORKERS5).
You can add this definition to compiler command line or change corresponding project settings in your IDE.
Here X can be any positive number.
ALGLIB will use exactly X worker threads, unless being told to use less by <code>setnworkers()</code> call.
</p>

<p>
<b>2</b>.
When you use commercial edition of ALGLIB,
you may choose between serial and multithreaded versions of SMP-capable functions:
</p>
<ul>
<li>serial version works as usual, in the context of the calling thread</li>
<li>multithreaded version (with <code>smp_</code> prefix in its name) creates (or wakes up) worker threads,
inserts task in the worker queue, and waits for completion of the task.
All processing is done in context of worker thread(s).</li>
</ul>
<p>
You should carefully decide what version of function to use.
Starting/stopping worker thread costs tens of thousands of CPU cycles.
Thus you won't get multithreading speedup on small computational problems.
</p>

<a name='gs_comm_smp' class='sheader'></a><h3>5.2.1 SMT (CMT/hyper-threading) issues</h3>

<p>
<i>Simultaneous multithreading (SMT)</i> also known as <i>Hyper-threading</i> (Intel)
and <i>Cluster-based Multithreading</i> (AMD)
is a CPU design where several (usually two) <i>logical</i> cores share resources of one <i>physical</i> core.
Say, on dual-core system with 2x HT scale factor you will see 4 logical cores.
Each pair of these 4 cores, however, share same hardware resources.
Thus, you may get only marginal speedup when running highly optimized software which fully utilizes CPU resources.
</p>

<p>
Say, if one thread occupies floating-point unit,
another thread on the same physical core may work with integer numbers at the same time without any performance penalties.
In this case you may get some speedup due to having additional cores.
But if both threads keep FPU unit 100% busy, they won't get <i>any</i> multithreaded speedup.
</p>

<p>
So, if 2 math-intensive threads are dispatched by OS scheduler to different physical cores,
you will get 2x speedup due to use of multithreading.
But if these threads are dispatched to different logical cores - but same physical core - you won't get any speedup at all!
One physical core will be 100% busy, and another one will be 100% idle.
From the other side, if you start four threads instead of two, your system will be 100% utilized independently of thread scheduling details.
</p>

<p>
Let we stress it one more time - multithreading speedup on SMT systems is highly dependent on number of threads you are running and decisions made by OS scheduler.
<b>It is not 100% deterministic!</b>
With "true SMP" when you run 2 threads, you get 2x speedup (or 1.95, or 1.80 - it depends on algorithm, but this factor is always same).
With SMT when you run 2 threads you may get your 2x speedup - or no speedup at all.
Modern OS schedulers do a good job on single-socket hardware,
but even in this "simple" case they give no guarantees of fair distribution of hardware resources.
And things become a bit tricky when you work with multi-socket hardware.
<b>On SMT systems the only guaranteed way to 100% utilize your CPU is to create as many worker threads as there are logical cores</b>.
In this case OS scheduler has no chance to make its work in a wrong way.
</p>

<a name='gs_comm_native' class='sheader'></a><h2>5.3 Using native computational core</h2>

<a name='gs_comm_native_intro' class='sheader'></a><h3>5.3.1 Introduction</h3>

<p>
Commercial version of ALGLIB for C# includes high-performance native computational core.
It supports multithreading and it was linked with Intel MKL - highly optimized linear algebra and FFT library from Intel.
Many ALGLIB functions are accelerated by MKL.
</p>

<p>
Native core provides same functionality as managed one and has 100% identical interface.
It allows you to switch between native and managed cores as you wish.
You may choose portability of fully managed code - or high performance of native core.
You may change cores during application development - without ever changing code which calls ALGLIB!
</p>

<p>
As of ALGLIB 3.8.1, HPC core can work only on Windows platforms (both x86 and x86_64).
However, we plan to introduce *nix versions of HPC core in future ALGLIB releases!
</p>

<a name='gs_comm_native_link' class='sheader'></a><h3>5.3.2 Linking with native core</h3>

<p>
Native computational core is located in <code>hpc-windows</code> subdirectory of the ALGLIB distribution.
This directory contains following files:
</p>

<ul>
<li>
<code>alglib32_hpc.dll</code> - 32-bit native DLL which includes
C version of ALGLIB compiled with best optimization settings and linked with Intel MKL
(MKL is statically linked and included in resulting DLL)
</li>
<li>
<code>alglib64_hpc.dll</code> - 64-bit native DLL with same functionality
</li>
<li>
<code>alglib_hpc.cs</code> - C# wrapper file which automatically detects platform we are running on (x86 or x64)
and loads appropriate DLL (32-bit or 64-bit one).
</li>
</ul>

<p>
First step is to add C# wrapper file <code>alglib_hpc.cs</code> to your project.
Just compile it with the rest of your application as one more unit.
This wrapper provides exactly same set of classes and methods as managed version of ALGLIB.
However, all method calls are silently redirected to native DLL,
and all ALGLIB objects now wrappers around native data structures.
</p>

<p class='p_att'>
IMPORTANT: you will have to allow "unsafe" code in your application in order to compile ALGLIB wrapper layer.
In can be done by specifying <code>"/insafe+"</code> at command line -
or by changing appropriate field in your project settings.
</p>

<p>
ALGLIB native DLL is automatically loaded during first call of any ALGLIB function.
Wrapper layer detects platform it is running on (x86 or x64) and chooses appropriate DLL
(32-bit or 64-bit one).
Thus your application can be easily moved between 32-bit and 64-bit hosts without recompilation.
</p>

<p class='p_note'>
ALGLIB native DLL's are automatically loaded during first call of ALGLIB functions,
but you may enforce this process by calling <code>alglib.activatealglibcore</code> method.
It can be useful if you running some kind of benchmark -
or just want to perform all "heavy" initialization during application startup.
</p>

<p>
Because HPC ALGLIB is a wrapper around native DLL's, these DLL's must be always accompany your application.
Wrapper layer tries to find native DLL's in the application's home directory.
It works well for "standalone" executables,
but this method may fail when wrapper is a part of assembly which was placed to the GAC.
In such cases you may manually specify path to ALGLIB native DLL's by calling <code>alglib.addsearchpath</code> method.
This method must be called prior to first call of ALGLIB functions.
</p>

<p>
After all steps above are done you may start using commercial version of ALGLIB!
</p>

<a name='gs_comm_native_diff' class='sheader'></a><h3>5.3.3 HPC core vs. Managed core</h3>

<p>
It was told before that HPC core provides same functionality as its managed counterpart.
It means that any application developed with managed core will work with HPC core.
However, there are several notable difference between two cores.
In this section we will outline these differences.
</p>

<p>
<b>Performance</b>. HPC core has better performance on large-scale problems (2x-4x improvement for most tasks),
but it is less suited for small-scale computational problems.
Say, calling HPC linear algebra functions involves copying of managed input arrays to unmanaged memory -
and similar extraction of result from unmanaged memory back to managed world.
Performance impact is negligible when you work with 1000x1000 matrices (multiplying them takes much longer then copying them),
but if you want to multiply 3x3 matrices - you will get better results with managed core,
which performs all work in managed memory.
</p>

<p>
<b>Reproducibility of numerical results</b>.
When your NET application works with floating point data, it may produce a bit different results on different computers.
It is normal situation which is caused by presence of rounding errors, which may have different magnitudes on different machines.
Same situation can be observed with HPC and managed ALGLIB cores - same algorithm may produce <i>a bit</i> different results in different computational cores.
Again, it is not algorithmic error, it just consequence of the fact that CPU works with finite-precision numbers.
</p>

<p>
<b>Memory consumption and management</b>.
Consider situation when you create ALGLIB object
which internally allocates large chunk of ALGLIB-controlled memory,
and then you destroy this object.
</p>

<pre class='p_code_head'>
Working with large data
</pre>
<pre class='p_code_body'>

alglib.kdtree tree;
alglib.kdtreebuild(<i>onegigabyteofdata</i>, ..., <b>out</b> tree); // Pass 1GB of data to object
tree = null;                                          // Destroy object

</pre>

<p>
What will do managed and native versions of ALGLIB after last line?
Pure NET version of ALGLIB stores all its data in managed memory and it will handle this situation just as normal NET application.
Gigabyte-sized memory chunk will be forgotten and reclaimed later during garbage collection.
What is most important, NET framework <i>will be aware</i> that we have 1GB of memory which waits to be collected.
</p>

<p>
However, situation is different with HPC ALGLIB.
This version of ALGLIB stores data in the unmanaged memory.
In HPC ALGLIB, <code>kdtree</code> object stores just opaque pointer to unmanaged data structures.
One gigabyte of data is copied to unmanaged memory, where it is controlled by ALGLIB -
and NET garbage collector is <i>no longer aware about this 1GB-sized block</i>.
It knows about ALGLIB object which is responsible for this data block,
but from the GC's point of view, size of this object is 8 bytes (size of pointer).
It has no way of knowing about large data structures hidden behind this pointer.
</p>

<p>
Of course, <i>this memory won't leak</i>.
After last line <code>kdtree</code> object will become candidate for the next garbage collection run.
It has destructor which will be called during garbage collection,
so ALGLIB will be able to free all memory it is responsible for.
The problem is that you don't know <i>when</i> it will be done.
Because GC do not know about actual size of ALGLIB object,
it may decide that we do not have to perform garbage collection right now.
So it may be beneficial to enforce GC run, as demonstrated below:
</p>

<pre class='p_code_head'>
Working with large data : solution #1
</pre>
<pre class='p_code_body'>

alglib.kdtree tree;
alglib.kdtreebuild(<i>onegigabyteofdata</i>, ..., <b>out</b> tree); // Pass 1GB of data to object
tree = null;                                          // Destroy object
System.GC.Collect();                                  // Enforce immediate GC

</pre>

<p>
Such solution works in most cases.
However, because GC is unaware about actual size of <code>tree</code> object,
sometimes it may decide to put such tiny object (8 bytes!) on hold until the next run.
And next.
And next.
Official documentation from Microsoft says that <code>GC.Collect</code> collects <i>all</i> objects,
but in practice some objects can survive GC run.
</p>

<p>
To handle such situations, HPC ALGLIB includes special method: <code>alglib.deallocateimmediately</code>,
which enforces immediate deallocation of internal data structures owned by ALGLIB object.
After method was called on ALGLIB object, all its memory is released and object becomes unusable.
In managed edition of ALGLIB this method does nothing, just sets variable it accepts to null.
</p>

<pre class='p_code_head'>
Working with large data : solution #2
</pre>
<pre class='p_code_body'>

alglib.kdtree tree;
alglib.kdtreebuild(<i>onegigabyteofdata</i>, ..., <b>out</b> tree); // Pass 1GB of data to object
alglib.deallocateimmediately(ref tree);               // deallocated and set to null

</pre>


<a name='gs_using' class='sheader'></a><h1>6 Using ALGLIB</h1>


<a name='gs_using_threadsafety' class='sheader'></a><h2>6.1 Thread-safety</h2>

<p>
Both open source and commercial versions of ALGLIB are 100% thread-safe
<b>as long as different user threads work with different instances of objects/arrays</b>.
Thread-safety is guaranteed by having no global shared variables.
</p>

<p>
However, <b>any kind</b> of sharing ALGLIB objects/arrays between different threads is potentially hazardous.
Even when this object is <b>seemingly</b> used in read-only mode!
</p>

<p class='p_note'>
Say, you use ALGLIB neural network <i>NET</i> to process two input vectors <i>X0</i> and <i>X1</i>,
and get two output vectors <i>Y0</i> and <i>Y1</i>.
You may decide that neural network is used in read-only mode which does not change state of <i>NET</i>,
because output is written to distinct arrays <i>Y</i>.
Thus, you may want to process these vectors from parallel threads.
<br><br>
But it is <b>not</b> read-only operation, even if it looks like this!
Neural network object <i>NET</i> allocates internal temporary buffers, which are modified by neural processing functions.
Thus, sharing one instance of neural network between two threads is thread-unsafe!
</p>

<a name='gs_global' class='sheader'></a><h2>6.2 ALGLIB classes</h2>

<p>
All ALGLIB functionality is provided by one large class - <code>alglib</code>.
</p>

<a name='gs_datatypes' class='sheader'></a><h2>6.3 Datatypes</h2>

<p>
ALGLIB defines several "basic" datatypes (types which are used across many packages) and many package-specific datatypes.
"Basic" datatypes are defined in <code>ap.cs</code>.
Here is short list:
</p>

<ul>
<li><code>alglib.complex</code>&nbsp;-&nbsp;double precision complex datatype, which supports arithmetic operations</li>
<li><code>alglib.alglibexception</code>&nbsp;-&nbsp;exception which is thrown by library</li>
<li><code>alglib.ndimensional_func</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_grad</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_hess</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_jac</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_pfunc</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_pgrad</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_phess</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_rep</code>&nbsp;-&nbsp;delegate used by optimizers/solvers</li>
<li><code>alglib.ndimensional_ode_rp</code>&nbsp;-&nbsp;delegate used by ODE solver</li>
<li><code>alglib.integrator1_func</code>&nbsp;-&nbsp;delegate used by 1-dimensional integrator</li>
</ul>

<p>
Package-specific datatypes are classes which can be divided into two distinct groups:
</p>

<ul>
<li>"struct-like" classes with public fields</li>
<li>"object-like" classes which have no public fields. You should use ALGLIB functions to work with them.</li>
</ul>

<a name='gs_stdfunctions' class='sheader'></a><h2>6.4 Functions</h2>

<p>
The most important "basic" functions from <code>alglib</code> class are:
</p>

<ul>
<li><code>alglib.math.randomreal()</code>&nbsp;-&nbsp;returns random real number from [0,1)</li>
<li><code>alglib.math.randominteger(mx)</code>&nbsp;-&nbsp;returns random integer number from [0,nx)</li>
<li><code>alglib.math.sqr(x)</code>&nbsp;-&nbsp;returns square of real x</li>
<li><code>alglib.math.csqr(z)</code>&nbsp;-&nbsp;returns square of complex z</li>
<li><code>alglib.math.conj(z)</code>&nbsp;-&nbsp;returns conjugate of complex z</li>
<li><code>alglib.math.abscomplex(z)</code>&nbsp;-&nbsp;returns magnitude of complex z</li>
</ul>

<a name='gs_functions' class='sheader'></a><h2>6.5 Using functions: 'expert' and 'friendly' interfaces</h2>

<p>
Most ALGLIB functions provide two interfaces: 'expert' and 'friendly'. What is the difference between two? When you use 'friendly' interface, ALGLIB:
</p>

<ul>
<li>tries to automatically determine size of input arguments</li>
<li>throws an exception when arguments have inconsistent size (for example, square matrix is expected, but non-square is passed;
another example - two parameters must have same size, but have different size)</li>
<li>if semantics of input parameter assumes that it is symmetric/Hermitian matrix,
checks that lower triangle is equal to upper triangle (conjugate of upper triangle) and throws an exception otherwise</li>
<li>if semantics of output parameter assumes that it is symmetric/Hermitian matrix,
returns full matrix (both upper and lower triangles)</li>
</ul>

<p>
When you use 'expert' interface, ALGLIB:
</p>

<ul>
<li>requires caller to explicitly specify size of input arguments.
If vector/matrix is larger than size being specified (say, N), only N leading elements are used</li>
<li>if semantics of input parameter assumes that it is symmetric/Hermitian matrix,
uses <i>only upper or lower triangle</i> of input matrix and requires caller <i>to specify what triangle to use</i></li>
<li>if semantics of output parameter assumes that it is symmetric/Hermitian matrix, returns only upper or lower triangle
(when you look at specific function, it is clear what triangle is returned)</li>
</ul>

<p>
Here are several examples of 'friendly' and 'expert' interfaces:
</p>

<pre class='p_example'>
double[] x = new double[]{0,1,2,3};
double[] y = new double[]{1,5,3,9};
double[] y2 = new double[]{1,5,3,9,0};
alglib.spline1dinterpolant s;

alglib.spline1dbuildlinear(x, y, 4, out s);  <span class='s_comment'>// 'expert' interface is used</span>
alglib.spline1dbuildlinear(x, y, out s);     <span class='s_comment'>// 'friendly' interface - input size is</span>
                                             <span class='s_comment'>// automatically determined</span>

alglib.spline1dbuildlinear(x, y2, 4, out s); <span class='s_comment'>// y2.length() is 5, but it will work</span>

alglib.spline1dbuildlinear(x, y2, out s);    <span class='s_comment'>// it won't work because sizes of x and y2</span>
                                             <span class='s_comment'>// are inconsistent</span>
</pre>

<p>
'Friendly' interface - matrix semantics:
</p>

<pre class='p_example'>
double[,] a;
alglib.matinvreport  rep;
alglib.ae_int_t      info;

<span class='s_comment'>// </span>
<span class='s_comment'>// 'Friendly' interface: spdmatrixinverse() accepts and returns symmetric matrix</span>
<span class='s_comment'>// </span>

<span class='s_comment'>// symmetric positive definite matrix</span>
a = new double[,]{{2,1},{1,2}};

<span class='s_comment'>// after this line A will contain [[0.66,-0.33],[-0.33,0.66]]</span>
<span class='s_comment'>// which is symmetric too</span>
alglib.spdmatrixinverse(ref a, out info, out rep); 

<span class='s_comment'>// you may try to pass nonsymmetric matrix</span>
a = new double[,]{{2,1},{0,2}};

<span class='s_comment'>// but exception will be thrown in such case</span>
alglib.spdmatrixinverse(ref a, out info, out rep); 
</pre>

<p>
Same function but with 'expert' interface:
</p>

<pre class='p_example'>
double[,] a;
alglib.matinvreport  rep;
alglib.ae_int_t      info;

<span class='s_comment'>// </span>
<span class='s_comment'>// 'Expert' interface, spdmatrixinverse()</span>
<span class='s_comment'>// </span>

<span class='s_comment'>// only upper triangle is used; a[1][0] is initialized by NAN,</span>
<span class='s_comment'>// but it can be arbitrary number</span>
a = new double[,]{{2,1},{Double.NaN,2}};

<span class='s_comment'>// after this line A will contain [[0.66,-0.33],[NAN,0.66]]</span>
<span class='s_comment'>// only upper triangle is modified</span>
alglib.spdmatrixinverse(ref a, 2 <span class='s_comment'>/* N */</span>, true <span class='s_comment'>/* upper triangle is used */</span>, out info, out rep); 
</pre>

<a name='gs_makecopy' class='sheader'></a><h2>6.6 Copying ALGLIB objects</h2>

<p>
Most objects in ALGLIB (optimizers, neural networks and so on) have <code>make_copy()</code> member function
which creates a copy of the object.
This function is defined in parent class <code>alglib.alglibobject</code> and is overridden in classes which inherit from it.
Thus, return type of this function is <code>alglib.alglibobject</code>, i.e. you should explicitly cast it to actial type of the object being copied.
</p>

<a name='gs_csv' class='sheader'></a><h2>6.7 Reading data from CSV files</h2>

<p>
ALGLIB has <code>alglib.read_csv()</code> function
which allows to read data from CSV file.
Entire file is loaded into memory as double precision 2D array.
This function provides following features:
</p>

<ul>
<li>support for ASCI encoding and UTF-8 without BOM (in header names)</li>
<li>ability to use any character (comma/tab/space) as field separator
(as long as it is distinct from one used for decimal point)</li>
<li>ability to use both comma and full stop as decimal point
(as long is decimal point is distinct from field separator).
<li>support for Unix and Windows text files (CR vs CRLF)</li>
</ul>

<p>
See comments on <code>alglib.read_csv()</code> function for more information about its functionality.
</p>

<a name='gs_advanced' class='sheader'></a><h1>7 Advanced topics</h1>

<a name='gs_testing' class='sheader'></a><h2>7.1 Testing ALGLIB</h2>

<p>
There are two test suites in ALGLIB: computational tests and interface tests.
Computational tests are located in <code>/tests/test_c.cs</code>.
They are focused on numerical properties of algorithms, stress testing and "deep" tests (large automatically generated problems).
They require significant amount of time to finish (tens of minutes).
</p>

<p>
Interface tests are located in <code>/tests/test_i.cs</code>.
These tests are focused on ability to correctly pass data between computational core and caller, ability to detect simple problems in inputs,
and on ability to at least compile ALGLIB with your compiler.
They are very fast (about a minute to finish including compilation time).
</p>

<p>
Running test suite is easy - just
</p>

<ol>
<li>compile one of these files (<code>test_c.cs</code> or <code>test_i.cs</code>) along with the rest of the library</li>
<li>launch executable you will get. It may take from several seconds (interface tests) to several minutes (computational tests) to get final results</li>
</ol>

<p>
However, there is no strong reasons to launch tests before using ALGLIB. It was tested with many different compiler settings,
and the very nature of .NET framework and its inherent portability allows us to say that ALGLIB for .NET will work on any system.
</p>

<a name='gs_largearrays' class='sheader'></a><h2>7.2 Working with VERY large arrays</h2>

<p>
Sometimes ALGLIB users have to work with very large computational problems.
For example, RBF interpolation problem with 400.000 points may require several gigabytes of memory for temporary variables (mostly for sparse matrix of coefficients).
The problem is that .NET framework has limitations on array size even on 64-bit systems:
1) array size must be less than 2GB,
2) maximum index in any single dimension is about 2^31,
3) maximum number of elements in array is <i>UInt32MaxValue</i>.
</p>

<p>
The most important restriction is <i>(1)</i> - 2GB limit on array size.
Say, for double precision values we can not have array with more than 2^28 (about 268.000.000) elements,
which is 8 times smaller than limitation imposed by <i>(2)</i> and <i>(3)</i>.
</p>

<p>
However, NET 4.5 has ability to allocate arrays larger than 2GB (with all other restrictions being present).
In order to do so you have to use <code>gcAllowVeryLargeObjects=true</code> in your configuration schema.
With this setting turned on you can allocate double precision arrays with up to 2^31 elements,
which use up to 16GB of memory.
</p>


</div>
<a name='alglib_main' class='sheader'></a><h1>8 ALGLIB packages and subpackages</h1>
<table border=0 cellspacing=0>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_AlglibMisc' class='sheader'></a><h2>8.1 <code>AlglibMisc</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_hqrnd' class=toc>hqrnd</a></td><td width=15>&nbsp;</td><td>High quality random numbers generator</td></tr>
<tr align=left valign=top><td><a href='#unit_nearestneighbor' class=toc>nearestneighbor</a></td><td width=15>&nbsp;</td><td>Nearest neighbor search: approximate and exact</td></tr>
<tr align=left valign=top><td><a href='#unit_xdebug' class=toc>xdebug</a></td><td width=15>&nbsp;</td><td>Debug functions to test ALGLIB interface generator </td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_DataAnalysis' class='sheader'></a><h2>8.2 <code>DataAnalysis</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_bdss' class=toc>bdss</a></td><td width=15>&nbsp;</td><td>Basic dataset functions</td></tr>
<tr align=left valign=top><td><a href='#unit_clustering' class=toc>clustering</a></td><td width=15>&nbsp;</td><td>Clustering functions (hierarchical, k-means, k-means++)</td></tr>
<tr align=left valign=top><td><a href='#unit_datacomp' class=toc>datacomp</a></td><td width=15>&nbsp;</td><td>Backward compatibility functions</td></tr>
<tr align=left valign=top><td><a href='#unit_dforest' class=toc>dforest</a></td><td width=15>&nbsp;</td><td>Decision forest classifier (regression model)</td></tr>
<tr align=left valign=top><td><a href='#unit_filters' class=toc>filters</a></td><td width=15>&nbsp;</td><td>Different filters used in data analysis</td></tr>
<tr align=left valign=top><td><a href='#unit_lda' class=toc>lda</a></td><td width=15>&nbsp;</td><td>Linear discriminant analysis</td></tr>
<tr align=left valign=top><td><a href='#unit_linreg' class=toc>linreg</a></td><td width=15>&nbsp;</td><td>Linear models</td></tr>
<tr align=left valign=top><td><a href='#unit_logit' class=toc>logit</a></td><td width=15>&nbsp;</td><td>Logit models</td></tr>
<tr align=left valign=top><td><a href='#unit_mcpd' class=toc>mcpd</a></td><td width=15>&nbsp;</td><td>Markov Chains for Population/proportional Data</td></tr>
<tr align=left valign=top><td><a href='#unit_mlpbase' class=toc>mlpbase</a></td><td width=15>&nbsp;</td><td>Basic functions for neural networks</td></tr>
<tr align=left valign=top><td><a href='#unit_mlpe' class=toc>mlpe</a></td><td width=15>&nbsp;</td><td>Basic functions for neural ensemble models</td></tr>
<tr align=left valign=top><td><a href='#unit_mlptrain' class=toc>mlptrain</a></td><td width=15>&nbsp;</td><td>Neural network training</td></tr>
<tr align=left valign=top><td><a href='#unit_pca' class=toc>pca</a></td><td width=15>&nbsp;</td><td>Principal component analysis</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_DiffEquations' class='sheader'></a><h2>8.3 <code>DiffEquations</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_odesolver' class=toc>odesolver</a></td><td width=15>&nbsp;</td><td>Ordinary differential equation solver</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_FastTransforms' class='sheader'></a><h2>8.4 <code>FastTransforms</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_conv' class=toc>conv</a></td><td width=15>&nbsp;</td><td>Fast real/complex convolution</td></tr>
<tr align=left valign=top><td><a href='#unit_corr' class=toc>corr</a></td><td width=15>&nbsp;</td><td>Fast real/complex cross-correlation</td></tr>
<tr align=left valign=top><td><a href='#unit_fft' class=toc>fft</a></td><td width=15>&nbsp;</td><td>Real/complex FFT</td></tr>
<tr align=left valign=top><td><a href='#unit_fht' class=toc>fht</a></td><td width=15>&nbsp;</td><td>Real Fast Hartley Transform</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_Integration' class='sheader'></a><h2>8.5 <code>Integration</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_autogk' class=toc>autogk</a></td><td width=15>&nbsp;</td><td>Adaptive 1-dimensional integration</td></tr>
<tr align=left valign=top><td><a href='#unit_gkq' class=toc>gkq</a></td><td width=15>&nbsp;</td><td>Gauss-Kronrod quadrature generator</td></tr>
<tr align=left valign=top><td><a href='#unit_gq' class=toc>gq</a></td><td width=15>&nbsp;</td><td>Gaussian quadrature generator</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_Interpolation' class='sheader'></a><h2>8.6 <code>Interpolation</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_idwint' class=toc>idwint</a></td><td width=15>&nbsp;</td><td>Inverse distance weighting: interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_lsfit' class=toc>lsfit</a></td><td width=15>&nbsp;</td><td>Linear and nonlinear least-squares solvers</td></tr>
<tr align=left valign=top><td><a href='#unit_parametric' class=toc>parametric</a></td><td width=15>&nbsp;</td><td>Parametric curves</td></tr>
<tr align=left valign=top><td><a href='#unit_polint' class=toc>polint</a></td><td width=15>&nbsp;</td><td>Polynomial interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_ratint' class=toc>ratint</a></td><td width=15>&nbsp;</td><td>Rational interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_rbf' class=toc>rbf</a></td><td width=15>&nbsp;</td><td>Scattered 2/3-dimensional interpolation with RBF models</td></tr>
<tr align=left valign=top><td><a href='#unit_spline1d' class=toc>spline1d</a></td><td width=15>&nbsp;</td><td>1D spline interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_spline2d' class=toc>spline2d</a></td><td width=15>&nbsp;</td><td>2D spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#unit_spline3d' class=toc>spline3d</a></td><td width=15>&nbsp;</td><td>3D spline interpolation</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_LinAlg' class='sheader'></a><h2>8.7 <code>LinAlg</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_ablas' class=toc>ablas</a></td><td width=15>&nbsp;</td><td>Level 2 and Level 3 BLAS operations</td></tr>
<tr align=left valign=top><td><a href='#unit_bdsvd' class=toc>bdsvd</a></td><td width=15>&nbsp;</td><td>Bidiagonal SVD</td></tr>
<tr align=left valign=top><td><a href='#unit_evd' class=toc>evd</a></td><td width=15>&nbsp;</td><td>Eigensolvers</td></tr>
<tr align=left valign=top><td><a href='#unit_inverseupdate' class=toc>inverseupdate</a></td><td width=15>&nbsp;</td><td>Sherman-Morrison update of the inverse matrix</td></tr>
<tr align=left valign=top><td><a href='#unit_matdet' class=toc>matdet</a></td><td width=15>&nbsp;</td><td>Determinant calculation</td></tr>
<tr align=left valign=top><td><a href='#unit_matgen' class=toc>matgen</a></td><td width=15>&nbsp;</td><td>Random matrix generation</td></tr>
<tr align=left valign=top><td><a href='#unit_matinv' class=toc>matinv</a></td><td width=15>&nbsp;</td><td>Matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#unit_normestimator' class=toc>normestimator</a></td><td width=15>&nbsp;</td><td>Estimates norm of the sparse matrix (from below)</td></tr>
<tr align=left valign=top><td><a href='#unit_ortfac' class=toc>ortfac</a></td><td width=15>&nbsp;</td><td>Real/complex QR/LQ, bi(tri)diagonal, Hessenberg decompositions</td></tr>
<tr align=left valign=top><td><a href='#unit_rcond' class=toc>rcond</a></td><td width=15>&nbsp;</td><td>Condition number estimate</td></tr>
<tr align=left valign=top><td><a href='#unit_schur' class=toc>schur</a></td><td width=15>&nbsp;</td><td>Schur decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_sparse' class=toc>sparse</a></td><td width=15>&nbsp;</td><td>Sparse matrices</td></tr>
<tr align=left valign=top><td><a href='#unit_spdgevd' class=toc>spdgevd</a></td><td width=15>&nbsp;</td><td>Generalized symmetric eigensolver</td></tr>
<tr align=left valign=top><td><a href='#unit_svd' class=toc>svd</a></td><td width=15>&nbsp;</td><td>Singular value decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_trfac' class=toc>trfac</a></td><td width=15>&nbsp;</td><td>LU and Cholesky decompositions (dense and sparse)</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_Optimization' class='sheader'></a><h2>8.8 <code>Optimization</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_minbleic' class=toc>minbleic</a></td><td width=15>&nbsp;</td><td>Bound constrained optimizer with additional linear equality/inequality constraints </td></tr>
<tr align=left valign=top><td><a href='#unit_mincg' class=toc>mincg</a></td><td width=15>&nbsp;</td><td>Conjugate gradient optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_mincomp' class=toc>mincomp</a></td><td width=15>&nbsp;</td><td>Backward compatibility functions</td></tr>
<tr align=left valign=top><td><a href='#unit_minlbfgs' class=toc>minlbfgs</a></td><td width=15>&nbsp;</td><td>Limited memory BFGS optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minlm' class=toc>minlm</a></td><td width=15>&nbsp;</td><td>Improved Levenberg-Marquardt optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minnlc' class=toc>minnlc</a></td><td width=15>&nbsp;</td><td>Nonlinearly constrained optimizer </td></tr>
<tr align=left valign=top><td><a href='#unit_minns' class=toc>minns</a></td><td width=15>&nbsp;</td><td>Nonsmooth constrained optimizer </td></tr>
<tr align=left valign=top><td><a href='#unit_minqp' class=toc>minqp</a></td><td width=15>&nbsp;</td><td>Quadratic programming with bound and linear equality/inequality constraints </td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_Solvers' class='sheader'></a><h2>8.9 <code>Solvers</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_densesolver' class=toc>densesolver</a></td><td width=15>&nbsp;</td><td>Dense linear system solver</td></tr>
<tr align=left valign=top><td><a href='#unit_lincg' class=toc>lincg</a></td><td width=15>&nbsp;</td><td>Sparse linear CG solver</td></tr>
<tr align=left valign=top><td><a href='#unit_linlsqr' class=toc>linlsqr</a></td><td width=15>&nbsp;</td><td>Sparse linear LSQR solver</td></tr>
<tr align=left valign=top><td><a href='#unit_nleq' class=toc>nleq</a></td><td width=15>&nbsp;</td><td>Solvers for nonlinear equations</td></tr>
<tr align=left valign=top><td><a href='#unit_polynomialsolver' class=toc>polynomialsolver</a></td><td width=15>&nbsp;</td><td>Polynomial solver</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_SpecialFunctions' class='sheader'></a><h2>8.10 <code>SpecialFunctions</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_airyf' class=toc>airyf</a></td><td width=15>&nbsp;</td><td>Airy functions</td></tr>
<tr align=left valign=top><td><a href='#unit_bessel' class=toc>bessel</a></td><td width=15>&nbsp;</td><td>Bessel functions</td></tr>
<tr align=left valign=top><td><a href='#unit_betaf' class=toc>betaf</a></td><td width=15>&nbsp;</td><td>Beta function</td></tr>
<tr align=left valign=top><td><a href='#unit_binomialdistr' class=toc>binomialdistr</a></td><td width=15>&nbsp;</td><td>Binomial distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_chebyshev' class=toc>chebyshev</a></td><td width=15>&nbsp;</td><td>Chebyshev polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_chisquaredistr' class=toc>chisquaredistr</a></td><td width=15>&nbsp;</td><td>Chi-Square distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_dawson' class=toc>dawson</a></td><td width=15>&nbsp;</td><td>Dawson integral</td></tr>
<tr align=left valign=top><td><a href='#unit_elliptic' class=toc>elliptic</a></td><td width=15>&nbsp;</td><td>Elliptic integrals</td></tr>
<tr align=left valign=top><td><a href='#unit_expintegrals' class=toc>expintegrals</a></td><td width=15>&nbsp;</td><td>Exponential integrals</td></tr>
<tr align=left valign=top><td><a href='#unit_fdistr' class=toc>fdistr</a></td><td width=15>&nbsp;</td><td>F-distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_fresnel' class=toc>fresnel</a></td><td width=15>&nbsp;</td><td>Fresnel integrals</td></tr>
<tr align=left valign=top><td><a href='#unit_gammafunc' class=toc>gammafunc</a></td><td width=15>&nbsp;</td><td>Gamma function</td></tr>
<tr align=left valign=top><td><a href='#unit_hermite' class=toc>hermite</a></td><td width=15>&nbsp;</td><td>Hermite polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_ibetaf' class=toc>ibetaf</a></td><td width=15>&nbsp;</td><td>Incomplete beta function</td></tr>
<tr align=left valign=top><td><a href='#unit_igammaf' class=toc>igammaf</a></td><td width=15>&nbsp;</td><td>Incomplete gamma function</td></tr>
<tr align=left valign=top><td><a href='#unit_jacobianelliptic' class=toc>jacobianelliptic</a></td><td width=15>&nbsp;</td><td>Jacobian elliptic functions</td></tr>
<tr align=left valign=top><td><a href='#unit_laguerre' class=toc>laguerre</a></td><td width=15>&nbsp;</td><td>Laguerre polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_legendre' class=toc>legendre</a></td><td width=15>&nbsp;</td><td>Legendre polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_normaldistr' class=toc>normaldistr</a></td><td width=15>&nbsp;</td><td>Normal distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_poissondistr' class=toc>poissondistr</a></td><td width=15>&nbsp;</td><td>Poisson distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_psif' class=toc>psif</a></td><td width=15>&nbsp;</td><td>Psi function</td></tr>
<tr align=left valign=top><td><a href='#unit_studenttdistr' class=toc>studenttdistr</a></td><td width=15>&nbsp;</td><td>Student's t-distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_trigintegrals' class=toc>trigintegrals</a></td><td width=15>&nbsp;</td><td>Trigonometric integrals</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8>
<a name='pck_Statistics' class='sheader'></a><h2>8.11 <code>Statistics</code> package</h2>
</td></tr>
<tr align=left valign=top><td><a href='#unit_basestat' class=toc>basestat</a></td><td width=15>&nbsp;</td><td>Mean, variance, covariance, correlation, etc.</td></tr>
<tr align=left valign=top><td><a href='#unit_correlationtests' class=toc>correlationtests</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: correlation tests</td></tr>
<tr align=left valign=top><td><a href='#unit_jarquebera' class=toc>jarquebera</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Jarque-Bera test</td></tr>
<tr align=left valign=top><td><a href='#unit_mannwhitneyu' class=toc>mannwhitneyu</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Mann-Whitney-U test</td></tr>
<tr align=left valign=top><td><a href='#unit_stest' class=toc>stest</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: sign test</td></tr>
<tr align=left valign=top><td><a href='#unit_studentttests' class=toc>studentttests</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Student's t-test</td></tr>
<tr align=left valign=top><td><a href='#unit_variancetests' class=toc>variancetests</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: F-test and one-sample variance test</td></tr>
<tr align=left valign=top><td><a href='#unit_wsr' class=toc>wsr</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Wilcoxon signed rank test</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
</table>
<a name=unit_ablas></a><h2 class=pageheader><code>ablas</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixcopy' class=toc>cmatrixcopy</a><br>
<a href='#sub_cmatrixgemm' class=toc>cmatrixgemm</a><br>
<a href='#sub_cmatrixherk' class=toc>cmatrixherk</a><br>
<a href='#sub_cmatrixlefttrsm' class=toc>cmatrixlefttrsm</a><br>
<a href='#sub_cmatrixmv' class=toc>cmatrixmv</a><br>
<a href='#sub_cmatrixrank1' class=toc>cmatrixrank1</a><br>
<a href='#sub_cmatrixrighttrsm' class=toc>cmatrixrighttrsm</a><br>
<a href='#sub_cmatrixsyrk' class=toc>cmatrixsyrk</a><br>
<a href='#sub_cmatrixtranspose' class=toc>cmatrixtranspose</a><br>
<a href='#sub_rmatrixcopy' class=toc>rmatrixcopy</a><br>
<a href='#sub_rmatrixenforcesymmetricity' class=toc>rmatrixenforcesymmetricity</a><br>
<a href='#sub_rmatrixgemm' class=toc>rmatrixgemm</a><br>
<a href='#sub_rmatrixlefttrsm' class=toc>rmatrixlefttrsm</a><br>
<a href='#sub_rmatrixmv' class=toc>rmatrixmv</a><br>
<a href='#sub_rmatrixrank1' class=toc>rmatrixrank1</a><br>
<a href='#sub_rmatrixrighttrsm' class=toc>rmatrixrighttrsm</a><br>
<a href='#sub_rmatrixsyrk' class=toc>rmatrixsyrk</a><br>
<a href='#sub_rmatrixtranspose' class=toc>rmatrixtranspose</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_ablas_d_gemm' class=toc>ablas_d_gemm</a></td><td width=15>&nbsp;</td><td>Matrix multiplication (single-threaded)</td></tr>
<tr align=left valign=top><td><a href='#example_ablas_d_syrk' class=toc>ablas_d_syrk</a></td><td width=15>&nbsp;</td><td>Symmetric rank-K update (single-threaded)</td></tr>
<tr align=left valign=top><td><a href='#example_ablas_smp_gemm' class=toc>ablas_smp_gemm</a></td><td width=15>&nbsp;</td><td>Matrix multiplication (multithreaded)</td></tr>
<tr align=left valign=top><td><a href='#example_ablas_smp_syrk' class=toc>ablas_smp_syrk</a></td><td width=15>&nbsp;</td><td>Symmetric rank-K update (multithreaded)</td></tr>
</table></div>
<a name='sub_cmatrixcopy'></a><h3 class=pageheader><code>cmatrixcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Copy

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    B   -   destination matrix, must be large enough to store result
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixcopy(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb)

</div></pre>
<a name='sub_cmatrixgemm'></a><h3 class=pageheader><code>cmatrixgemm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
* C is MxN general matrix
* op1(A) is MxK matrix
* op2(B) is KxN matrix
* &quot;op&quot; may be identity transformation, transposition, conjugate transposition

Additional info:
* cache-oblivious algorithm is used.
* multiplication result replaces C. If Beta=0, C elements are not used in
  calculations (not multiplied by zero - just not referenced)
* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
* if both Beta and Alpha are zero, C is filled by zeros.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

IMPORTANT:

This function does NOT preallocate output matrix C, it MUST be preallocated
by caller prior to calling this function. In case C does not have  enough
space to store result, exception will be generated.

INPUT PARAMETERS
    M       -   matrix size, M&gt;0
    N       -   matrix size, N&gt;0
    K       -   matrix size, K&gt;0
    Alpha   -   coefficient
    A       -   matrix
    IA      -   submatrix offset
    JA      -   submatrix offset
    OpTypeA -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    B       -   matrix
    IB      -   submatrix offset
    JB      -   submatrix offset
    OpTypeB -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    Beta    -   coefficient
    C       -   matrix (PREALLOCATED, large enough to store result)
    IC      -   submatrix offset
    JC      -   submatrix offset

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixgemm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    complex alpha,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    complex[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb,
    <font color=navy>int</font> optypeb,
    complex beta,
    <font color=navy>ref</font> complex[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixgemm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    complex alpha,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    complex[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb,
    <font color=navy>int</font> optypeb,
    complex beta,
    <font color=navy>ref</font> complex[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ablas_d_gemm' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_ablas_smp_gemm' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixherk'></a><h3 class=pageheader><code>cmatrixherk</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
where:
* C is NxN Hermitian matrix given by its upper/lower triangle
* A is NxK matrix when A*A^H is calculated, KxN matrix otherwise

Additional info:
* cache-oblivious algorithm is used.
* multiplication result replaces C. If Beta=0, C elements are not used in
  calculations (not multiplied by zero - just not referenced)
* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
* if both Beta and Alpha are zero, C is filled by zeros.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    N       -   matrix size, N&gt;=0
    K       -   matrix size, K&gt;=0
    Alpha   -   coefficient
    A       -   matrix
    IA      -   submatrix offset (row index)
    JA      -   submatrix offset (column index)
    OpTypeA -   multiplication type:
                * 0 - A*A^H is calculated
                * 2 - A^H*A is calculated
    Beta    -   coefficient
    C       -   preallocated input/output matrix
    IC      -   submatrix offset (row index)
    JC      -   submatrix offset (column index)
    IsUpper -   whether upper or lower triangle of C is updated;
                this function updates only one half of C, leaving
                other half unchanged (not referenced at all).

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixherk(
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> complex[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc,
    <font color=navy>bool</font> isupper)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixherk(
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> complex[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc,
    <font color=navy>bool</font> isupper)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ablas_d_syrk' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_ablas_smp_syrk' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixlefttrsm'></a><h3 class=pageheader><code>cmatrixlefttrsm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates op(A^-1)*X where:
* X is MxN general matrix
* A is MxM upper/lower triangular/unitriangular matrix
* &quot;op&quot; may be identity transformation, transposition, conjugate transposition

Multiplication result replaces X.
Cache-oblivious algorithm is used.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    N   -   matrix size, N&gt;=0
    M   -   matrix size, N&gt;=0
    A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
    I1      -   submatrix offset
    J1      -   submatrix offset
    IsUpper -   whether matrix is upper triangular
    IsUnit  -   whether matrix is unitriangular
    OpType  -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
    I2  -   submatrix offset
    J2  -   submatrix offset

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlefttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> complex[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixlefttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> complex[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)

</div></pre>
<a name='sub_cmatrixmv'></a><h3 class=pageheader><code>cmatrixmv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Matrix-vector product: y := op(A)*x

INPUT PARAMETERS:
    M   -   number of rows of op(A)
            M&gt;=0
    N   -   number of columns of op(A)
            N&gt;=0
    A   -   target matrix
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    OpA -   operation type:
            * OpA=0     =&gt;  op(A) = A
            * OpA=1     =&gt;  op(A) = A^T
            * OpA=2     =&gt;  op(A) = A^H
    X   -   input vector
    IX  -   subvector offset
    IY  -   subvector offset
    Y   -   preallocated matrix, must be large enough to store result

OUTPUT PARAMETERS:
    Y   -   vector which stores result

if M=0, then subroutine does nothing.
if N=0, Y is filled by zeros.


  -- ALGLIB routine --

     28.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixmv(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> opa,
    complex[] x,
    <font color=navy>int</font> ix,
    <font color=navy>ref</font> complex[] y,
    <font color=navy>int</font> iy)

</div></pre>
<a name='sub_cmatrixrank1'></a><h3 class=pageheader><code>cmatrixrank1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rank-1 correction: A := A + u*v'

INPUT PARAMETERS:
    M   -   number of rows
    N   -   number of columns
    A   -   target matrix, MxN submatrix is updated
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    U   -   vector #1
    IU  -   subvector offset
    V   -   vector #2
    IV  -   subvector offset
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixrank1(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>ref</font> complex[] u,
    <font color=navy>int</font> iu,
    <font color=navy>ref</font> complex[] v,
    <font color=navy>int</font> iv)

</div></pre>
<a name='sub_cmatrixrighttrsm'></a><h3 class=pageheader><code>cmatrixrighttrsm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates X*op(A^-1) where:
* X is MxN general matrix
* A is NxN upper/lower triangular/unitriangular matrix
* &quot;op&quot; may be identity transformation, transposition, conjugate transposition

Multiplication result replaces X.
Cache-oblivious algorithm is used.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    N   -   matrix size, N&gt;=0
    M   -   matrix size, N&gt;=0
    A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
    I1      -   submatrix offset
    J1      -   submatrix offset
    IsUpper -   whether matrix is upper triangular
    IsUnit  -   whether matrix is unitriangular
    OpType  -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
    I2  -   submatrix offset
    J2  -   submatrix offset

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixrighttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> complex[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixrighttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> complex[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)

</div></pre>
<a name='sub_cmatrixsyrk'></a><h3 class=pageheader><code>cmatrixsyrk</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine is an older version of CMatrixHERK(), one with wrong  name
(it is HErmitian update, not SYmmetric). It  is  left  here  for  backward
compatibility.

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixsyrk(
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> complex[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc,
    <font color=navy>bool</font> isupper)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixsyrk(
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> complex[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_cmatrixtranspose'></a><h3 class=pageheader><code>cmatrixtranspose</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivous complex &quot;copy-and-transpose&quot;

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    B   -   destination matrix, must be large enough to store result
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixtranspose(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb)

</div></pre>
<a name='sub_rmatrixcopy'></a><h3 class=pageheader><code>rmatrixcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Copy

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    B   -   destination matrix, must be large enough to store result
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixcopy(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb)

</div></pre>
<a name='sub_rmatrixenforcesymmetricity'></a><h3 class=pageheader><code>rmatrixenforcesymmetricity</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This code enforces symmetricy of the matrix by copying Upper part to lower
one (or vice versa).

INPUT PARAMETERS:
    A   -   matrix
    N   -   number of rows/columns
    IsUpper - whether we want to copy upper triangle to lower one (True)
            or vice versa (False).
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixenforcesymmetricity(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_rmatrixgemm'></a><h3 class=pageheader><code>rmatrixgemm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
* C is MxN general matrix
* op1(A) is MxK matrix
* op2(B) is KxN matrix
* &quot;op&quot; may be identity transformation, transposition

Additional info:
* cache-oblivious algorithm is used.
* multiplication result replaces C. If Beta=0, C elements are not used in
  calculations (not multiplied by zero - just not referenced)
* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
* if both Beta and Alpha are zero, C is filled by zeros.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

IMPORTANT:

This function does NOT preallocate output matrix C, it MUST be preallocated
by caller prior to calling this function. In case C does not have  enough
space to store result, exception will be generated.

INPUT PARAMETERS
    M       -   matrix size, M&gt;0
    N       -   matrix size, N&gt;0
    K       -   matrix size, K&gt;0
    Alpha   -   coefficient
    A       -   matrix
    IA      -   submatrix offset
    JA      -   submatrix offset
    OpTypeA -   transformation type:
                * 0 - no transformation
                * 1 - transposition
    B       -   matrix
    IB      -   submatrix offset
    JB      -   submatrix offset
    OpTypeB -   transformation type:
                * 0 - no transformation
                * 1 - transposition
    Beta    -   coefficient
    C       -   PREALLOCATED output matrix, large enough to store result
    IC      -   submatrix offset
    JC      -   submatrix offset

  -- ALGLIB routine --
     2009-2013
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixgemm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb,
    <font color=navy>int</font> optypeb,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> <font color=navy>double</font>[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixgemm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb,
    <font color=navy>int</font> optypeb,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> <font color=navy>double</font>[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ablas_d_gemm' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_ablas_smp_gemm' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixlefttrsm'></a><h3 class=pageheader><code>rmatrixlefttrsm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates op(A^-1)*X where:
* X is MxN general matrix
* A is MxM upper/lower triangular/unitriangular matrix
* &quot;op&quot; may be identity transformation, transposition

Multiplication result replaces X.
Cache-oblivious algorithm is used.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    N   -   matrix size, N&gt;=0
    M   -   matrix size, N&gt;=0
    A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
    I1      -   submatrix offset
    J1      -   submatrix offset
    IsUpper -   whether matrix is upper triangular
    IsUnit  -   whether matrix is unitriangular
    OpType  -   transformation type:
                * 0 - no transformation
                * 1 - transposition
    X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
    I2  -   submatrix offset
    J2  -   submatrix offset

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlefttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> <font color=navy>double</font>[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixlefttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> <font color=navy>double</font>[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)

</div></pre>
<a name='sub_rmatrixmv'></a><h3 class=pageheader><code>rmatrixmv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Matrix-vector product: y := op(A)*x

INPUT PARAMETERS:
    M   -   number of rows of op(A)
    N   -   number of columns of op(A)
    A   -   target matrix
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    OpA -   operation type:
            * OpA=0     =&gt;  op(A) = A
            * OpA=1     =&gt;  op(A) = A^T
    X   -   input vector
    IX  -   subvector offset
    IY  -   subvector offset
    Y   -   preallocated matrix, must be large enough to store result

OUTPUT PARAMETERS:
    Y   -   vector which stores result

if M=0, then subroutine does nothing.
if N=0, Y is filled by zeros.


  -- ALGLIB routine --

     28.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixmv(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> opa,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> ix,
    <font color=navy>ref</font> <font color=navy>double</font>[] y,
    <font color=navy>int</font> iy)

</div></pre>
<a name='sub_rmatrixrank1'></a><h3 class=pageheader><code>rmatrixrank1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rank-1 correction: A := A + u*v'

INPUT PARAMETERS:
    M   -   number of rows
    N   -   number of columns
    A   -   target matrix, MxN submatrix is updated
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    U   -   vector #1
    IU  -   subvector offset
    V   -   vector #2
    IV  -   subvector offset
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixrank1(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>ref</font> <font color=navy>double</font>[] u,
    <font color=navy>int</font> iu,
    <font color=navy>ref</font> <font color=navy>double</font>[] v,
    <font color=navy>int</font> iv)

</div></pre>
<a name='sub_rmatrixrighttrsm'></a><h3 class=pageheader><code>rmatrixrighttrsm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates X*op(A^-1) where:
* X is MxN general matrix
* A is NxN upper/lower triangular/unitriangular matrix
* &quot;op&quot; may be identity transformation, transposition

Multiplication result replaces X.
Cache-oblivious algorithm is used.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    N   -   matrix size, N&gt;=0
    M   -   matrix size, N&gt;=0
    A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
    I1      -   submatrix offset
    J1      -   submatrix offset
    IsUpper -   whether matrix is upper triangular
    IsUnit  -   whether matrix is unitriangular
    OpType  -   transformation type:
                * 0 - no transformation
                * 1 - transposition
    X   -   matrix, actial matrix is stored in X[I2:I2+M-1,J2:J2+N-1]
    I2  -   submatrix offset
    J2  -   submatrix offset

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixrighttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> <font color=navy>double</font>[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixrighttrsm(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> j1,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> <font color=navy>double</font>[,] x,
    <font color=navy>int</font> i2,
    <font color=navy>int</font> j2)

</div></pre>
<a name='sub_rmatrixsyrk'></a><h3 class=pageheader><code>rmatrixsyrk</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates  C=alpha*A*A^T+beta*C  or  C=alpha*A^T*A+beta*C
where:
* C is NxN symmetric matrix given by its upper/lower triangle
* A is NxK matrix when A*A^T is calculated, KxN matrix otherwise

Additional info:
* cache-oblivious algorithm is used.
* multiplication result replaces C. If Beta=0, C elements are not used in
  calculations (not multiplied by zero - just not referenced)
* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
* if both Beta and Alpha are zero, C is filled by zeros.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  Because  starting/stopping  worker  thread always
  ! involves some overhead, parallelism starts to be  profitable  for  N's
  ! larger than 128.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    N       -   matrix size, N&gt;=0
    K       -   matrix size, K&gt;=0
    Alpha   -   coefficient
    A       -   matrix
    IA      -   submatrix offset (row index)
    JA      -   submatrix offset (column index)
    OpTypeA -   multiplication type:
                * 0 - A*A^T is calculated
                * 2 - A^T*A is calculated
    Beta    -   coefficient
    C       -   preallocated input/output matrix
    IC      -   submatrix offset (row index)
    JC      -   submatrix offset (column index)
    IsUpper -   whether C is upper triangular or lower triangular

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixsyrk(
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> <font color=navy>double</font>[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc,
    <font color=navy>bool</font> isupper)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixsyrk(
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>int</font> optypea,
    <font color=navy>double</font> beta,
    <font color=navy>ref</font> <font color=navy>double</font>[,] c,
    <font color=navy>int</font> ic,
    <font color=navy>int</font> jc,
    <font color=navy>bool</font> isupper)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ablas_d_syrk' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_ablas_smp_syrk' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixtranspose'></a><h3 class=pageheader><code>rmatrixtranspose</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivous real &quot;copy-and-transpose&quot;

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    B   -   destination matrix, must be large enough to store result
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixtranspose(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> ia,
    <font color=navy>int</font> ja,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> ib,
    <font color=navy>int</font> jb)

</div></pre>
<a name='example_ablas_d_gemm'></a><h3 class=pageheader>ablas_d_gemm example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{2,1},{1,3}};
    <font color=navy>double</font>[,] b = new <font color=navy>double</font>[,]{{2,1},{0,1}};
    <font color=navy>double</font>[,] c = new <font color=navy>double</font>[,]{{0,0},{0,0}};

    <font color=green>//</font>
    <font color=green>// rmatrixgemm() function allows us to calculate matrix product C:=A*B or</font>
    <font color=green>// to perform more general operation, C:=alpha*op1(A)*op2(B)+beta*C,</font>
    <font color=green>// where A, B, C are rectangular matrices, op(X) can be X or X^T,</font>
    <font color=green>// alpha and beta are scalars.</font>
    <font color=green>//</font>
    <font color=green>// This function:</font>
    <font color=green>// * can apply transposition and/or multiplication by scalar to operands</font>
    <font color=green>// * can use arbitrary part of matrices A/B (given by submatrix offset)</font>
    <font color=green>// * can store result into arbitrary part of C</font>
    <font color=green>// * <font color=navy>for</font> performance reasons requires C to be preallocated</font>
    <font color=green>//</font>
    <font color=green>// Parameters of this function are:</font>
    <font color=green>// * M, N, K            -   sizes of op1(A) (which is MxK), op2(B) (which</font>
    <font color=green>//                          is KxN) and C (which is MxN)</font>
    <font color=green>// * Alpha              -   coefficient before A*B</font>
    <font color=green>// * A, IA, JA          -   matrix A and offset of the submatrix</font>
    <font color=green>// * OpTypeA            -   transformation type:</font>
    <font color=green>//                          0 - no transformation</font>
    <font color=green>//                          1 - transposition</font>
    <font color=green>// * B, IB, JB          -   matrix B and offset of the submatrix</font>
    <font color=green>// * OpTypeB            -   transformation type:</font>
    <font color=green>//                          0 - no transformation</font>
    <font color=green>//                          1 - transposition</font>
    <font color=green>// * Beta               -   coefficient before C</font>
    <font color=green>// * C, IC, JC          -   preallocated matrix C and offset of the submatrix</font>
    <font color=green>//</font>
    <font color=green>// Below we perform simple product C:=A*B (alpha=1, beta=0)</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT: this function works with preallocated C, which must be large</font>
    <font color=green>//            enough to store multiplication result.</font>
    <font color=green>//</font>
    <font color=navy>int</font> m = 2;
    <font color=navy>int</font> n = 2;
    <font color=navy>int</font> k = 2;
    <font color=navy>double</font> alpha = 1.0;
    <font color=navy>int</font> ia = 0;
    <font color=navy>int</font> ja = 0;
    <font color=navy>int</font> optypea = 0;
    <font color=navy>int</font> ib = 0;
    <font color=navy>int</font> jb = 0;
    <font color=navy>int</font> optypeb = 0;
    <font color=navy>double</font> beta = 0.0;
    <font color=navy>int</font> ic = 0;
    <font color=navy>int</font> jc = 0;
    alglib.rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, <font color=navy>ref</font> c, ic, jc);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[4,3],[2,4]]</font>

    <font color=green>//</font>
    <font color=green>// Now we try to apply some simple transformation to operands: C:=A*B^T</font>
    <font color=green>//</font>
    optypeb = 1;
    alglib.rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, <font color=navy>ref</font> c, ic, jc);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[5,1],[5,3]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_ablas_d_syrk'></a><h3 class=pageheader>ablas_d_syrk example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// rmatrixsyrk() function allows us to calculate symmetric rank-K update</font>
    <font color=green>// C := beta*C + alpha*A'*A, where C is square N*N matrix, A is square K*N</font>
    <font color=green>// matrix, alpha and beta are scalars. It is also possible to update by</font>
    <font color=green>// adding A*A' instead of A'*A.</font>
    <font color=green>//</font>
    <font color=green>// Parameters of this function are:</font>
    <font color=green>// * N, K       -   matrix size</font>
    <font color=green>// * Alpha      -   coefficient before A</font>
    <font color=green>// * A, IA, JA  -   matrix and submatrix offsets</font>
    <font color=green>// * OpTypeA    -   multiplication type:</font>
    <font color=green>//                  * 0 - A*A^T is calculated</font>
    <font color=green>//                  * 2 - A^T*A is calculated</font>
    <font color=green>// * Beta       -   coefficient before C</font>
    <font color=green>// * C, IC, JC  -   preallocated input/output matrix and submatrix offsets</font>
    <font color=green>// * IsUpper    -   whether upper or lower triangle of C is updated;</font>
    <font color=green>//                  this function updates only one half of C, leaving</font>
    <font color=green>//                  other half unchanged (not referenced at all).</font>
    <font color=green>//</font>
    <font color=green>// Below we will show how to calculate simple product C:=A'*A</font>
    <font color=green>//</font>
    <font color=green>// NOTE: beta=0 and we <font color=navy>do</font> not use previous value of C, but still it</font>
    <font color=green>//       MUST be preallocated.</font>
    <font color=green>//</font>
    <font color=navy>int</font> n = 2;
    <font color=navy>int</font> k = 1;
    <font color=navy>double</font> alpha = 1.0;
    <font color=navy>int</font> ia = 0;
    <font color=navy>int</font> ja = 0;
    <font color=navy>int</font> optypea = 2;
    <font color=navy>double</font> beta = 0.0;
    <font color=navy>int</font> ic = 0;
    <font color=navy>int</font> jc = 0;
    <font color=navy>bool</font> isupper = true;
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{1,2}};

    <font color=green>// preallocate space to store result</font>
    <font color=navy>double</font>[,] c = new <font color=navy>double</font>[,]{{0,0},{0,0}};

    <font color=green>// calculate product, store result into upper part of c</font>
    alglib.rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, <font color=navy>ref</font> c, ic, jc, isupper);

    <font color=green>// output result.</font>
    <font color=green>// IMPORTANT: lower triangle of C was NOT updated!</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[1,2],[0,4]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_ablas_smp_gemm'></a><h3 class=pageheader>ablas_smp_gemm example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we assume that you already know how to work with</font>
    <font color=green>// rmatrixgemm() function. Below we concentrate on its multithreading</font>
    <font color=green>// capabilities.</font>
    <font color=green>//</font>
    <font color=green>// SMP edition of ALGLIB includes smp_rmatrixgemm() - multithreaded</font>
    <font color=green>// version of rmatrixgemm() function. In the basic edition of ALGLIB</font>
    <font color=green>// (GPL edition or commercial version without SMP support) this function</font>
    <font color=green>// just calls single-threaded stub. So, you may call this function from</font>
    <font color=green>// ANY edition of ALGLIB, but only in SMP edition it will work in really</font>
    <font color=green>// multithreaded mode.</font>
    <font color=green>//</font>
    <font color=green>// In order to use multithreading, you have to:</font>
    <font color=green>// 1) Install SMP edition of ALGLIB.</font>
    <font color=green>// 2) This step is specific <font color=navy>for</font> C++ users: you should activate OS-specific</font>
    <font color=green>//    capabilities of ALGLIB by defining AE_OS=AE_POSIX (<font color=navy>for</font> *nix systems)</font>
    <font color=green>//    or AE_OS=AE_WINDOWS (<font color=navy>for</font> Windows systems).</font>
    <font color=green>//    C# users <font color=navy>do</font> not have to perform this step because C# programs are</font>
    <font color=green>//    portable across different systems without OS-specific tuning.</font>
    <font color=green>// 3) Allow ALGLIB to know about number of worker threads to use:</font>
    <font color=green>//    a) autodetection (C++, C#):</font>
    <font color=green>//          ALGLIB will automatically determine number of CPU cores and</font>
    <font color=green>//          (by default) will use all cores except <font color=navy>for</font> one. Say, on 4-core</font>
    <font color=green>//          system it will use three cores - unless you manually told it</font>
    <font color=green>//          to use more or less. It will keep your system responsive during</font>
    <font color=green>//          lengthy computations.</font>
    <font color=green>//          Such behavior may be changed with setnworkers() call:</font>
    <font color=green>//          * alglib::setnworkers(0)  = use all cores</font>
    <font color=green>//          * alglib::setnworkers(-1) = leave one core unused</font>
    <font color=green>//          * alglib::setnworkers(-2) = leave two cores unused</font>
    <font color=green>//          * alglib::setnworkers(+2) = use 2 cores (even <font color=navy>if</font> you have more)</font>
    <font color=green>//    b) manual specification (C++, C#):</font>
    <font color=green>//          You may want to specify maximum number of worker threads during</font>
    <font color=green>//          compile time by means of preprocessor definition AE_NWORKERS.</font>
    <font color=green>//          For C++ it will be <font color=blue><b>&quot;AE_NWORKERS=X&quot;</b></font> where X can be any positive number.</font>
    <font color=green>//          For C# it is <font color=blue><b>&quot;AE_NWORKERSX&quot;</b></font>, where X should be replaced by number of</font>
    <font color=green>//          workers (AE_NWORKERS2, AE_NWORKERS3, AE_NWORKERS4, ...).</font>
    <font color=green>//          You can add this definition to compiler command line or change</font>
    <font color=green>//          corresponding project settings in your IDE.</font>
    <font color=green>//</font>
    <font color=green>// After you installed and configured SMP edition of ALGLIB, you may choose</font>
    <font color=green>// between serial and multithreaded versions of SMP-capable functions:</font>
    <font color=green>// * serial version works as usual, in the context of the calling thread</font>
    <font color=green>// * multithreaded version (with <font color=blue><b>&quot;smp_&quot;</b></font> prefix) creates (or wakes up) worker</font>
    <font color=green>//   threads, inserts task in the worker queue, and waits <font color=navy>for</font> completion of</font>
    <font color=green>//   the task. All processing is done in context of worker thread(s).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: because starting/stopping worker threads costs thousands of CPU cycles,</font>
    <font color=green>//       you should not use multithreading <font color=navy>for</font> lightweight computational problems.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: some old POSIX-compatible operating systems <font color=navy>do</font> not support</font>
    <font color=green>//       sysconf(_SC_NPROCESSORS_ONLN) system call which is required in order</font>
    <font color=green>//       to automatically determine number of active cores. On these systems</font>
    <font color=green>//       you should specify number of cores manually at compile time.</font>
    <font color=green>//       Without it ALGLIB will run in single-threaded mode.</font>
    <font color=green>//</font>
    <font color=green>// Now, back to our example. In this example we will show you:</font>
    <font color=green>// * how to call SMP version of rmatrixgemm(). Because we work with tiny 2x2</font>
    <font color=green>//   matrices, we won't expect to see ANY speedup from using multithreading.</font>
    <font color=green>//   The only purpose of this demo is to show how to call SMP functions.</font>
    <font color=green>// * how to modify number of worker threads used by ALGLIB</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{2,1},{1,3}};
    <font color=navy>double</font>[,] b = new <font color=navy>double</font>[,]{{2,1},{0,1}};
    <font color=navy>double</font>[,] c = new <font color=navy>double</font>[,]{{0,0},{0,0}};
    <font color=navy>int</font> m = 2;
    <font color=navy>int</font> n = 2;
    <font color=navy>int</font> k = 2;
    <font color=navy>double</font> alpha = 1.0;
    <font color=navy>int</font> ia = 0;
    <font color=navy>int</font> ja = 0;
    <font color=navy>int</font> optypea = 0;
    <font color=navy>int</font> ib = 0;
    <font color=navy>int</font> jb = 0;
    <font color=navy>int</font> optypeb = 0;
    <font color=navy>double</font> beta = 0.0;
    <font color=navy>int</font> ic = 0;
    <font color=navy>int</font> jc = 0;

    <font color=green>// serial code</font>
    c = new <font color=navy>double</font>[,]{{0,0},{0,0}};
    alglib.rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, <font color=navy>ref</font> c, ic, jc);

    <font color=green>// SMP code with default number of worker threads</font>
    c = new <font color=navy>double</font>[,]{{0,0},{0,0}};
    alglib.smp_rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, <font color=navy>ref</font> c, ic, jc);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[4,3],[2,4]]</font>

    <font color=green>// override number of worker threads - use two cores</font>
    alglib.setnworkers(+2);
    c = new <font color=navy>double</font>[,]{{0,0},{0,0}};
    alglib.smp_rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, <font color=navy>ref</font> c, ic, jc);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[4,3],[2,4]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_ablas_smp_syrk'></a><h3 class=pageheader>ablas_smp_syrk example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we assume that you already know how to work with</font>
    <font color=green>// rmatrixsyrk() function. Below we concentrate on its multithreading</font>
    <font color=green>// capabilities.</font>
    <font color=green>//</font>
    <font color=green>// SMP edition of ALGLIB includes smp_rmatrixsyrk() - multithreaded</font>
    <font color=green>// version of rmatrixsyrk() function. In the basic edition of ALGLIB</font>
    <font color=green>// (GPL edition or commercial version without SMP support) this function</font>
    <font color=green>// just calls single-threaded stub. So, you may call this function from</font>
    <font color=green>// ANY edition of ALGLIB, but only in SMP edition it will work in really</font>
    <font color=green>// multithreaded mode.</font>
    <font color=green>//</font>
    <font color=green>// In order to use multithreading, you have to:</font>
    <font color=green>// 1) Install SMP edition of ALGLIB.</font>
    <font color=green>// 2) This step is specific <font color=navy>for</font> C++ users: you should activate OS-specific</font>
    <font color=green>//    capabilities of ALGLIB by defining AE_OS=AE_POSIX (<font color=navy>for</font> *nix systems)</font>
    <font color=green>//    or AE_OS=AE_WINDOWS (<font color=navy>for</font> Windows systems).</font>
    <font color=green>//    C# users <font color=navy>do</font> not have to perform this step because C# programs are</font>
    <font color=green>//    portable across different systems without OS-specific tuning.</font>
    <font color=green>// 3) Allow ALGLIB to know about number of worker threads to use:</font>
    <font color=green>//    a) autodetection (C++, C#):</font>
    <font color=green>//          ALGLIB will automatically determine number of CPU cores and</font>
    <font color=green>//          (by default) will use all cores except <font color=navy>for</font> one. Say, on 4-core</font>
    <font color=green>//          system it will use three cores - unless you manually told it</font>
    <font color=green>//          to use more or less. It will keep your system responsive during</font>
    <font color=green>//          lengthy computations.</font>
    <font color=green>//          Such behavior may be changed with setnworkers() call:</font>
    <font color=green>//          * alglib::setnworkers(0)  = use all cores</font>
    <font color=green>//          * alglib::setnworkers(-1) = leave one core unused</font>
    <font color=green>//          * alglib::setnworkers(-2) = leave two cores unused</font>
    <font color=green>//          * alglib::setnworkers(+2) = use 2 cores (even <font color=navy>if</font> you have more)</font>
    <font color=green>//    b) manual specification (C++, C#):</font>
    <font color=green>//          You may want to specify maximum number of worker threads during</font>
    <font color=green>//          compile time by means of preprocessor definition AE_NWORKERS.</font>
    <font color=green>//          For C++ it will be <font color=blue><b>&quot;AE_NWORKERS=X&quot;</b></font> where X can be any positive number.</font>
    <font color=green>//          For C# it is <font color=blue><b>&quot;AE_NWORKERSX&quot;</b></font>, where X should be replaced by number of</font>
    <font color=green>//          workers (AE_NWORKERS2, AE_NWORKERS3, AE_NWORKERS4, ...).</font>
    <font color=green>//          You can add this definition to compiler command line or change</font>
    <font color=green>//          corresponding project settings in your IDE.</font>
    <font color=green>//</font>
    <font color=green>// After you installed and configured SMP edition of ALGLIB, you may choose</font>
    <font color=green>// between serial and multithreaded versions of SMP-capable functions:</font>
    <font color=green>// * serial version works as usual, in the context of the calling thread</font>
    <font color=green>// * multithreaded version (with <font color=blue><b>&quot;smp_&quot;</b></font> prefix) creates (or wakes up) worker</font>
    <font color=green>//   threads, inserts task in the worker queue, and waits <font color=navy>for</font> completion of</font>
    <font color=green>//   the task. All processing is done in context of worker thread(s).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: because starting/stopping worker threads costs thousands of CPU cycles,</font>
    <font color=green>//       you should not use multithreading <font color=navy>for</font> lightweight computational problems.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: some old POSIX-compatible operating systems <font color=navy>do</font> not support</font>
    <font color=green>//       sysconf(_SC_NPROCESSORS_ONLN) system call which is required in order</font>
    <font color=green>//       to automatically determine number of active cores. On these systems</font>
    <font color=green>//       you should specify number of cores manually at compile time.</font>
    <font color=green>//       Without it ALGLIB will run in single-threaded mode.</font>
    <font color=green>//</font>
    <font color=green>// Now, back to our example. In this example we will show you:</font>
    <font color=green>// * how to call SMP version of rmatrixsyrk(). Because we work with tiny 2x2</font>
    <font color=green>//   matrices, we won't expect to see ANY speedup from using multithreading.</font>
    <font color=green>//   The only purpose of this demo is to show how to call SMP functions.</font>
    <font color=green>// * how to modify number of worker threads used by ALGLIB</font>
    <font color=green>//</font>
    <font color=navy>int</font> n = 2;
    <font color=navy>int</font> k = 1;
    <font color=navy>double</font> alpha = 1.0;
    <font color=navy>int</font> ia = 0;
    <font color=navy>int</font> ja = 0;
    <font color=navy>int</font> optypea = 2;
    <font color=navy>double</font> beta = 0.0;
    <font color=navy>int</font> ic = 0;
    <font color=navy>int</font> jc = 0;
    <font color=navy>bool</font> isupper = true;
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{1,2}};
    <font color=navy>double</font>[,] c = new <font color=navy>double</font>[0,0];

    <font color=green>//</font>
    <font color=green>// Default number of worker threads.</font>
    <font color=green>// Preallocate space to store result, call multithreaded version, test.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: this function updates only one triangular part of C. In our</font>
    <font color=green>//       example we choose to update upper triangle.</font>
    <font color=green>//</font>
    c = new <font color=navy>double</font>[,]{{0,0},{0,0}};
    alglib.smp_rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, <font color=navy>ref</font> c, ic, jc, isupper);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[1,2],[0,4]]</font>

    <font color=green>//</font>
    <font color=green>// Override default number of worker threads (set to 2).</font>
    <font color=green>// Preallocate space to store result, call multithreaded version, test.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: this function updates only one triangular part of C. In our</font>
    <font color=green>//       example we choose to update upper triangle.</font>
    <font color=green>//</font>
    alglib.setnworkers(+2);
    c = new <font color=navy>double</font>[,]{{0,0},{0,0}};
    alglib.smp_rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, <font color=navy>ref</font> c, ic, jc, isupper);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [[1,2],[0,4]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_airyf></a><h2 class=pageheader><code>airyf</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_airy' class=toc>airy</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_airy'></a><h3 class=pageheader><code>airy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Airy function

Solution of the differential equation

y&quot;(x) = xy.

The function returns the two independent solutions Ai, Bi
and their first derivatives Ai'(x), Bi'(x).

Evaluation is by power series summation for small x,
by rational minimax approximations for large x.



ACCURACY:
Error criterion is absolute when function &lt;= 1, relative
when function &gt; 1, except * denotes relative error criterion.
For large negative x, the absolute error increases as x^1.5.
For large positive x, the relative error increases as x^1.5.

Arithmetic  domain   function  # trials      peak         rms
IEEE        -10, 0     Ai        10000       1.6e-15     2.7e-16
IEEE          0, 10    Ai        10000       2.3e-14*    1.8e-15*
IEEE        -10, 0     Ai'       10000       4.6e-15     7.6e-16
IEEE          0, 10    Ai'       10000       1.8e-14*    1.5e-15*
IEEE        -10, 10    Bi        30000       4.2e-15     5.3e-16
IEEE        -10, 10    Bi'       30000       4.9e-15     7.3e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.airy(
    <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> ai,
    <font color=navy>out</font> <font color=navy>double</font> aip,
    <font color=navy>out</font> <font color=navy>double</font> bi,
    <font color=navy>out</font> <font color=navy>double</font> bip)

</div></pre>
<a name=unit_autogk></a><h2 class=pageheader><code>autogk</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_autogkreport' class=toc>autogkreport</a><br>
<a href='#struct_autogkstate' class=toc>autogkstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_autogkintegrate' class=toc>autogkintegrate</a><br>
<a href='#sub_autogkresults' class=toc>autogkresults</a><br>
<a href='#sub_autogksingular' class=toc>autogksingular</a><br>
<a href='#sub_autogksmooth' class=toc>autogksmooth</a><br>
<a href='#sub_autogksmoothw' class=toc>autogksmoothw</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_autogk_d1' class=toc>autogk_d1</a></td><td width=15>&nbsp;</td><td>Integrating f=exp(x) by adaptive integrator</td></tr>
</table></div>
<a name='struct_autogkreport'></a><h3 class=pageheader><code>autogkreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration report:
* TerminationType = completetion code:
    * -5    non-convergence of Gauss-Kronrod nodes
            calculation subroutine.
    * -1    incorrect parameters were specified
    *  1    OK
* Rep.NFEV countains number of function calculations
* Rep.NIntervals contains number of intervals [a,b]
  was partitioned into.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class autogkreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  nintervals;
}

</div></pre>
<a name='struct_autogkstate'></a><h3 class=pageheader><code>autogkstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores state of the integration algorithm.

Although this class has public fields,  they are not intended for external
use. You should use ALGLIB functions to work with this class:
* autogksmooth()/AutoGKSmoothW()/... to create objects
* autogkintegrate() to begin integration
* autogkresults() to get results
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class autogkstate
{
}

</div></pre>
<a name='sub_autogkintegrate'></a><h3 class=pageheader><code>autogkintegrate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to launcn iterations of ODE solver

It accepts following parameters:
    diff    -   callback which calculates dy/dx for given y and x
    obj     -   optional object which is passed to diff; can be NULL


  -- ALGLIB --
     Copyright 07.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> autogkintegrate(autogkstate state, integrator1_func func, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_autogkresults'></a><h3 class=pageheader><code>autogkresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Adaptive integration results

Called after AutoGKIteration returned False.

Input parameters:
    State   -   algorithm state (used by AutoGKIteration).

Output parameters:
    V       -   integral(f(x)dx,a,b)
    Rep     -   optimization report (see AutoGKReport description)

  -- ALGLIB --
     Copyright 14.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.autogkresults(
    autogkstate state,
    <font color=navy>out</font> <font color=navy>double</font> v,
    <font color=navy>out</font> autogkreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_autogksingular'></a><h3 class=pageheader><code>autogksingular</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration on a finite interval [A,B].
Integrand have integrable singularities at A/B.

F(X) must diverge as &quot;(x-A)^alpha&quot; at A, as &quot;(B-x)^beta&quot; at B,  with known
alpha/beta (alpha&gt;-1, beta&gt;-1).  If alpha/beta  are  not known,  estimates
from below can be used (but these estimates should be greater than -1 too).

One  of  alpha/beta variables (or even both alpha/beta) may be equal to 0,
which means than function F(x) is non-singular at A/B. Anyway (singular at
bounds or not), function F(x) is supposed to be continuous on (A,B).

Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
is calculated with accuracy close to the machine precision.

INPUT PARAMETERS:
    A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)
    Alpha   -   power-law coefficient of the F(x) at A,
                Alpha&gt;-1
    Beta    -   power-law coefficient of the F(x) at B,
                Beta&gt;-1

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state

SEE ALSO
    AutoGKSmooth, AutoGKSmoothW, AutoGKResults.


  -- ALGLIB --
     Copyright 06.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.autogksingular(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font> beta,
    <font color=navy>out</font> autogkstate state)

</div></pre>
<a name='sub_autogksmooth'></a><h3 class=pageheader><code>autogksmooth</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration of a smooth function F(x) on a finite interval [a,b].

Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
is calculated with accuracy close to the machine precision.

Algorithm works well only with smooth integrands.  It  may  be  used  with
continuous non-smooth integrands, but with  less  performance.

It should never be used with integrands which have integrable singularities
at lower or upper limits - algorithm may crash. Use AutoGKSingular in such
cases.

INPUT PARAMETERS:
    A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state

SEE ALSO
    AutoGKSmoothW, AutoGKSingular, AutoGKResults.


  -- ALGLIB --
     Copyright 06.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.autogksmooth(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> autogkstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_autogksmoothw'></a><h3 class=pageheader><code>autogksmoothw</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration of a smooth function F(x) on a finite interval [a,b].

This subroutine is same as AutoGKSmooth(), but it guarantees that interval
[a,b] is partitioned into subintervals which have width at most XWidth.

Subroutine  can  be  used  when  integrating nearly-constant function with
narrow &quot;bumps&quot; (about XWidth wide). If &quot;bumps&quot; are too narrow, AutoGKSmooth
subroutine can overlook them.

INPUT PARAMETERS:
    A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state

SEE ALSO
    AutoGKSmooth, AutoGKSingular, AutoGKResults.


  -- ALGLIB --
     Copyright 06.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.autogksmoothw(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font> xwidth,
    <font color=navy>out</font> autogkstate state)

</div></pre>
<a name='example_autogk_d1'></a><h3 class=pageheader>autogk_d1 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> int_function_1_func(<font color=navy>double</font> x, <font color=navy>double</font> xminusa, <font color=navy>double</font> bminusx, <font color=navy>ref</font> <font color=navy>double</font> y, object obj)
{
    <font color=green>// this callback calculates f(x)=exp(x)</font>
    y = Math.Exp(x);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates integration of f=exp(x) on [0,1]:</font>
    <font color=green>// * first, autogkstate is initialized</font>
    <font color=green>// * then we call integration function</font>
    <font color=green>// * and finally we obtain results with autogkresults() call</font>
    <font color=green>//</font>
    <font color=navy>double</font> a = 0;
    <font color=navy>double</font> b = 1;
    alglib.autogkstate s;
    <font color=navy>double</font> v;
    alglib.autogkreport rep;

    alglib.autogksmooth(a, b, <font color=navy>out</font> s);
    alglib.autogkintegrate(s, int_function_1_func, null);
    alglib.autogkresults(s, <font color=navy>out</font> v, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.7182</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_basestat></a><h2 class=pageheader><code>basestat</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cov2' class=toc>cov2</a><br>
<a href='#sub_covm' class=toc>covm</a><br>
<a href='#sub_covm2' class=toc>covm2</a><br>
<a href='#sub_pearsoncorr2' class=toc>pearsoncorr2</a><br>
<a href='#sub_pearsoncorrelation' class=toc>pearsoncorrelation</a><br>
<a href='#sub_pearsoncorrm' class=toc>pearsoncorrm</a><br>
<a href='#sub_pearsoncorrm2' class=toc>pearsoncorrm2</a><br>
<a href='#sub_rankdata' class=toc>rankdata</a><br>
<a href='#sub_rankdatacentered' class=toc>rankdatacentered</a><br>
<a href='#sub_sampleadev' class=toc>sampleadev</a><br>
<a href='#sub_samplekurtosis' class=toc>samplekurtosis</a><br>
<a href='#sub_samplemean' class=toc>samplemean</a><br>
<a href='#sub_samplemedian' class=toc>samplemedian</a><br>
<a href='#sub_samplemoments' class=toc>samplemoments</a><br>
<a href='#sub_samplepercentile' class=toc>samplepercentile</a><br>
<a href='#sub_sampleskewness' class=toc>sampleskewness</a><br>
<a href='#sub_samplevariance' class=toc>samplevariance</a><br>
<a href='#sub_spearmancorr2' class=toc>spearmancorr2</a><br>
<a href='#sub_spearmancorrm' class=toc>spearmancorrm</a><br>
<a href='#sub_spearmancorrm2' class=toc>spearmancorrm2</a><br>
<a href='#sub_spearmanrankcorrelation' class=toc>spearmanrankcorrelation</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_basestat_d_base' class=toc>basestat_d_base</a></td><td width=15>&nbsp;</td><td>Basic functionality (moments, adev, median, percentile)</td></tr>
<tr align=left valign=top><td><a href='#example_basestat_d_c2' class=toc>basestat_d_c2</a></td><td width=15>&nbsp;</td><td>Correlation (covariance) between two random variables</td></tr>
<tr align=left valign=top><td><a href='#example_basestat_d_cm' class=toc>basestat_d_cm</a></td><td width=15>&nbsp;</td><td>Correlation (covariance) between components of random vector</td></tr>
<tr align=left valign=top><td><a href='#example_basestat_d_cm2' class=toc>basestat_d_cm2</a></td><td width=15>&nbsp;</td><td>Correlation (covariance) between two random vectors</td></tr>
</table></div>
<a name='sub_cov2'></a><h3 class=pageheader><code>cov2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
2-sample covariance

Input parameters:
    X       -   sample 1 (array indexes: [0..N-1])
    Y       -   sample 2 (array indexes: [0..N-1])
    N       -   N&gt;=0, sample size:
                * if given, only N leading elements of X/Y are processed
                * if not given, automatically determined from input sizes

Result:
    covariance (zero for N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cov2(<font color=navy>double</font>[] x, <font color=navy>double</font>[] y)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cov2(<font color=navy>double</font>[] x, <font color=navy>double</font>[] y, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_c2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_covm'></a><h3 class=pageheader><code>covm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Covariance matrix

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! with covariance matrices smaller than 128*128.

INPUT PARAMETERS:
    X   -   array[N,M], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    N   -   N&gt;=0, number of observations:
            * if given, only leading N rows of X are used
            * if not given, automatically determined from input size
    M   -   M&gt;0, number of variables:
            * if given, only leading M columns of X are used
            * if not given, automatically determined from input size

OUTPUT PARAMETERS:
    C   -   array[M,M], covariance matrix (zero if N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.covm(<font color=navy>double</font>[,] x, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.covm(<font color=navy>double</font>[,] x, <font color=navy>int</font> n, <font color=navy>int</font> m, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_covm(<font color=navy>double</font>[,] x, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_covm(<font color=navy>double</font>[,] x, <font color=navy>int</font> n, <font color=navy>int</font> m, <font color=navy>out</font> <font color=navy>double</font>[,] c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_covm2'></a><h3 class=pageheader><code>covm2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cross-covariance matrix

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! with covariance matrices smaller than 128*128.

INPUT PARAMETERS:
    X   -   array[N,M1], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    Y   -   array[N,M2], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    N   -   N&gt;=0, number of observations:
            * if given, only leading N rows of X/Y are used
            * if not given, automatically determined from input sizes
    M1  -   M1&gt;0, number of variables in X:
            * if given, only leading M1 columns of X are used
            * if not given, automatically determined from input size
    M2  -   M2&gt;0, number of variables in Y:
            * if given, only leading M1 columns of X are used
            * if not given, automatically determined from input size

OUTPUT PARAMETERS:
    C   -   array[M1,M2], cross-covariance matrix (zero if N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.covm2(<font color=navy>double</font>[,] x, <font color=navy>double</font>[,] y, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.covm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m1,
    <font color=navy>int</font> m2,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_covm2(<font color=navy>double</font>[,] x, <font color=navy>double</font>[,] y, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_covm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m1,
    <font color=navy>int</font> m2,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pearsoncorr2'></a><h3 class=pageheader><code>pearsoncorr2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Pearson product-moment correlation coefficient

Input parameters:
    X       -   sample 1 (array indexes: [0..N-1])
    Y       -   sample 2 (array indexes: [0..N-1])
    N       -   N&gt;=0, sample size:
                * if given, only N leading elements of X/Y are processed
                * if not given, automatically determined from input sizes

Result:
    Pearson product-moment correlation coefficient
    (zero for N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.pearsoncorr2(<font color=navy>double</font>[] x, <font color=navy>double</font>[] y)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.pearsoncorr2(<font color=navy>double</font>[] x, <font color=navy>double</font>[] y, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_c2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pearsoncorrelation'></a><h3 class=pageheader><code>pearsoncorrelation</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete function, we recommend to use PearsonCorr2().

  -- ALGLIB --
     Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.pearsoncorrelation(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_pearsoncorrm'></a><h3 class=pageheader><code>pearsoncorrm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Pearson product-moment correlation matrix

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! with correlation matrices smaller than 128*128.

INPUT PARAMETERS:
    X   -   array[N,M], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    N   -   N&gt;=0, number of observations:
            * if given, only leading N rows of X are used
            * if not given, automatically determined from input size
    M   -   M&gt;0, number of variables:
            * if given, only leading M columns of X are used
            * if not given, automatically determined from input size

OUTPUT PARAMETERS:
    C   -   array[M,M], correlation matrix (zero if N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pearsoncorrm(<font color=navy>double</font>[,] x, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pearsoncorrm(
    <font color=navy>double</font>[,] x,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_pearsoncorrm(<font color=navy>double</font>[,] x, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_pearsoncorrm(
    <font color=navy>double</font>[,] x,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pearsoncorrm2'></a><h3 class=pageheader><code>pearsoncorrm2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Pearson product-moment cross-correlation matrix

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! with correlation matrices smaller than 128*128.

INPUT PARAMETERS:
    X   -   array[N,M1], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    Y   -   array[N,M2], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    N   -   N&gt;=0, number of observations:
            * if given, only leading N rows of X/Y are used
            * if not given, automatically determined from input sizes
    M1  -   M1&gt;0, number of variables in X:
            * if given, only leading M1 columns of X are used
            * if not given, automatically determined from input size
    M2  -   M2&gt;0, number of variables in Y:
            * if given, only leading M1 columns of X are used
            * if not given, automatically determined from input size

OUTPUT PARAMETERS:
    C   -   array[M1,M2], cross-correlation matrix (zero if N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pearsoncorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pearsoncorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m1,
    <font color=navy>int</font> m2,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_pearsoncorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_pearsoncorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m1,
    <font color=navy>int</font> m2,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rankdata'></a><h3 class=pageheader><code>rankdata</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function replaces data in XY by their ranks:
* XY is processed row-by-row
* rows are processed separately
* tied data are correctly handled (tied ranks are calculated)
* ranking starts from 0, ends at NFeatures-1
* sum of within-row values is equal to (NFeatures-1)*NFeatures/2

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! ones where expected operations count is less than 100.000

INPUT PARAMETERS:
    XY      -   array[NPoints,NFeatures], dataset
    NPoints -   number of points
    NFeatures-  number of features

OUTPUT PARAMETERS:
    XY      -   data are replaced by their within-row ranks;
                ranking starts from 0, ends at NFeatures-1

  -- ALGLIB --
     Copyright 18.04.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rankdata(<font color=navy>ref</font> <font color=navy>double</font>[,] xy)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rankdata(
    <font color=navy>ref</font> <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rankdata(<font color=navy>ref</font> <font color=navy>double</font>[,] xy)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rankdata(
    <font color=navy>ref</font> <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures)

</div></pre>
<a name='sub_rankdatacentered'></a><h3 class=pageheader><code>rankdatacentered</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function replaces data in XY by their CENTERED ranks:
* XY is processed row-by-row
* rows are processed separately
* tied data are correctly handled (tied ranks are calculated)
* centered ranks are just usual ranks, but centered in such way  that  sum
  of within-row values is equal to 0.0.
* centering is performed by subtracting mean from each row, i.e it changes
  mean value, but does NOT change higher moments

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! ones where expected operations count is less than 100.000

INPUT PARAMETERS:
    XY      -   array[NPoints,NFeatures], dataset
    NPoints -   number of points
    NFeatures-  number of features

OUTPUT PARAMETERS:
    XY      -   data are replaced by their within-row ranks;
                ranking starts from 0, ends at NFeatures-1

  -- ALGLIB --
     Copyright 18.04.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rankdatacentered(<font color=navy>ref</font> <font color=navy>double</font>[,] xy)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rankdatacentered(
    <font color=navy>ref</font> <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rankdatacentered(<font color=navy>ref</font> <font color=navy>double</font>[,] xy)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rankdatacentered(
    <font color=navy>ref</font> <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures)

</div></pre>
<a name='sub_sampleadev'></a><h3 class=pageheader><code>sampleadev</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
ADev

Input parameters:
    X   -   sample
    N   -   N&gt;=0, sample size:
            * if given, only leading N elements of X are processed
            * if not given, automatically determined from size of X

Output parameters:
    ADev-   ADev

  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sampleadev(<font color=navy>double</font>[] x, <font color=navy>out</font> <font color=navy>double</font> adev)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sampleadev(<font color=navy>double</font>[] x, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font> adev)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_samplekurtosis'></a><h3 class=pageheader><code>samplekurtosis</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the kurtosis.

INPUT PARAMETERS:
    X       -   sample
    N       -   N&gt;=0, sample size:
                * if given, only leading N elements of X are processed
                * if not given, automatically determined from size of X

NOTE:

This function return result  which calculated by 'SampleMoments' function
and stored at 'Kurtosis' variable.


  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.samplekurtosis(<font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.samplekurtosis(<font color=navy>double</font>[] x, <font color=navy>int</font> n)

</div></pre>
<a name='sub_samplemean'></a><h3 class=pageheader><code>samplemean</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the mean.

INPUT PARAMETERS:
    X       -   sample
    N       -   N&gt;=0, sample size:
                * if given, only leading N elements of X are processed
                * if not given, automatically determined from size of X

NOTE:

This function return result  which calculated by 'SampleMoments' function
and stored at 'Mean' variable.


  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.samplemean(<font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.samplemean(<font color=navy>double</font>[] x, <font color=navy>int</font> n)

</div></pre>
<a name='sub_samplemedian'></a><h3 class=pageheader><code>samplemedian</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Median calculation.

Input parameters:
    X   -   sample (array indexes: [0..N-1])
    N   -   N&gt;=0, sample size:
            * if given, only leading N elements of X are processed
            * if not given, automatically determined from size of X

Output parameters:
    Median

  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.samplemedian(<font color=navy>double</font>[] x, <font color=navy>out</font> <font color=navy>double</font> median)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.samplemedian(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font> median)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_samplemoments'></a><h3 class=pageheader><code>samplemoments</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the distribution moments: mean, variance, skewness, kurtosis.

INPUT PARAMETERS:
    X       -   sample
    N       -   N&gt;=0, sample size:
                * if given, only leading N elements of X are processed
                * if not given, automatically determined from size of X

OUTPUT PARAMETERS
    Mean    -   mean.
    Variance-   variance.
    Skewness-   skewness (if variance&lt;&gt;0; zero otherwise).
    Kurtosis-   kurtosis (if variance&lt;&gt;0; zero otherwise).

NOTE: variance is calculated by dividing sum of squares by N-1, not N.

  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.samplemoments(
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font> mean,
    <font color=navy>out</font> <font color=navy>double</font> variance,
    <font color=navy>out</font> <font color=navy>double</font> skewness,
    <font color=navy>out</font> <font color=navy>double</font> kurtosis)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.samplemoments(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font> mean,
    <font color=navy>out</font> <font color=navy>double</font> variance,
    <font color=navy>out</font> <font color=navy>double</font> skewness,
    <font color=navy>out</font> <font color=navy>double</font> kurtosis)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_samplepercentile'></a><h3 class=pageheader><code>samplepercentile</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Percentile calculation.

Input parameters:
    X   -   sample (array indexes: [0..N-1])
    N   -   N&gt;=0, sample size:
            * if given, only leading N elements of X are processed
            * if not given, automatically determined from size of X
    P   -   percentile (0&lt;=P&lt;=1)

Output parameters:
    V   -   percentile

  -- ALGLIB --
     Copyright 01.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.samplepercentile(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> p,
    <font color=navy>out</font> <font color=navy>double</font> v)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.samplepercentile(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font> p,
    <font color=navy>out</font> <font color=navy>double</font> v)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_sampleskewness'></a><h3 class=pageheader><code>sampleskewness</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the skewness.

INPUT PARAMETERS:
    X       -   sample
    N       -   N&gt;=0, sample size:
                * if given, only leading N elements of X are processed
                * if not given, automatically determined from size of X

NOTE:

This function return result  which calculated by 'SampleMoments' function
and stored at 'Skewness' variable.


  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.sampleskewness(<font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.sampleskewness(<font color=navy>double</font>[] x, <font color=navy>int</font> n)

</div></pre>
<a name='sub_samplevariance'></a><h3 class=pageheader><code>samplevariance</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the variance.

INPUT PARAMETERS:
    X       -   sample
    N       -   N&gt;=0, sample size:
                * if given, only leading N elements of X are processed
                * if not given, automatically determined from size of X

NOTE:

This function return result  which calculated by 'SampleMoments' function
and stored at 'Variance' variable.


  -- ALGLIB --
     Copyright 06.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.samplevariance(<font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.samplevariance(<font color=navy>double</font>[] x, <font color=navy>int</font> n)

</div></pre>
<a name='sub_spearmancorr2'></a><h3 class=pageheader><code>spearmancorr2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Spearman's rank correlation coefficient

Input parameters:
    X       -   sample 1 (array indexes: [0..N-1])
    Y       -   sample 2 (array indexes: [0..N-1])
    N       -   N&gt;=0, sample size:
                * if given, only N leading elements of X/Y are processed
                * if not given, automatically determined from input sizes

Result:
    Spearman's rank correlation coefficient
    (zero for N=0 or N=1)

  -- ALGLIB --
     Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spearmancorr2(<font color=navy>double</font>[] x, <font color=navy>double</font>[] y)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spearmancorr2(<font color=navy>double</font>[] x, <font color=navy>double</font>[] y, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_c2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmancorrm'></a><h3 class=pageheader><code>spearmancorrm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Spearman's rank correlation matrix

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! with correlation matrices smaller than 128*128.

INPUT PARAMETERS:
    X   -   array[N,M], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    N   -   N&gt;=0, number of observations:
            * if given, only leading N rows of X are used
            * if not given, automatically determined from input size
    M   -   M&gt;0, number of variables:
            * if given, only leading M columns of X are used
            * if not given, automatically determined from input size

OUTPUT PARAMETERS:
    C   -   array[M,M], correlation matrix (zero if N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spearmancorrm(<font color=navy>double</font>[,] x, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spearmancorrm(
    <font color=navy>double</font>[,] x,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spearmancorrm(<font color=navy>double</font>[,] x, <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spearmancorrm(
    <font color=navy>double</font>[,] x,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmancorrm2'></a><h3 class=pageheader><code>spearmancorrm2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Spearman's rank cross-correlation matrix

SMP EDITION OF ALGLIB:

  ! This function can utilize multicore capabilities of  your system.  In
  ! order to do this you have to call version with &quot;smp_&quot; prefix,   which
  ! indicates that multicore code will be used.
  !
  ! This note is given for users of SMP edition; if you use GPL  edition,
  ! or commercial edition of ALGLIB without SMP support, you  still  will
  ! be able to call smp-version of this function,  but  all  computations
  ! will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.
  !
  ! You should remember that starting/stopping worker thread always  have
  ! non-zero cost. Although  multicore  version  is  pretty  efficient on
  ! large problems, we do not recommend you to use it on small problems -
  ! with correlation matrices smaller than 128*128.

INPUT PARAMETERS:
    X   -   array[N,M1], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    Y   -   array[N,M2], sample matrix:
            * J-th column corresponds to J-th variable
            * I-th row corresponds to I-th observation
    N   -   N&gt;=0, number of observations:
            * if given, only leading N rows of X/Y are used
            * if not given, automatically determined from input sizes
    M1  -   M1&gt;0, number of variables in X:
            * if given, only leading M1 columns of X are used
            * if not given, automatically determined from input size
    M2  -   M2&gt;0, number of variables in Y:
            * if given, only leading M1 columns of X are used
            * if not given, automatically determined from input size

OUTPUT PARAMETERS:
    C   -   array[M1,M2], cross-correlation matrix (zero if N=0 or N=1)

  -- ALGLIB --
     Copyright 28.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spearmancorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spearmancorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m1,
    <font color=navy>int</font> m2,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spearmancorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spearmancorrm2(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[,] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m1,
    <font color=navy>int</font> m2,
    <font color=navy>out</font> <font color=navy>double</font>[,] c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmanrankcorrelation'></a><h3 class=pageheader><code>spearmanrankcorrelation</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete function, we recommend to use SpearmanCorr2().

    -- ALGLIB --
    Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spearmanrankcorrelation(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n)

</div></pre>
<a name='example_basestat_d_base'></a><h3 class=pageheader>basestat_d_base example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,1,4,9,16,25,36,49,64,81};
    <font color=navy>double</font> mean;
    <font color=navy>double</font> variance;
    <font color=navy>double</font> skewness;
    <font color=navy>double</font> kurtosis;
    <font color=navy>double</font> adev;
    <font color=navy>double</font> p;
    <font color=navy>double</font> v;

    <font color=green>//</font>
    <font color=green>// Here we demonstrate calculation of sample moments</font>
    <font color=green>// (mean, variance, skewness, kurtosis)</font>
    <font color=green>//</font>
    alglib.samplemoments(x, <font color=navy>out</font> mean, <font color=navy>out</font> variance, <font color=navy>out</font> skewness, <font color=navy>out</font> kurtosis);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, mean); <font color=green>// EXPECTED: 28.5</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, variance); <font color=green>// EXPECTED: 801.1667</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, skewness); <font color=green>// EXPECTED: 0.5751</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, kurtosis); <font color=green>// EXPECTED: -1.2666</font>

    <font color=green>//</font>
    <font color=green>// Average deviation</font>
    <font color=green>//</font>
    alglib.sampleadev(x, <font color=navy>out</font> adev);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, adev); <font color=green>// EXPECTED: 23.2</font>

    <font color=green>//</font>
    <font color=green>// Median and percentile</font>
    <font color=green>//</font>
    alglib.samplemedian(x, <font color=navy>out</font> v);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, v); <font color=green>// EXPECTED: 20.5</font>
    p = 0.5;
    alglib.samplepercentile(x, p, <font color=navy>out</font> v);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, v); <font color=green>// EXPECTED: 20.5</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_basestat_d_c2'></a><h3 class=pageheader>basestat_d_c2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We have two samples - x and y, and want to measure dependency between them</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,1,4,9,16,25,36,49,64,81};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0,1,2,3,4,5,6,7,8,9};
    <font color=navy>double</font> v;

    <font color=green>//</font>
    <font color=green>// Three dependency measures are calculated:</font>
    <font color=green>// * covariation</font>
    <font color=green>// * Pearson correlation</font>
    <font color=green>// * Spearman rank correlation</font>
    <font color=green>//</font>
    v = alglib.cov2(x, y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 82.5</font>
    v = alglib.pearsoncorr2(x, y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.9627</font>
    v = alglib.spearmancorr2(x, y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.000</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_basestat_d_cm'></a><h3 class=pageheader>basestat_d_cm example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// X is a sample matrix:</font>
    <font color=green>// * I-th row corresponds to I-th observation</font>
    <font color=green>// * J-th column corresponds to J-th variable</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{1,0,1},{1,1,0},{-1,1,0},{-2,-1,1},{-1,0,9}};
    <font color=navy>double</font>[,] c;

    <font color=green>//</font>
    <font color=green>// Three dependency measures are calculated:</font>
    <font color=green>// * covariation</font>
    <font color=green>// * Pearson correlation</font>
    <font color=green>// * Spearman rank correlation</font>
    <font color=green>//</font>
    <font color=green>// Result is stored into C, with C[i,j] equal to correlation</font>
    <font color=green>// (covariance) between I-th and J-th variables of X.</font>
    <font color=green>//</font>
    alglib.covm(x, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [[1.80,0.60,-1.40],[0.60,0.70,-0.80],[-1.40,-0.80,14.70]]</font>
    alglib.pearsoncorrm(x, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [[1.000,0.535,-0.272],[0.535,1.000,-0.249],[-0.272,-0.249,1.000]]</font>
    alglib.spearmancorrm(x, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [[1.000,0.556,-0.306],[0.556,1.000,-0.750],[-0.306,-0.750,1.000]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_basestat_d_cm2'></a><h3 class=pageheader>basestat_d_cm2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// X and Y are sample matrices:</font>
    <font color=green>// * I-th row corresponds to I-th observation</font>
    <font color=green>// * J-th column corresponds to J-th variable</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{1,0,1},{1,1,0},{-1,1,0},{-2,-1,1},{-1,0,9}};
    <font color=navy>double</font>[,] y = new <font color=navy>double</font>[,]{{2,3},{2,1},{-1,6},{-9,9},{7,1}};
    <font color=navy>double</font>[,] c;

    <font color=green>//</font>
    <font color=green>// Three dependency measures are calculated:</font>
    <font color=green>// * covariation</font>
    <font color=green>// * Pearson correlation</font>
    <font color=green>// * Spearman rank correlation</font>
    <font color=green>//</font>
    <font color=green>// Result is stored into C, with C[i,j] equal to correlation</font>
    <font color=green>// (covariance) between I-th variable of X and J-th variable of Y.</font>
    <font color=green>//</font>
    alglib.covm2(x, y, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [[4.100,-3.250],[2.450,-1.500],[13.450,-5.750]]</font>
    alglib.pearsoncorrm2(x, y, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [[0.519,-0.699],[0.497,-0.518],[0.596,-0.433]]</font>
    alglib.spearmancorrm2(x, y, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [[0.541,-0.649],[0.216,-0.433],[0.433,-0.135]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_bdss></a><h2 class=pageheader><code>bdss</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_dsoptimalsplit2' class=toc>dsoptimalsplit2</a><br>
<a href='#sub_dsoptimalsplit2fast' class=toc>dsoptimalsplit2fast</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_dsoptimalsplit2'></a><h3 class=pageheader><code>dsoptimalsplit2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Optimal binary classification

Algorithms finds optimal (=with minimal cross-entropy) binary partition.
Internal subroutine.

INPUT PARAMETERS:
    A       -   array[0..N-1], variable
    C       -   array[0..N-1], class numbers (0 or 1).
    N       -   array size

OUTPUT PARAMETERS:
    Info    -   completetion code:
                * -3, all values of A[] are same (partition is impossible)
                * -2, one of C[] is incorrect (&lt;0, &gt;1)
                * -1, incorrect pararemets were passed (N&lt;=0).
                *  1, OK
    Threshold-  partiton boundary. Left part contains values which are
                strictly less than Threshold. Right part contains values
                which are greater than or equal to Threshold.
    PAL, PBL-   probabilities P(0|v&lt;Threshold) and P(1|v&lt;Threshold)
    PAR, PBR-   probabilities P(0|v&gt;=Threshold) and P(1|v&gt;=Threshold)
    CVE     -   cross-validation estimate of cross-entropy

  -- ALGLIB --
     Copyright 22.05.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.dsoptimalsplit2(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font> threshold,
    <font color=navy>out</font> <font color=navy>double</font> pal,
    <font color=navy>out</font> <font color=navy>double</font> pbl,
    <font color=navy>out</font> <font color=navy>double</font> par,
    <font color=navy>out</font> <font color=navy>double</font> pbr,
    <font color=navy>out</font> <font color=navy>double</font> cve)

</div></pre>
<a name='sub_dsoptimalsplit2fast'></a><h3 class=pageheader><code>dsoptimalsplit2fast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Optimal partition, internal subroutine. Fast version.

Accepts:
    A       array[0..N-1]       array of attributes     array[0..N-1]
    C       array[0..N-1]       array of class labels
    TiesBuf array[0..N]         temporaries (ties)
    CntBuf  array[0..2*NC-1]    temporaries (counts)
    Alpha                       centering factor (0&lt;=alpha&lt;=1, recommended value - 0.05)
    BufR    array[0..N-1]       temporaries
    BufI    array[0..N-1]       temporaries

Output:
    Info    error code (&quot;&gt;0&quot;=OK, &quot;&lt;0&quot;=bad)
    RMS     training set RMS error
    CVRMS   leave-one-out RMS error

Note:
    content of all arrays is changed by subroutine;
    it doesn't allocate temporaries.

  -- ALGLIB --
     Copyright 11.12.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.dsoptimalsplit2fast(
    <font color=navy>ref</font> <font color=navy>double</font>[] a,
    <font color=navy>ref</font> <font color=navy>int</font>[] c,
    <font color=navy>ref</font> <font color=navy>int</font>[] tiesbuf,
    <font color=navy>ref</font> <font color=navy>int</font>[] cntbuf,
    <font color=navy>ref</font> <font color=navy>double</font>[] bufr,
    <font color=navy>ref</font> <font color=navy>int</font>[] bufi,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nc,
    <font color=navy>double</font> alpha,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font> threshold,
    <font color=navy>out</font> <font color=navy>double</font> rms,
    <font color=navy>out</font> <font color=navy>double</font> cvrms)

</div></pre>
<a name=unit_bdsvd></a><h2 class=pageheader><code>bdsvd</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixbdsvd' class=toc>rmatrixbdsvd</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixbdsvd'></a><h3 class=pageheader><code>rmatrixbdsvd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Singular value decomposition of a bidiagonal matrix (extended algorithm)

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

The algorithm performs the singular value decomposition  of  a  bidiagonal
matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
orthogonal matrices, S - diagonal matrix with non-negative elements on the
main diagonal, in descending order.

The  algorithm  finds  singular  values.  In  addition,  the algorithm can
calculate  matrices  Q  and P (more precisely, not the matrices, but their
product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
matrices U and VT can be of any type, including identity. Furthermore, the
algorithm can calculate Q'*C (this product is calculated more  effectively
than U*Q,  because  this calculation operates with rows instead  of matrix
columns).

The feature of the algorithm is its ability to find  all  singular  values
including those which are arbitrarily close to 0  with  relative  accuracy
close to  machine precision. If the parameter IsFractionalAccuracyRequired
is set to True, all singular values will have high relative accuracy close
to machine precision. If the parameter is set to False, only  the  biggest
singular value will have relative accuracy  close  to  machine  precision.
The absolute error of other singular values is equal to the absolute error
of the biggest singular value.

Input parameters:
    D       -   main diagonal of matrix B.
                Array whose index ranges within [0..N-1].
    E       -   superdiagonal (or subdiagonal) of matrix B.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix B.
    IsUpper -   True, if the matrix is upper bidiagonal.
    IsFractionalAccuracyRequired -
                THIS PARAMETER IS IGNORED SINCE ALGLIB 3.5.0
                SINGULAR VALUES ARE ALWAYS SEARCHED WITH HIGH ACCURACY.
    U       -   matrix to be multiplied by Q.
                Array whose indexes range within [0..NRU-1, 0..N-1].
                The matrix can be bigger, in that case only the  submatrix
                [0..NRU-1, 0..N-1] will be multiplied by Q.
    NRU     -   number of rows in matrix U.
    C       -   matrix to be multiplied by Q'.
                Array whose indexes range within [0..N-1, 0..NCC-1].
                The matrix can be bigger, in that case only the  submatrix
                [0..N-1, 0..NCC-1] will be multiplied by Q'.
    NCC     -   number of columns in matrix C.
    VT      -   matrix to be multiplied by P^T.
                Array whose indexes range within [0..N-1, 0..NCVT-1].
                The matrix can be bigger, in that case only the  submatrix
                [0..N-1, 0..NCVT-1] will be multiplied by P^T.
    NCVT    -   number of columns in matrix VT.

Output parameters:
    D       -   singular values of matrix B in descending order.
    U       -   if NRU&gt;0, contains matrix U*Q.
    VT      -   if NCVT&gt;0, contains matrix (P^T)*VT.
    C       -   if NCC&gt;0, contains matrix Q'*C.

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged (rare case).

NOTE: multiplication U*Q is performed by means of transposition to internal
      buffer, multiplication and backward transposition. It helps to avoid
      costly columnwise operations and speed-up algorithm.

Additional information:
    The type of convergence is controlled by the internal  parameter  TOL.
    If the parameter is greater than 0, the singular values will have
    relative accuracy TOL. If TOL&lt;0, the singular values will have
    absolute accuracy ABS(TOL)*norm(B).
    By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
    where Epsilon is the machine precision. It is not  recommended  to  use
    TOL less than 10*Epsilon since this will  considerably  slow  down  the
    algorithm and may not lead to error decreasing.

History:
    * 31 March, 2007.
        changed MAXITR from 6 to 12.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1999.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.rmatrixbdsvd(
    <font color=navy>ref</font> <font color=navy>double</font>[] d,
    <font color=navy>double</font>[] e,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isfractionalaccuracyrequired,
    <font color=navy>ref</font> <font color=navy>double</font>[,] u,
    <font color=navy>int</font> nru,
    <font color=navy>ref</font> <font color=navy>double</font>[,] c,
    <font color=navy>int</font> ncc,
    <font color=navy>ref</font> <font color=navy>double</font>[,] vt,
    <font color=navy>int</font> ncvt)

</div></pre>
<a name=unit_bessel></a><h2 class=pageheader><code>bessel</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_besseli0' class=toc>besseli0</a><br>
<a href='#sub_besseli1' class=toc>besseli1</a><br>
<a href='#sub_besselj0' class=toc>besselj0</a><br>
<a href='#sub_besselj1' class=toc>besselj1</a><br>
<a href='#sub_besseljn' class=toc>besseljn</a><br>
<a href='#sub_besselk0' class=toc>besselk0</a><br>
<a href='#sub_besselk1' class=toc>besselk1</a><br>
<a href='#sub_besselkn' class=toc>besselkn</a><br>
<a href='#sub_bessely0' class=toc>bessely0</a><br>
<a href='#sub_bessely1' class=toc>bessely1</a><br>
<a href='#sub_besselyn' class=toc>besselyn</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_besseli0'></a><h3 class=pageheader><code>besseli0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modified Bessel function of order zero

Returns modified Bessel function of order zero of the
argument.

The function is defined as i0(x) = j0( ix ).

The range is partitioned into the two intervals [0,8] and
(8, infinity).  Chebyshev polynomial expansions are employed
in each interval.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0,30        30000       5.8e-16     1.4e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besseli0(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besseli1'></a><h3 class=pageheader><code>besseli1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modified Bessel function of order one

Returns modified Bessel function of order one of the
argument.

The function is defined as i1(x) = -i j1( ix ).

The range is partitioned into the two intervals [0,8] and
(8, infinity).  Chebyshev polynomial expansions are employed
in each interval.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       30000       1.9e-15     2.1e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1985, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besseli1(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besselj0'></a><h3 class=pageheader><code>besselj0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bessel function of order zero

Returns Bessel function of order zero of the argument.

The domain is divided into the intervals [0, 5] and
(5, infinity). In the first interval the following rational
approximation is used:


       2         2
(w - r  ) (w - r  ) P (w) / Q (w)
      1         2    3       8

           2
where w = x  and the two r's are zeros of the function.

In the second interval, the Hankel asymptotic expansion
is employed with two rational functions of degree 6/6
and 7/7.

ACCURACY:

                     Absolute error:
arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       60000       4.2e-16     1.1e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besselj0(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besselj1'></a><h3 class=pageheader><code>besselj1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bessel function of order one

Returns Bessel function of order one of the argument.

The domain is divided into the intervals [0, 8] and
(8, infinity). In the first interval a 24 term Chebyshev
expansion is used. In the second, the asymptotic
trigonometric representation is employed using two
rational functions of degree 5/5.

ACCURACY:

                     Absolute error:
arithmetic   domain      # trials      peak         rms
   IEEE      0, 30       30000       2.6e-16     1.1e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besselj1(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besseljn'></a><h3 class=pageheader><code>besseljn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bessel function of integer order

Returns Bessel function of order n, where n is a
(possibly negative) integer.

The ratio of jn(x) to j0(x) is computed by backward
recurrence.  First the ratio jn/jn-1 is found by a
continued fraction expansion.  Then the recurrence
relating successive orders is applied until j0 or j1 is
reached.

If n = 0 or 1 the routine for j0 or j1 is called
directly.

ACCURACY:

                     Absolute error:
arithmetic   range      # trials      peak         rms
   IEEE      0, 30        5000       4.4e-16     7.9e-17


Not suitable for large n or x. Use jv() (fractional order) instead.

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besseljn(<font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name='sub_besselk0'></a><h3 class=pageheader><code>besselk0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modified Bessel function, second kind, order zero

Returns modified Bessel function of the second kind
of order zero of the argument.

The range is partitioned into the two intervals [0,8] and
(8, infinity).  Chebyshev polynomial expansions are employed
in each interval.

ACCURACY:

Tested at 2000 random points between 0 and 8.  Peak absolute
error (relative when K0 &gt; 1) was 1.46e-14; rms, 4.26e-15.
                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       30000       1.2e-15     1.6e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besselk0(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besselk1'></a><h3 class=pageheader><code>besselk1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modified Bessel function, second kind, order one

Computes the modified Bessel function of the second kind
of order one of the argument.

The range is partitioned into the two intervals [0,2] and
(2, infinity).  Chebyshev polynomial expansions are employed
in each interval.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       30000       1.2e-15     1.6e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besselk1(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besselkn'></a><h3 class=pageheader><code>besselkn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modified Bessel function, second kind, integer order

Returns modified Bessel function of the second kind
of order n of the argument.

The range is partitioned into the two intervals [0,9.55] and
(9.55, infinity).  An ascending power series is used in the
low range, and an asymptotic expansion in the high range.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0,30        90000       1.8e-8      3.0e-10

Error is high only near the crossover point x = 9.55
between the two expansions used.

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besselkn(<font color=navy>int</font> nn, <font color=navy>double</font> x)

</div></pre>
<a name='sub_bessely0'></a><h3 class=pageheader><code>bessely0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bessel function of the second kind, order zero

Returns Bessel function of the second kind, of order
zero, of the argument.

The domain is divided into the intervals [0, 5] and
(5, infinity). In the first interval a rational approximation
R(x) is employed to compute
  y0(x)  = R(x)  +   2 * log(x) * j0(x) / PI.
Thus a call to j0() is required.

In the second interval, the Hankel asymptotic expansion
is employed with two rational functions of degree 6/6
and 7/7.



ACCURACY:

 Absolute error, when y0(x) &lt; 1; else relative error:

arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       30000       1.3e-15     1.6e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.bessely0(<font color=navy>double</font> x)

</div></pre>
<a name='sub_bessely1'></a><h3 class=pageheader><code>bessely1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bessel function of second kind of order one

Returns Bessel function of the second kind of order one
of the argument.

The domain is divided into the intervals [0, 8] and
(8, infinity). In the first interval a 25 term Chebyshev
expansion is used, and a call to j1() is required.
In the second, the asymptotic trigonometric representation
is employed using two rational functions of degree 5/5.

ACCURACY:

                     Absolute error:
arithmetic   domain      # trials      peak         rms
   IEEE      0, 30       30000       1.0e-15     1.3e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.bessely1(<font color=navy>double</font> x)

</div></pre>
<a name='sub_besselyn'></a><h3 class=pageheader><code>besselyn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bessel function of second kind of integer order

Returns Bessel function of order n, where n is a
(possibly negative) integer.

The function is evaluated by forward recurrence on
n, starting with values computed by the routines
y0() and y1().

If n = 0 or 1 the routine for y0 or y1 is called
directly.

ACCURACY:
                     Absolute error, except relative
                     when y &gt; 1:
arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       30000       3.4e-15     4.3e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.besselyn(<font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name=unit_betaf></a><h2 class=pageheader><code>betaf</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_beta' class=toc>beta</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_beta'></a><h3 class=pageheader><code>beta</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Beta function


                  -     -
                 | (a) | (b)
beta( a, b )  =  -----------.
                    -
                   | (a+b)

For large arguments the logarithm of the function is
evaluated using lgam(), then exponentiated.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE       0,30       30000       8.1e-14     1.1e-14

Cephes Math Library Release 2.0:  April, 1987
Copyright 1984, 1987 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.beta(<font color=navy>double</font> a, <font color=navy>double</font> b)

</div></pre>
<a name=unit_binomialdistr></a><h2 class=pageheader><code>binomialdistr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_binomialcdistribution' class=toc>binomialcdistribution</a><br>
<a href='#sub_binomialdistribution' class=toc>binomialdistribution</a><br>
<a href='#sub_invbinomialdistribution' class=toc>invbinomialdistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_binomialcdistribution'></a><h3 class=pageheader><code>binomialcdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complemented binomial distribution

Returns the sum of the terms k+1 through n of the Binomial
probability density:

  n
  --  ( n )   j      n-j
  &gt;   (   )  p  (1-p)
  --  ( j )
 j=k+1

The terms are not summed directly; instead the incomplete
beta integral is employed, according to the formula

y = bdtrc( k, n, p ) = incbet( k+1, n-k, p ).

The arguments must be positive, with p ranging from 0 to 1.

ACCURACY:

Tested at random points (a,b,p).

              a,b                     Relative error:
arithmetic  domain     # trials      peak         rms
 For p between 0.001 and 1:
   IEEE     0,100       100000      6.7e-15     8.2e-16
 For p between 0 and .001:
   IEEE     0,100       100000      1.5e-13     2.7e-15

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.binomialcdistribution(<font color=navy>int</font> k, <font color=navy>int</font> n, <font color=navy>double</font> p)

</div></pre>
<a name='sub_binomialdistribution'></a><h3 class=pageheader><code>binomialdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Binomial distribution

Returns the sum of the terms 0 through k of the Binomial
probability density:

  k
  --  ( n )   j      n-j
  &gt;   (   )  p  (1-p)
  --  ( j )
 j=0

The terms are not summed directly; instead the incomplete
beta integral is employed, according to the formula

y = bdtr( k, n, p ) = incbet( n-k, k+1, 1-p ).

The arguments must be positive, with p ranging from 0 to 1.

ACCURACY:

Tested at random points (a,b,p), with p between 0 and 1.

              a,b                     Relative error:
arithmetic  domain     # trials      peak         rms
 For p between 0.001 and 1:
   IEEE     0,100       100000      4.3e-15     2.6e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.binomialdistribution(<font color=navy>int</font> k, <font color=navy>int</font> n, <font color=navy>double</font> p)

</div></pre>
<a name='sub_invbinomialdistribution'></a><h3 class=pageheader><code>invbinomialdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse binomial distribution

Finds the event probability p such that the sum of the
terms 0 through k of the Binomial probability density
is equal to the given cumulative probability y.

This is accomplished using the inverse beta integral
function and the relation

1 - p = incbi( n-k, k+1, y ).

ACCURACY:

Tested at random points (a,b,p).

              a,b                     Relative error:
arithmetic  domain     # trials      peak         rms
 For p between 0.001 and 1:
   IEEE     0,100       100000      2.3e-14     6.4e-16
   IEEE     0,10000     100000      6.6e-12     1.2e-13
 For p between 10^-6 and 0.001:
   IEEE     0,100       100000      2.0e-12     1.3e-14
   IEEE     0,10000     100000      1.5e-12     3.2e-14

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invbinomialdistribution(
    <font color=navy>int</font> k,
    <font color=navy>int</font> n,
    <font color=navy>double</font> y)

</div></pre>
<a name=unit_chebyshev></a><h2 class=pageheader><code>chebyshev</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_chebyshevcalculate' class=toc>chebyshevcalculate</a><br>
<a href='#sub_chebyshevcoefficients' class=toc>chebyshevcoefficients</a><br>
<a href='#sub_chebyshevsum' class=toc>chebyshevsum</a><br>
<a href='#sub_fromchebyshev' class=toc>fromchebyshev</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_chebyshevcalculate'></a><h3 class=pageheader><code>chebyshevcalculate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the value of the Chebyshev polynomials of the
first and second kinds.

Parameters:
    r   -   polynomial kind, either 1 or 2.
    n   -   degree, n&gt;=0
    x   -   argument, -1 &lt;= x &lt;= 1

Result:
    the value of the Chebyshev polynomial at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.chebyshevcalculate(<font color=navy>int</font> r, <font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name='sub_chebyshevcoefficients'></a><h3 class=pageheader><code>chebyshevcoefficients</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Representation of Tn as C[0] + C[1]*X + ... + C[N]*X^N

Input parameters:
    N   -   polynomial degree, n&gt;=0

Output parameters:
    C   -   coefficients
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.chebyshevcoefficients(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] c)

</div></pre>
<a name='sub_chebyshevsum'></a><h3 class=pageheader><code>chebyshevsum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Summation of Chebyshev polynomials using Clenshaws recurrence formula.

This routine calculates
    c[0]*T0(x) + c[1]*T1(x) + ... + c[N]*TN(x)
or
    c[0]*U0(x) + c[1]*U1(x) + ... + c[N]*UN(x)
depending on the R.

Parameters:
    r   -   polynomial kind, either 1 or 2.
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Chebyshev polynomial at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.chebyshevsum(
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> r,
    <font color=navy>int</font> n,
    <font color=navy>double</font> x)

</div></pre>
<a name='sub_fromchebyshev'></a><h3 class=pageheader><code>fromchebyshev</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conversion of a series of Chebyshev polynomials to a power series.

Represents A[0]*T0(x) + A[1]*T1(x) + ... + A[N]*Tn(x) as
B[0] + B[1]*X + ... + B[N]*X^N.

Input parameters:
    A   -   Chebyshev series coefficients
    N   -   degree, N&gt;=0

Output parameters
    B   -   power series coefficients
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fromchebyshev(<font color=navy>double</font>[] a, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] b)

</div></pre>
<a name=unit_chisquaredistr></a><h2 class=pageheader><code>chisquaredistr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_chisquarecdistribution' class=toc>chisquarecdistribution</a><br>
<a href='#sub_chisquaredistribution' class=toc>chisquaredistribution</a><br>
<a href='#sub_invchisquaredistribution' class=toc>invchisquaredistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_chisquarecdistribution'></a><h3 class=pageheader><code>chisquarecdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complemented Chi-square distribution

Returns the area under the right hand tail (from x to
infinity) of the Chi square probability density function
with v degrees of freedom:

                                 inf.
                                   -
                       1          | |  v/2-1  -t/2
 P( x | v )   =   -----------     |   t      e     dt
                   v/2  -       | |
                  2    | (v/2)   -
                                  x

where x is the Chi-square variable.

The incomplete gamma integral is used, according to the
formula

y = chdtr( v, x ) = igamc( v/2.0, x/2.0 ).

The arguments must both be positive.

ACCURACY:

See incomplete gamma function

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.chisquarecdistribution(<font color=navy>double</font> v, <font color=navy>double</font> x)

</div></pre>
<a name='sub_chisquaredistribution'></a><h3 class=pageheader><code>chisquaredistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Chi-square distribution

Returns the area under the left hand tail (from 0 to x)
of the Chi square probability density function with
v degrees of freedom.


                                  x
                                   -
                       1          | |  v/2-1  -t/2
 P( x | v )   =   -----------     |   t      e     dt
                   v/2  -       | |
                  2    | (v/2)   -
                                  0

where x is the Chi-square variable.

The incomplete gamma integral is used, according to the
formula

y = chdtr( v, x ) = igam( v/2.0, x/2.0 ).

The arguments must both be positive.

ACCURACY:

See incomplete gamma function


Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.chisquaredistribution(<font color=navy>double</font> v, <font color=navy>double</font> x)

</div></pre>
<a name='sub_invchisquaredistribution'></a><h3 class=pageheader><code>invchisquaredistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse of complemented Chi-square distribution

Finds the Chi-square argument x such that the integral
from x to infinity of the Chi-square density is equal
to the given cumulative probability y.

This is accomplished using the inverse gamma integral
function and the relation

   x/2 = igami( df/2, y );

ACCURACY:

See inverse incomplete gamma function


Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invchisquaredistribution(<font color=navy>double</font> v, <font color=navy>double</font> y)

</div></pre>
<a name=unit_clustering></a><h2 class=pageheader><code>clustering</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_ahcreport' class=toc>ahcreport</a><br>
<a href='#struct_clusterizerstate' class=toc>clusterizerstate</a><br>
<a href='#struct_kmeansreport' class=toc>kmeansreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_clusterizercreate' class=toc>clusterizercreate</a><br>
<a href='#sub_clusterizergetdistances' class=toc>clusterizergetdistances</a><br>
<a href='#sub_clusterizergetkclusters' class=toc>clusterizergetkclusters</a><br>
<a href='#sub_clusterizerrunahc' class=toc>clusterizerrunahc</a><br>
<a href='#sub_clusterizerrunkmeans' class=toc>clusterizerrunkmeans</a><br>
<a href='#sub_clusterizerseparatedbycorr' class=toc>clusterizerseparatedbycorr</a><br>
<a href='#sub_clusterizerseparatedbydist' class=toc>clusterizerseparatedbydist</a><br>
<a href='#sub_clusterizersetahcalgo' class=toc>clusterizersetahcalgo</a><br>
<a href='#sub_clusterizersetdistances' class=toc>clusterizersetdistances</a><br>
<a href='#sub_clusterizersetkmeansinit' class=toc>clusterizersetkmeansinit</a><br>
<a href='#sub_clusterizersetkmeanslimits' class=toc>clusterizersetkmeanslimits</a><br>
<a href='#sub_clusterizersetpoints' class=toc>clusterizersetpoints</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_clst_ahc' class=toc>clst_ahc</a></td><td width=15>&nbsp;</td><td>Simple hierarchical clusterization with Euclidean distance function</td></tr>
<tr align=left valign=top><td><a href='#example_clst_distance' class=toc>clst_distance</a></td><td width=15>&nbsp;</td><td>Clusterization with different metric types</td></tr>
<tr align=left valign=top><td><a href='#example_clst_kclusters' class=toc>clst_kclusters</a></td><td width=15>&nbsp;</td><td>Obtaining K top clusters from clusterization tree</td></tr>
<tr align=left valign=top><td><a href='#example_clst_kmeans' class=toc>clst_kmeans</a></td><td width=15>&nbsp;</td><td>Simple k-means clusterization</td></tr>
<tr align=left valign=top><td><a href='#example_clst_linkage' class=toc>clst_linkage</a></td><td width=15>&nbsp;</td><td>Clusterization with different linkage types</td></tr>
</table></div>
<a name='struct_ahcreport'></a><h3 class=pageheader><code>ahcreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure  is used to store results of the agglomerative hierarchical
clustering (AHC).

Following information is returned:

* TerminationType - completion code:
  * 1   for successful completion of algorithm
  * -5  inappropriate combination of  clustering  algorithm  and  distance
        function was used. As for now, it  is  possible  only when  Ward's
        method is called for dataset with non-Euclidean distance function.
  In case negative completion code is returned,  other  fields  of  report
  structure are invalid and should not be used.

* NPoints contains number of points in the original dataset

* Z contains information about merges performed  (see below).  Z  contains
  indexes from the original (unsorted) dataset and it can be used when you
  need to know what points were merged. However, it is not convenient when
  you want to build a dendrograd (see below).

* if  you  want  to  build  dendrogram, you  can use Z, but it is not good
  option, because Z contains  indexes from  unsorted  dataset.  Dendrogram
  built from such dataset is likely to have intersections. So, you have to
  reorder you points before building dendrogram.
  Permutation which reorders point is returned in P. Another representation
  of  merges,  which  is  more  convenient for dendorgram construction, is
  returned in PM.

* more information on format of Z, P and PM can be found below and in the
  examples from ALGLIB Reference Manual.

FORMAL DESCRIPTION OF FIELDS:
    NPoints         number of points
    Z               array[NPoints-1,2],  contains   indexes   of  clusters
                    linked in pairs to  form  clustering  tree.  I-th  row
                    corresponds to I-th merge:
                    * Z[I,0] - index of the first cluster to merge
                    * Z[I,1] - index of the second cluster to merge
                    * Z[I,0]&lt;Z[I,1]
                    * clusters are  numbered  from 0 to 2*NPoints-2,  with
                      indexes from 0 to NPoints-1 corresponding to  points
                      of the original dataset, and indexes from NPoints to
                      2*NPoints-2  correspond  to  clusters  generated  by
                      subsequent  merges  (I-th  row  of Z creates cluster
                      with index NPoints+I).

                    IMPORTANT: indexes in Z[] are indexes in the ORIGINAL,
                    unsorted dataset. In addition to  Z algorithm  outputs
                    permutation which rearranges points in such  way  that
                    subsequent merges are  performed  on  adjacent  points
                    (such order is needed if you want to build dendrogram).
                    However,  indexes  in  Z  are  related  to   original,
                    unrearranged sequence of points.

    P               array[NPoints], permutation which reorders points  for
                    dendrogram  construction.  P[i] contains  index of the
                    position  where  we  should  move  I-th  point  of the
                    original dataset in order to apply merges PZ/PM.

    PZ              same as Z, but for permutation of points given  by  P.
                    The  only  thing  which  changed  are  indexes  of the
                    original points; indexes of clusters remained same.

    MergeDist       array[NPoints-1], contains distances between  clusters
                    being merged (MergeDist[i] correspond to merge  stored
                    in Z[i,...]):
                    * CLINK, SLINK and  average  linkage algorithms report
                      &quot;raw&quot;, unmodified distance metric.
                    * Ward's   method   reports   weighted   intra-cluster
                      variance, which is equal to ||Ca-Cb||^2 * Sa*Sb/(Sa+Sb).
                      Here  A  and  B  are  clusters being merged, Ca is a
                      center of A, Cb is a center of B, Sa is a size of A,
                      Sb is a size of B.

    PM              array[NPoints-1,6], another representation of  merges,
                    which is suited for dendrogram construction. It  deals
                    with rearranged points (permutation P is applied)  and
                    represents merges in a form which different  from  one
                    used by Z.
                    For each I from 0 to NPoints-2, I-th row of PM represents
                    merge performed on two clusters C0 and C1. Here:
                    * C0 contains points with indexes PM[I,0]...PM[I,1]
                    * C1 contains points with indexes PM[I,2]...PM[I,3]
                    * indexes stored in PM are given for dataset sorted
                      according to permutation P
                    * PM[I,1]=PM[I,2]-1 (only adjacent clusters are merged)
                    * PM[I,0]&lt;=PM[I,1], PM[I,2]&lt;=PM[I,3], i.e. both
                      clusters contain at least one point
                    * heights of &quot;subdendrograms&quot; corresponding  to  C0/C1
                      are stored in PM[I,4]  and  PM[I,5].  Subdendrograms
                      corresponding   to   single-point   clusters    have
                      height=0. Dendrogram of the merge result has  height
                      H=max(H0,H1)+1.

NOTE: there is one-to-one correspondence between merges described by Z and
      PM. I-th row of Z describes same merge of clusters as I-th row of PM,
      with &quot;left&quot; cluster from Z corresponding to the &quot;left&quot; one from PM.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class ahcreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  npoints;
    <font color=navy>public</font> <font color=navy>int</font>[]                p;
    <font color=navy>public</font> <font color=navy>int</font>[,]               z;
    <font color=navy>public</font> <font color=navy>int</font>[,]               pz;
    <font color=navy>public</font> <font color=navy>int</font>[,]               pm;
    <font color=navy>public</font> <font color=navy>double</font>[]             mergedist;
}

</div></pre>
<a name='struct_clusterizerstate'></a><h3 class=pageheader><code>clusterizerstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure is a clusterization engine.

You should not try to access its fields directly.
Use ALGLIB functions in order to work with this object.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class clusterizerstate
{
}

</div></pre>
<a name='struct_kmeansreport'></a><h3 class=pageheader><code>kmeansreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  structure   is  used  to  store  results of the  k-means  clustering
algorithm.

Following information is always returned:
* NPoints contains number of points in the original dataset
* TerminationType contains completion code, negative on failure, positive
  on success
* K contains number of clusters

For positive TerminationType we return:
* NFeatures contains number of variables in the original dataset
* C, which contains centers found by algorithm
* CIdx, which maps points of the original dataset to clusters

FORMAL DESCRIPTION OF FIELDS:
    NPoints         number of points, &gt;=0
    NFeatures       number of variables, &gt;=1
    TerminationType completion code:
                    * -5 if  distance  type  is  anything  different  from
                         Euclidean metric
                    * -3 for degenerate dataset: a) less  than  K  distinct
                         points, b) K=0 for non-empty dataset.
                    * +1 for successful completion
    K               number of clusters
    C               array[K,NFeatures], rows of the array store centers
    CIdx            array[NPoints], which contains cluster indexes
    IterationsCount actual number of iterations performed by clusterizer.
                    If algorithm performed more than one random restart,
                    total number of iterations is returned.
    Energy          merit function, &quot;energy&quot;, sum  of  squared  deviations
                    from cluster centers

  -- ALGLIB --
     Copyright 27.11.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class kmeansreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  npoints;
    <font color=navy>public</font> <font color=navy>int</font>                  nfeatures;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>double</font>               energy;
    <font color=navy>public</font> <font color=navy>int</font>                  k;
    <font color=navy>public</font> <font color=navy>double</font>[,]            c;
    <font color=navy>public</font> <font color=navy>int</font>[]                cidx;
}

</div></pre>
<a name='sub_clusterizercreate'></a><h3 class=pageheader><code>clusterizercreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function initializes clusterizer object. Newly initialized object  is
empty, i.e. it does not contain dataset. You should use it as follows:
1. creation
2. dataset is added with ClusterizerSetPoints()
3. additional parameters are set
3. clusterization is performed with one of the clustering functions

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizercreate(<font color=navy>out</font> clusterizerstate s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_clst_ahc' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_clst_kmeans' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_clst_linkage' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_clst_distance' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_clst_kclusters' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_clusterizergetdistances'></a><h3 class=pageheader><code>clusterizergetdistances</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns distance matrix for dataset

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Agglomerative  hierarchical  clustering  algorithm  has  two   phases:
  ! distance matrix calculation  and  clustering  itself. Only first phase
  ! (distance matrix calculation) is accelerated by Intel MKL  and  multi-
  ! threading. Thus, acceleration is significant only for  medium or high-
  ! dimensional problems.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    XY      -   array[NPoints,NFeatures], dataset
    NPoints -   number of points, &gt;=0
    NFeatures-  number of features, &gt;=1
    DistType-   distance function:
                *  0    Chebyshev distance  (L-inf norm)
                *  1    city block distance (L1 norm)
                *  2    Euclidean distance  (L2 norm, non-squared)
                * 10    Pearson correlation:
                        dist(a,b) = 1-corr(a,b)
                * 11    Absolute Pearson correlation:
                        dist(a,b) = 1-|corr(a,b)|
                * 12    Uncentered Pearson correlation (cosine of the angle):
                        dist(a,b) = a'*b/(|a|*|b|)
                * 13    Absolute uncentered Pearson correlation
                        dist(a,b) = |a'*b|/(|a|*|b|)
                * 20    Spearman rank correlation:
                        dist(a,b) = 1-rankcorr(a,b)
                * 21    Absolute Spearman rank correlation
                        dist(a,b) = 1-|rankcorr(a,b)|

OUTPUT PARAMETERS:
    D       -   array[NPoints,NPoints], distance matrix
                (full matrix is returned, with lower and upper triangles)

NOTE:  different distance functions have different performance penalty:
       * Euclidean or Pearson correlation distances are the fastest ones
       * Spearman correlation distance function is a bit slower
       * city block and Chebyshev distances are order of magnitude slower

       The reason behing difference in performance is that correlation-based
       distance functions are computed using optimized linear algebra kernels,
       while Chebyshev and city block distance functions are computed using
       simple nested loops with two branches at each iteration.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizergetdistances(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures,
    <font color=navy>int</font> disttype,
    <font color=navy>out</font> <font color=navy>double</font>[,] d)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_clusterizergetdistances(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures,
    <font color=navy>int</font> disttype,
    <font color=navy>out</font> <font color=navy>double</font>[,] d)

</div></pre>
<a name='sub_clusterizergetkclusters'></a><h3 class=pageheader><code>clusterizergetkclusters</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function takes as input clusterization report Rep,  desired  clusters
count K, and builds top K clusters from hierarchical clusterization  tree.
It returns assignment of points to clusters (array of cluster indexes).

INPUT PARAMETERS:
    Rep     -   report from ClusterizerRunAHC() performed on XY
    K       -   desired number of clusters, 1&lt;=K&lt;=NPoints.
                K can be zero only when NPoints=0.

OUTPUT PARAMETERS:
    CIdx    -   array[NPoints], I-th element contains cluster index  (from
                0 to K-1) for I-th point of the dataset.
    CZ      -   array[K]. This array allows  to  convert  cluster  indexes
                returned by this function to indexes used by  Rep.Z.  J-th
                cluster returned by this function corresponds to  CZ[J]-th
                cluster stored in Rep.Z/PZ/PM.
                It is guaranteed that CZ[I]&lt;CZ[I+1].

NOTE: K clusters built by this subroutine are assumed to have no hierarchy.
      Although  they  were  obtained  by  manipulation with top K nodes of
      dendrogram  (i.e.  hierarchical  decomposition  of  dataset),   this
      function does not return information about hierarchy.  Each  of  the
      clusters stand on its own.

NOTE: Cluster indexes returned by this function  does  not  correspond  to
      indexes returned in Rep.Z/PZ/PM. Either you work  with  hierarchical
      representation of the dataset (dendrogram), or you work with  &quot;flat&quot;
      representation returned by this function.  Each  of  representations
      has its own clusters indexing system (former uses [0, 2*NPoints-2]),
      while latter uses [0..K-1]), although  it  is  possible  to  perform
      conversion from one system to another by means of CZ array, returned
      by this function, which allows you to convert indexes stored in CIdx
      to the numeration system used by Rep.Z.

NOTE: this subroutine is optimized for moderate values of K. Say, for  K=5
      it will perform many times faster than  for  K=100.  Its  worst-case
      performance is O(N*K), although in average case  it  perform  better
      (up to O(N*log(K))).

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizergetkclusters(
    ahcreport rep,
    <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font>[] cidx,
    <font color=navy>out</font> <font color=navy>int</font>[] cz)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_clst_linkage' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_clst_kclusters' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_clusterizerrunahc'></a><h3 class=pageheader><code>clusterizerrunahc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function performs agglomerative hierarchical clustering

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Agglomerative  hierarchical  clustering  algorithm  has  two   phases:
  ! distance matrix calculation  and  clustering  itself. Only first phase
  ! (distance matrix calculation) is accelerated by Intel MKL  and  multi-
  ! threading. Thus, acceleration is significant only for  medium or high-
  ! dimensional problems.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()

OUTPUT PARAMETERS:
    Rep     -   clustering results; see description of AHCReport
                structure for more information.

NOTE 1: hierarchical clustering algorithms require large amounts of memory.
        In particular, this implementation needs  sizeof(double)*NPoints^2
        bytes, which are used to store distance matrix. In  case  we  work
        with user-supplied matrix, this amount is multiplied by 2 (we have
        to store original matrix and to work with its copy).

        For example, problem with 10000 points  would require 800M of RAM,
        even when working in a 1-dimensional space.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizerrunahc(
    clusterizerstate s,
    <font color=navy>out</font> ahcreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_clusterizerrunahc(
    clusterizerstate s,
    <font color=navy>out</font> ahcreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_clst_ahc' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_clst_kmeans' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_clst_linkage' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_clst_distance' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_clst_kclusters' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_clusterizerrunkmeans'></a><h3 class=pageheader><code>clusterizerrunkmeans</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function performs clustering by k-means++ algorithm.

You may change algorithm properties by calling:
* ClusterizerSetKMeansLimits() to change number of restarts or iterations
* ClusterizerSetKMeansInit() to change initialization algorithm

By  default,  one  restart  and  unlimited number of iterations are  used.
Initialization algorithm is chosen automatically.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes  two important  improvements  of
  ! this function:
  ! * multicore support (can be used from C# and C++)
  ! * access to high-performance C++ core (actual for C# users)
  !
  ! K-means clustering  algorithm has two  phases:  selection  of  initial
  ! centers  and  clustering  itself.  ALGLIB  parallelizes  both  phases.
  ! Parallel version is optimized for the following  scenario:  medium  or
  ! high-dimensional problem (20 or more dimensions) with large number  of
  ! points and clusters. However, some speed-up can be obtained even  when
  ! assumptions above are violated.
  !
  ! As for native-vs-managed comparison, working with native  core  brings
  ! 30-40% improvement in speed over pure C# version of ALGLIB.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()
    K       -   number of clusters, K&gt;=0.
                K  can  be  zero only when algorithm is called  for  empty
                dataset,  in   this   case   completion  code  is  set  to
                success (+1).
                If  K=0  and  dataset  size  is  non-zero,  we   can   not
                meaningfully assign points to some center  (there  are  no
                centers because K=0) and  return  -3  as  completion  code
                (failure).

OUTPUT PARAMETERS:
    Rep     -   clustering results; see description of KMeansReport
                structure for more information.

NOTE 1: k-means  clustering  can  be  performed  only  for  datasets  with
        Euclidean  distance  function.  Algorithm  will  return   negative
        completion code in Rep.TerminationType in case dataset  was  added
        to clusterizer with DistType other than Euclidean (or dataset  was
        specified by distance matrix instead of explicitly given points).

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizerrunkmeans(
    clusterizerstate s,
    <font color=navy>int</font> k,
    <font color=navy>out</font> kmeansreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_clusterizerrunkmeans(
    clusterizerstate s,
    <font color=navy>int</font> k,
    <font color=navy>out</font> kmeansreport rep)

</div></pre>
<a name='sub_clusterizerseparatedbycorr'></a><h3 class=pageheader><code>clusterizerseparatedbycorr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  accepts  AHC  report  Rep,  desired  maximum  intercluster
correlation and returns top clusters from hierarchical clusterization tree
which are separated by correlation R or LOWER.

It returns assignment of points to clusters (array of cluster indexes).

There is one more function with similar name - ClusterizerSeparatedByDist,
which returns clusters with intercluster distance equal  to  R  or  HIGHER
(note: higher for distance, lower for correlation).

INPUT PARAMETERS:
    Rep     -   report from ClusterizerRunAHC() performed on XY
    R       -   desired maximum intercluster correlation, -1&lt;=R&lt;=+1

OUTPUT PARAMETERS:
    K       -   number of clusters, 1&lt;=K&lt;=NPoints
    CIdx    -   array[NPoints], I-th element contains cluster index  (from
                0 to K-1) for I-th point of the dataset.
    CZ      -   array[K]. This array allows  to  convert  cluster  indexes
                returned by this function to indexes used by  Rep.Z.  J-th
                cluster returned by this function corresponds to  CZ[J]-th
                cluster stored in Rep.Z/PZ/PM.
                It is guaranteed that CZ[I]&lt;CZ[I+1].

NOTE: K clusters built by this subroutine are assumed to have no hierarchy.
      Although  they  were  obtained  by  manipulation with top K nodes of
      dendrogram  (i.e.  hierarchical  decomposition  of  dataset),   this
      function does not return information about hierarchy.  Each  of  the
      clusters stand on its own.

NOTE: Cluster indexes returned by this function  does  not  correspond  to
      indexes returned in Rep.Z/PZ/PM. Either you work  with  hierarchical
      representation of the dataset (dendrogram), or you work with  &quot;flat&quot;
      representation returned by this function.  Each  of  representations
      has its own clusters indexing system (former uses [0, 2*NPoints-2]),
      while latter uses [0..K-1]), although  it  is  possible  to  perform
      conversion from one system to another by means of CZ array, returned
      by this function, which allows you to convert indexes stored in CIdx
      to the numeration system used by Rep.Z.

NOTE: this subroutine is optimized for moderate values of K. Say, for  K=5
      it will perform many times faster than  for  K=100.  Its  worst-case
      performance is O(N*K), although in average case  it  perform  better
      (up to O(N*log(K))).

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizerseparatedbycorr(
    ahcreport rep,
    <font color=navy>double</font> r,
    <font color=navy>out</font> <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font>[] cidx,
    <font color=navy>out</font> <font color=navy>int</font>[] cz)

</div></pre>
<a name='sub_clusterizerseparatedbydist'></a><h3 class=pageheader><code>clusterizerseparatedbydist</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  accepts  AHC  report  Rep,  desired  minimum  intercluster
distance and returns top clusters from  hierarchical  clusterization  tree
which are separated by distance R or HIGHER.

It returns assignment of points to clusters (array of cluster indexes).

There is one more function with similar name - ClusterizerSeparatedByCorr,
which returns clusters with intercluster correlation equal to R  or  LOWER
(note: higher for distance, lower for correlation).

INPUT PARAMETERS:
    Rep     -   report from ClusterizerRunAHC() performed on XY
    R       -   desired minimum intercluster distance, R&gt;=0

OUTPUT PARAMETERS:
    K       -   number of clusters, 1&lt;=K&lt;=NPoints
    CIdx    -   array[NPoints], I-th element contains cluster index  (from
                0 to K-1) for I-th point of the dataset.
    CZ      -   array[K]. This array allows  to  convert  cluster  indexes
                returned by this function to indexes used by  Rep.Z.  J-th
                cluster returned by this function corresponds to  CZ[J]-th
                cluster stored in Rep.Z/PZ/PM.
                It is guaranteed that CZ[I]&lt;CZ[I+1].

NOTE: K clusters built by this subroutine are assumed to have no hierarchy.
      Although  they  were  obtained  by  manipulation with top K nodes of
      dendrogram  (i.e.  hierarchical  decomposition  of  dataset),   this
      function does not return information about hierarchy.  Each  of  the
      clusters stand on its own.

NOTE: Cluster indexes returned by this function  does  not  correspond  to
      indexes returned in Rep.Z/PZ/PM. Either you work  with  hierarchical
      representation of the dataset (dendrogram), or you work with  &quot;flat&quot;
      representation returned by this function.  Each  of  representations
      has its own clusters indexing system (former uses [0, 2*NPoints-2]),
      while latter uses [0..K-1]), although  it  is  possible  to  perform
      conversion from one system to another by means of CZ array, returned
      by this function, which allows you to convert indexes stored in CIdx
      to the numeration system used by Rep.Z.

NOTE: this subroutine is optimized for moderate values of K. Say, for  K=5
      it will perform many times faster than  for  K=100.  Its  worst-case
      performance is O(N*K), although in average case  it  perform  better
      (up to O(N*log(K))).

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizerseparatedbydist(
    ahcreport rep,
    <font color=navy>double</font> r,
    <font color=navy>out</font> <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font>[] cidx,
    <font color=navy>out</font> <font color=navy>int</font>[] cz)

</div></pre>
<a name='sub_clusterizersetahcalgo'></a><h3 class=pageheader><code>clusterizersetahcalgo</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets agglomerative hierarchical clustering algorithm

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()
    Algo    -   algorithm type:
                * 0     complete linkage (default algorithm)
                * 1     single linkage
                * 2     unweighted average linkage
                * 3     weighted average linkage
                * 4     Ward's method

NOTE: Ward's method works correctly only with Euclidean  distance,  that's
      why algorithm will return negative termination  code  (failure)  for
      any other distance type.

      It is possible, however,  to  use  this  method  with  user-supplied
      distance matrix. It  is  your  responsibility  to pass one which was
      calculated with Euclidean distance function.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetahcalgo(
    clusterizerstate s,
    <font color=navy>int</font> algo)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_clst_ahc' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_clst_kmeans' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_clst_linkage' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_clst_distance' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_clst_kclusters' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_clusterizersetdistances'></a><h3 class=pageheader><code>clusterizersetdistances</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function adds dataset given by distance  matrix  to  the  clusterizer
structure. It is important that dataset is not  given  explicitly  -  only
distance matrix is given.

This function overrides all previous calls  of  ClusterizerSetPoints()  or
ClusterizerSetDistances().

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()
    D       -   array[NPoints,NPoints], distance matrix given by its upper
                or lower triangle (main diagonal is  ignored  because  its
                entries are expected to be zero).
    NPoints -   number of points
    IsUpper -   whether upper or lower triangle of D is given.

NOTE 1: different clustering algorithms have different limitations:
        * agglomerative hierarchical clustering algorithms may be used with
          any kind of distance metric, including one  which  is  given  by
          distance matrix
        * k-means++ clustering algorithm may be used only  with  Euclidean
          distance function and explicitly given points - it  can  not  be
          used with dataset given by distance matrix
        Thus, if you call this function, you will be unable to use k-means
        clustering algorithm to process your problem.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetdistances(
    clusterizerstate s,
    <font color=navy>double</font>[,] d,
    <font color=navy>bool</font> isupper)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetdistances(
    clusterizerstate s,
    <font color=navy>double</font>[,] d,
    <font color=navy>int</font> npoints,
    <font color=navy>bool</font> isupper)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_clst_distance' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_clusterizersetkmeansinit'></a><h3 class=pageheader><code>clusterizersetkmeansinit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets k-means  initialization  algorithm.  Several  different
algorithms can be chosen, including k-means++.

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()
    InitAlgo-   initialization algorithm:
                * 0  automatic selection ( different  versions  of  ALGLIB
                     may select different algorithms)
                * 1  random initialization
                * 2  k-means++ initialization  (best  quality  of  initial
                     centers, but long  non-parallelizable  initialization
                     phase with bad cache locality)
                * 3  &quot;fast-greedy&quot;  algorithm  with  efficient,  easy   to
                     parallelize initialization. Quality of initial centers
                     is  somewhat  worse  than  that  of  k-means++.  This
                     algorithm is a default one in the current version  of
                     ALGLIB.
                *-1  &quot;debug&quot; algorithm which always selects first  K  rows
                     of dataset; this algorithm is used for debug purposes
                     only. Do not use it in the industrial code!

  -- ALGLIB --
     Copyright 21.01.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetkmeansinit(
    clusterizerstate s,
    <font color=navy>int</font> initalgo)

</div></pre>
<a name='sub_clusterizersetkmeanslimits'></a><h3 class=pageheader><code>clusterizersetkmeanslimits</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  sets k-means properties:  number  of  restarts and maximum
number of iterations per one run.

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()
    Restarts-   restarts count, &gt;=1.
                k-means++ algorithm performs several restarts and  chooses
                best set of centers (one with minimum squared distance).
    MaxIts  -   maximum number of k-means iterations performed during  one
                run. &gt;=0, zero value means that algorithm performs unlimited
                number of iterations.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetkmeanslimits(
    clusterizerstate s,
    <font color=navy>int</font> restarts,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_clusterizersetpoints'></a><h3 class=pageheader><code>clusterizersetpoints</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function adds dataset to the clusterizer structure.

This function overrides all previous calls  of  ClusterizerSetPoints()  or
ClusterizerSetDistances().

INPUT PARAMETERS:
    S       -   clusterizer state, initialized by ClusterizerCreate()
    XY      -   array[NPoints,NFeatures], dataset
    NPoints -   number of points, &gt;=0
    NFeatures-  number of features, &gt;=1
    DistType-   distance function:
                *  0    Chebyshev distance  (L-inf norm)
                *  1    city block distance (L1 norm)
                *  2    Euclidean distance  (L2 norm), non-squared
                * 10    Pearson correlation:
                        dist(a,b) = 1-corr(a,b)
                * 11    Absolute Pearson correlation:
                        dist(a,b) = 1-|corr(a,b)|
                * 12    Uncentered Pearson correlation (cosine of the angle):
                        dist(a,b) = a'*b/(|a|*|b|)
                * 13    Absolute uncentered Pearson correlation
                        dist(a,b) = |a'*b|/(|a|*|b|)
                * 20    Spearman rank correlation:
                        dist(a,b) = 1-rankcorr(a,b)
                * 21    Absolute Spearman rank correlation
                        dist(a,b) = 1-|rankcorr(a,b)|

NOTE 1: different distance functions have different performance penalty:
        * Euclidean or Pearson correlation distances are the fastest ones
        * Spearman correlation distance function is a bit slower
        * city block and Chebyshev distances are order of magnitude slower

        The reason behing difference in performance is that correlation-based
        distance functions are computed using optimized linear algebra kernels,
        while Chebyshev and city block distance functions are computed using
        simple nested loops with two branches at each iteration.

NOTE 2: different clustering algorithms have different limitations:
        * agglomerative hierarchical clustering algorithms may be used with
          any kind of distance metric
        * k-means++ clustering algorithm may be used only  with  Euclidean
          distance function
        Thus, list of specific clustering algorithms you may  use  depends
        on distance function you specify when you set your dataset.

  -- ALGLIB --
     Copyright 10.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetpoints(
    clusterizerstate s,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> disttype)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.clusterizersetpoints(
    clusterizerstate s,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nfeatures,
    <font color=navy>int</font> disttype)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_clst_ahc' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_clst_kmeans' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_clst_linkage' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_clst_distance' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_clst_kclusters' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='example_clst_ahc'></a><h3 class=pageheader>clst_ahc example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// The very simple clusterization example</font>
    <font color=green>//</font>
    <font color=green>// We have a set of points in 2D space:</font>
    <font color=green>//     (P0,P1,P2,P3,P4) = ((1,1),(1,2),(4,1),(2,3),(4,1.5))</font>
    <font color=green>//</font>
    <font color=green>//  |</font>
    <font color=green>//  |     P3</font>
    <font color=green>//  |</font>
    <font color=green>//  | P1          </font>
    <font color=green>//  |             P4</font>
    <font color=green>//  | P0          P2</font>
    <font color=green>//  |-------------------------</font>
    <font color=green>//</font>
    <font color=green>// We want to perform Agglomerative Hierarchic Clusterization (AHC),</font>
    <font color=green>// using complete linkage (default algorithm) and Euclidean distance</font>
    <font color=green>// (default metric).</font>
    <font color=green>//</font>
    <font color=green>// In order to <font color=navy>do</font> that, we:</font>
    <font color=green>// * create clusterizer with clusterizercreate()</font>
    <font color=green>// * set points XY and metric (2=Euclidean) with clusterizersetpoints()</font>
    <font color=green>// * run AHC algorithm with clusterizerrunahc</font>
    <font color=green>//</font>
    <font color=green>// You may see that clusterization itself is a minor part of the example,</font>
    <font color=green>// most of which is dominated by comments :)</font>
    <font color=green>//</font>
    alglib.clusterizerstate s;
    alglib.ahcreport rep;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,1},{1,2},{4,1},{2,3},{4,1.5}};

    alglib.clusterizercreate(<font color=navy>out</font> s);
    alglib.clusterizersetpoints(s, xy, 2);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Now we've built our clusterization tree. Rep.z contains information which</font>
    <font color=green>// is required to build dendrogram. I-th row of rep.z represents one merge</font>
    <font color=green>// operation, with first cluster to merge having index rep.z[I,0] and second</font>
    <font color=green>// one having index rep.z[I,1]. Merge result has index NPoints+I.</font>
    <font color=green>//</font>
    <font color=green>// Clusters with indexes less than NPoints are single-point initial clusters,</font>
    <font color=green>// <font color=navy>while</font> ones with indexes from NPoints to 2*NPoints-2 are multi-point</font>
    <font color=green>// clusters created during merges.</font>
    <font color=green>//</font>
    <font color=green>// In our example, Z=[[2,4], [0,1], [3,6], [5,7]]</font>
    <font color=green>//</font>
    <font color=green>// It means that:</font>
    <font color=green>// * first, we merge C2=(P2) and C4=(P4),    and create C5=(P2,P4)</font>
    <font color=green>// * then, we merge  C2=(P0) and C1=(P1),    and create C6=(P0,P1)</font>
    <font color=green>// * then, we merge  C3=(P3) and C6=(P0,P1), and create C7=(P0,P1,P3)</font>
    <font color=green>// * finally, we merge C5 and C7 and create C8=(P0,P1,P2,P3,P4)</font>
    <font color=green>//</font>
    <font color=green>// Thus, we have following dendrogram:</font>
    <font color=green>//  </font>
    <font color=green>//      ------8-----</font>
    <font color=green>//      |          |</font>
    <font color=green>//      |      ----7----</font>
    <font color=green>//      |      |       |</font>
    <font color=green>//   ---5---   |    ---6---</font>
    <font color=green>//   |     |   |    |     |</font>
    <font color=green>//   P2   P4   P3   P0   P1</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(rep.z)); <font color=green>// EXPECTED: [[2,4],[0,1],[3,6],[5,7]]</font>

    <font color=green>//</font>
    <font color=green>// We've built dendrogram above by reordering our dataset.</font>
    <font color=green>//</font>
    <font color=green>// Without such reordering it would be impossible to build dendrogram without</font>
    <font color=green>// intersections. Luckily, ahcreport structure contains two additional fields</font>
    <font color=green>// which help to build dendrogram from your data:</font>
    <font color=green>// * rep.p, which contains permutation applied to dataset</font>
    <font color=green>// * rep.pm, which contains another representation of merges </font>
    <font color=green>//</font>
    <font color=green>// In our example we have:</font>
    <font color=green>// * P=[3,4,0,2,1]</font>
    <font color=green>// * PZ=[[0,0,1,1,0,0],[3,3,4,4,0,0],[2,2,3,4,0,1],[0,1,2,4,1,2]]</font>
    <font color=green>//</font>
    <font color=green>// Permutation array P tells us that P0 should be moved to position 3,</font>
    <font color=green>// P1 moved to position 4, P2 moved to position 0 and so on:</font>
    <font color=green>//</font>
    <font color=green>//   (P0 P1 P2 P3 P4) =&gt; (P2 P4 P3 P0 P1)</font>
    <font color=green>//</font>
    <font color=green>// Merges array PZ tells us how to perform merges on the sorted dataset.</font>
    <font color=green>// One row of PZ corresponds to one merge operations, with first pair of</font>
    <font color=green>// elements denoting first of the clusters to merge (start index, end</font>
    <font color=green>// index) and next pair of elements denoting second of the clusters to</font>
    <font color=green>// merge. Clusters being merged are always adjacent, with first one on</font>
    <font color=green>// the left and second one on the right.</font>
    <font color=green>//</font>
    <font color=green>// For example, first row of PZ tells us that clusters [0,0] and [1,1] are</font>
    <font color=green>// merged (single-point clusters, with first one containing P2 and second</font>
    <font color=green>// one containing P4). Third row of PZ tells us that we merge one single-</font>
    <font color=green>// point cluster [2,2] with one two-point cluster [3,4].</font>
    <font color=green>//</font>
    <font color=green>// There are two more elements in each row of PZ. These are the helper</font>
    <font color=green>// elements, which denote HEIGHT (not size) of left and right subdendrograms.</font>
    <font color=green>// For example, according to PZ, first two merges are performed on clusterization</font>
    <font color=green>// trees of height 0, <font color=navy>while</font> next two merges are performed on 0-1 and 1-2</font>
    <font color=green>// pairs of trees correspondingly.</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(rep.p)); <font color=green>// EXPECTED: [3,4,0,2,1]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(rep.pm)); <font color=green>// EXPECTED: [[0,0,1,1,0,0],[3,3,4,4,0,0],[2,2,3,4,0,1],[0,1,2,4,1,2]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_clst_distance'></a><h3 class=pageheader>clst_distance example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We have three points in 4D space:</font>
    <font color=green>//     (P0,P1,P2) = ((1, 2, 1, 2), (6, 7, 6, 7), (7, 6, 7, 6))</font>
    <font color=green>//</font>
    <font color=green>// We want to try clustering them with different distance functions.</font>
    <font color=green>// Distance function is chosen when we add dataset to the clusterizer.</font>
    <font color=green>// We can choose several distance types - Euclidean, city block, Chebyshev,</font>
    <font color=green>// several correlation measures or user-supplied distance matrix.</font>
    <font color=green>//</font>
    <font color=green>// Here we'll try three distances: Euclidean, Pearson correlation,</font>
    <font color=green>// user-supplied distance matrix. Different distance functions lead</font>
    <font color=green>// to different choices being made by algorithm during clustering.</font>
    <font color=green>//</font>
    alglib.clusterizerstate s;
    alglib.ahcreport rep;
    <font color=navy>int</font> disttype;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,2,1,2},{6,7,6,7},{7,6,7,6}};
    alglib.clusterizercreate(<font color=navy>out</font> s);

    <font color=green>// With Euclidean distance function (disttype=2) two closest points</font>
    <font color=green>// are P1 and P2, thus:</font>
    <font color=green>// * first, we merge P1 and P2 to form C3=[P1,P2]</font>
    <font color=green>// * second, we merge P0 and C3 to form C4=[P0,P1,P2]</font>
    disttype = 2;
    alglib.clusterizersetpoints(s, xy, disttype);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(rep.z)); <font color=green>// EXPECTED: [[1,2],[0,3]]</font>

    <font color=green>// With Pearson correlation distance function (disttype=10) situation</font>
    <font color=green>// is different - distance between P0 and P1 is zero, thus:</font>
    <font color=green>// * first, we merge P0 and P1 to form C3=[P0,P1]</font>
    <font color=green>// * second, we merge P2 and C3 to form C4=[P0,P1,P2]</font>
    disttype = 10;
    alglib.clusterizersetpoints(s, xy, disttype);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(rep.z)); <font color=green>// EXPECTED: [[0,1],[2,3]]</font>

    <font color=green>// Finally, we try clustering with user-supplied distance matrix:</font>
    <font color=green>//     [ 0 3 1 ]</font>
    <font color=green>// P = [ 3 0 3 ], where P[i,j] = dist(Pi,Pj)</font>
    <font color=green>//     [ 1 3 0 ]</font>
    <font color=green>//</font>
    <font color=green>// * first, we merge P0 and P2 to form C3=[P0,P2]</font>
    <font color=green>// * second, we merge P1 and C3 to form C4=[P0,P1,P2]</font>
    <font color=navy>double</font>[,] d = new <font color=navy>double</font>[,]{{0,3,1},{3,0,3},{1,3,0}};
    alglib.clusterizersetdistances(s, d, true);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(rep.z)); <font color=green>// EXPECTED: [[0,2],[1,3]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_clst_kclusters'></a><h3 class=pageheader>clst_kclusters example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We have a set of points in 2D space:</font>
    <font color=green>//     (P0,P1,P2,P3,P4) = ((1,1),(1,2),(4,1),(2,3),(4,1.5))</font>
    <font color=green>//</font>
    <font color=green>//  |</font>
    <font color=green>//  |     P3</font>
    <font color=green>//  |</font>
    <font color=green>//  | P1          </font>
    <font color=green>//  |             P4</font>
    <font color=green>//  | P0          P2</font>
    <font color=green>//  |-------------------------</font>
    <font color=green>//</font>
    <font color=green>// We perform Agglomerative Hierarchic Clusterization (AHC) and we want</font>
    <font color=green>// to get top K clusters from clusterization tree <font color=navy>for</font> different K.</font>
    <font color=green>//</font>
    alglib.clusterizerstate s;
    alglib.ahcreport rep;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,1},{1,2},{4,1},{2,3},{4,1.5}};
    <font color=navy>int</font>[] cidx;
    <font color=navy>int</font>[] cz;

    alglib.clusterizercreate(<font color=navy>out</font> s);
    alglib.clusterizersetpoints(s, xy, 2);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);

    <font color=green>// with K=5, every points is assigned to its own cluster:</font>
    <font color=green>// C0=P0, C1=P1 and so on...</font>
    alglib.clusterizergetkclusters(rep, 5, <font color=navy>out</font> cidx, <font color=navy>out</font> cz);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(cidx)); <font color=green>// EXPECTED: [0,1,2,3,4]</font>

    <font color=green>// with K=1 we have one large cluster C0=[P0,P1,P2,P3,P4,P5]</font>
    alglib.clusterizergetkclusters(rep, 1, <font color=navy>out</font> cidx, <font color=navy>out</font> cz);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(cidx)); <font color=green>// EXPECTED: [0,0,0,0,0]</font>

    <font color=green>// with K=3 we have three clusters C0=[P3], C1=[P2,P4], C2=[P0,P1]</font>
    alglib.clusterizergetkclusters(rep, 3, <font color=navy>out</font> cidx, <font color=navy>out</font> cz);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(cidx)); <font color=green>// EXPECTED: [2,2,1,0,1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_clst_kmeans'></a><h3 class=pageheader>clst_kmeans example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// The very simple clusterization example</font>
    <font color=green>//</font>
    <font color=green>// We have a set of points in 2D space:</font>
    <font color=green>//     (P0,P1,P2,P3,P4) = ((1,1),(1,2),(4,1),(2,3),(4,1.5))</font>
    <font color=green>//</font>
    <font color=green>//  |</font>
    <font color=green>//  |     P3</font>
    <font color=green>//  |</font>
    <font color=green>//  | P1          </font>
    <font color=green>//  |             P4</font>
    <font color=green>//  | P0          P2</font>
    <font color=green>//  |-------------------------</font>
    <font color=green>//</font>
    <font color=green>// We want to perform k-means++ clustering with K=2.</font>
    <font color=green>//</font>
    <font color=green>// In order to <font color=navy>do</font> that, we:</font>
    <font color=green>// * create clusterizer with clusterizercreate()</font>
    <font color=green>// * set points XY and metric (must be Euclidean, distype=2) with clusterizersetpoints()</font>
    <font color=green>// * (optional) set number of restarts from random positions to 5</font>
    <font color=green>// * run k-means algorithm with clusterizerrunkmeans()</font>
    <font color=green>//</font>
    <font color=green>// You may see that clusterization itself is a minor part of the example,</font>
    <font color=green>// most of which is dominated by comments :)</font>
    <font color=green>//</font>
    alglib.clusterizerstate s;
    alglib.kmeansreport rep;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,1},{1,2},{4,1},{2,3},{4,1.5}};

    alglib.clusterizercreate(<font color=navy>out</font> s);
    alglib.clusterizersetpoints(s, xy, 2);
    alglib.clusterizersetkmeanslimits(s, 5, 0);
    alglib.clusterizerrunkmeans(s, 2, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// We've performed clusterization, and it succeeded (completion code is +1).</font>
    <font color=green>//</font>
    <font color=green>// Now first center is stored in the first row of rep.c, second one is stored</font>
    <font color=green>// in the second row. rep.cidx can be used to determine which center is</font>
    <font color=green>// closest to some specific point of the dataset.</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>

    <font color=green>// We called clusterizersetpoints() with disttype=2 because k-means++</font>
    <font color=green>// algorithm does NOT support metrics other than Euclidean. But what <font color=navy>if</font> we</font>
    <font color=green>// try to use some other metric?</font>
    <font color=green>//</font>
    <font color=green>// We change metric type by calling clusterizersetpoints() one more time,</font>
    <font color=green>// and try to run k-means algo again. It fails.</font>
    <font color=green>//</font>
    alglib.clusterizersetpoints(s, xy, 0);
    alglib.clusterizerrunkmeans(s, 2, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: -5</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_clst_linkage'></a><h3 class=pageheader>clst_linkage example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We have a set of points in 1D space:</font>
    <font color=green>//     (P0,P1,P2,P3,P4) = (1, 3, 10, 16, 20)</font>
    <font color=green>//</font>
    <font color=green>// We want to perform Agglomerative Hierarchic Clusterization (AHC),</font>
    <font color=green>// using either complete or single linkage and Euclidean distance</font>
    <font color=green>// (default metric).</font>
    <font color=green>//</font>
    <font color=green>// First two steps merge P0/P1 and P3/P4 independently of the linkage type.</font>
    <font color=green>// However, third step depends on linkage type being used:</font>
    <font color=green>// * in case of complete linkage P2=10 is merged with [P0,P1]</font>
    <font color=green>// * in case of single linkage P2=10 is merged with [P3,P4]</font>
    <font color=green>//</font>
    alglib.clusterizerstate s;
    alglib.ahcreport rep;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1},{3},{10},{16},{20}};
    <font color=navy>int</font>[] cidx;
    <font color=navy>int</font>[] cz;

    alglib.clusterizercreate(<font color=navy>out</font> s);
    alglib.clusterizersetpoints(s, xy, 2);

    <font color=green>// use complete linkage, reduce set down to 2 clusters.</font>
    <font color=green>// print clusterization with clusterizergetkclusters(2).</font>
    <font color=green>// P2 must belong to [P0,P1]</font>
    alglib.clusterizersetahcalgo(s, 0);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);
    alglib.clusterizergetkclusters(rep, 2, <font color=navy>out</font> cidx, <font color=navy>out</font> cz);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(cidx)); <font color=green>// EXPECTED: [1,1,1,0,0]</font>

    <font color=green>// use single linkage, reduce set down to 2 clusters.</font>
    <font color=green>// print clusterization with clusterizergetkclusters(2).</font>
    <font color=green>// P2 must belong to [P2,P3]</font>
    alglib.clusterizersetahcalgo(s, 1);
    alglib.clusterizerrunahc(s, <font color=navy>out</font> rep);
    alglib.clusterizergetkclusters(rep, 2, <font color=navy>out</font> cidx, <font color=navy>out</font> cz);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(cidx)); <font color=green>// EXPECTED: [0,0,1,1,1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_conv></a><h2 class=pageheader><code>conv</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_convc1d' class=toc>convc1d</a><br>
<a href='#sub_convc1dcircular' class=toc>convc1dcircular</a><br>
<a href='#sub_convc1dcircularinv' class=toc>convc1dcircularinv</a><br>
<a href='#sub_convc1dinv' class=toc>convc1dinv</a><br>
<a href='#sub_convr1d' class=toc>convr1d</a><br>
<a href='#sub_convr1dcircular' class=toc>convr1dcircular</a><br>
<a href='#sub_convr1dcircularinv' class=toc>convr1dcircularinv</a><br>
<a href='#sub_convr1dinv' class=toc>convr1dinv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_convc1d'></a><h3 class=pageheader><code>convc1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex convolution.

For given A/B returns conv(A,B) (non-circular). Subroutine can automatically
choose between three implementations: straightforward O(M*N)  formula  for
very small N (or M), overlap-add algorithm for  cases  where  max(M,N)  is
significantly larger than min(M,N), but O(M*N) algorithm is too slow,  and
general FFT-based formula for cases where two previois algorithms are  too
slow.

Algorithm has max(M,N)*log(max(M,N)) complexity for any M/N.

INPUT PARAMETERS
    A   -   array[0..M-1] - complex function to be transformed
    M   -   problem size
    B   -   array[0..N-1] - complex function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..N+M-2].

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convc1d(
    complex[] a,
    <font color=navy>int</font> m,
    complex[] b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] r)

</div></pre>
<a name='sub_convc1dcircular'></a><h3 class=pageheader><code>convc1dcircular</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular complex convolution.

For given S/R returns conv(S,R) (circular). Algorithm has linearithmic
complexity for any M/N.

IMPORTANT:  normal convolution is commutative,  i.e.   it  is symmetric  -
conv(A,B)=conv(B,A).  Cyclic convolution IS NOT.  One function - S - is  a
signal,  periodic function, and another - R - is a response,  non-periodic
function with limited length.

INPUT PARAMETERS
    S   -   array[0..M-1] - complex periodic signal
    M   -   problem size
    B   -   array[0..N-1] - complex non-periodic response
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convc1dcircular(
    complex[] s,
    <font color=navy>int</font> m,
    complex[] r,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] c)

</div></pre>
<a name='sub_convc1dcircularinv'></a><h3 class=pageheader><code>convc1dcircularinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular complex deconvolution (inverse of ConvC1DCircular()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved periodic signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - non-periodic response
    N   -   response length

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-1].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convc1dcircularinv(
    complex[] a,
    <font color=navy>int</font> m,
    complex[] b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] r)

</div></pre>
<a name='sub_convc1dinv'></a><h3 class=pageheader><code>convc1dinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex non-circular deconvolution (inverse of ConvC1D()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - response
    N   -   response length, N&lt;=M

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-N].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convc1dinv(
    complex[] a,
    <font color=navy>int</font> m,
    complex[] b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] r)

</div></pre>
<a name='sub_convr1d'></a><h3 class=pageheader><code>convr1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real convolution.

Analogous to ConvC1D(), see ConvC1D() comments for more details.

INPUT PARAMETERS
    A   -   array[0..M-1] - real function to be transformed
    M   -   problem size
    B   -   array[0..N-1] - real function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..N+M-2].

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convr1d(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] r)

</div></pre>
<a name='sub_convr1dcircular'></a><h3 class=pageheader><code>convr1dcircular</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular real convolution.

Analogous to ConvC1DCircular(), see ConvC1DCircular() comments for more details.

INPUT PARAMETERS
    S   -   array[0..M-1] - real signal
    M   -   problem size
    B   -   array[0..N-1] - real response
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convr1dcircular(
    <font color=navy>double</font>[] s,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] r,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] c)

</div></pre>
<a name='sub_convr1dcircularinv'></a><h3 class=pageheader><code>convr1dcircularinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex deconvolution (inverse of ConvC1D()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - response
    N   -   response length

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-N].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convr1dcircularinv(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] r)

</div></pre>
<a name='sub_convr1dinv'></a><h3 class=pageheader><code>convr1dinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real deconvolution (inverse of ConvC1D()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - response
    N   -   response length, N&lt;=M

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-N].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.convr1dinv(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] r)

</div></pre>
<a name=unit_corr></a><h2 class=pageheader><code>corr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_corrc1d' class=toc>corrc1d</a><br>
<a href='#sub_corrc1dcircular' class=toc>corrc1dcircular</a><br>
<a href='#sub_corrr1d' class=toc>corrr1d</a><br>
<a href='#sub_corrr1dcircular' class=toc>corrr1dcircular</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_corrc1d'></a><h3 class=pageheader><code>corrc1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (non-circular).

Correlation is calculated using reduction to  convolution.  Algorithm with
max(N,N)*log(max(N,N)) complexity is used (see  ConvC1D()  for  more  info
about performance).

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order: CorrC1D(Signal, Pattern) = Pattern x Signal (using  traditional
    definition of cross-correlation, denoting cross-correlation as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - complex function to be transformed,
                signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - complex function to be transformed,
                pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R       -   cross-correlation, array[0..N+M-2]:
                * positive lags are stored in R[0..N-1],
                  R[i] = sum(conj(pattern[j])*signal[i+j]
                * negative lags are stored in R[N..N+M-2],
                  R[N+M-1-i] = sum(conj(pattern[j])*signal[-i+j]

NOTE:
    It is assumed that pattern domain is [0..M-1].  If Pattern is non-zero
on [-K..M-1],  you can still use this subroutine, just shift result by K.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.corrc1d(
    complex[] signal,
    <font color=navy>int</font> n,
    complex[] pattern,
    <font color=navy>int</font> m,
    <font color=navy>out</font> complex[] r)

</div></pre>
<a name='sub_corrc1dcircular'></a><h3 class=pageheader><code>corrc1dcircular</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular complex cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (circular).
Algorithm has linearithmic complexity for any M/N.

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order:   CorrC1DCircular(Signal, Pattern) = Pattern x Signal    (using
    traditional definition of cross-correlation, denoting cross-correlation
    as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - complex function to be transformed,
                periodic signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - complex function to be transformed,
                non-periodic pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].


  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.corrc1dcircular(
    complex[] signal,
    <font color=navy>int</font> m,
    complex[] pattern,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] c)

</div></pre>
<a name='sub_corrr1d'></a><h3 class=pageheader><code>corrr1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (non-circular).

Correlation is calculated using reduction to  convolution.  Algorithm with
max(N,N)*log(max(N,N)) complexity is used (see  ConvC1D()  for  more  info
about performance).

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order: CorrR1D(Signal, Pattern) = Pattern x Signal (using  traditional
    definition of cross-correlation, denoting cross-correlation as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - real function to be transformed,
                signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - real function to be transformed,
                pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R       -   cross-correlation, array[0..N+M-2]:
                * positive lags are stored in R[0..N-1],
                  R[i] = sum(pattern[j]*signal[i+j]
                * negative lags are stored in R[N..N+M-2],
                  R[N+M-1-i] = sum(pattern[j]*signal[-i+j]

NOTE:
    It is assumed that pattern domain is [0..M-1].  If Pattern is non-zero
on [-K..M-1],  you can still use this subroutine, just shift result by K.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.corrr1d(
    <font color=navy>double</font>[] signal,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] pattern,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[] r)

</div></pre>
<a name='sub_corrr1dcircular'></a><h3 class=pageheader><code>corrr1dcircular</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular real cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (circular).
Algorithm has linearithmic complexity for any M/N.

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order:   CorrR1DCircular(Signal, Pattern) = Pattern x Signal    (using
    traditional definition of cross-correlation, denoting cross-correlation
    as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - real function to be transformed,
                periodic signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - real function to be transformed,
                non-periodic pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].


  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.corrr1dcircular(
    <font color=navy>double</font>[] signal,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] pattern,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] c)

</div></pre>
<a name=unit_correlationtests></a><h2 class=pageheader><code>correlationtests</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_pearsoncorrelationsignificance' class=toc>pearsoncorrelationsignificance</a><br>
<a href='#sub_spearmanrankcorrelationsignificance' class=toc>spearmanrankcorrelationsignificance</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_pearsoncorrelationsignificance'></a><h3 class=pageheader><code>pearsoncorrelationsignificance</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Pearson's correlation coefficient significance test

This test checks hypotheses about whether X  and  Y  are  samples  of  two
continuous  distributions  having  zero  correlation  or   whether   their
correlation is non-zero.

The following tests are performed:
    * two-tailed test (null hypothesis - X and Y have zero correlation)
    * left-tailed test (null hypothesis - the correlation  coefficient  is
      greater than or equal to 0)
    * right-tailed test (null hypothesis - the correlation coefficient  is
      less than or equal to 0).

Requirements:
    * the number of elements in each sample is not less than 5
    * normality of distributions of X and Y.

Input parameters:
    R   -   Pearson's correlation coefficient for X and Y
    N   -   number of elements in samples, N&gt;=5.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

  -- ALGLIB --
     Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pearsoncorrelationsignificance(
    <font color=navy>double</font> r,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name='sub_spearmanrankcorrelationsignificance'></a><h3 class=pageheader><code>spearmanrankcorrelationsignificance</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Spearman's rank correlation coefficient significance test

This test checks hypotheses about whether X  and  Y  are  samples  of  two
continuous  distributions  having  zero  correlation  or   whether   their
correlation is non-zero.

The following tests are performed:
    * two-tailed test (null hypothesis - X and Y have zero correlation)
    * left-tailed test (null hypothesis - the correlation  coefficient  is
      greater than or equal to 0)
    * right-tailed test (null hypothesis - the correlation coefficient  is
      less than or equal to 0).

Requirements:
    * the number of elements in each sample is not less than 5.

The test is non-parametric and doesn't require distributions X and Y to be
normal.

Input parameters:
    R   -   Spearman's rank correlation coefficient for X and Y
    N   -   number of elements in samples, N&gt;=5.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

  -- ALGLIB --
     Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spearmanrankcorrelationsignificance(
    <font color=navy>double</font> r,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name=unit_datacomp></a><h2 class=pageheader><code>datacomp</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_kmeansgenerate' class=toc>kmeansgenerate</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_kmeansgenerate'></a><h3 class=pageheader><code>kmeansgenerate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
k-means++ clusterization.
Backward compatibility function, we recommend to use CLUSTERING subpackage
as better replacement.

  -- ALGLIB --
     Copyright 21.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kmeansgenerate(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> k,
    <font color=navy>int</font> restarts,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[,] c,
    <font color=navy>out</font> <font color=navy>int</font>[] xyc)

</div></pre>
<a name=unit_dawson></a><h2 class=pageheader><code>dawson</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_dawsonintegral' class=toc>dawsonintegral</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_dawsonintegral'></a><h3 class=pageheader><code>dawsonintegral</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dawson's Integral

Approximates the integral

                            x
                            -
                     2     | |        2
 dawsn(x)  =  exp( -x  )   |    exp( t  ) dt
                         | |
                          -
                          0

Three different rational approximations are employed, for
the intervals 0 to 3.25; 3.25 to 6.25; and 6.25 up.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0,10        10000       6.9e-16     1.0e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.dawsonintegral(<font color=navy>double</font> x)

</div></pre>
<a name=unit_densesolver></a><h2 class=pageheader><code>densesolver</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_densesolverlsreport' class=toc>densesolverlsreport</a><br>
<a href='#struct_densesolverreport' class=toc>densesolverreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlusolve' class=toc>cmatrixlusolve</a><br>
<a href='#sub_cmatrixlusolvefast' class=toc>cmatrixlusolvefast</a><br>
<a href='#sub_cmatrixlusolvem' class=toc>cmatrixlusolvem</a><br>
<a href='#sub_cmatrixlusolvemfast' class=toc>cmatrixlusolvemfast</a><br>
<a href='#sub_cmatrixmixedsolve' class=toc>cmatrixmixedsolve</a><br>
<a href='#sub_cmatrixmixedsolvem' class=toc>cmatrixmixedsolvem</a><br>
<a href='#sub_cmatrixsolve' class=toc>cmatrixsolve</a><br>
<a href='#sub_cmatrixsolvefast' class=toc>cmatrixsolvefast</a><br>
<a href='#sub_cmatrixsolvem' class=toc>cmatrixsolvem</a><br>
<a href='#sub_cmatrixsolvemfast' class=toc>cmatrixsolvemfast</a><br>
<a href='#sub_hpdmatrixcholeskysolve' class=toc>hpdmatrixcholeskysolve</a><br>
<a href='#sub_hpdmatrixcholeskysolvefast' class=toc>hpdmatrixcholeskysolvefast</a><br>
<a href='#sub_hpdmatrixcholeskysolvem' class=toc>hpdmatrixcholeskysolvem</a><br>
<a href='#sub_hpdmatrixcholeskysolvemfast' class=toc>hpdmatrixcholeskysolvemfast</a><br>
<a href='#sub_hpdmatrixsolve' class=toc>hpdmatrixsolve</a><br>
<a href='#sub_hpdmatrixsolvefast' class=toc>hpdmatrixsolvefast</a><br>
<a href='#sub_hpdmatrixsolvem' class=toc>hpdmatrixsolvem</a><br>
<a href='#sub_hpdmatrixsolvemfast' class=toc>hpdmatrixsolvemfast</a><br>
<a href='#sub_rmatrixlusolve' class=toc>rmatrixlusolve</a><br>
<a href='#sub_rmatrixlusolvefast' class=toc>rmatrixlusolvefast</a><br>
<a href='#sub_rmatrixlusolvem' class=toc>rmatrixlusolvem</a><br>
<a href='#sub_rmatrixlusolvemfast' class=toc>rmatrixlusolvemfast</a><br>
<a href='#sub_rmatrixmixedsolve' class=toc>rmatrixmixedsolve</a><br>
<a href='#sub_rmatrixmixedsolvem' class=toc>rmatrixmixedsolvem</a><br>
<a href='#sub_rmatrixsolve' class=toc>rmatrixsolve</a><br>
<a href='#sub_rmatrixsolvefast' class=toc>rmatrixsolvefast</a><br>
<a href='#sub_rmatrixsolvels' class=toc>rmatrixsolvels</a><br>
<a href='#sub_rmatrixsolvem' class=toc>rmatrixsolvem</a><br>
<a href='#sub_rmatrixsolvemfast' class=toc>rmatrixsolvemfast</a><br>
<a href='#sub_spdmatrixcholeskysolve' class=toc>spdmatrixcholeskysolve</a><br>
<a href='#sub_spdmatrixcholeskysolvefast' class=toc>spdmatrixcholeskysolvefast</a><br>
<a href='#sub_spdmatrixcholeskysolvem' class=toc>spdmatrixcholeskysolvem</a><br>
<a href='#sub_spdmatrixcholeskysolvemfast' class=toc>spdmatrixcholeskysolvemfast</a><br>
<a href='#sub_spdmatrixsolve' class=toc>spdmatrixsolve</a><br>
<a href='#sub_spdmatrixsolvefast' class=toc>spdmatrixsolvefast</a><br>
<a href='#sub_spdmatrixsolvem' class=toc>spdmatrixsolvem</a><br>
<a href='#sub_spdmatrixsolvemfast' class=toc>spdmatrixsolvemfast</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_densesolverlsreport'></a><h3 class=pageheader><code>densesolverlsreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class densesolverlsreport
{
    <font color=navy>public</font> <font color=navy>double</font>               r2;
    <font color=navy>public</font> <font color=navy>double</font>[,]            cx;
    <font color=navy>public</font> <font color=navy>int</font>                  n;
    <font color=navy>public</font> <font color=navy>int</font>                  k;
}

</div></pre>
<a name='struct_densesolverreport'></a><h3 class=pageheader><code>densesolverreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class densesolverreport
{
    <font color=navy>public</font> <font color=navy>double</font>               r1;
    <font color=navy>public</font> <font color=navy>double</font>               rinf;
}

</div></pre>
<a name='sub_cmatrixlusolve'></a><h3 class=pageheader><code>cmatrixlusolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex dense linear solver for A*x=b with complex N*N A  given  by its LU
decomposition and N*1 vectors x and b. This is  &quot;slow-but-robust&quot;  version
of  the  complex  linear  solver  with  additional  features   which   add
significant performance overhead. Faster version  is  CMatrixLUSolveFast()
function.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation

No iterative refinement is provided because exact form of original matrix
is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which results in 10-15x  performance  penalty  when  compared
           ! with &quot;fast&quot; version which just calls triangular solver.
           !
           ! This performance penalty is insignificant  when compared with
           ! cost of large LU decomposition.  However,  if you  call  this
           ! function many times for the same  left  side,  this  overhead
           ! BECOMES significant. It  also  becomes significant for small-
           ! scale problems.
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! CMatrixLUSolveFast() function.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlusolve(
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)

</div></pre>
<a name='sub_cmatrixlusolvefast'></a><h3 class=pageheader><code>cmatrixlusolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex dense linear solver for A*x=b with N*N complex A given by  its  LU
decomposition and N*1 vectors x and b. This is  fast  lightweight  version
of solver, which is significantly faster than CMatrixLUSolve(),  but  does
not provide additional information (like condition numbers).

Algorithm features:
* O(N^2) complexity
* no additional time-consuming features, just triangular solver

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros

NOTE: unlike  CMatrixLUSolve(),  this   function   does   NOT   check  for
      near-degeneracy of input matrix. It  checks  for  EXACT  degeneracy,
      because this check is easy to do. However,  very  badly  conditioned
      matrices may went unnoticed.


  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlusolvefast(
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_cmatrixlusolvem'></a><h3 class=pageheader><code>cmatrixlusolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N complex A given by its  LU  decomposition,
and N*M matrices X and B (multiple right sides).   &quot;Slow-but-feature-rich&quot;
version of the solver.

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation

No iterative refinement  is provided because exact form of original matrix
is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant  performance   penalty   when
           ! compared with &quot;fast&quot;  version  which  just  calls  triangular
           ! solver.
           !
           ! This performance penalty is especially apparent when you  use
           ! ALGLIB parallel capabilities (condition number estimation  is
           ! inherently  sequential).  It   also   becomes significant for
           ! small-scale problems.
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! CMatrixLUSolveMFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. Triangular solver is relatively easy to parallelize.
  ! However, parallelization will be efficient  only for  large number  of
  ! right parts M.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlusolvem(
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixlusolvem(
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)

</div></pre>
<a name='sub_cmatrixlusolvemfast'></a><h3 class=pageheader><code>cmatrixlusolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N complex A given by its  LU  decomposition,
and N*M matrices X and B (multiple  right  sides).  &quot;Fast-but-lightweight&quot;
version of the solver.

Algorithm features:
* O(M*N^2) complexity
* no additional time-consuming features

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. Triangular solver is relatively easy to parallelize.
  ! However, parallelization will be efficient  only for  large number  of
  ! right parts M.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N,M]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros


  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlusolvemfast(
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixlusolvemfast(
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_cmatrixmixedsolve'></a><h3 class=pageheader><code>cmatrixmixedsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixMixedSolve(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixmixedsolve(
    complex[,] a,
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)

</div></pre>
<a name='sub_cmatrixmixedsolvem'></a><h3 class=pageheader><code>cmatrixmixedsolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixMixedSolveM(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(M*N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixmixedsolvem(
    complex[,] a,
    complex[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)

</div></pre>
<a name='sub_cmatrixsolve'></a><h3 class=pageheader><code>cmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex dense solver for A*x=B with N*N complex matrix A and  N*1  complex
vectors x and b. &quot;Slow-but-feature-rich&quot; version of the solver.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^3) complexity

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear  system
           ! and  performs  iterative   refinement,   which   results   in
           ! significant performance penalty  when  compared  with  &quot;fast&quot;
           ! version  which  just  performs  LU  decomposition  and  calls
           ! triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, CMatrixSolveFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixsolve(
    complex[,] a,
    <font color=navy>int</font> n,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixsolve(
    complex[,] a,
    <font color=navy>int</font> n,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)

</div></pre>
<a name='sub_cmatrixsolvefast'></a><h3 class=pageheader><code>cmatrixsolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex dense solver for A*x=B with N*N complex matrix A and  N*1  complex
vectors x and b. &quot;Fast-but-lightweight&quot; version of the solver.

Algorithm features:
* O(N^3) complexity
* no additional time consuming features, just triangular solver

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixsolvefast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixsolvefast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_cmatrixsolvem'></a><h3 class=pageheader><code>cmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex dense solver for A*X=B with N*N  complex  matrix  A,  N*M  complex
matrices  X  and  B.  &quot;Slow-but-feature-rich&quot;   version   which   provides
additional functions, at the cost of slower  performance.  Faster  version
may be invoked with CMatrixSolveMFast() function.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^3+M*N^2) complexity

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear  system
           ! and  performs  iterative   refinement,   which   results   in
           ! significant performance penalty  when  compared  with  &quot;fast&quot;
           ! version  which  just  performs  LU  decomposition  and  calls
           ! triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, CMatrixSolveMFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size
    RFS     -   iterative refinement switch:
                * True - refinement is used.
                  Less performance, more precision.
                * False - refinement is not used.
                  More performance, less precision.

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixsolvem(
    complex[,] a,
    <font color=navy>int</font> n,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>bool</font> rfs,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixsolvem(
    complex[,] a,
    <font color=navy>int</font> n,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>bool</font> rfs,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)

</div></pre>
<a name='sub_cmatrixsolvemfast'></a><h3 class=pageheader><code>cmatrixsolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex dense solver for A*X=B with N*N  complex  matrix  A,  N*M  complex
matrices  X  and  B.  &quot;Fast-but-lightweight&quot; version which  provides  just
triangular solver - and no additional functions like iterative  refinement
or condition number estimation.

Algorithm features:
* O(N^3+M*N^2) complexity
* no additional time consuming functions

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N,M]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 16.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixsolvemfast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixsolvemfast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_hpdmatrixcholeskysolve'></a><h3 class=pageheader><code>hpdmatrixcholeskysolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b with N*N Hermitian positive definite matrix A given
by its Cholesky decomposition, and N*1 complex vectors x and  b.  This  is
&quot;slow-but-feature-rich&quot; version of the solver  which  estimates  condition
number of the system.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which results in 10-15x  performance  penalty  when  compared
           ! with &quot;fast&quot; version which just calls triangular solver.
           !
           ! This performance penalty is insignificant  when compared with
           ! cost of large LU decomposition.  However,  if you  call  this
           ! function many times for the same  left  side,  this  overhead
           ! BECOMES significant. It  also  becomes significant for small-
           ! scale problems (N&lt;50).
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! HPDMatrixCholeskySolveFast() function.

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of A
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or ill conditioned
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N]:
                * for info&gt;0  - solution
                * for info=-3 - filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixcholeskysolve(
    complex[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)

</div></pre>
<a name='sub_hpdmatrixcholeskysolvefast'></a><h3 class=pageheader><code>hpdmatrixcholeskysolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b with N*N Hermitian positive definite matrix A given
by its Cholesky decomposition, and N*1 complex vectors x and  b.  This  is
&quot;fast-but-lightweight&quot; version of the solver.

Algorithm features:
* O(N^2) complexity
* matrix is represented by its upper or lower triangle
* no additional time-consuming features

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of A
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or ill conditioned
                        B is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N]:
                * for info&gt;0  - overwritten by solution
                * for info=-3 - filled by zeros

  -- ALGLIB --
     Copyright 18.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixcholeskysolvefast(
    complex[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_hpdmatrixcholeskysolvem'></a><h3 class=pageheader><code>hpdmatrixcholeskysolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N Hermitian positive definite matrix A given
by its Cholesky decomposition and N*M complex matrices X  and  B.  This is
&quot;slow-but-feature-rich&quot; version of the solver which, in  addition  to  the
solution, estimates condition number of the system.

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant  performance   penalty   when
           ! compared with &quot;fast&quot;  version  which  just  calls  triangular
           ! solver. Amount of  overhead  introduced  depends  on  M  (the
           ! larger - the more efficient).
           !
           ! This performance penalty is insignificant  when compared with
           ! cost of large Cholesky decomposition.  However,  if  you call
           ! this  function  many  times  for  the same  left  side,  this
           ! overhead BECOMES significant. It  also   becomes  significant
           ! for small-scale problems (N&lt;50).
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! HPDMatrixCholeskySolveMFast() function.


INPUT PARAMETERS
    CHA     -   array[N,N], Cholesky decomposition,
                HPDMatrixCholesky result
    N       -   size of CHA
    IsUpper -   what half of CHA is provided
    B       -   array[N,M], right part
    M       -   right part size

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    A is singular, or VERY close to singular.
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task was solved
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N]:
                * for info&gt;0 contains solution
                * for info=-3 filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixcholeskysolvem(
    complex[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixcholeskysolvem(
    complex[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)

</div></pre>
<a name='sub_hpdmatrixcholeskysolvemfast'></a><h3 class=pageheader><code>hpdmatrixcholeskysolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N Hermitian positive definite matrix A given
by its Cholesky decomposition and N*M complex matrices X  and  B.  This is
&quot;fast-but-lightweight&quot; version of the solver.

Algorithm features:
* O(M*N^2) complexity
* matrix is represented by its upper or lower triangle
* no additional time-consuming features

INPUT PARAMETERS
    CHA     -   array[N,N], Cholesky decomposition,
                HPDMatrixCholesky result
    N       -   size of CHA
    IsUpper -   what half of CHA is provided
    B       -   array[N,M], right part
    M       -   right part size

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    A is singular, or VERY close to singular.
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task was solved
    B       -   array[N]:
                * for info&gt;0 overwritten by solution
                * for info=-3 filled by zeros

  -- ALGLIB --
     Copyright 18.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixcholeskysolvemfast(
    complex[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixcholeskysolvemfast(
    complex[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_hpdmatrixsolve'></a><h3 class=pageheader><code>hpdmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b, with N*N Hermitian positive definite matrix A, and
N*1 complex vectors  x  and  b.  &quot;Slow-but-feature-rich&quot;  version  of  the
solver.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant   performance   penalty  when
           ! compared with &quot;fast&quot; version  which  just  performs  Cholesky
           ! decomposition and calls triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, HPDMatrixSolveFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
                Returns -3 for non-HPD matrices.
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixsolve(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixsolve(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[] x)

</div></pre>
<a name='sub_hpdmatrixsolvefast'></a><h3 class=pageheader><code>hpdmatrixsolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b, with N*N Hermitian positive definite matrix A, and
N*1 complex vectors  x  and  b.  &quot;Fast-but-lightweight&quot;  version  of   the
solver without additional functions.

Algorithm features:
* O(N^3) complexity
* matrix is represented by its upper or lower triangle
* no additional time consuming functions

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or not positive definite
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task was solved
    B       -   array[0..N-1]:
                * overwritten by solution
                * zeros, if A is exactly singular (diagonal of its LU
                  decomposition has exact zeros).

  -- ALGLIB --
     Copyright 17.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixsolvefast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixsolvefast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_hpdmatrixsolvem'></a><h3 class=pageheader><code>hpdmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B, with N*N Hermitian positive definite matrix A  and
N*M  complex  matrices  X  and  B.  &quot;Slow-but-feature-rich&quot; version of the
solver.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3+M*N^2) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant  performance   penalty   when
           ! compared with &quot;fast&quot;  version  which  just  calls  triangular
           ! solver.
           !
           ! This performance penalty is especially apparent when you  use
           ! ALGLIB parallel capabilities (condition number estimation  is
           ! inherently  sequential).  It   also   becomes significant for
           ! small-scale problems (N&lt;100).
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! HPDMatrixSolveMFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve.
                Returns -3 for non-HPD matrices.
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixsolvem(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixsolvem(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> complex[,] x)

</div></pre>
<a name='sub_hpdmatrixsolvemfast'></a><h3 class=pageheader><code>hpdmatrixsolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B, with N*N Hermitian positive definite matrix A  and
N*M complex matrices X and B. &quot;Fast-but-lightweight&quot; version of the solver.

Algorithm features:
* O(N^3+M*N^2) complexity
* matrix is represented by its upper or lower triangle
* no additional time consuming features like condition number estimation

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly  singular or is not positive definite.
                        B is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[0..N-1]:
                * overwritten by solution
                * zeros, if problem was not solved

  -- ALGLIB --
     Copyright 17.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixsolvemfast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixsolvemfast(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> complex[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_rmatrixlusolve'></a><h3 class=pageheader><code>rmatrixlusolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
real matrix given by its LU decomposition, x and b are real vectors.  This
is &quot;slow-but-robust&quot; version of the linear LU-based solver. Faster version
is RMatrixLUSolveFast() function.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation

No iterative refinement  is provided because exact form of original matrix
is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which results in 10-15x  performance  penalty  when  compared
           ! with &quot;fast&quot; version which just calls triangular solver.
           !
           ! This performance penalty is insignificant  when compared with
           ! cost of large LU decomposition.  However,  if you  call  this
           ! function many times for the same  left  side,  this  overhead
           ! BECOMES significant. It  also  becomes significant for small-
           ! scale problems.
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! RMatrixLUSolveFast() function.

INPUT PARAMETERS
    LUA     -   array[N,N], LU decomposition, RMatrixLU result
    P       -   array[N], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[N], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros


  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlusolve(
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_rmatrixlusolvefast'></a><h3 class=pageheader><code>rmatrixlusolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
real matrix given by its LU decomposition, x and b are real vectors.  This
is &quot;fast-without-any-checks&quot; version of the linear LU-based solver. Slower
but more robust version is RMatrixLUSolve() function.

Algorithm features:
* O(N^2) complexity
* fast algorithm without ANY additional checks, just triangular solver

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 18.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlusolvefast(
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_rmatrixlusolvem'></a><h3 class=pageheader><code>rmatrixlusolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixLUSolve() but solves  task  with  multiple  right  parts
(where b and x are NxM matrices). This  is  &quot;robust-but-slow&quot;  version  of
LU-based solver which performs additional  checks  for  non-degeneracy  of
inputs (condition number estimation). If you need  best  performance,  use
&quot;fast-without-any-checks&quot; version, RMatrixLUSolveMFast().

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation

No iterative refinement  is provided because exact form of original matrix
is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant  performance   penalty   when
           ! compared with &quot;fast&quot;  version  which  just  calls  triangular
           ! solver.
           !
           ! This performance penalty is especially apparent when you  use
           ! ALGLIB parallel capabilities (condition number estimation  is
           ! inherently  sequential).  It   also   becomes significant for
           ! small-scale problems.
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! RMatrixLUSolveMFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. Triangular solver is relatively easy to parallelize.
  ! However, parallelization will be efficient  only for  large number  of
  ! right parts M.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    LUA     -   array[N,N], LU decomposition, RMatrixLU result
    P       -   array[N], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros


  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlusolvem(
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixlusolvem(
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)

</div></pre>
<a name='sub_rmatrixlusolvemfast'></a><h3 class=pageheader><code>rmatrixlusolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixLUSolve() but solves  task  with  multiple  right parts,
where b and x are NxM matrices.  This is &quot;fast-without-any-checks&quot; version
of LU-based solver. It does not estimate  condition number  of  a  system,
so it is extremely fast. If you need better detection  of  near-degenerate
cases, use RMatrixLUSolveM() function.

Algorithm features:
* O(M*N^2) complexity
* fast algorithm without ANY additional checks, just triangular solver

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. Triangular solver is relatively easy to parallelize.
  ! However, parallelization will be efficient  only for  large number  of
  ! right parts M.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N,M]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 18.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlusolvemfast(
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixlusolvemfast(
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_rmatrixmixedsolve'></a><h3 class=pageheader><code>rmatrixmixedsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*x=b,  where BOTH ORIGINAL A AND ITS
LU DECOMPOSITION ARE KNOWN. You can use it if for some  reasons  you  have
both A and its LU decomposition.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixmixedsolve(
    <font color=navy>double</font>[,] a,
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_rmatrixmixedsolvem'></a><h3 class=pageheader><code>rmatrixmixedsolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixMixedSolve() but  solves task with multiple right  parts
(where b and x are NxM matrices).

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(M*N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixmixedsolvem(
    <font color=navy>double</font>[,] a,
    <font color=navy>double</font>[,] lua,
    <font color=navy>int</font>[] p,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)

</div></pre>
<a name='sub_rmatrixsolve'></a><h3 class=pageheader><code>rmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b with N*N real matrix A and N*1 real vectorx  x  and
b. This is &quot;slow-but-feature rich&quot; version of the  linear  solver.  Faster
version is RMatrixSolveFast() function.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^3) complexity

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear  system
           ! and  performs  iterative   refinement,   which   results   in
           ! significant performance penalty  when  compared  with  &quot;fast&quot;
           ! version  which  just  performs  LU  decomposition  and  calls
           ! triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations. It also very significant on small matrices.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, RMatrixSolveFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or exactly singular.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixsolve(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixsolve(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_rmatrixsolvefast'></a><h3 class=pageheader><code>rmatrixsolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
real matrix, x  and  b  are  vectors.  This is a &quot;fast&quot; version of  linear
solver which does NOT provide  any  additional  functions  like  condition
number estimation or iterative refinement.

Algorithm features:
* efficient algorithm O(N^3) complexity
* no performance overhead from additional functionality

If you need condition number estimation or iterative refinement, use  more
feature-rich version - RMatrixSolve().

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 16.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixsolvefast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixsolvefast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_rmatrixsolvels'></a><h3 class=pageheader><code>rmatrixsolvels</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This subroutine finds solution of the linear system A*X=B with non-square,
possibly degenerate A.  System  is  solved in the least squares sense, and
general least squares solution  X = X0 + CX*y  which  minimizes |A*X-B| is
returned. If A is non-degenerate, solution in the usual sense is returned.

Algorithm features:
* automatic detection (and correct handling!) of degenerate cases
* iterative refinement
* O(N^3) complexity

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is only partially supported (some parts are
  ! optimized, but most - are not).
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..NRows-1,0..NCols-1], system matrix
    NRows   -   vertical size of A
    NCols   -   horizontal size of A
    B       -   array[0..NCols-1], right part
    Threshold-  a number in [0,1]. Singular values  beyond  Threshold  are
                considered  zero.  Set  it to 0.0, if you don't understand
                what it means, so the solver will choose good value on its
                own.

OUTPUT PARAMETERS
    Info    -   return code:
                * -4    SVD subroutine failed
                * -1    if NRows&lt;=0 or NCols&lt;=0 or Threshold&lt;0 was passed
                *  1    if task is solved
    Rep     -   solver report, see below for more info
    X       -   array[0..N-1,0..M-1], it contains:
                * solution of A*X=B (even for singular A)
                * zeros, if SVD subroutine failed

SOLVER REPORT

Subroutine sets following fields of the Rep structure:
* R2        reciprocal of condition number: 1/cond(A), 2-norm.
* N         = NCols
* K         dim(Null(A))
* CX        array[0..N-1,0..K-1], kernel of A.
            Columns of CX store such vectors that A*CX[i]=0.

  -- ALGLIB --
     Copyright 24.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixsolvels(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> nrows,
    <font color=navy>int</font> ncols,
    <font color=navy>double</font>[] b,
    <font color=navy>double</font> threshold,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverlsreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixsolvels(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> nrows,
    <font color=navy>int</font> ncols,
    <font color=navy>double</font>[] b,
    <font color=navy>double</font> threshold,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverlsreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_rmatrixsolvem'></a><h3 class=pageheader><code>rmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixSolve() but solves task with multiple right parts (where
b and x are NxM matrices). This is  &quot;slow-but-robust&quot;  version  of  linear
solver with additional functionality  like  condition  number  estimation.
There also exists faster version - RMatrixSolveMFast().

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* optional iterative refinement
* O(N^3+M*N^2) complexity

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear  system
           ! and  performs  iterative   refinement,   which   results   in
           ! significant performance penalty  when  compared  with  &quot;fast&quot;
           ! version  which  just  performs  LU  decomposition  and  calls
           ! triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations. It also very significant on small matrices.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, RMatrixSolveMFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size
    RFS     -   iterative refinement switch:
                * True - refinement is used.
                  Less performance, more precision.
                * False - refinement is not used.
                  More performance, less precision.

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is ill conditioned or singular.
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros


  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixsolvem(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>bool</font> rfs,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixsolvem(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>bool</font> rfs,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)

</div></pre>
<a name='sub_rmatrixsolvemfast'></a><h3 class=pageheader><code>rmatrixsolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixSolve() but solves task with multiple right parts (where
b and x are NxM matrices). This is &quot;fast&quot; version of linear  solver  which
does NOT offer additional functions like condition  number  estimation  or
iterative refinement.

Algorithm features:
* O(N^3+M*N^2) complexity
* no additional functionality, highest performance

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size
    RFS     -   iterative refinement switch:
                * True - refinement is used.
                  Less performance, more precision.
                * False - refinement is not used.
                  More performance, less precision.

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is exactly singular (ill conditioned matrices
                        are not recognized).
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    B       -   array[N]:
                * info&gt;0    =&gt;  overwritten by solution
                * info=-3   =&gt;  filled by zeros


  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixsolvemfast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixsolvemfast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_spdmatrixcholeskysolve'></a><h3 class=pageheader><code>spdmatrixcholeskysolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b with N*N symmetric positive definite matrix A given
by its Cholesky decomposition, and N*1 real vectors x and b. This is &quot;slow-
but-feature-rich&quot;  version  of  the  solver  which,  in  addition  to  the
solution, performs condition number estimation.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which results in 10-15x  performance  penalty  when  compared
           ! with &quot;fast&quot; version which just calls triangular solver.
           !
           ! This performance penalty is insignificant  when compared with
           ! cost of large LU decomposition.  However,  if you  call  this
           ! function many times for the same  left  side,  this  overhead
           ! BECOMES significant. It  also  becomes significant for small-
           ! scale problems (N&lt;50).
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! SPDMatrixCholeskySolveFast() function.

INPUT PARAMETERS
    CHA     -   array[N,N], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of A
    IsUpper -   what half of CHA is provided
    B       -   array[N], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or ill conditioned
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N]:
                * for info&gt;0  - solution
                * for info=-3 - filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskysolve(
    <font color=navy>double</font>[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_spdmatrixcholeskysolvefast'></a><h3 class=pageheader><code>spdmatrixcholeskysolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*x=b with N*N symmetric positive definite matrix A given
by its Cholesky decomposition, and N*1 real vectors x and b. This is &quot;fast-
but-lightweight&quot; version of the solver.

Algorithm features:
* O(N^2) complexity
* matrix is represented by its upper or lower triangle
* no additional features

INPUT PARAMETERS
    CHA     -   array[N,N], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of A
    IsUpper -   what half of CHA is provided
    B       -   array[N], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or ill conditioned
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved
    B       -   array[N]:
                * for info&gt;0  - overwritten by solution
                * for info=-3 - filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskysolvefast(
    <font color=navy>double</font>[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_spdmatrixcholeskysolvem'></a><h3 class=pageheader><code>spdmatrixcholeskysolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N symmetric positive definite matrix A given
by its Cholesky decomposition, and N*M vectors X and B. It  is  &quot;slow-but-
feature-rich&quot; version of the solver which estimates  condition  number  of
the system.

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant  performance   penalty   when
           ! compared with &quot;fast&quot;  version  which  just  calls  triangular
           ! solver. Amount of  overhead  introduced  depends  on  M  (the
           ! larger - the more efficient).
           !
           ! This performance penalty is insignificant  when compared with
           ! cost of large LU decomposition.  However,  if you  call  this
           ! function many times for the same  left  side,  this  overhead
           ! BECOMES significant. It  also  becomes significant for small-
           ! scale problems (N&lt;50).
           !
           ! In such cases we strongly recommend you to use faster solver,
           ! SPDMatrixCholeskySolveMFast() function.

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of CHA
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or badly conditioned
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task was solved
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N]:
                * for info&gt;0 contains solution
                * for info=-3 filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskysolvem(
    <font color=navy>double</font>[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixcholeskysolvem(
    <font color=navy>double</font>[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)

</div></pre>
<a name='sub_spdmatrixcholeskysolvemfast'></a><h3 class=pageheader><code>spdmatrixcholeskysolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N symmetric positive definite matrix A given
by its Cholesky decomposition, and N*M vectors X and B. It  is  &quot;fast-but-
lightweight&quot; version of  the  solver  which  just  solves  linear  system,
without any additional functions.

Algorithm features:
* O(M*N^2) complexity
* matrix is represented by its upper or lower triangle
* no additional functionality

INPUT PARAMETERS
    CHA     -   array[N,N], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of CHA
    IsUpper -   what half of CHA is provided
    B       -   array[N,M], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or badly conditioned
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task was solved
    B       -   array[N]:
                * for info&gt;0 overwritten by solution
                * for info=-3 filled by zeros

  -- ALGLIB --
     Copyright 18.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskysolvemfast(
    <font color=navy>double</font>[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixcholeskysolvemfast(
    <font color=navy>double</font>[,] cha,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_spdmatrixsolve'></a><h3 class=pageheader><code>spdmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense linear solver for A*x=b with N*N real  symmetric  positive  definite
matrix A,  N*1 vectors x and b.  &quot;Slow-but-feature-rich&quot;  version  of  the
solver.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant   performance   penalty  when
           ! compared with &quot;fast&quot; version  which  just  performs  Cholesky
           ! decomposition and calls triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, SPDMatrixSolveFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or non-SPD.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixsolve(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixsolve(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_spdmatrixsolvefast'></a><h3 class=pageheader><code>spdmatrixsolvefast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense linear solver for A*x=b with N*N real  symmetric  positive  definite
matrix A,  N*1 vectors x and  b.  &quot;Fast-but-lightweight&quot;  version  of  the
solver.

Algorithm features:
* O(N^3) complexity
* matrix is represented by its upper or lower triangle
* no additional time consuming features like condition number estimation

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular or non-SPD
                * -1    N&lt;=0 was passed
                *  1    task was solved
    B       -   array[N], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 17.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixsolvefast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixsolvefast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[] b,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name='sub_spdmatrixsolvem'></a><h3 class=pageheader><code>spdmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N symmetric positive definite matrix A,  and
N*M vectors X and B. It is &quot;slow-but-feature-rich&quot; version of the solver.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3+M*N^2) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

IMPORTANT: ! this function is NOT the most efficient linear solver provided
           ! by ALGLIB. It estimates condition  number  of  linear system,
           ! which  results  in  significant   performance   penalty  when
           ! compared with &quot;fast&quot; version  which  just  performs  Cholesky
           ! decomposition and calls triangular solver.
           !
           ! This  performance  penalty  is  especially  visible  in   the
           ! multithreaded mode, because both condition number  estimation
           ! and   iterative    refinement   are   inherently   sequential
           ! calculations.
           !
           ! Thus, if you need high performance and if you are pretty sure
           ! that your system is well conditioned, we  strongly  recommend
           ! you to use faster solver, SPDMatrixSolveMFast() function.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    matrix is very badly conditioned or non-SPD.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   additional report, following fields are set:
                * rep.r1    condition number in 1-norm
                * rep.rinf  condition number in inf-norm
    X       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixsolvem(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixsolvem(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> densesolverreport rep,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)

</div></pre>
<a name='sub_spdmatrixsolvemfast'></a><h3 class=pageheader><code>spdmatrixsolvemfast</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver for A*X=B with N*N symmetric positive definite matrix A,  and
N*M vectors X and B. It is &quot;fast-but-lightweight&quot; version of the solver.

Algorithm features:
* O(N^3+M*N^2) complexity
* matrix is represented by its upper or lower triangle
* no additional time consuming features

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is is exactly singular
                * -1    N&lt;=0 was passed
                *  1    task was solved
    B       -   array[N,M], it contains:
                * info&gt;0    =&gt;  solution
                * info=-3   =&gt;  filled by zeros

  -- ALGLIB --
     Copyright 17.03.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixsolvemfast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixsolvemfast(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info)

</div></pre>
<a name=unit_dforest></a><h2 class=pageheader><code>dforest</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_decisionforest' class=toc>decisionforest</a><br>
<a href='#struct_dfreport' class=toc>dfreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_dfavgce' class=toc>dfavgce</a><br>
<a href='#sub_dfavgerror' class=toc>dfavgerror</a><br>
<a href='#sub_dfavgrelerror' class=toc>dfavgrelerror</a><br>
<a href='#sub_dfbuildrandomdecisionforest' class=toc>dfbuildrandomdecisionforest</a><br>
<a href='#sub_dfbuildrandomdecisionforestx1' class=toc>dfbuildrandomdecisionforestx1</a><br>
<a href='#sub_dfprocess' class=toc>dfprocess</a><br>
<a href='#sub_dfprocessi' class=toc>dfprocessi</a><br>
<a href='#sub_dfrelclserror' class=toc>dfrelclserror</a><br>
<a href='#sub_dfrmserror' class=toc>dfrmserror</a><br>
<a href='#sub_dfserialize' class=toc>dfserialize</a><br>
<a href='#sub_dfunserialize' class=toc>dfunserialize</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_decisionforest'></a><h3 class=pageheader><code>decisionforest</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class decisionforest
{
}

</div></pre>
<a name='struct_dfreport'></a><h3 class=pageheader><code>dfreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class dfreport
{
    <font color=navy>public</font> <font color=navy>double</font>               relclserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgce;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>double</font>               oobrelclserror;
    <font color=navy>public</font> <font color=navy>double</font>               oobavgce;
    <font color=navy>public</font> <font color=navy>double</font>               oobrmserror;
    <font color=navy>public</font> <font color=navy>double</font>               oobavgerror;
    <font color=navy>public</font> <font color=navy>double</font>               oobavgrelerror;
}

</div></pre>
<a name='sub_dfavgce'></a><h3 class=pageheader><code>dfavgce</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average cross-entropy (in bits per element) on the test set

INPUT PARAMETERS:
    DF      -   decision forest model
    XY      -   test set
    NPoints -   test set size

RESULT:
    CrossEntropy/(NPoints*LN(2)).
    Zero if model solves regression task.

  -- ALGLIB --
     Copyright 16.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.dfavgce(
    decisionforest df,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_dfavgerror'></a><h3 class=pageheader><code>dfavgerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average error on the test set

INPUT PARAMETERS:
    DF      -   decision forest model
    XY      -   test set
    NPoints -   test set size

RESULT:
    Its meaning for regression task is obvious. As for
    classification task, it means average error when estimating posterior
    probabilities.

  -- ALGLIB --
     Copyright 16.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.dfavgerror(
    decisionforest df,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_dfavgrelerror'></a><h3 class=pageheader><code>dfavgrelerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average relative error on the test set

INPUT PARAMETERS:
    DF      -   decision forest model
    XY      -   test set
    NPoints -   test set size

RESULT:
    Its meaning for regression task is obvious. As for
    classification task, it means average relative error when estimating
    posterior probability of belonging to the correct class.

  -- ALGLIB --
     Copyright 16.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.dfavgrelerror(
    decisionforest df,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_dfbuildrandomdecisionforest'></a><h3 class=pageheader><code>dfbuildrandomdecisionforest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds random decision forest.

INPUT PARAMETERS:
    XY          -   training set
    NPoints     -   training set size, NPoints&gt;=1
    NVars       -   number of independent variables, NVars&gt;=1
    NClasses    -   task type:
                    * NClasses=1 - regression task with one
                                   dependent variable
                    * NClasses&gt;1 - classification task with
                                   NClasses classes.
    NTrees      -   number of trees in a forest, NTrees&gt;=1.
                    recommended values: 50-100.
    R           -   percent of a training set used to build
                    individual trees. 0&lt;R&lt;=1.
                    recommended values: 0.1 &lt;= R &lt;= 0.66.

OUTPUT PARAMETERS:
    Info        -   return code:
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed
                          (NPoints&lt;1, NVars&lt;1, NClasses&lt;1, NTrees&lt;1, R&lt;=0
                          or R&gt;1).
                    *  1, if task has been solved
    DF          -   model built
    Rep         -   training report, contains error on a training set
                    and out-of-bag estimates of generalization error.

  -- ALGLIB --
     Copyright 19.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.dfbuildrandomdecisionforest(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>int</font> ntrees,
    <font color=navy>double</font> r,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> decisionforest df,
    <font color=navy>out</font> dfreport rep)

</div></pre>
<a name='sub_dfbuildrandomdecisionforestx1'></a><h3 class=pageheader><code>dfbuildrandomdecisionforestx1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds random decision forest.
This function gives ability to tune number of variables used when choosing
best split.

INPUT PARAMETERS:
    XY          -   training set
    NPoints     -   training set size, NPoints&gt;=1
    NVars       -   number of independent variables, NVars&gt;=1
    NClasses    -   task type:
                    * NClasses=1 - regression task with one
                                   dependent variable
                    * NClasses&gt;1 - classification task with
                                   NClasses classes.
    NTrees      -   number of trees in a forest, NTrees&gt;=1.
                    recommended values: 50-100.
    NRndVars    -   number of variables used when choosing best split
    R           -   percent of a training set used to build
                    individual trees. 0&lt;R&lt;=1.
                    recommended values: 0.1 &lt;= R &lt;= 0.66.

OUTPUT PARAMETERS:
    Info        -   return code:
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed
                          (NPoints&lt;1, NVars&lt;1, NClasses&lt;1, NTrees&lt;1, R&lt;=0
                          or R&gt;1).
                    *  1, if task has been solved
    DF          -   model built
    Rep         -   training report, contains error on a training set
                    and out-of-bag estimates of generalization error.

  -- ALGLIB --
     Copyright 19.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.dfbuildrandomdecisionforestx1(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>int</font> ntrees,
    <font color=navy>int</font> nrndvars,
    <font color=navy>double</font> r,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> decisionforest df,
    <font color=navy>out</font> dfreport rep)

</div></pre>
<a name='sub_dfprocess'></a><h3 class=pageheader><code>dfprocess</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procesing

INPUT PARAMETERS:
    DF      -   decision forest model
    X       -   input vector,  array[0..NVars-1].

OUTPUT PARAMETERS:
    Y       -   result. Regression estimate when solving regression  task,
                vector of posterior probabilities for classification task.

See also DFProcessI.

  -- ALGLIB --
     Copyright 16.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.dfprocess(
    decisionforest df,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_dfprocessi'></a><h3 class=pageheader><code>dfprocessi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
'interactive' variant of DFProcess for languages like Python which support
constructs like &quot;Y = DFProcessI(DF,X)&quot; and interactive mode of interpreter

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.dfprocessi(
    decisionforest df,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_dfrelclserror'></a><h3 class=pageheader><code>dfrelclserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Relative classification error on the test set

INPUT PARAMETERS:
    DF      -   decision forest model
    XY      -   test set
    NPoints -   test set size

RESULT:
    percent of incorrectly classified cases.
    Zero if model solves regression task.

  -- ALGLIB --
     Copyright 16.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.dfrelclserror(
    decisionforest df,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_dfrmserror'></a><h3 class=pageheader><code>dfrmserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set

INPUT PARAMETERS:
    DF      -   decision forest model
    XY      -   test set
    NPoints -   test set size

RESULT:
    root mean square error.
    Its meaning for regression task is obvious. As for
    classification task, RMS error means error when estimating posterior
    probabilities.

  -- ALGLIB --
     Copyright 16.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.dfrmserror(
    decisionforest df,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_dfserialize'></a><h3 class=pageheader><code>dfserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function serializes data structure to string.

Important properties of s_out:
* it contains alphanumeric characters, dots, underscores, minus signs
* these symbols are grouped into words, which are separated by spaces
  and Windows-style (CR+LF) newlines
* although  serializer  uses  spaces and CR+LF as separators, you can 
  replace any separator character by arbitrary combination of spaces,
  tabs, Windows or Unix newlines. It allows flexible reformatting  of
  the  string  in  case you want to include it into text or XML file. 
  But you should not insert separators into the middle of the &quot;words&quot;
  nor you should change case of letters.
* s_out can be freely moved between 32-bit and 64-bit systems, little
  and big endian machines, and so on. You can serialize structure  on
  32-bit machine and unserialize it on 64-bit one (or vice versa), or
  serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
  serialize  it  in  C++ version of ALGLIB and unserialize in C# one, 
  and vice versa.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> dfserialize(decisionforest obj, <font color=navy>out</font> string s_out)

</div></pre>
<a name='sub_dfunserialize'></a><h3 class=pageheader><code>dfunserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function unserializes data structure from string.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> dfunserialize(string s_in, <font color=navy>out</font> decisionforest obj)

</div></pre>
<a name=unit_elliptic></a><h2 class=pageheader><code>elliptic</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_ellipticintegrale' class=toc>ellipticintegrale</a><br>
<a href='#sub_ellipticintegralk' class=toc>ellipticintegralk</a><br>
<a href='#sub_ellipticintegralkhighprecision' class=toc>ellipticintegralkhighprecision</a><br>
<a href='#sub_incompleteellipticintegrale' class=toc>incompleteellipticintegrale</a><br>
<a href='#sub_incompleteellipticintegralk' class=toc>incompleteellipticintegralk</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_ellipticintegrale'></a><h3 class=pageheader><code>ellipticintegrale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complete elliptic integral of the second kind

Approximates the integral


           pi/2
            -
           | |                 2
E(m)  =    |    sqrt( 1 - m sin t ) dt
         | |
          -
           0

using the approximation

     P(x)  -  x log x Q(x).

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE       0, 1       10000       2.1e-16     7.3e-17

Cephes Math Library, Release 2.8: June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.ellipticintegrale(<font color=navy>double</font> m)

</div></pre>
<a name='sub_ellipticintegralk'></a><h3 class=pageheader><code>ellipticintegralk</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complete elliptic integral of the first kind

Approximates the integral



           pi/2
            -
           | |
           |           dt
K(m)  =    |    ------------------
           |                   2
         | |    sqrt( 1 - m sin t )
          -
           0

using the approximation

    P(x)  -  log x Q(x).

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE       0,1        30000       2.5e-16     6.8e-17

Cephes Math Library, Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.ellipticintegralk(<font color=navy>double</font> m)

</div></pre>
<a name='sub_ellipticintegralkhighprecision'></a><h3 class=pageheader><code>ellipticintegralkhighprecision</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complete elliptic integral of the first kind

Approximates the integral



           pi/2
            -
           | |
           |           dt
K(m)  =    |    ------------------
           |                   2
         | |    sqrt( 1 - m sin t )
          -
           0

where m = 1 - m1, using the approximation

    P(x)  -  log x Q(x).

The argument m1 is used rather than m so that the logarithmic
singularity at m = 1 will be shifted to the origin; this
preserves maximum accuracy.

K(0) = pi/2.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE       0,1        30000       2.5e-16     6.8e-17

Cephes Math Library, Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.ellipticintegralkhighprecision(<font color=navy>double</font> m1)

</div></pre>
<a name='sub_incompleteellipticintegrale'></a><h3 class=pageheader><code>incompleteellipticintegrale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Incomplete elliptic integral of the second kind

Approximates the integral


               phi
                -
               | |
               |                   2
E(phi_\m)  =    |    sqrt( 1 - m sin t ) dt
               |
             | |
              -
               0

of amplitude phi and modulus m, using the arithmetic -
geometric mean algorithm.

ACCURACY:

Tested at random arguments with phi in [-10, 10] and m in
[0, 1].
                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE     -10,10      150000       3.3e-15     1.4e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1993, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.incompleteellipticintegrale(
    <font color=navy>double</font> phi,
    <font color=navy>double</font> m)

</div></pre>
<a name='sub_incompleteellipticintegralk'></a><h3 class=pageheader><code>incompleteellipticintegralk</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Incomplete elliptic integral of the first kind F(phi|m)

Approximates the integral



               phi
                -
               | |
               |           dt
F(phi_\m)  =    |    ------------------
               |                   2
             | |    sqrt( 1 - m sin t )
              -
               0

of amplitude phi and modulus m, using the arithmetic -
geometric mean algorithm.




ACCURACY:

Tested at random points with m in [0, 1] and phi as indicated.

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE     -10,10       200000      7.4e-16     1.0e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.incompleteellipticintegralk(
    <font color=navy>double</font> phi,
    <font color=navy>double</font> m)

</div></pre>
<a name=unit_evd></a><h2 class=pageheader><code>evd</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hmatrixevd' class=toc>hmatrixevd</a><br>
<a href='#sub_hmatrixevdi' class=toc>hmatrixevdi</a><br>
<a href='#sub_hmatrixevdr' class=toc>hmatrixevdr</a><br>
<a href='#sub_rmatrixevd' class=toc>rmatrixevd</a><br>
<a href='#sub_smatrixevd' class=toc>smatrixevd</a><br>
<a href='#sub_smatrixevdi' class=toc>smatrixevdi</a><br>
<a href='#sub_smatrixevdr' class=toc>smatrixevdr</a><br>
<a href='#sub_smatrixtdevd' class=toc>smatrixtdevd</a><br>
<a href='#sub_smatrixtdevdi' class=toc>smatrixtdevdi</a><br>
<a href='#sub_smatrixtdevdr' class=toc>smatrixtdevdr</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_hmatrixevd'></a><h3 class=pageheader><code>hmatrixevd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding the eigenvalues and eigenvectors of a Hermitian matrix

The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
real tridiagonal form and using the QL/QR algorithm.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   Hermitian matrix which is given  by  its  upper  or  lower
                triangular part.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.
    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
                not. If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.

Output parameters:
    D       -   eigenvalues in ascending order.
                Array whose index ranges within [0..N-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains the eigenvectors.
                Array whose indexes range within [0..N-1, 0..N-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged (rare case).

Note:
    eigenvectors of Hermitian matrix are defined up to  multiplication  by
    a complex number L, such that |L|=1.

  -- ALGLIB --
     Copyright 2005, 23 March 2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.hmatrixevd(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>double</font>[] d,
    <font color=navy>out</font> complex[,] z)

</div></pre>
<a name='sub_hmatrixevdi'></a><h3 class=pageheader><code>hmatrixevdi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
matrix with given indexes by using bisection and inverse iteration methods

Input parameters:
    A       -   Hermitian matrix which is given  by  its  upper  or  lower
                triangular part.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
                not. If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    I1, I2 -    index interval for searching (from I1 to I2).
                0 &lt;= I1 &lt;= I2 &lt;= N-1.

Output parameters:
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..I2-I1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..I2-I1].
                In  that  case,  the eigenvectors are stored in the matrix
                columns.

Result:
    True, if successful. W contains the eigenvalues, Z contains the
    eigenvectors (if needed).

    False, if the bisection method subroutine  wasn't  able  to  find  the
    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
    subroutine wasn't able to find  all  the  corresponding  eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned.

Note:
    eigen vectors of Hermitian matrix are defined up to multiplication  by
    a complex number L, such as |L|=1.

  -- ALGLIB --
     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.hmatrixevdi(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>bool</font> isupper,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> i2,
    <font color=navy>out</font> <font color=navy>double</font>[] w,
    <font color=navy>out</font> complex[,] z)

</div></pre>
<a name='sub_hmatrixevdr'></a><h3 class=pageheader><code>hmatrixevdr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
matrix  in  a  given half-interval (A, B] by using a bisection and inverse
iteration

Input parameters:
    A       -   Hermitian matrix which is given  by  its  upper  or  lower
                triangular  part.  Array  whose   indexes   range   within
                [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
                not. If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    B1, B2 -    half-interval (B1, B2] to search eigenvalues in.

Output parameters:
    M       -   number of eigenvalues found in a given half-interval, M&gt;=0
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..M-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..M-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if successful. M contains the number of eigenvalues in the given
    half-interval (could be equal to 0), W contains the eigenvalues,
    Z contains the eigenvectors (if needed).

    False, if the bisection method subroutine  wasn't  able  to  find  the
    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
    subroutine  wasn't  able  to  find all the corresponding eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned, M  is
    equal to 0.

Note:
    eigen vectors of Hermitian matrix are defined up to multiplication  by
    a complex number L, such as |L|=1.

  -- ALGLIB --
     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.hmatrixevdr(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font> b1,
    <font color=navy>double</font> b2,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[] w,
    <font color=navy>out</font> complex[,] z)

</div></pre>
<a name='sub_rmatrixevd'></a><h3 class=pageheader><code>rmatrixevd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding eigenvalues and eigenvectors of a general (unsymmetric) matrix

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison. Speed-up provided by MKL for this particular problem (EVD)
  ! is really high, because  MKL  uses combination of (a) better low-level
  ! optimizations, and (b) better EVD algorithms.
  !
  ! On one particular SSE-capable  machine  for  N=1024,  commercial  MKL-
  ! -capable ALGLIB was:
  ! * 7-10 times faster than open source &quot;generic C&quot; version
  ! * 15-18 times faster than &quot;pure C#&quot; version
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

The algorithm finds eigenvalues and eigenvectors of a general matrix by
using the QR algorithm with multiple shifts. The algorithm can find
eigenvalues and both left and right eigenvectors.

The right eigenvector is a vector x such that A*x = w*x, and the left
eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
conjugate transposition of vector y).

Input parameters:
    A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    VNeeded -   flag controlling whether eigenvectors are needed or not.
                If VNeeded is equal to:
                 * 0, eigenvectors are not returned;
                 * 1, right eigenvectors are returned;
                 * 2, left eigenvectors are returned;
                 * 3, both left and right eigenvectors are returned.

Output parameters:
    WR      -   real parts of eigenvalues.
                Array whose index ranges within [0..N-1].
    WR      -   imaginary parts of eigenvalues.
                Array whose index ranges within [0..N-1].
    VL, VR  -   arrays of left and right eigenvectors (if they are needed).
                If WI[i]=0, the respective eigenvalue is a real number,
                and it corresponds to the column number I of matrices VL/VR.
                If WI[i]&gt;0, we have a pair of complex conjugate numbers with
                positive and negative imaginary parts:
                    the first eigenvalue WR[i] + sqrt(-1)*WI[i];
                    the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
                    WI[i]&gt;0
                    WI[i+1] = -WI[i] &lt; 0
                In that case, the eigenvector  corresponding to the first
                eigenvalue is located in i and i+1 columns of matrices
                VL/VR (the column number i contains the real part, and the
                column number i+1 contains the imaginary part), and the vector
                corresponding to the second eigenvalue is a complex conjugate to
                the first vector.
                Arrays whose indexes range within [0..N-1, 0..N-1].

Result:
    True, if the algorithm has converged.
    False, if the algorithm has not converged.

Note 1:
    Some users may ask the following question: what if WI[N-1]&gt;0?
    WI[N] must contain an eigenvalue which is complex conjugate to the
    N-th eigenvalue, but the array has only size N?
    The answer is as follows: such a situation cannot occur because the
    algorithm finds a pairs of eigenvalues, therefore, if WI[i]&gt;0, I is
    strictly less than N-1.

Note 2:
    The algorithm performance depends on the value of the internal parameter
    NS of the InternalSchurDecomposition subroutine which defines the number
    of shifts in the QR algorithm (similarly to the block width in block-matrix
    algorithms of linear algebra). If you require maximum performance
    on your machine, it is recommended to adjust this parameter manually.


See also the InternalTREVC subroutine.

The algorithm is based on the LAPACK 3.0 library.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.rmatrixevd(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> vneeded,
    <font color=navy>out</font> <font color=navy>double</font>[] wr,
    <font color=navy>out</font> <font color=navy>double</font>[] wi,
    <font color=navy>out</font> <font color=navy>double</font>[,] vl,
    <font color=navy>out</font> <font color=navy>double</font>[,] vr)

</div></pre>
<a name='sub_smatrixevd'></a><h3 class=pageheader><code>smatrixevd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding the eigenvalues and eigenvectors of a symmetric matrix

The algorithm finds eigen pairs of a symmetric matrix by reducing it to
tridiagonal form and using the QL/QR algorithm.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   symmetric matrix which is given by its upper or lower
                triangular part.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpper -   storage format.

Output parameters:
    D       -   eigenvalues in ascending order.
                Array whose index ranges within [0..N-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains the eigenvectors.
                Array whose indexes range within [0..N-1, 0..N-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged (rare case).

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixevd(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>double</font>[] d,
    <font color=navy>out</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name='sub_smatrixevdi'></a><h3 class=pageheader><code>smatrixevdi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
matrix with given indexes by using bisection and inverse iteration methods.

Input parameters:
    A       -   symmetric matrix which is given by its upper or lower
                triangular part. Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    I1, I2 -    index interval for searching (from I1 to I2).
                0 &lt;= I1 &lt;= I2 &lt;= N-1.

Output parameters:
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..I2-I1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..I2-I1].
                In that case, the eigenvectors are stored in the matrix columns.

Result:
    True, if successful. W contains the eigenvalues, Z contains the
    eigenvectors (if needed).

    False, if the bisection method subroutine wasn't able to find the
    eigenvalues in the given interval or if the inverse iteration subroutine
    wasn't able to find all the corresponding eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned.

  -- ALGLIB --
     Copyright 07.01.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixevdi(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>bool</font> isupper,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> i2,
    <font color=navy>out</font> <font color=navy>double</font>[] w,
    <font color=navy>out</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name='sub_smatrixevdr'></a><h3 class=pageheader><code>smatrixevdr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
matrix  in  a  given half open interval (A, B] by using  a  bisection  and
inverse iteration

Input parameters:
    A       -   symmetric matrix which is given by its upper or lower
                triangular part. Array [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    B1, B2 -    half open interval (B1, B2] to search eigenvalues in.

Output parameters:
    M       -   number of eigenvalues found in a given half-interval (M&gt;=0).
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..M-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..M-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if successful. M contains the number of eigenvalues in the given
    half-interval (could be equal to 0), W contains the eigenvalues,
    Z contains the eigenvectors (if needed).

    False, if the bisection method subroutine wasn't able to find the
    eigenvalues in the given interval or if the inverse iteration subroutine
    wasn't able to find all the corresponding eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned,
    M is equal to 0.

  -- ALGLIB --
     Copyright 07.01.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixevdr(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font> b1,
    <font color=navy>double</font> b2,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[] w,
    <font color=navy>out</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name='sub_smatrixtdevd'></a><h3 class=pageheader><code>smatrixtdevd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix

The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
using an QL/QR algorithm with implicit shifts.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    D       -   the main diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-1].
    E       -   the secondary diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not needed;
                 * 1, the eigenvectors of a tridiagonal matrix
                   are multiplied by the square matrix Z. It is used if the
                   tridiagonal matrix is obtained by the similarity
                   transformation of a symmetric matrix;
                 * 2, the eigenvectors of a tridiagonal matrix replace the
                   square matrix Z;
                 * 3, matrix Z contains the first row of the eigenvectors
                   matrix.
    Z       -   if ZNeeded=1, Z contains the square matrix by which the
                eigenvectors are multiplied.
                Array whose indexes range within [0..N-1, 0..N-1].

Output parameters:
    D       -   eigenvalues in ascending order.
                Array whose index ranges within [0..N-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains the product of a given matrix (from the left)
                   and the eigenvectors matrix (from the right);
                 * 2, Z contains the eigenvectors.
                 * 3, Z contains the first row of the eigenvectors matrix.
                If ZNeeded&lt;3, Z is the array whose indexes range within [0..N-1, 0..N-1].
                In that case, the eigenvectors are stored in the matrix columns.
                If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixtdevd(
    <font color=navy>ref</font> <font color=navy>double</font>[] d,
    <font color=navy>double</font>[] e,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>ref</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name='sub_smatrixtdevdi'></a><h3 class=pageheader><code>smatrixtdevdi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
indexes (in ascending order) by using the bisection and inverse iteraion.

Input parameters:
    D       -   the main diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-1].
    E       -   the secondary diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix. N&gt;=0.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not needed;
                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
                   by the square matrix Z. It is used if the
                   tridiagonal matrix is obtained by the similarity transformation
                   of a symmetric matrix.
                 * 2, the eigenvectors of a tridiagonal matrix replace
                   matrix Z.
    I1, I2  -   index interval for searching (from I1 to I2).
                0 &lt;= I1 &lt;= I2 &lt;= N-1.
    Z       -   if ZNeeded is equal to:
                 * 0, Z isn't used and remains unchanged;
                 * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
                   which reduces the given symmetric matrix to  tridiagonal form;
                 * 2, Z isn't used (but changed on the exit).

Output parameters:
    D       -   array of the eigenvalues found.
                Array whose index ranges within [0..I2-I1].
    Z       -   if ZNeeded is equal to:
                 * 0, doesn't contain any information;
                 * 1, contains the product of a given NxN matrix Z (from the left) and
                   Nx(I2-I1) matrix of the eigenvectors found (from the right).
                   Array whose indexes range within [0..N-1, 0..I2-I1].
                 * 2, contains the matrix of the eigenvalues found.
                   Array whose indexes range within [0..N-1, 0..I2-I1].


Result:

    True, if successful. In that case, D contains the eigenvalues,
    Z contains the eigenvectors (if needed).
    It should be noted that the subroutine changes the size of arrays D and Z.

    False, if the bisection method subroutine wasn't able to find the eigenvalues
    in the given interval or if the inverse iteration subroutine wasn't able
    to find all the corresponding eigenvectors. In that case, the eigenvalues
    and eigenvectors are not returned.

  -- ALGLIB --
     Copyright 25.12.2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixtdevdi(
    <font color=navy>ref</font> <font color=navy>double</font>[] d,
    <font color=navy>double</font>[] e,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>int</font> i1,
    <font color=navy>int</font> i2,
    <font color=navy>ref</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name='sub_smatrixtdevdr'></a><h3 class=pageheader><code>smatrixtdevdr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
given half-interval (A, B] by using bisection and inverse iteration.

Input parameters:
    D       -   the main diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-1].
    E       -   the secondary diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix, N&gt;=0.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not needed;
                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
                   by the square matrix Z. It is used if the tridiagonal
                   matrix is obtained by the similarity transformation
                   of a symmetric matrix.
                 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
    A, B    -   half-interval (A, B] to search eigenvalues in.
    Z       -   if ZNeeded is equal to:
                 * 0, Z isn't used and remains unchanged;
                 * 1, Z contains the square matrix (array whose indexes range
                   within [0..N-1, 0..N-1]) which reduces the given symmetric
                   matrix to tridiagonal form;
                 * 2, Z isn't used (but changed on the exit).

Output parameters:
    D       -   array of the eigenvalues found.
                Array whose index ranges within [0..M-1].
    M       -   number of eigenvalues found in the given half-interval (M&gt;=0).
    Z       -   if ZNeeded is equal to:
                 * 0, doesn't contain any information;
                 * 1, contains the product of a given NxN matrix Z (from the
                   left) and NxM matrix of the eigenvectors found (from the
                   right). Array whose indexes range within [0..N-1, 0..M-1].
                 * 2, contains the matrix of the eigenvectors found.
                   Array whose indexes range within [0..N-1, 0..M-1].

Result:

    True, if successful. In that case, M contains the number of eigenvalues
    in the given half-interval (could be equal to 0), D contains the eigenvalues,
    Z contains the eigenvectors (if needed).
    It should be noted that the subroutine changes the size of arrays D and Z.

    False, if the bisection method subroutine wasn't able to find the
    eigenvalues in the given interval or if the inverse iteration subroutine
    wasn't able to find all the corresponding eigenvectors. In that case,
    the eigenvalues and eigenvectors are not returned, M is equal to 0.

  -- ALGLIB --
     Copyright 31.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixtdevdr(
    <font color=navy>ref</font> <font color=navy>double</font>[] d,
    <font color=navy>double</font>[] e,
    <font color=navy>int</font> n,
    <font color=navy>int</font> zneeded,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>ref</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name=unit_expintegrals></a><h2 class=pageheader><code>expintegrals</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_exponentialintegralei' class=toc>exponentialintegralei</a><br>
<a href='#sub_exponentialintegralen' class=toc>exponentialintegralen</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_exponentialintegralei'></a><h3 class=pageheader><code>exponentialintegralei</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Exponential integral Ei(x)

              x
               -     t
              | |   e
   Ei(x) =   -|-   ---  dt .
            | |     t
             -
            -inf

Not defined for x &lt;= 0.
See also expn.c.



ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE       0,100       50000      8.6e-16     1.3e-16

Cephes Math Library Release 2.8:  May, 1999
Copyright 1999 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.exponentialintegralei(<font color=navy>double</font> x)

</div></pre>
<a name='sub_exponentialintegralen'></a><h3 class=pageheader><code>exponentialintegralen</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Exponential integral En(x)

Evaluates the exponential integral

                inf.
                  -
                 | |   -xt
                 |    e
     E (x)  =    |    ----  dt.
      n          |      n
               | |     t
                -
                 1


Both n and x must be nonnegative.

The routine employs either a power series, a continued
fraction, or an asymptotic formula depending on the
relative values of n and x.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0, 30       10000       1.7e-15     3.6e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1985, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.exponentialintegralen(<font color=navy>double</font> x, <font color=navy>int</font> n)

</div></pre>
<a name=unit_fdistr></a><h2 class=pageheader><code>fdistr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fcdistribution' class=toc>fcdistribution</a><br>
<a href='#sub_fdistribution' class=toc>fdistribution</a><br>
<a href='#sub_invfdistribution' class=toc>invfdistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fcdistribution'></a><h3 class=pageheader><code>fcdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complemented F distribution

Returns the area from x to infinity under the F density
function (also known as Snedcor's density or the
variance ratio density).


                     inf.
                      -
             1       | |  a-1      b-1
1-P(x)  =  ------    |   t    (1-t)    dt
           B(a,b)  | |
                    -
                     x


The incomplete beta integral is used, according to the
formula

P(x) = incbet( df2/2, df1/2, (df2/(df2 + df1*x) ).


ACCURACY:

Tested at random points (a,b,x) in the indicated intervals.
               x     a,b                     Relative error:
arithmetic  domain  domain     # trials      peak         rms
   IEEE      0,1    1,100       100000      3.7e-14     5.9e-16
   IEEE      1,5    1,100       100000      8.0e-15     1.6e-15
   IEEE      0,1    1,10000     100000      1.8e-11     3.5e-13
   IEEE      1,5    1,10000     100000      2.0e-11     3.0e-12

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.fcdistribution(<font color=navy>int</font> a, <font color=navy>int</font> b, <font color=navy>double</font> x)

</div></pre>
<a name='sub_fdistribution'></a><h3 class=pageheader><code>fdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
F distribution

Returns the area from zero to x under the F density
function (also known as Snedcor's density or the
variance ratio density).  This is the density
of x = (u1/df1)/(u2/df2), where u1 and u2 are random
variables having Chi square distributions with df1
and df2 degrees of freedom, respectively.
The incomplete beta integral is used, according to the
formula

P(x) = incbet( df1/2, df2/2, (df1*x/(df2 + df1*x) ).


The arguments a and b are greater than zero, and x is
nonnegative.

ACCURACY:

Tested at random points (a,b,x).

               x     a,b                     Relative error:
arithmetic  domain  domain     # trials      peak         rms
   IEEE      0,1    0,100       100000      9.8e-15     1.7e-15
   IEEE      1,5    0,100       100000      6.5e-15     3.5e-16
   IEEE      0,1    1,10000     100000      2.2e-11     3.3e-12
   IEEE      1,5    1,10000     100000      1.1e-11     1.7e-13

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.fdistribution(<font color=navy>int</font> a, <font color=navy>int</font> b, <font color=navy>double</font> x)

</div></pre>
<a name='sub_invfdistribution'></a><h3 class=pageheader><code>invfdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse of complemented F distribution

Finds the F density argument x such that the integral
from x to infinity of the F density is equal to the
given probability p.

This is accomplished using the inverse beta integral
function and the relations

     z = incbi( df2/2, df1/2, p )
     x = df2 (1-z) / (df1 z).

Note: the following relations hold for the inverse of
the uncomplemented F distribution:

     z = incbi( df1/2, df2/2, p )
     x = df2 z / (df1 (1-z)).

ACCURACY:

Tested at random points (a,b,p).

             a,b                     Relative error:
arithmetic  domain     # trials      peak         rms
 For p between .001 and 1:
   IEEE     1,100       100000      8.3e-15     4.7e-16
   IEEE     1,10000     100000      2.1e-11     1.4e-13
 For p between 10^-6 and 10^-3:
   IEEE     1,100        50000      1.3e-12     8.4e-15
   IEEE     1,10000      50000      3.0e-12     4.8e-14

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invfdistribution(<font color=navy>int</font> a, <font color=navy>int</font> b, <font color=navy>double</font> y)

</div></pre>
<a name=unit_fft></a><h2 class=pageheader><code>fft</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fftc1d' class=toc>fftc1d</a><br>
<a href='#sub_fftc1dinv' class=toc>fftc1dinv</a><br>
<a href='#sub_fftr1d' class=toc>fftr1d</a><br>
<a href='#sub_fftr1dinv' class=toc>fftr1dinv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_fft_complex_d1' class=toc>fft_complex_d1</a></td><td width=15>&nbsp;</td><td>Complex FFT: simple example</td></tr>
<tr align=left valign=top><td><a href='#example_fft_complex_d2' class=toc>fft_complex_d2</a></td><td width=15>&nbsp;</td><td>Complex FFT: advanced example</td></tr>
<tr align=left valign=top><td><a href='#example_fft_real_d1' class=toc>fft_real_d1</a></td><td width=15>&nbsp;</td><td>Real FFT: simple example</td></tr>
<tr align=left valign=top><td><a href='#example_fft_real_d2' class=toc>fft_real_d2</a></td><td width=15>&nbsp;</td><td>Real FFT: advanced example</td></tr>
</table></div>
<a name='sub_fftc1d'></a><h3 class=pageheader><code>fftc1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex FFT.

Array size N may be arbitrary number (composite or prime).  Composite  N's
are handled with cache-oblivious variation of  a  Cooley-Tukey  algorithm.
Small prime-factors are transformed using hard coded  codelets (similar to
FFTW codelets, but without low-level  optimization),  large  prime-factors
are handled with Bluestein's algorithm.

Fastests transforms are for smooth N's (prime factors are 2, 3,  5  only),
most fast for powers of 2. When N have prime factors  larger  than  these,
but orders of magnitude smaller than N, computations will be about 4 times
slower than for nearby highly composite N's. When N itself is prime, speed
will be 6 times lower.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - complex function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    A   -   DFT of a input array, array[0..N-1]
            A_out[j] = SUM(A_in[k]*exp(-2*pi*sqrt(-1)*j*k/N), k = 0..N-1)


  -- ALGLIB --
     Copyright 29.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftc1d(<font color=navy>ref</font> complex[] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftc1d(<font color=navy>ref</font> complex[] a, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_complex_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_complex_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_fftc1dinv'></a><h3 class=pageheader><code>fftc1dinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex inverse FFT.

Array size N may be arbitrary number (composite or prime).  Algorithm  has
O(N*logN) complexity for any N (composite or prime).

See FFTC1D() description for more information about algorithm performance.

INPUT PARAMETERS
    A   -   array[0..N-1] - complex array to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    A   -   inverse DFT of a input array, array[0..N-1]
            A_out[j] = SUM(A_in[k]/N*exp(+2*pi*sqrt(-1)*j*k/N), k = 0..N-1)


  -- ALGLIB --
     Copyright 29.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftc1dinv(<font color=navy>ref</font> complex[] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftc1dinv(<font color=navy>ref</font> complex[] a, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_complex_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_complex_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_fftr1d'></a><h3 class=pageheader><code>fftr1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real FFT.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - real function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    F   -   DFT of a input array, array[0..N-1]
            F[j] = SUM(A[k]*exp(-2*pi*sqrt(-1)*j*k/N), k = 0..N-1)

NOTE:
    F[] satisfies symmetry property F[k] = conj(F[N-k]),  so just one half
of  array  is  usually needed. But for convinience subroutine returns full
complex array (with frequencies above N/2), so its result may be  used  by
other FFT-related subroutines.


  -- ALGLIB --
     Copyright 01.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftr1d(<font color=navy>double</font>[] a, <font color=navy>out</font> complex[] f)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftr1d(<font color=navy>double</font>[] a, <font color=navy>int</font> n, <font color=navy>out</font> complex[] f)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_real_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_real_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_fftr1dinv'></a><h3 class=pageheader><code>fftr1dinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real inverse FFT.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    F   -   array[0..floor(N/2)] - frequencies from forward real FFT
    N   -   problem size

OUTPUT PARAMETERS
    A   -   inverse DFT of a input array, array[0..N-1]

NOTE:
    F[] should satisfy symmetry property F[k] = conj(F[N-k]), so just  one
half of frequencies array is needed - elements from 0 to floor(N/2).  F[0]
is ALWAYS real. If N is even F[floor(N/2)] is real too. If N is odd,  then
F[floor(N/2)] has no special properties.

Relying on properties noted above, FFTR1DInv subroutine uses only elements
from 0th to floor(N/2)-th. It ignores imaginary part of F[0],  and in case
N is even it ignores imaginary part of F[floor(N/2)] too.

When you call this function using full arguments list - &quot;FFTR1DInv(F,N,A)&quot;
- you can pass either either frequencies array with N elements or  reduced
array with roughly N/2 elements - subroutine will  successfully  transform
both.

If you call this function using reduced arguments list -  &quot;FFTR1DInv(F,A)&quot;
- you must pass FULL array with N elements (although higher  N/2 are still
not used) because array size is used to automatically determine FFT length


  -- ALGLIB --
     Copyright 01.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftr1dinv(complex[] f, <font color=navy>out</font> <font color=navy>double</font>[] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fftr1dinv(complex[] f, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_real_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_real_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='example_fft_complex_d1'></a><h3 class=pageheader>fft_complex_d1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// first we demonstrate forward FFT:</font>
    <font color=green>// [1i,1i,1i,1i] is converted to [4i, 0, 0, 0]</font>
    <font color=green>//</font>
    alglib.complex[] z = new alglib.complex[]{new alglib.complex(0,1),new alglib.complex(0,1),new alglib.complex(0,1),new alglib.complex(0,1)};
    alglib.fftc1d(<font color=navy>ref</font> z);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(z,3)); <font color=green>// EXPECTED: [4i,0,0,0]</font>

    <font color=green>//</font>
    <font color=green>// now we convert [4i, 0, 0, 0] back to [1i,1i,1i,1i]</font>
    <font color=green>// with backward FFT</font>
    <font color=green>//</font>
    alglib.fftc1dinv(<font color=navy>ref</font> z);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(z,3)); <font color=green>// EXPECTED: [1i,1i,1i,1i]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_fft_complex_d2'></a><h3 class=pageheader>fft_complex_d2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// first we demonstrate forward FFT:</font>
    <font color=green>// [0,1,0,1i] is converted to [1+1i, -1-1i, -1-1i, 1+1i]</font>
    <font color=green>//</font>
    alglib.complex[] z = new alglib.complex[]{0,1,0,new alglib.complex(0,1)};
    alglib.fftc1d(<font color=navy>ref</font> z);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(z,3)); <font color=green>// EXPECTED: [1+1i, -1-1i, -1-1i, 1+1i]</font>

    <font color=green>//</font>
    <font color=green>// now we convert result back with backward FFT</font>
    <font color=green>//</font>
    alglib.fftc1dinv(<font color=navy>ref</font> z);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(z,3)); <font color=green>// EXPECTED: [0,1,0,1i]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_fft_real_d1'></a><h3 class=pageheader>fft_real_d1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// first we demonstrate forward FFT:</font>
    <font color=green>// [1,1,1,1] is converted to [4, 0, 0, 0]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1,1,1,1};
    alglib.complex[] f;
    <font color=navy>double</font>[] x2;
    alglib.fftr1d(x, <font color=navy>out</font> f);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(f,3)); <font color=green>// EXPECTED: [4,0,0,0]</font>

    <font color=green>//</font>
    <font color=green>// now we convert [4, 0, 0, 0] back to [1,1,1,1]</font>
    <font color=green>// with backward FFT</font>
    <font color=green>//</font>
    alglib.fftr1dinv(f, <font color=navy>out</font> x2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x2,3)); <font color=green>// EXPECTED: [1,1,1,1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_fft_real_d2'></a><h3 class=pageheader>fft_real_d2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// first we demonstrate forward FFT:</font>
    <font color=green>// [1,2,3,4] is converted to [10, -2+2i, -2, -2-2i]</font>
    <font color=green>//</font>
    <font color=green>// note that output array is self-adjoint:</font>
    <font color=green>// * f[0] = conj(f[0])</font>
    <font color=green>// * f[1] = conj(f[3])</font>
    <font color=green>// * f[2] = conj(f[2])</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1,2,3,4};
    alglib.complex[] f;
    <font color=navy>double</font>[] x2;
    alglib.fftr1d(x, <font color=navy>out</font> f);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(f,3)); <font color=green>// EXPECTED: [10, -2+2i, -2, -2-2i]</font>

    <font color=green>//</font>
    <font color=green>// now we convert [10, -2+2i, -2, -2-2i] back to [1,2,3,4]</font>
    <font color=green>//</font>
    alglib.fftr1dinv(f, <font color=navy>out</font> x2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x2,3)); <font color=green>// EXPECTED: [1,2,3,4]</font>

    <font color=green>//</font>
    <font color=green>// remember that F is self-adjoint? It means that we can pass just half</font>
    <font color=green>// (slightly larger than half) of F to inverse real FFT and still get our result.</font>
    <font color=green>//</font>
    <font color=green>// I.e. instead [10, -2+2i, -2, -2-2i] we pass just [10, -2+2i, -2] and everything works!</font>
    <font color=green>//</font>
    <font color=green>// NOTE: in this case we should explicitly pass array length (which is 4) to ALGLIB;</font>
    <font color=green>// <font color=navy>if</font> not, it will automatically use array length to determine FFT size and</font>
    <font color=green>// will erroneously make half-length FFT.</font>
    <font color=green>//</font>
    f = new alglib.complex[]{10,new alglib.complex(-2,+2),-2};
    alglib.fftr1dinv(f, 4, <font color=navy>out</font> x2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x2,3)); <font color=green>// EXPECTED: [1,2,3,4]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_fht></a><h2 class=pageheader><code>fht</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fhtr1d' class=toc>fhtr1d</a><br>
<a href='#sub_fhtr1dinv' class=toc>fhtr1dinv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fhtr1d'></a><h3 class=pageheader><code>fhtr1d</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional Fast Hartley Transform.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - real function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    A   -   FHT of a input array, array[0..N-1],
            A_out[k] = sum(A_in[j]*(cos(2*pi*j*k/N)+sin(2*pi*j*k/N)), j=0..N-1)


  -- ALGLIB --
     Copyright 04.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fhtr1d(<font color=navy>ref</font> <font color=navy>double</font>[] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_fhtr1dinv'></a><h3 class=pageheader><code>fhtr1dinv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional inverse FHT.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - complex array to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    A   -   inverse FHT of a input array, array[0..N-1]


  -- ALGLIB --
     Copyright 29.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fhtr1dinv(<font color=navy>ref</font> <font color=navy>double</font>[] a, <font color=navy>int</font> n)

</div></pre>
<a name=unit_filters></a><h2 class=pageheader><code>filters</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_filterema' class=toc>filterema</a><br>
<a href='#sub_filterlrma' class=toc>filterlrma</a><br>
<a href='#sub_filtersma' class=toc>filtersma</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_filters_d_ema' class=toc>filters_d_ema</a></td><td width=15>&nbsp;</td><td>EMA(alpha) filter</td></tr>
<tr align=left valign=top><td><a href='#example_filters_d_lrma' class=toc>filters_d_lrma</a></td><td width=15>&nbsp;</td><td>LRMA(k) filter</td></tr>
<tr align=left valign=top><td><a href='#example_filters_d_sma' class=toc>filters_d_sma</a></td><td width=15>&nbsp;</td><td>SMA(k) filter</td></tr>
</table></div>
<a name='sub_filterema'></a><h3 class=pageheader><code>filterema</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Filters: exponential moving averages.

This filter replaces array by results of EMA(alpha) filter. EMA(alpha) is
defined as filter which replaces X[] by S[]:
    S[0] = X[0]
    S[t] = alpha*X[t] + (1-alpha)*S[t-1]

INPUT PARAMETERS:
    X           -   array[N], array to process. It can be larger than N,
                    in this case only first N points are processed.
    N           -   points count, N&gt;=0
    alpha       -   0&lt;alpha&lt;=1, smoothing parameter.

OUTPUT PARAMETERS:
    X           -   array, whose first N elements were processed
                    with EMA(alpha)

NOTE 1: this function uses efficient in-place  algorithm  which  does not
        allocate temporary arrays.

NOTE 2: this algorithm uses BOTH previous points and  current  one,  i.e.
        new value of X[i] depends on BOTH previous point and X[i] itself.

NOTE 3: technical analytis users quite often work  with  EMA  coefficient
        expressed in DAYS instead of fractions. If you want to  calculate
        EMA(N), where N is a number of days, you can use alpha=2/(N+1).

  -- ALGLIB --
     Copyright 25.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.filterema(<font color=navy>ref</font> <font color=navy>double</font>[] x, <font color=navy>double</font> alpha)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.filterema(<font color=navy>ref</font> <font color=navy>double</font>[] x, <font color=navy>int</font> n, <font color=navy>double</font> alpha)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_filters_d_ema' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_filterlrma'></a><h3 class=pageheader><code>filterlrma</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Filters: linear regression moving averages.

This filter replaces array by results of LRMA(K) filter.

LRMA(K) is defined as filter which, for each data  point,  builds  linear
regression  model  using  K  prevous  points (point itself is included in
these K points) and calculates value of this linear model at the point in
question.

INPUT PARAMETERS:
    X           -   array[N], array to process. It can be larger than N,
                    in this case only first N points are processed.
    N           -   points count, N&gt;=0
    K           -   K&gt;=1 (K can be larger than N ,  such  cases  will  be
                    correctly handled). Window width. K=1 corresponds  to
                    identity transformation (nothing changes).

OUTPUT PARAMETERS:
    X           -   array, whose first N elements were processed with SMA(K)

NOTE 1: this function uses efficient in-place  algorithm  which  does not
        allocate temporary arrays.

NOTE 2: this algorithm makes only one pass through array and uses running
        sum  to speed-up calculation of the averages. Additional measures
        are taken to ensure that running sum on a long sequence  of  zero
        elements will be correctly reset to zero even in the presence  of
        round-off error.

NOTE 3: this  is  unsymmetric version of the algorithm,  which  does  NOT
        averages points after the current one. Only X[i], X[i-1], ... are
        used when calculating new value of X[i]. We should also note that
        this algorithm uses BOTH previous points and  current  one,  i.e.
        new value of X[i] depends on BOTH previous point and X[i] itself.

  -- ALGLIB --
     Copyright 25.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.filterlrma(<font color=navy>ref</font> <font color=navy>double</font>[] x, <font color=navy>int</font> k)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.filterlrma(<font color=navy>ref</font> <font color=navy>double</font>[] x, <font color=navy>int</font> n, <font color=navy>int</font> k)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_filters_d_lrma' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_filtersma'></a><h3 class=pageheader><code>filtersma</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Filters: simple moving averages (unsymmetric).

This filter replaces array by results of SMA(K) filter. SMA(K) is defined
as filter which averages at most K previous points (previous - not points
AROUND central point) - or less, in case of the first K-1 points.

INPUT PARAMETERS:
    X           -   array[N], array to process. It can be larger than N,
                    in this case only first N points are processed.
    N           -   points count, N&gt;=0
    K           -   K&gt;=1 (K can be larger than N ,  such  cases  will  be
                    correctly handled). Window width. K=1 corresponds  to
                    identity transformation (nothing changes).

OUTPUT PARAMETERS:
    X           -   array, whose first N elements were processed with SMA(K)

NOTE 1: this function uses efficient in-place  algorithm  which  does not
        allocate temporary arrays.

NOTE 2: this algorithm makes only one pass through array and uses running
        sum  to speed-up calculation of the averages. Additional measures
        are taken to ensure that running sum on a long sequence  of  zero
        elements will be correctly reset to zero even in the presence  of
        round-off error.

NOTE 3: this  is  unsymmetric version of the algorithm,  which  does  NOT
        averages points after the current one. Only X[i], X[i-1], ... are
        used when calculating new value of X[i]. We should also note that
        this algorithm uses BOTH previous points and  current  one,  i.e.
        new value of X[i] depends on BOTH previous point and X[i] itself.

  -- ALGLIB --
     Copyright 25.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.filtersma(<font color=navy>ref</font> <font color=navy>double</font>[] x, <font color=navy>int</font> k)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.filtersma(<font color=navy>ref</font> <font color=navy>double</font>[] x, <font color=navy>int</font> n, <font color=navy>int</font> k)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_filters_d_sma' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_filters_d_ema'></a><h3 class=pageheader>filters_d_ema example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Here we demonstrate EMA(0.5) filtering <font color=navy>for</font> time series.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{5,6,7,8};

    <font color=green>//</font>
    <font color=green>// Apply filter.</font>
    <font color=green>// We should get [5, 5.5, 6.25, 7.125] as result</font>
    <font color=green>//</font>
    alglib.filterema(<font color=navy>ref</font> x, 0.5);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,4)); <font color=green>// EXPECTED: [5,5.5,6.25,7.125]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_filters_d_lrma'></a><h3 class=pageheader>filters_d_lrma example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Here we demonstrate LRMA(3) filtering <font color=navy>for</font> time series.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{7,8,8,9,12,12};

    <font color=green>//</font>
    <font color=green>// Apply filter.</font>
    <font color=green>// We should get [7.0000, 8.0000, 8.1667, 8.8333, 11.6667, 12.5000] as result</font>
    <font color=green>//    </font>
    alglib.filterlrma(<font color=navy>ref</font> x, 3);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,4)); <font color=green>// EXPECTED: [7.0000,8.0000,8.1667,8.8333,11.6667,12.5000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_filters_d_sma'></a><h3 class=pageheader>filters_d_sma example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Here we demonstrate SMA(k) filtering <font color=navy>for</font> time series.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{5,6,7,8};

    <font color=green>//</font>
    <font color=green>// Apply filter.</font>
    <font color=green>// We should get [5, 5.5, 6.5, 7.5] as result</font>
    <font color=green>//</font>
    alglib.filtersma(<font color=navy>ref</font> x, 2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,4)); <font color=green>// EXPECTED: [5,5.5,6.5,7.5]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_fresnel></a><h2 class=pageheader><code>fresnel</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fresnelintegral' class=toc>fresnelintegral</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fresnelintegral'></a><h3 class=pageheader><code>fresnelintegral</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fresnel integral

Evaluates the Fresnel integrals

          x
          -
         | |
C(x) =   |   cos(pi/2 t**2) dt,
       | |
        -
         0

          x
          -
         | |
S(x) =   |   sin(pi/2 t**2) dt.
       | |
        -
         0


The integrals are evaluated by a power series for x &lt; 1.
For x &gt;= 1 auxiliary functions f(x) and g(x) are employed
such that

C(x) = 0.5 + f(x) sin( pi/2 x**2 ) - g(x) cos( pi/2 x**2 )
S(x) = 0.5 - f(x) cos( pi/2 x**2 ) - g(x) sin( pi/2 x**2 )



ACCURACY:

 Relative error.

Arithmetic  function   domain     # trials      peak         rms
  IEEE       S(x)      0, 10       10000       2.0e-15     3.2e-16
  IEEE       C(x)      0, 10       10000       1.8e-15     3.3e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fresnelintegral(
    <font color=navy>double</font> x,
    <font color=navy>ref</font> <font color=navy>double</font> c,
    <font color=navy>ref</font> <font color=navy>double</font> s)

</div></pre>
<a name=unit_gammafunc></a><h2 class=pageheader><code>gammafunc</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_gammafunction' class=toc>gammafunction</a><br>
<a href='#sub_lngamma' class=toc>lngamma</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_gammafunction'></a><h3 class=pageheader><code>gammafunction</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Gamma function

Input parameters:
    X   -   argument

Domain:
    0 &lt; X &lt; 171.6
    -170 &lt; X &lt; 0, X is not an integer.

Relative error:
 arithmetic   domain     # trials      peak         rms
    IEEE    -170,-33      20000       2.3e-15     3.3e-16
    IEEE     -33,  33     20000       9.4e-16     2.2e-16
    IEEE      33, 171.6   20000       2.3e-15     3.2e-16

Cephes Math Library Release 2.8:  June, 2000
Original copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.gammafunction(<font color=navy>double</font> x)

</div></pre>
<a name='sub_lngamma'></a><h3 class=pageheader><code>lngamma</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Natural logarithm of gamma function

Input parameters:
    X       -   argument

Result:
    logarithm of the absolute value of the Gamma(X).

Output parameters:
    SgnGam  -   sign(Gamma(X))

Domain:
    0 &lt; X &lt; 2.55e305
    -2.55e305 &lt; X &lt; 0, X is not an integer.

ACCURACY:
arithmetic      domain        # trials     peak         rms
   IEEE    0, 3                 28000     5.4e-16     1.1e-16
   IEEE    2.718, 2.556e305     40000     3.5e-16     8.3e-17
The error criterion was relative when the function magnitude
was greater than one but absolute when it was less than one.

The following test used the relative error criterion, though
at certain points the relative error could be much higher than
indicated.
   IEEE    -200, -4             10000     4.8e-16     1.3e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.lngamma(<font color=navy>double</font> x, <font color=navy>out</font> <font color=navy>double</font> sgngam)

</div></pre>
<a name=unit_gkq></a><h2 class=pageheader><code>gkq</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_gkqgenerategaussjacobi' class=toc>gkqgenerategaussjacobi</a><br>
<a href='#sub_gkqgenerategausslegendre' class=toc>gkqgenerategausslegendre</a><br>
<a href='#sub_gkqgeneraterec' class=toc>gkqgeneraterec</a><br>
<a href='#sub_gkqlegendrecalc' class=toc>gkqlegendrecalc</a><br>
<a href='#sub_gkqlegendretbl' class=toc>gkqlegendretbl</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_gkqgenerategaussjacobi'></a><h3 class=pageheader><code>gkqgenerategaussjacobi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns   Gauss   and   Gauss-Kronrod   nodes/weights   for   Gauss-Jacobi
quadrature on [-1,1] with weight function

    W(x)=Power(1-x,Alpha)*Power(1+x,Beta).

INPUT PARAMETERS:
    N           -   number of Kronrod nodes, must be odd number, &gt;=3.
    Alpha       -   power-law coefficient, Alpha&gt;-1
    Beta        -   power-law coefficient, Beta&gt;-1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -5    no real and positive Gauss-Kronrod formula can
                            be created for such a weight function  with  a
                            given number of nodes.
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes. Alpha or  Beta  are  too  close
                            to -1 to obtain weights/nodes with high enough
                            accuracy, or, may be, N is too large.  Try  to
                            use multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N was passed
                    * +1    OK
                    * +2    OK, but quadrature rule have exterior  nodes,
                            x[0]&lt;-1 or x[n-1]&gt;+1
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gkqgenerategaussjacobi(
    <font color=navy>int</font> n,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font> beta,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] wkronrod,
    <font color=navy>out</font> <font color=navy>double</font>[] wgauss)

</div></pre>
<a name='sub_gkqgenerategausslegendre'></a><h3 class=pageheader><code>gkqgenerategausslegendre</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns   Gauss   and   Gauss-Kronrod   nodes/weights  for  Gauss-Legendre
quadrature with N points.

GKQLegendreCalc (calculation) or  GKQLegendreTbl  (precomputed  table)  is
used depending on machine precision and number of nodes.

INPUT PARAMETERS:
    N           -   number of Kronrod nodes, must be odd number, &gt;=3.

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error   was   detected   when  calculating
                            weights/nodes.  N  is  too  large   to  obtain
                            weights/nodes  with  high   enough   accuracy.
                            Try  to   use   multiple   precision  version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gkqgenerategausslegendre(
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] wkronrod,
    <font color=navy>out</font> <font color=navy>double</font>[] wgauss)

</div></pre>
<a name='sub_gkqgeneraterec'></a><h3 class=pageheader><code>gkqgeneraterec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights of a Gauss-Kronrod quadrature formula

The algorithm generates the N-point Gauss-Kronrod quadrature formula  with
weight  function  given  by  coefficients  alpha  and beta of a recurrence
relation which generates a system of orthogonal polynomials:

    P-1(x)   =  0
    P0(x)    =  1
    Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zero moment Mu0

    Mu0 = integral(W(x)dx,a,b)


INPUT PARAMETERS:
    Alpha          alpha coefficients, array[0..floor(3*K/2)].
    Beta           beta coefficients,  array[0..ceil(3*K/2)].
                    Beta[0] is not used and may be arbitrary.
                    Beta[I]&gt;0.
    Mu0            zeroth moment of the weight function.
    N              number of nodes of the Gauss-Kronrod quadrature formula,
                    N &gt;= 3,
                    N =  2*K+1.

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -5    no real and positive Gauss-Kronrod formula can
                            be created for such a weight function  with  a
                            given number of nodes.
                    * -4    N is too large, task may be ill  conditioned -
                            x[i]=x[i+1] found.
                    * -3    internal eigenproblem solver hasn't converged
                    * -2    Beta[i]&lt;=0
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).

  -- ALGLIB --
     Copyright 08.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gkqgeneraterec(
    <font color=navy>double</font>[] alpha,
    <font color=navy>double</font>[] beta,
    <font color=navy>double</font> mu0,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] wkronrod,
    <font color=navy>out</font> <font color=navy>double</font>[] wgauss)

</div></pre>
<a name='sub_gkqlegendrecalc'></a><h3 class=pageheader><code>gkqlegendrecalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns Gauss and Gauss-Kronrod nodes for quadrature with N points.

Reduction to tridiagonal eigenproblem is used.

INPUT PARAMETERS:
    N           -   number of Kronrod nodes, must be odd number, &gt;=3.

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error   was   detected   when  calculating
                            weights/nodes.  N  is  too  large   to  obtain
                            weights/nodes  with  high   enough   accuracy.
                            Try  to   use   multiple   precision  version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).

  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gkqlegendrecalc(
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] wkronrod,
    <font color=navy>out</font> <font color=navy>double</font>[] wgauss)

</div></pre>
<a name='sub_gkqlegendretbl'></a><h3 class=pageheader><code>gkqlegendretbl</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns Gauss and Gauss-Kronrod nodes for quadrature with N  points  using
pre-calculated table. Nodes/weights were  computed  with  accuracy  up  to
1.0E-32 (if MPFR version of ALGLIB is used). In standard double  precision
accuracy reduces to something about 2.0E-16 (depending  on your compiler's
handling of long floating point constants).

INPUT PARAMETERS:
    N           -   number of Kronrod nodes.
                    N can be 15, 21, 31, 41, 51, 61.

OUTPUT PARAMETERS:
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gkqlegendretbl(
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] wkronrod,
    <font color=navy>out</font> <font color=navy>double</font>[] wgauss,
    <font color=navy>out</font> <font color=navy>double</font> eps)

</div></pre>
<a name=unit_gq></a><h2 class=pageheader><code>gq</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_gqgenerategausshermite' class=toc>gqgenerategausshermite</a><br>
<a href='#sub_gqgenerategaussjacobi' class=toc>gqgenerategaussjacobi</a><br>
<a href='#sub_gqgenerategausslaguerre' class=toc>gqgenerategausslaguerre</a><br>
<a href='#sub_gqgenerategausslegendre' class=toc>gqgenerategausslegendre</a><br>
<a href='#sub_gqgenerategausslobattorec' class=toc>gqgenerategausslobattorec</a><br>
<a href='#sub_gqgenerategaussradaurec' class=toc>gqgenerategaussradaurec</a><br>
<a href='#sub_gqgeneraterec' class=toc>gqgeneraterec</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_gqgenerategausshermite'></a><h3 class=pageheader><code>gqgenerategausshermite</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns  nodes/weights  for  Gauss-Hermite  quadrature on (-inf,+inf) with
weight function W(x)=Exp(-x*x)

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes.  May be, N is too large. Try to
                            use multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N/Alpha was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgenerategausshermite(
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_gqgenerategaussjacobi'></a><h3 class=pageheader><code>gqgenerategaussjacobi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns  nodes/weights  for  Gauss-Jacobi quadrature on [-1,1] with weight
function W(x)=Power(1-x,Alpha)*Power(1+x,Beta).

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1
    Alpha       -   power-law coefficient, Alpha&gt;-1
    Beta        -   power-law coefficient, Beta&gt;-1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes. Alpha or  Beta  are  too  close
                            to -1 to obtain weights/nodes with high enough
                            accuracy, or, may be, N is too large.  Try  to
                            use multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N/Alpha/Beta was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgenerategaussjacobi(
    <font color=navy>int</font> n,
    <font color=navy>double</font> alpha,
    <font color=navy>double</font> beta,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_gqgenerategausslaguerre'></a><h3 class=pageheader><code>gqgenerategausslaguerre</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns  nodes/weights  for  Gauss-Laguerre  quadrature  on  [0,+inf) with
weight function W(x)=Power(x,Alpha)*Exp(-x)

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1
    Alpha       -   power-law coefficient, Alpha&gt;-1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes. Alpha is too  close  to  -1  to
                            obtain weights/nodes with high enough accuracy
                            or, may  be,  N  is  too  large.  Try  to  use
                            multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N/Alpha was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgenerategausslaguerre(
    <font color=navy>int</font> n,
    <font color=navy>double</font> alpha,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_gqgenerategausslegendre'></a><h3 class=pageheader><code>gqgenerategausslegendre</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns nodes/weights for Gauss-Legendre quadrature on [-1,1] with N
nodes.

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error   was   detected   when  calculating
                            weights/nodes.  N  is  too  large   to  obtain
                            weights/nodes  with  high   enough   accuracy.
                            Try  to   use   multiple   precision  version.
                    * -3    internal eigenproblem solver hasn't  converged
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgenerategausslegendre(
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_gqgenerategausslobattorec'></a><h3 class=pageheader><code>gqgenerategausslobattorec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights for a Gauss-Lobatto quadrature formula

The algorithm generates the N-point Gauss-Lobatto quadrature formula  with
weight function given by coefficients alpha and beta of a recurrence which
generates a system of orthogonal polynomials.

P-1(x)   =  0
P0(x)    =  1
Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zeroth moment Mu0

Mu0 = integral(W(x)dx,a,b)

INPUT PARAMETERS:
    Alpha      array[0..N-2], alpha coefficients
    Beta       array[0..N-2], beta coefficients.
                Zero-indexed element is not used, may be arbitrary.
                Beta[I]&gt;0
    Mu0        zeroth moment of the weighting function.
    A          left boundary of the integration interval.
    B          right boundary of the integration interval.
    N          number of nodes of the quadrature formula, N&gt;=3
                (including the left and right boundary nodes).

OUTPUT PARAMETERS:
    Info    -   error code:
                * -3    internal eigenproblem solver hasn't converged
                * -2    Beta[i]&lt;=0
                * -1    incorrect N was passed
                *  1    OK
    X       -   array[0..N-1] - array of quadrature nodes,
                in ascending order.
    W       -   array[0..N-1] - array of quadrature weights.

  -- ALGLIB --
     Copyright 2005-2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgenerategausslobattorec(
    <font color=navy>double</font>[] alpha,
    <font color=navy>double</font>[] beta,
    <font color=navy>double</font> mu0,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_gqgenerategaussradaurec'></a><h3 class=pageheader><code>gqgenerategaussradaurec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights for a Gauss-Radau quadrature formula

The algorithm generates the N-point Gauss-Radau  quadrature  formula  with
weight function given by the coefficients alpha and  beta  of a recurrence
which generates a system of orthogonal polynomials.

P-1(x)   =  0
P0(x)    =  1
Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zeroth moment Mu0

Mu0 = integral(W(x)dx,a,b)

INPUT PARAMETERS:
    Alpha      array[0..N-2], alpha coefficients.
    Beta       array[0..N-1], beta coefficients
                Zero-indexed element is not used.
                Beta[I]&gt;0
    Mu0        zeroth moment of the weighting function.
    A          left boundary of the integration interval.
    N          number of nodes of the quadrature formula, N&gt;=2
                (including the left boundary node).

OUTPUT PARAMETERS:
    Info    -   error code:
                * -3    internal eigenproblem solver hasn't converged
                * -2    Beta[i]&lt;=0
                * -1    incorrect N was passed
                *  1    OK
    X       -   array[0..N-1] - array of quadrature nodes,
                in ascending order.
    W       -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 2005-2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgenerategaussradaurec(
    <font color=navy>double</font>[] alpha,
    <font color=navy>double</font>[] beta,
    <font color=navy>double</font> mu0,
    <font color=navy>double</font> a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_gqgeneraterec'></a><h3 class=pageheader><code>gqgeneraterec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights for a Gauss quadrature formula

The algorithm generates the N-point Gauss quadrature formula  with  weight
function given by coefficients alpha and beta  of  a  recurrence  relation
which generates a system of orthogonal polynomials:

P-1(x)   =  0
P0(x)    =  1
Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zeroth moment Mu0

Mu0 = integral(W(x)dx,a,b)

INPUT PARAMETERS:
    Alpha      array[0..N-1], alpha coefficients
    Beta       array[0..N-1], beta coefficients
                Zero-indexed element is not used and may be arbitrary.
                Beta[I]&gt;0.
    Mu0        zeroth moment of the weight function.
    N          number of nodes of the quadrature formula, N&gt;=1

OUTPUT PARAMETERS:
    Info    -   error code:
                * -3    internal eigenproblem solver hasn't converged
                * -2    Beta[i]&lt;=0
                * -1    incorrect N was passed
                *  1    OK
    X       -   array[0..N-1] - array of quadrature nodes,
                in ascending order.
    W       -   array[0..N-1] - array of quadrature weights.

  -- ALGLIB --
     Copyright 2005-2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.gqgeneraterec(
    <font color=navy>double</font>[] alpha,
    <font color=navy>double</font>[] beta,
    <font color=navy>double</font> mu0,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name=unit_hermite></a><h2 class=pageheader><code>hermite</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hermitecalculate' class=toc>hermitecalculate</a><br>
<a href='#sub_hermitecoefficients' class=toc>hermitecoefficients</a><br>
<a href='#sub_hermitesum' class=toc>hermitesum</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_hermitecalculate'></a><h3 class=pageheader><code>hermitecalculate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the value of the Hermite polynomial.

Parameters:
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Hermite polynomial Hn at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hermitecalculate(<font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name='sub_hermitecoefficients'></a><h3 class=pageheader><code>hermitecoefficients</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Representation of Hn as C[0] + C[1]*X + ... + C[N]*X^N

Input parameters:
    N   -   polynomial degree, n&gt;=0

Output parameters:
    C   -   coefficients
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hermitecoefficients(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] c)

</div></pre>
<a name='sub_hermitesum'></a><h3 class=pageheader><code>hermitesum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Summation of Hermite polynomials using Clenshaws recurrence formula.

This routine calculates
    c[0]*H0(x) + c[1]*H1(x) + ... + c[N]*HN(x)

Parameters:
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Hermite polynomial at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hermitesum(<font color=navy>double</font>[] c, <font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name=unit_hqrnd></a><h2 class=pageheader><code>hqrnd</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_hqrndstate' class=toc>hqrndstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hqrndcontinuous' class=toc>hqrndcontinuous</a><br>
<a href='#sub_hqrnddiscrete' class=toc>hqrnddiscrete</a><br>
<a href='#sub_hqrndexponential' class=toc>hqrndexponential</a><br>
<a href='#sub_hqrndnormal' class=toc>hqrndnormal</a><br>
<a href='#sub_hqrndnormal2' class=toc>hqrndnormal2</a><br>
<a href='#sub_hqrndrandomize' class=toc>hqrndrandomize</a><br>
<a href='#sub_hqrndseed' class=toc>hqrndseed</a><br>
<a href='#sub_hqrnduniformi' class=toc>hqrnduniformi</a><br>
<a href='#sub_hqrnduniformr' class=toc>hqrnduniformr</a><br>
<a href='#sub_hqrndunit2' class=toc>hqrndunit2</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_hqrndstate'></a><h3 class=pageheader><code>hqrndstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Portable high quality random number generator state.
Initialized with HQRNDRandomize() or HQRNDSeed().

Fields:
    S1, S2      -   seed values
    V           -   precomputed value
    MagicV      -   'magic' value used to determine whether State structure
                    was correctly initialized.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class hqrndstate
{
}

</div></pre>
<a name='sub_hqrndcontinuous'></a><h3 class=pageheader><code>hqrndcontinuous</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function generates random number from continuous  distribution  given
by finite sample X.

INPUT PARAMETERS
    State   -   high quality random number generator, must be
                initialized with HQRNDRandomize() or HQRNDSeed().
        X   -   finite sample, array[N] (can be larger, in this  case only
                leading N elements are used). THIS ARRAY MUST BE SORTED BY
                ASCENDING.
        N   -   number of elements to use, N&gt;=1

RESULT
    this function returns random number from continuous distribution which
    tries to approximate X as mush as possible. min(X)&lt;=Result&lt;=max(X).

  -- ALGLIB --
     Copyright 08.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hqrndcontinuous(
    hqrndstate state,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_hqrnddiscrete'></a><h3 class=pageheader><code>hqrnddiscrete</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function generates  random number from discrete distribution given by
finite sample X.

INPUT PARAMETERS
    State   -   high quality random number generator, must be
                initialized with HQRNDRandomize() or HQRNDSeed().
        X   -   finite sample
        N   -   number of elements to use, N&gt;=1

RESULT
    this function returns one of the X[i] for random i=0..N-1

  -- ALGLIB --
     Copyright 08.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hqrnddiscrete(
    hqrndstate state,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_hqrndexponential'></a><h3 class=pageheader><code>hqrndexponential</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Random number generator: exponential distribution

State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

  -- ALGLIB --
     Copyright 11.08.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hqrndexponential(
    hqrndstate state,
    <font color=navy>double</font> lambdav)

</div></pre>
<a name='sub_hqrndnormal'></a><h3 class=pageheader><code>hqrndnormal</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Random number generator: normal numbers

This function generates one random number from normal distribution.
Its performance is equal to that of HQRNDNormal2()

State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hqrndnormal(hqrndstate state)

</div></pre>
<a name='sub_hqrndnormal2'></a><h3 class=pageheader><code>hqrndnormal2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Random number generator: normal numbers

This function generates two independent random numbers from normal
distribution. Its performance is equal to that of HQRNDNormal()

State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hqrndnormal2(
    hqrndstate state,
    <font color=navy>out</font> <font color=navy>double</font> x1,
    <font color=navy>out</font> <font color=navy>double</font> x2)

</div></pre>
<a name='sub_hqrndrandomize'></a><h3 class=pageheader><code>hqrndrandomize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
HQRNDState  initialization  with  random  values  which come from standard
RNG.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hqrndrandomize(<font color=navy>out</font> hqrndstate state)

</div></pre>
<a name='sub_hqrndseed'></a><h3 class=pageheader><code>hqrndseed</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
HQRNDState initialization with seed values

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hqrndseed(<font color=navy>int</font> s1, <font color=navy>int</font> s2, <font color=navy>out</font> hqrndstate state)

</div></pre>
<a name='sub_hqrnduniformi'></a><h3 class=pageheader><code>hqrnduniformi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function generates random integer number in [0, N)

1. State structure must be initialized with HQRNDRandomize() or HQRNDSeed()
2. N can be any positive number except for very large numbers:
   * close to 2^31 on 32-bit systems
   * close to 2^62 on 64-bit systems
   An exception will be generated if N is too large.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.hqrnduniformi(hqrndstate state, <font color=navy>int</font> n)

</div></pre>
<a name='sub_hqrnduniformr'></a><h3 class=pageheader><code>hqrnduniformr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function generates random real number in (0,1),
not including interval boundaries

State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hqrnduniformr(hqrndstate state)

</div></pre>
<a name='sub_hqrndunit2'></a><h3 class=pageheader><code>hqrndunit2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Random number generator: random X and Y such that X^2+Y^2=1

State structure must be initialized with HQRNDRandomize() or HQRNDSeed().

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hqrndunit2(
    hqrndstate state,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> y)

</div></pre>
<a name=unit_ibetaf></a><h2 class=pageheader><code>ibetaf</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_incompletebeta' class=toc>incompletebeta</a><br>
<a href='#sub_invincompletebeta' class=toc>invincompletebeta</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_incompletebeta'></a><h3 class=pageheader><code>incompletebeta</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Incomplete beta integral

Returns incomplete beta integral of the arguments, evaluated
from zero to x.  The function is defined as

                 x
    -            -
   | (a+b)      | |  a-1     b-1
 -----------    |   t   (1-t)   dt.
  -     -     | |
 | (a) | (b)   -
                0

The domain of definition is 0 &lt;= x &lt;= 1.  In this
implementation a and b are restricted to positive values.
The integral from x to 1 may be obtained by the symmetry
relation

   1 - incbet( a, b, x )  =  incbet( b, a, 1-x ).

The integral is evaluated by a continued fraction expansion
or, when b*x is small, by a power series.

ACCURACY:

Tested at uniformly distributed random points (a,b,x) with a and b
in &quot;domain&quot; and x between 0 and 1.
                                       Relative error
arithmetic   domain     # trials      peak         rms
   IEEE      0,5         10000       6.9e-15     4.5e-16
   IEEE      0,85       250000       2.2e-13     1.7e-14
   IEEE      0,1000      30000       5.3e-12     6.3e-13
   IEEE      0,10000    250000       9.3e-11     7.1e-12
   IEEE      0,100000    10000       8.7e-10     4.8e-11
Outputs smaller than the IEEE gradual underflow threshold
were excluded from these statistics.

Cephes Math Library, Release 2.8:  June, 2000
Copyright 1984, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.incompletebeta(<font color=navy>double</font> a, <font color=navy>double</font> b, <font color=navy>double</font> x)

</div></pre>
<a name='sub_invincompletebeta'></a><h3 class=pageheader><code>invincompletebeta</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse of imcomplete beta integral

Given y, the function finds x such that

 incbet( a, b, x ) = y .

The routine performs interval halving or Newton iterations to find the
root of incbet(a,b,x) - y = 0.


ACCURACY:

                     Relative error:
               x     a,b
arithmetic   domain  domain  # trials    peak       rms
   IEEE      0,1    .5,10000   50000    5.8e-12   1.3e-13
   IEEE      0,1   .25,100    100000    1.8e-13   3.9e-15
   IEEE      0,1     0,5       50000    1.1e-12   5.5e-15
With a and b constrained to half-integer or integer values:
   IEEE      0,1    .5,10000   50000    5.8e-12   1.1e-13
   IEEE      0,1    .5,100    100000    1.7e-14   7.9e-16
With a = .5, b constrained to half-integer or integer values:
   IEEE      0,1    .5,10000   10000    8.3e-11   1.0e-11

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1996, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invincompletebeta(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font> y)

</div></pre>
<a name=unit_idwint></a><h2 class=pageheader><code>idwint</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_idwinterpolant' class=toc>idwinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_idwbuildmodifiedshepard' class=toc>idwbuildmodifiedshepard</a><br>
<a href='#sub_idwbuildmodifiedshepardr' class=toc>idwbuildmodifiedshepardr</a><br>
<a href='#sub_idwbuildnoisy' class=toc>idwbuildnoisy</a><br>
<a href='#sub_idwcalc' class=toc>idwcalc</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_idwinterpolant'></a><h3 class=pageheader><code>idwinterpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolant.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class idwinterpolant
{
}

</div></pre>
<a name='sub_idwbuildmodifiedshepard'></a><h3 class=pageheader><code>idwbuildmodifiedshepard</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolant using modified Shepard method for uniform point
distributions.

INPUT PARAMETERS:
    XY  -   X and Y values, array[0..N-1,0..NX].
            First NX columns contain X-values, last column contain
            Y-values.
    N   -   number of nodes, N&gt;0.
    NX  -   space dimension, NX&gt;=1.
    D   -   nodal function type, either:
            * 0     constant  model.  Just  for  demonstration only, worst
                    model ever.
            * 1     linear model, least squares fitting. Simpe  model  for
                    datasets too small for quadratic models
            * 2     quadratic  model,  least  squares  fitting. Best model
                    available (if your dataset is large enough).
            * -1    &quot;fast&quot;  linear  model,  use  with  caution!!!   It  is
                    significantly  faster than linear/quadratic and better
                    than constant model. But it is less robust (especially
                    in the presence of noise).
    NQ  -   number of points used to calculate  nodal  functions  (ignored
            for constant models). NQ should be LARGER than:
            * max(1.5*(1+NX),2^NX+1) for linear model,
            * max(3/4*(NX+2)*(NX+1),2^NX+1) for quadratic model.
            Values less than this threshold will be silently increased.
    NW  -   number of points used to calculate weights and to interpolate.
            Required: &gt;=2^NX+1, values less than this  threshold  will  be
            silently increased.
            Recommended value: about 2*NQ

OUTPUT PARAMETERS:
    Z   -   IDW interpolant.

NOTES:
  * best results are obtained with quadratic models, worst - with constant
    models
  * when N is large, NQ and NW must be significantly smaller than  N  both
    to obtain optimal performance and to obtain optimal accuracy. In 2  or
    3-dimensional tasks NQ=15 and NW=25 are good values to start with.
  * NQ  and  NW  may  be  greater  than  N.  In  such  cases  they will be
    automatically decreased.
  * this subroutine is always succeeds (as long as correct parameters  are
    passed).
  * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
    Robert J. Renka for more information on this algorithm.
  * this subroutine assumes that point distribution is uniform at the small
    scales.  If  it  isn't  -  for  example,  points are concentrated along
    &quot;lines&quot;, but &quot;lines&quot; distribution is uniform at the larger scale - then
    you should use IDWBuildModifiedShepardR()


  -- ALGLIB PROJECT --
     Copyright 02.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.idwbuildmodifiedshepard(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nx,
    <font color=navy>int</font> d,
    <font color=navy>int</font> nq,
    <font color=navy>int</font> nw,
    <font color=navy>out</font> idwinterpolant z)

</div></pre>
<a name='sub_idwbuildmodifiedshepardr'></a><h3 class=pageheader><code>idwbuildmodifiedshepardr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolant using modified Shepard method for non-uniform datasets.

This type of model uses  constant  nodal  functions and interpolates using
all nodes which are closer than user-specified radius R. It  may  be  used
when points distribution is non-uniform at the small scale, but it  is  at
the distances as large as R.

INPUT PARAMETERS:
    XY  -   X and Y values, array[0..N-1,0..NX].
            First NX columns contain X-values, last column contain
            Y-values.
    N   -   number of nodes, N&gt;0.
    NX  -   space dimension, NX&gt;=1.
    R   -   radius, R&gt;0

OUTPUT PARAMETERS:
    Z   -   IDW interpolant.

NOTES:
* if there is less than IDWKMin points within  R-ball,  algorithm  selects
  IDWKMin closest ones, so that continuity properties of  interpolant  are
  preserved even far from points.

  -- ALGLIB PROJECT --
     Copyright 11.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.idwbuildmodifiedshepardr(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nx,
    <font color=navy>double</font> r,
    <font color=navy>out</font> idwinterpolant z)

</div></pre>
<a name='sub_idwbuildnoisy'></a><h3 class=pageheader><code>idwbuildnoisy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW model for noisy data.

This subroutine may be used to handle noisy data, i.e. data with noise  in
OUTPUT values.  It differs from IDWBuildModifiedShepard() in the following
aspects:
* nodal functions are not constrained to pass through  nodes:  Qi(xi)&lt;&gt;yi,
  i.e. we have fitting  instead  of  interpolation.
* weights which are used during least  squares fitting stage are all equal
  to 1.0 (independently of distance)
* &quot;fast&quot;-linear or constant nodal functions are not supported (either  not
  robust enough or too rigid)

This problem require far more complex tuning than interpolation  problems.
Below you can find some recommendations regarding this problem:
* focus on tuning NQ; it controls noise reduction. As for NW, you can just
  make it equal to 2*NQ.
* you can use cross-validation to determine optimal NQ.
* optimal NQ is a result of complex tradeoff  between  noise  level  (more
  noise = larger NQ required) and underlying  function  complexity  (given
  fixed N, larger NQ means smoothing of compex features in the data).  For
  example, NQ=N will reduce noise to the minimum level possible,  but  you
  will end up with just constant/linear/quadratic (depending on  D)  least
  squares model for the whole dataset.

INPUT PARAMETERS:
    XY  -   X and Y values, array[0..N-1,0..NX].
            First NX columns contain X-values, last column contain
            Y-values.
    N   -   number of nodes, N&gt;0.
    NX  -   space dimension, NX&gt;=1.
    D   -   nodal function degree, either:
            * 1     linear model, least squares fitting. Simpe  model  for
                    datasets too small for quadratic models (or  for  very
                    noisy problems).
            * 2     quadratic  model,  least  squares  fitting. Best model
                    available (if your dataset is large enough).
    NQ  -   number of points used to calculate nodal functions.  NQ should
            be  significantly   larger   than  1.5  times  the  number  of
            coefficients in a nodal function to overcome effects of noise:
            * larger than 1.5*(1+NX) for linear model,
            * larger than 3/4*(NX+2)*(NX+1) for quadratic model.
            Values less than this threshold will be silently increased.
    NW  -   number of points used to calculate weights and to interpolate.
            Required: &gt;=2^NX+1, values less than this  threshold  will  be
            silently increased.
            Recommended value: about 2*NQ or larger

OUTPUT PARAMETERS:
    Z   -   IDW interpolant.

NOTES:
  * best results are obtained with quadratic models, linear models are not
    recommended to use unless you are pretty sure that it is what you want
  * this subroutine is always succeeds (as long as correct parameters  are
    passed).
  * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
    Robert J. Renka for more information on this algorithm.


  -- ALGLIB PROJECT --
     Copyright 02.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.idwbuildnoisy(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nx,
    <font color=navy>int</font> d,
    <font color=navy>int</font> nq,
    <font color=navy>int</font> nw,
    <font color=navy>out</font> idwinterpolant z)

</div></pre>
<a name='sub_idwcalc'></a><h3 class=pageheader><code>idwcalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolation

INPUT PARAMETERS:
    Z   -   IDW interpolant built with one of model building
            subroutines.
    X   -   array[0..NX-1], interpolation point

Result:
    IDW interpolant Z(X)

  -- ALGLIB --
     Copyright 02.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.idwcalc(idwinterpolant z, <font color=navy>double</font>[] x)

</div></pre>
<a name=unit_igammaf></a><h2 class=pageheader><code>igammaf</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_incompletegamma' class=toc>incompletegamma</a><br>
<a href='#sub_incompletegammac' class=toc>incompletegammac</a><br>
<a href='#sub_invincompletegammac' class=toc>invincompletegammac</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_incompletegamma'></a><h3 class=pageheader><code>incompletegamma</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Incomplete gamma integral

The function is defined by

                          x
                           -
                  1       | |  -t  a-1
 igam(a,x)  =   -----     |   e   t   dt.
                 -      | |
                | (a)    -
                          0


In this implementation both arguments must be positive.
The integral is evaluated by either a power series or
continued fraction expansion, depending on the relative
values of a and x.

ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0,30       200000       3.6e-14     2.9e-15
   IEEE      0,100      300000       9.9e-14     1.5e-14

Cephes Math Library Release 2.8:  June, 2000
Copyright 1985, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.incompletegamma(<font color=navy>double</font> a, <font color=navy>double</font> x)

</div></pre>
<a name='sub_incompletegammac'></a><h3 class=pageheader><code>incompletegammac</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complemented incomplete gamma integral

The function is defined by


 igamc(a,x)   =   1 - igam(a,x)

                           inf.
                             -
                    1       | |  -t  a-1
              =   -----     |   e   t   dt.
                   -      | |
                  | (a)    -
                            x


In this implementation both arguments must be positive.
The integral is evaluated by either a power series or
continued fraction expansion, depending on the relative
values of a and x.

ACCURACY:

Tested at random a, x.
               a         x                      Relative error:
arithmetic   domain   domain     # trials      peak         rms
   IEEE     0.5,100   0,100      200000       1.9e-14     1.7e-15
   IEEE     0.01,0.5  0,100      200000       1.4e-13     1.6e-15

Cephes Math Library Release 2.8:  June, 2000
Copyright 1985, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.incompletegammac(<font color=navy>double</font> a, <font color=navy>double</font> x)

</div></pre>
<a name='sub_invincompletegammac'></a><h3 class=pageheader><code>invincompletegammac</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse of complemented imcomplete gamma integral

Given p, the function finds x such that

 igamc( a, x ) = p.

Starting with the approximate value

        3
 x = a t

 where

 t = 1 - d - ndtri(p) sqrt(d)

and

 d = 1/9a,

the routine performs up to 10 Newton iterations to find the
root of igamc(a,x) - p = 0.

ACCURACY:

Tested at random a, p in the intervals indicated.

               a        p                      Relative error:
arithmetic   domain   domain     # trials      peak         rms
   IEEE     0.5,100   0,0.5       100000       1.0e-14     1.7e-15
   IEEE     0.01,0.5  0,0.5       100000       9.0e-14     3.4e-15
   IEEE    0.5,10000  0,0.5        20000       2.3e-13     3.8e-14

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invincompletegammac(<font color=navy>double</font> a, <font color=navy>double</font> y0)

</div></pre>
<a name=unit_inverseupdate></a><h2 class=pageheader><code>inverseupdate</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixinvupdatecolumn' class=toc>rmatrixinvupdatecolumn</a><br>
<a href='#sub_rmatrixinvupdaterow' class=toc>rmatrixinvupdaterow</a><br>
<a href='#sub_rmatrixinvupdatesimple' class=toc>rmatrixinvupdatesimple</a><br>
<a href='#sub_rmatrixinvupdateuv' class=toc>rmatrixinvupdateuv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixinvupdatecolumn'></a><h3 class=pageheader><code>rmatrixinvupdatecolumn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm updates matrix A^-1 when adding a vector to a column
of matrix A.

Input parameters:
    InvA        -   inverse of matrix A.
                    Array whose indexes range within [0..N-1, 0..N-1].
    N           -   size of matrix A.
    UpdColumn   -   the column of A whose vector U was added.
                    0 &lt;= UpdColumn &lt;= N-1
    U           -   the vector to be added to a column.
                    Array whose index ranges within [0..N-1].

Output parameters:
    InvA        -   inverse of modified matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixinvupdatecolumn(
    <font color=navy>ref</font> <font color=navy>double</font>[,] inva,
    <font color=navy>int</font> n,
    <font color=navy>int</font> updcolumn,
    <font color=navy>double</font>[] u)

</div></pre>
<a name='sub_rmatrixinvupdaterow'></a><h3 class=pageheader><code>rmatrixinvupdaterow</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm updates matrix A^-1 when adding a vector to a row
of matrix A.

Input parameters:
    InvA    -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    UpdRow  -   the row of A whose vector V was added.
                0 &lt;= Row &lt;= N-1
    V       -   the vector to be added to a row.
                Array whose index ranges within [0..N-1].

Output parameters:
    InvA    -   inverse of modified matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixinvupdaterow(
    <font color=navy>ref</font> <font color=navy>double</font>[,] inva,
    <font color=navy>int</font> n,
    <font color=navy>int</font> updrow,
    <font color=navy>double</font>[] v)

</div></pre>
<a name='sub_rmatrixinvupdatesimple'></a><h3 class=pageheader><code>rmatrixinvupdatesimple</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm updates matrix A^-1 when adding a number to an element
of matrix A.

Input parameters:
    InvA    -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    UpdRow  -   row where the element to be updated is stored.
    UpdColumn - column where the element to be updated is stored.
    UpdVal  -   a number to be added to the element.


Output parameters:
    InvA    -   inverse of modified matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixinvupdatesimple(
    <font color=navy>ref</font> <font color=navy>double</font>[,] inva,
    <font color=navy>int</font> n,
    <font color=navy>int</font> updrow,
    <font color=navy>int</font> updcolumn,
    <font color=navy>double</font> updval)

</div></pre>
<a name='sub_rmatrixinvupdateuv'></a><h3 class=pageheader><code>rmatrixinvupdateuv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm computes the inverse of matrix A+u*v by using the given matrix
A^-1 and the vectors u and v.

Input parameters:
    InvA    -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    U       -   the vector modifying the matrix.
                Array whose index ranges within [0..N-1].
    V       -   the vector modifying the matrix.
                Array whose index ranges within [0..N-1].

Output parameters:
    InvA - inverse of matrix A + u*v'.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixinvupdateuv(
    <font color=navy>ref</font> <font color=navy>double</font>[,] inva,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] u,
    <font color=navy>double</font>[] v)

</div></pre>
<a name=unit_jacobianelliptic></a><h2 class=pageheader><code>jacobianelliptic</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_jacobianellipticfunctions' class=toc>jacobianellipticfunctions</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_jacobianellipticfunctions'></a><h3 class=pageheader><code>jacobianellipticfunctions</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Jacobian Elliptic Functions

Evaluates the Jacobian elliptic functions sn(u|m), cn(u|m),
and dn(u|m) of parameter m between 0 and 1, and real
argument u.

These functions are periodic, with quarter-period on the
real axis equal to the complete elliptic integral
ellpk(1.0-m).

Relation to incomplete elliptic integral:
If u = ellik(phi,m), then sn(u|m) = sin(phi),
and cn(u|m) = cos(phi).  Phi is called the amplitude of u.

Computation is by means of the arithmetic-geometric mean
algorithm, except when m is within 1e-9 of 0 or 1.  In the
latter case with m close to 1, the approximation applies
only for phi &lt; pi/2.

ACCURACY:

Tested at random points with u between 0 and 10, m between
0 and 1.

           Absolute error (* = relative error):
arithmetic   function   # trials      peak         rms
   IEEE      phi         10000       9.2e-16*    1.4e-16*
   IEEE      sn          50000       4.1e-15     4.6e-16
   IEEE      cn          40000       3.6e-15     4.4e-16
   IEEE      dn          10000       1.3e-12     1.8e-14

 Peak error observed in consistency check using addition
theorem for sn(u+v) was 4e-16 (absolute).  Also tested by
the above relation to the incomplete elliptic integral.
Accuracy deteriorates when u is large.

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.jacobianellipticfunctions(
    <font color=navy>double</font> u,
    <font color=navy>double</font> m,
    <font color=navy>out</font> <font color=navy>double</font> sn,
    <font color=navy>out</font> <font color=navy>double</font> cn,
    <font color=navy>out</font> <font color=navy>double</font> dn,
    <font color=navy>out</font> <font color=navy>double</font> ph)

</div></pre>
<a name=unit_jarquebera></a><h2 class=pageheader><code>jarquebera</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_jarqueberatest' class=toc>jarqueberatest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_jarqueberatest'></a><h3 class=pageheader><code>jarqueberatest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Jarque-Bera test

This test checks hypotheses about the fact that a  given  sample  X  is  a
sample of normal random variable.

Requirements:
    * the number of elements in the sample is not less than 5.

Input parameters:
    X   -   sample. Array whose index goes from 0 to N-1.
    N   -   size of the sample. N&gt;=5

Output parameters:
    P           -   p-value for the test

Accuracy of the approximation used (5&lt;=N&lt;=1951):

p-value  	    relative error (5&lt;=N&lt;=1951)
[1, 0.1]            &lt; 1%
[0.1, 0.01]         &lt; 2%
[0.01, 0.001]       &lt; 6%
[0.001, 0]          wasn't measured

For N&gt;1951 accuracy wasn't measured but it shouldn't be sharply  different
from table values.

  -- ALGLIB --
     Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.jarqueberatest(<font color=navy>double</font>[] x, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font> p)

</div></pre>
<a name=unit_laguerre></a><h2 class=pageheader><code>laguerre</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_laguerrecalculate' class=toc>laguerrecalculate</a><br>
<a href='#sub_laguerrecoefficients' class=toc>laguerrecoefficients</a><br>
<a href='#sub_laguerresum' class=toc>laguerresum</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_laguerrecalculate'></a><h3 class=pageheader><code>laguerrecalculate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the value of the Laguerre polynomial.

Parameters:
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Laguerre polynomial Ln at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.laguerrecalculate(<font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name='sub_laguerrecoefficients'></a><h3 class=pageheader><code>laguerrecoefficients</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Representation of Ln as C[0] + C[1]*X + ... + C[N]*X^N

Input parameters:
    N   -   polynomial degree, n&gt;=0

Output parameters:
    C   -   coefficients
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.laguerrecoefficients(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] c)

</div></pre>
<a name='sub_laguerresum'></a><h3 class=pageheader><code>laguerresum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Summation of Laguerre polynomials using Clenshaws recurrence formula.

This routine calculates c[0]*L0(x) + c[1]*L1(x) + ... + c[N]*LN(x)

Parameters:
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Laguerre polynomial at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.laguerresum(<font color=navy>double</font>[] c, <font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name=unit_lda></a><h2 class=pageheader><code>lda</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fisherlda' class=toc>fisherlda</a><br>
<a href='#sub_fisherldan' class=toc>fisherldan</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fisherlda'></a><h3 class=pageheader><code>fisherlda</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiclass Fisher LDA

Subroutine finds coefficients of linear combination which optimally separates
training set on classes.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two important  improvements   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison. Best results are achieved  for  high-dimensional  problems
  ! (NVars is at least 256).
  !
  ! Multithreading is used to  accelerate  initial  phase  of  LDA,  which
  ! includes calculation of products of large matrices.  Again,  for  best
  ! efficiency problem must be high-dimensional.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    XY          -   training set, array[0..NPoints-1,0..NVars].
                    First NVars columns store values of independent
                    variables, next column stores number of class (from 0
                    to NClasses-1) which dataset element belongs to. Fractional
                    values are rounded to nearest integer.
    NPoints     -   training set size, NPoints&gt;=0
    NVars       -   number of independent variables, NVars&gt;=1
    NClasses    -   number of classes, NClasses&gt;=2


OUTPUT PARAMETERS:
    Info        -   return code:
                    * -4, if internal EVD subroutine hasn't converged
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed (NPoints&lt;0,
                          NVars&lt;1, NClasses&lt;2)
                    *  1, if task has been solved
                    *  2, if there was a multicollinearity in training set,
                          but task has been solved.
    W           -   linear combination coefficients, array[0..NVars-1]

  -- ALGLIB --
     Copyright 31.05.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fisherlda(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name='sub_fisherldan'></a><h3 class=pageheader><code>fisherldan</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
N-dimensional multiclass Fisher LDA

Subroutine finds coefficients of linear combinations which optimally separates
training set on classes. It returns N-dimensional basis whose vector are sorted
by quality of training set separation (in descending order).

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two important  improvements   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison. Best results are achieved  for  high-dimensional  problems
  ! (NVars is at least 256).
  !
  ! Multithreading is used to  accelerate  initial  phase  of  LDA,  which
  ! includes calculation of products of large matrices.  Again,  for  best
  ! efficiency problem must be high-dimensional.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    XY          -   training set, array[0..NPoints-1,0..NVars].
                    First NVars columns store values of independent
                    variables, next column stores number of class (from 0
                    to NClasses-1) which dataset element belongs to. Fractional
                    values are rounded to nearest integer.
    NPoints     -   training set size, NPoints&gt;=0
    NVars       -   number of independent variables, NVars&gt;=1
    NClasses    -   number of classes, NClasses&gt;=2


OUTPUT PARAMETERS:
    Info        -   return code:
                    * -4, if internal EVD subroutine hasn't converged
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed (NPoints&lt;0,
                          NVars&lt;1, NClasses&lt;2)
                    *  1, if task has been solved
                    *  2, if there was a multicollinearity in training set,
                          but task has been solved.
    W           -   basis, array[0..NVars-1,0..NVars-1]
                    columns of matrix stores basis vectors, sorted by
                    quality of training set separation (in descending order)

  -- ALGLIB --
     Copyright 31.05.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.fisherldan(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[,] w)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_fisherldan(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[,] w)

</div></pre>
<a name=unit_legendre></a><h2 class=pageheader><code>legendre</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_legendrecalculate' class=toc>legendrecalculate</a><br>
<a href='#sub_legendrecoefficients' class=toc>legendrecoefficients</a><br>
<a href='#sub_legendresum' class=toc>legendresum</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_legendrecalculate'></a><h3 class=pageheader><code>legendrecalculate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the value of the Legendre polynomial Pn.

Parameters:
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Legendre polynomial Pn at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.legendrecalculate(<font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name='sub_legendrecoefficients'></a><h3 class=pageheader><code>legendrecoefficients</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Representation of Pn as C[0] + C[1]*X + ... + C[N]*X^N

Input parameters:
    N   -   polynomial degree, n&gt;=0

Output parameters:
    C   -   coefficients
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.legendrecoefficients(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] c)

</div></pre>
<a name='sub_legendresum'></a><h3 class=pageheader><code>legendresum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Summation of Legendre polynomials using Clenshaws recurrence formula.

This routine calculates
    c[0]*P0(x) + c[1]*P1(x) + ... + c[N]*PN(x)

Parameters:
    n   -   degree, n&gt;=0
    x   -   argument

Result:
    the value of the Legendre polynomial at x
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.legendresum(<font color=navy>double</font>[] c, <font color=navy>int</font> n, <font color=navy>double</font> x)

</div></pre>
<a name=unit_lincg></a><h2 class=pageheader><code>lincg</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_lincgreport' class=toc>lincgreport</a><br>
<a href='#struct_lincgstate' class=toc>lincgstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_lincgcreate' class=toc>lincgcreate</a><br>
<a href='#sub_lincgresults' class=toc>lincgresults</a><br>
<a href='#sub_lincgsetcond' class=toc>lincgsetcond</a><br>
<a href='#sub_lincgsetprecdiag' class=toc>lincgsetprecdiag</a><br>
<a href='#sub_lincgsetprecunit' class=toc>lincgsetprecunit</a><br>
<a href='#sub_lincgsetrestartfreq' class=toc>lincgsetrestartfreq</a><br>
<a href='#sub_lincgsetrupdatefreq' class=toc>lincgsetrupdatefreq</a><br>
<a href='#sub_lincgsetstartingpoint' class=toc>lincgsetstartingpoint</a><br>
<a href='#sub_lincgsetxrep' class=toc>lincgsetxrep</a><br>
<a href='#sub_lincgsolvesparse' class=toc>lincgsolvesparse</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_lincg_d_1' class=toc>lincg_d_1</a></td><td width=15>&nbsp;</td><td>Solution of sparse linear systems with CG</td></tr>
</table></div>
<a name='struct_lincgreport'></a><h3 class=pageheader><code>lincgreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class lincgreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nmv;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>double</font>               r2;
}

</div></pre>
<a name='struct_lincgstate'></a><h3 class=pageheader><code>lincgstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores state of the linear CG method.

You should use ALGLIB functions to work with this object.
Never try to access its fields directly!
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class lincgstate
{
}

</div></pre>
<a name='sub_lincgcreate'></a><h3 class=pageheader><code>lincgcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function initializes linear CG Solver. This solver is used  to  solve
symmetric positive definite problems. If you want  to  solve  nonsymmetric
(or non-positive definite) problem you may use LinLSQR solver provided  by
ALGLIB.

USAGE:
1. User initializes algorithm state with LinCGCreate() call
2. User tunes solver parameters with  LinCGSetCond() and other functions
3. Optionally, user sets starting point with LinCGSetStartingPoint()
4. User  calls LinCGSolveSparse() function which takes algorithm state and
   SparseMatrix object.
5. User calls LinCGResults() to get solution
6. Optionally, user may call LinCGSolveSparse()  again  to  solve  another
   problem  with different matrix and/or right part without reinitializing
   LinCGState structure.

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgcreate(<font color=navy>int</font> n, <font color=navy>out</font> lincgstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lincgresults'></a><h3 class=pageheader><code>lincgresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
CG-solver: results.

This function must be called after LinCGSolve

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[N], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -5    input matrix is either not positive definite,
                            too large or too small
                    * -4    overflow/underflow during solution
                            (ill conditioned problem)
                    *  1    ||residual||&lt;=EpsF*||b||
                    *  5    MaxIts steps was taken
                    *  7    rounding errors prevent further progress,
                            best point found is returned
                * Rep.IterationsCount contains iterations count
                * NMV countains number of matrix-vector calculations

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgresults(
    lincgstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> lincgreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lincgsetcond'></a><h3 class=pageheader><code>lincgsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping criteria.

INPUT PARAMETERS:
    EpsF    -   algorithm will be stopped if norm of residual is less than
                EpsF*||b||.
    MaxIts  -   algorithm will be stopped if number of iterations is  more
                than MaxIts.

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTES:
If  both  EpsF  and  MaxIts  are  zero then small EpsF will be set to small
value.

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetcond(
    lincgstate state,
    <font color=navy>double</font> epsf,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_lincgsetprecdiag'></a><h3 class=pageheader><code>lincgsetprecdiag</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  changes  preconditioning  settings  of  LinCGSolveSparse()
function.  LinCGSolveSparse() will use diagonal of the  system  matrix  as
preconditioner. This preconditioning mode is active by default.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 19.11.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetprecdiag(lincgstate state)

</div></pre>
<a name='sub_lincgsetprecunit'></a><h3 class=pageheader><code>lincgsetprecunit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  changes  preconditioning  settings  of  LinCGSolveSparse()
function. By default, SolveSparse() uses diagonal preconditioner,  but  if
you want to use solver without preconditioning, you can call this function
which forces solver to use unit matrix for preconditioning.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 19.11.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetprecunit(lincgstate state)

</div></pre>
<a name='sub_lincgsetrestartfreq'></a><h3 class=pageheader><code>lincgsetrestartfreq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets restart frequency. By default, algorithm  is  restarted
after N subsequent iterations.

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetrestartfreq(lincgstate state, <font color=navy>int</font> srf)

</div></pre>
<a name='sub_lincgsetrupdatefreq'></a><h3 class=pageheader><code>lincgsetrupdatefreq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets frequency of residual recalculations.

Algorithm updates residual r_k using iterative formula,  but  recalculates
it from scratch after each 10 iterations. It is done to avoid accumulation
of numerical errors and to stop algorithm when r_k starts to grow.

Such low update frequence (1/10) gives very  little  overhead,  but  makes
algorithm a bit more robust against numerical errors. However, you may
change it

INPUT PARAMETERS:
    Freq    -   desired update frequency, Freq&gt;=0.
                Zero value means that no updates will be done.

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetrupdatefreq(lincgstate state, <font color=navy>int</font> freq)

</div></pre>
<a name='sub_lincgsetstartingpoint'></a><h3 class=pageheader><code>lincgsetstartingpoint</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets starting point.
By default, zero starting point is used.

INPUT PARAMETERS:
    X       -   starting point, array[N]

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetstartingpoint(
    lincgstate state,
    <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_lincgsetxrep'></a><h3 class=pageheader><code>lincgsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinCGOptimize().

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsetxrep(lincgstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='sub_lincgsolvesparse'></a><h3 class=pageheader><code>lincgsolvesparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procedure for solution of A*x=b with sparse A.

INPUT PARAMETERS:
    State   -   algorithm state
    A       -   sparse matrix in the CRS format (you MUST contvert  it  to
                CRS format by calling SparseConvertToCRS() function).
    IsUpper -   whether upper or lower triangle of A is used:
                * IsUpper=True  =&gt; only upper triangle is used and lower
                                   triangle is not referenced at all
                * IsUpper=False =&gt; only lower triangle is used and upper
                                   triangle is not referenced at all
    B       -   right part, array[N]

RESULT:
    This function returns no result.
    You can get solution by calling LinCGResults()

NOTE: this function uses lightweight preconditioning -  multiplication  by
      inverse of diag(A). If you want, you can turn preconditioning off by
      calling LinCGSetPrecUnit(). However, preconditioning cost is low and
      preconditioner  is  very  important  for  solution  of  badly scaled
      problems.

  -- ALGLIB --
     Copyright 14.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lincgsolvesparse(
    lincgstate state,
    sparsematrix a,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] b)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_lincg_d_1'></a><h3 class=pageheader>lincg_d_1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example illustrates solution of sparse linear systems with</font>
    <font color=green>// conjugate gradient method.</font>
    <font color=green>// </font>
    <font color=green>// Suppose that we have linear system A*x=b with sparse symmetric</font>
    <font color=green>// positive definite A (represented by sparsematrix object)</font>
    <font color=green>//         [ 5 1       ]</font>
    <font color=green>//         [ 1 7 2     ]</font>
    <font color=green>//     A = [   2 8 1   ]</font>
    <font color=green>//         [     1 4 1 ]</font>
    <font color=green>//         [       1 4 ]</font>
    <font color=green>// and right part b</font>
    <font color=green>//     [  7 ]</font>
    <font color=green>//     [ 17 ]</font>
    <font color=green>// b = [ 14 ]</font>
    <font color=green>//     [ 10 ]</font>
    <font color=green>//     [  6 ]</font>
    <font color=green>// and we want to solve this system using sparse linear CG. In order</font>
    <font color=green>// to <font color=navy>do</font> so, we have to create left part (sparsematrix object) and</font>
    <font color=green>// right part (dense array).</font>
    <font color=green>//</font>
    <font color=green>// Initially, sparse matrix is created in the Hash-Table format,</font>
    <font color=green>// which allows easy initialization, but <font color=navy>do</font> not allow matrix to be</font>
    <font color=green>// used in the linear solvers. So after construction you should convert</font>
    <font color=green>// sparse matrix to CRS format (one suited <font color=navy>for</font> linear operations).</font>
    <font color=green>//</font>
    <font color=green>// It is important to note that in our example we initialize full</font>
    <font color=green>// matrix A, both lower and upper triangles. However, it is symmetric</font>
    <font color=green>// and sparse solver needs just one half of the matrix. So you may</font>
    <font color=green>// save about half of the space by filling only one of the triangles.</font>
    <font color=green>//</font>
    alglib.sparsematrix a;
    alglib.sparsecreate(5, 5, <font color=navy>out</font> a);
    alglib.sparseset(a, 0, 0, 5.0);
    alglib.sparseset(a, 0, 1, 1.0);
    alglib.sparseset(a, 1, 0, 1.0);
    alglib.sparseset(a, 1, 1, 7.0);
    alglib.sparseset(a, 1, 2, 2.0);
    alglib.sparseset(a, 2, 1, 2.0);
    alglib.sparseset(a, 2, 2, 8.0);
    alglib.sparseset(a, 2, 3, 1.0);
    alglib.sparseset(a, 3, 2, 1.0);
    alglib.sparseset(a, 3, 3, 4.0);
    alglib.sparseset(a, 3, 4, 1.0);
    alglib.sparseset(a, 4, 3, 1.0);
    alglib.sparseset(a, 4, 4, 4.0);

    <font color=green>//</font>
    <font color=green>// Now our matrix is fully initialized, but we have to <font color=navy>do</font> one more</font>
    <font color=green>// step - convert it from Hash-Table format to CRS format (see</font>
    <font color=green>// documentation on sparse matrices <font color=navy>for</font> more information about these</font>
    <font color=green>// formats).</font>
    <font color=green>//</font>
    <font color=green>// If you omit this call, ALGLIB will generate exception on the first</font>
    <font color=green>// attempt to use A in linear operations. </font>
    <font color=green>//</font>
    alglib.sparseconverttocrs(a);

    <font color=green>//</font>
    <font color=green>// Initialization of the right part</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] b = new <font color=navy>double</font>[]{7,17,14,10,6};

    <font color=green>//</font>
    <font color=green>// Now we have to create linear solver object and to use it <font color=navy>for</font> the</font>
    <font color=green>// solution of the linear system.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: lincgsolvesparse() accepts additional parameter which tells</font>
    <font color=green>//       what triangle of the symmetric matrix should be used - upper</font>
    <font color=green>//       or lower. Because we've filled both parts of the matrix, we</font>
    <font color=green>//       can use any part - upper or lower.</font>
    <font color=green>//</font>
    alglib.lincgstate s;
    alglib.lincgreport rep;
    <font color=navy>double</font>[] x;
    alglib.lincgcreate(5, <font color=navy>out</font> s);
    alglib.lincgsolvesparse(s, a, true, b);
    alglib.lincgresults(s, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [1.000,2.000,1.000,2.000,1.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_linlsqr></a><h2 class=pageheader><code>linlsqr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_linlsqrreport' class=toc>linlsqrreport</a><br>
<a href='#struct_linlsqrstate' class=toc>linlsqrstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_linlsqrcreate' class=toc>linlsqrcreate</a><br>
<a href='#sub_linlsqrresults' class=toc>linlsqrresults</a><br>
<a href='#sub_linlsqrsetcond' class=toc>linlsqrsetcond</a><br>
<a href='#sub_linlsqrsetlambdai' class=toc>linlsqrsetlambdai</a><br>
<a href='#sub_linlsqrsetprecdiag' class=toc>linlsqrsetprecdiag</a><br>
<a href='#sub_linlsqrsetprecunit' class=toc>linlsqrsetprecunit</a><br>
<a href='#sub_linlsqrsetxrep' class=toc>linlsqrsetxrep</a><br>
<a href='#sub_linlsqrsolvesparse' class=toc>linlsqrsolvesparse</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_linlsqr_d_1' class=toc>linlsqr_d_1</a></td><td width=15>&nbsp;</td><td>Solution of sparse linear systems with CG</td></tr>
</table></div>
<a name='struct_linlsqrreport'></a><h3 class=pageheader><code>linlsqrreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class linlsqrreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nmv;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_linlsqrstate'></a><h3 class=pageheader><code>linlsqrstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores state of the LinLSQR method.

You should use ALGLIB functions to work with this object.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class linlsqrstate
{
}

</div></pre>
<a name='sub_linlsqrcreate'></a><h3 class=pageheader><code>linlsqrcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function initializes linear LSQR Solver. This solver is used to solve
non-symmetric (and, possibly, non-square) problems. Least squares solution
is returned for non-compatible systems.

USAGE:
1. User initializes algorithm state with LinLSQRCreate() call
2. User tunes solver parameters with  LinLSQRSetCond() and other functions
3. User  calls  LinLSQRSolveSparse()  function which takes algorithm state
   and SparseMatrix object.
4. User calls LinLSQRResults() to get solution
5. Optionally, user may call LinLSQRSolveSparse() again to  solve  another
   problem  with different matrix and/or right part without reinitializing
   LinLSQRState structure.

INPUT PARAMETERS:
    M       -   number of rows in A
    N       -   number of variables, N&gt;0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 30.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrcreate(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> linlsqrstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_linlsqr_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_linlsqrresults'></a><h3 class=pageheader><code>linlsqrresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LSQR solver: results.

This function must be called after LinLSQRSolve

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[N], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    *  1    ||Rk||&lt;=EpsB*||B||
                    *  4    ||A^T*Rk||/(||A||*||Rk||)&lt;=EpsA
                    *  5    MaxIts steps was taken
                    *  7    rounding errors prevent further progress,
                            X contains best point found so far.
                            (sometimes returned on singular systems)
                * Rep.IterationsCount contains iterations count
                * NMV countains number of matrix-vector calculations

  -- ALGLIB --
     Copyright 30.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrresults(
    linlsqrstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> linlsqrreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_linlsqr_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_linlsqrsetcond'></a><h3 class=pageheader><code>linlsqrsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping criteria.

INPUT PARAMETERS:
    EpsA    -   algorithm will be stopped if ||A^T*Rk||/(||A||*||Rk||)&lt;=EpsA.
    EpsB    -   algorithm will be stopped if ||Rk||&lt;=EpsB*||B||
    MaxIts  -   algorithm will be stopped if number of iterations
                more than MaxIts.

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTE: if EpsA,EpsB,EpsC and MaxIts are zero then these variables will
be setted as default values.

  -- ALGLIB --
     Copyright 30.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrsetcond(
    linlsqrstate state,
    <font color=navy>double</font> epsa,
    <font color=navy>double</font> epsb,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_linlsqrsetlambdai'></a><h3 class=pageheader><code>linlsqrsetlambdai</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets optional Tikhonov regularization coefficient.
It is zero by default.

INPUT PARAMETERS:
    LambdaI -   regularization factor, LambdaI&gt;=0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 30.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrsetlambdai(
    linlsqrstate state,
    <font color=navy>double</font> lambdai)

</div></pre>
<a name='sub_linlsqrsetprecdiag'></a><h3 class=pageheader><code>linlsqrsetprecdiag</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  changes  preconditioning  settings  of  LinCGSolveSparse()
function.  LinCGSolveSparse() will use diagonal of the  system  matrix  as
preconditioner. This preconditioning mode is active by default.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 19.11.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrsetprecdiag(linlsqrstate state)

</div></pre>
<a name='sub_linlsqrsetprecunit'></a><h3 class=pageheader><code>linlsqrsetprecunit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  changes  preconditioning  settings of LinLSQQSolveSparse()
function. By default, SolveSparse() uses diagonal preconditioner,  but  if
you want to use solver without preconditioning, you can call this function
which forces solver to use unit matrix for preconditioning.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 19.11.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrsetprecunit(linlsqrstate state)

</div></pre>
<a name='sub_linlsqrsetxrep'></a><h3 class=pageheader><code>linlsqrsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinCGOptimize().

  -- ALGLIB --
     Copyright 30.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrsetxrep(
    linlsqrstate state,
    <font color=navy>bool</font> needxrep)

</div></pre>
<a name='sub_linlsqrsolvesparse'></a><h3 class=pageheader><code>linlsqrsolvesparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procedure for solution of A*x=b with sparse A.

INPUT PARAMETERS:
    State   -   algorithm state
    A       -   sparse M*N matrix in the CRS format (you MUST contvert  it
                to CRS format  by  calling  SparseConvertToCRS()  function
                BEFORE you pass it to this function).
    B       -   right part, array[M]

RESULT:
    This function returns no result.
    You can get solution by calling LinCGResults()

NOTE: this function uses lightweight preconditioning -  multiplication  by
      inverse of diag(A). If you want, you can turn preconditioning off by
      calling LinLSQRSetPrecUnit(). However, preconditioning cost is   low
      and preconditioner is very important for solution  of  badly  scaled
      problems.

  -- ALGLIB --
     Copyright 30.11.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.linlsqrsolvesparse(
    linlsqrstate state,
    sparsematrix a,
    <font color=navy>double</font>[] b)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_linlsqr_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_linlsqr_d_1'></a><h3 class=pageheader>linlsqr_d_1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example illustrates solution of sparse linear least squares problem</font>
    <font color=green>// with LSQR algorithm.</font>
    <font color=green>// </font>
    <font color=green>// Suppose that we have least squares problem min|A*x-b| with sparse A</font>
    <font color=green>// represented by sparsematrix object</font>
    <font color=green>//         [ 1 1 ]</font>
    <font color=green>//         [ 1 1 ]</font>
    <font color=green>//     A = [ 2 1 ]</font>
    <font color=green>//         [ 1   ]</font>
    <font color=green>//         [   1 ]</font>
    <font color=green>// and right part b</font>
    <font color=green>//     [ 4 ]</font>
    <font color=green>//     [ 2 ]</font>
    <font color=green>// b = [ 4 ]</font>
    <font color=green>//     [ 1 ]</font>
    <font color=green>//     [ 2 ]</font>
    <font color=green>// and we want to solve this system in the least squares sense using</font>
    <font color=green>// LSQR algorithm. In order to <font color=navy>do</font> so, we have to create left part</font>
    <font color=green>// (sparsematrix object) and right part (dense array).</font>
    <font color=green>//</font>
    <font color=green>// Initially, sparse matrix is created in the Hash-Table format,</font>
    <font color=green>// which allows easy initialization, but <font color=navy>do</font> not allow matrix to be</font>
    <font color=green>// used in the linear solvers. So after construction you should convert</font>
    <font color=green>// sparse matrix to CRS format (one suited <font color=navy>for</font> linear operations).</font>
    <font color=green>//</font>
    alglib.sparsematrix a;
    alglib.sparsecreate(5, 2, <font color=navy>out</font> a);
    alglib.sparseset(a, 0, 0, 1.0);
    alglib.sparseset(a, 0, 1, 1.0);
    alglib.sparseset(a, 1, 0, 1.0);
    alglib.sparseset(a, 1, 1, 1.0);
    alglib.sparseset(a, 2, 0, 2.0);
    alglib.sparseset(a, 2, 1, 1.0);
    alglib.sparseset(a, 3, 0, 1.0);
    alglib.sparseset(a, 4, 1, 1.0);

    <font color=green>//</font>
    <font color=green>// Now our matrix is fully initialized, but we have to <font color=navy>do</font> one more</font>
    <font color=green>// step - convert it from Hash-Table format to CRS format (see</font>
    <font color=green>// documentation on sparse matrices <font color=navy>for</font> more information about these</font>
    <font color=green>// formats).</font>
    <font color=green>//</font>
    <font color=green>// If you omit this call, ALGLIB will generate exception on the first</font>
    <font color=green>// attempt to use A in linear operations. </font>
    <font color=green>//</font>
    alglib.sparseconverttocrs(a);

    <font color=green>//</font>
    <font color=green>// Initialization of the right part</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] b = new <font color=navy>double</font>[]{4,2,4,1,2};

    <font color=green>//</font>
    <font color=green>// Now we have to create linear solver object and to use it <font color=navy>for</font> the</font>
    <font color=green>// solution of the linear system.</font>
    <font color=green>//</font>
    alglib.linlsqrstate s;
    alglib.linlsqrreport rep;
    <font color=navy>double</font>[] x;
    alglib.linlsqrcreate(5, 2, <font color=navy>out</font> s);
    alglib.linlsqrsolvesparse(s, a, b);
    alglib.linlsqrresults(s, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [1.000,2.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_linreg></a><h2 class=pageheader><code>linreg</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_linearmodel' class=toc>linearmodel</a><br>
<a href='#struct_lrreport' class=toc>lrreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_lravgerror' class=toc>lravgerror</a><br>
<a href='#sub_lravgrelerror' class=toc>lravgrelerror</a><br>
<a href='#sub_lrbuild' class=toc>lrbuild</a><br>
<a href='#sub_lrbuilds' class=toc>lrbuilds</a><br>
<a href='#sub_lrbuildz' class=toc>lrbuildz</a><br>
<a href='#sub_lrbuildzs' class=toc>lrbuildzs</a><br>
<a href='#sub_lrpack' class=toc>lrpack</a><br>
<a href='#sub_lrprocess' class=toc>lrprocess</a><br>
<a href='#sub_lrrmserror' class=toc>lrrmserror</a><br>
<a href='#sub_lrunpack' class=toc>lrunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_linreg_d_basic' class=toc>linreg_d_basic</a></td><td width=15>&nbsp;</td><td>Linear regression used to build the very basic model and unpack coefficients</td></tr>
</table></div>
<a name='struct_linearmodel'></a><h3 class=pageheader><code>linearmodel</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class linearmodel
{
}

</div></pre>
<a name='struct_lrreport'></a><h3 class=pageheader><code>lrreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LRReport structure contains additional information about linear model:
* C             -   covariation matrix,  array[0..NVars,0..NVars].
                    C[i,j] = Cov(A[i],A[j])
* RMSError      -   root mean square error on a training set
* AvgError      -   average error on a training set
* AvgRelError   -   average relative error on a training set (excluding
                    observations with zero function value).
* CVRMSError    -   leave-one-out cross-validation estimate of
                    generalization error. Calculated using fast algorithm
                    with O(NVars*NPoints) complexity.
* CVAvgError    -   cross-validation estimate of average error
* CVAvgRelError -   cross-validation estimate of average relative error

All other fields of the structure are intended for internal use and should
not be used outside ALGLIB.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class lrreport
{
    <font color=navy>public</font> <font color=navy>double</font>[,]            c;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>double</font>               cvrmserror;
    <font color=navy>public</font> <font color=navy>double</font>               cvavgerror;
    <font color=navy>public</font> <font color=navy>double</font>               cvavgrelerror;
    <font color=navy>public</font> <font color=navy>int</font>                  ncvdefects;
    <font color=navy>public</font> <font color=navy>int</font>[]                cvdefects;
}

</div></pre>
<a name='sub_lravgerror'></a><h3 class=pageheader><code>lravgerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average error on the test set

INPUT PARAMETERS:
    LM      -   linear model
    XY      -   test set
    NPoints -   test set size

RESULT:
    average error.

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.lravgerror(
    linearmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_lravgrelerror'></a><h3 class=pageheader><code>lravgrelerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set

INPUT PARAMETERS:
    LM      -   linear model
    XY      -   test set
    NPoints -   test set size

RESULT:
    average relative error.

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.lravgrelerror(
    linearmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_lrbuild'></a><h3 class=pageheader><code>lrbuild</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Linear regression

Subroutine builds model:

    Y = A(0)*X[0] + ... + A(N-1)*X[N-1] + A(N)

and model found in ALGLIB format, covariation matrix, training set  errors
(rms,  average,  average  relative)   and  leave-one-out  cross-validation
estimate of the generalization error. CV  estimate calculated  using  fast
algorithm with O(NPoints*NVars) complexity.

When  covariation  matrix  is  calculated  standard deviations of function
values are assumed to be equal to RMS error on the training set.

INPUT PARAMETERS:
    XY          -   training set, array [0..NPoints-1,0..NVars]:
                    * NVars columns - independent variables
                    * last column - dependent variable
    NPoints     -   training set size, NPoints&gt;NVars+1
    NVars       -   number of independent variables

OUTPUT PARAMETERS:
    Info        -   return code:
                    * -255, in case of unknown internal error
                    * -4, if internal SVD subroutine haven't converged
                    * -1, if incorrect parameters was passed (NPoints&lt;NVars+2, NVars&lt;1).
                    *  1, if subroutine successfully finished
    LM          -   linear model in the ALGLIB format. Use subroutines of
                    this unit to work with the model.
    AR          -   additional results


  -- ALGLIB --
     Copyright 02.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lrbuild(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> linearmodel lm,
    <font color=navy>out</font> lrreport ar)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_linreg_d_basic' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lrbuilds'></a><h3 class=pageheader><code>lrbuilds</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Linear regression

Variant of LRBuild which uses vector of standatd deviations (errors in
function values).

INPUT PARAMETERS:
    XY          -   training set, array [0..NPoints-1,0..NVars]:
                    * NVars columns - independent variables
                    * last column - dependent variable
    S           -   standard deviations (errors in function values)
                    array[0..NPoints-1], S[i]&gt;0.
    NPoints     -   training set size, NPoints&gt;NVars+1
    NVars       -   number of independent variables

OUTPUT PARAMETERS:
    Info        -   return code:
                    * -255, in case of unknown internal error
                    * -4, if internal SVD subroutine haven't converged
                    * -1, if incorrect parameters was passed (NPoints&lt;NVars+2, NVars&lt;1).
                    * -2, if S[I]&lt;=0
                    *  1, if subroutine successfully finished
    LM          -   linear model in the ALGLIB format. Use subroutines of
                    this unit to work with the model.
    AR          -   additional results


  -- ALGLIB --
     Copyright 02.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lrbuilds(
    <font color=navy>double</font>[,] xy,
    <font color=navy>double</font>[] s,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> linearmodel lm,
    <font color=navy>out</font> lrreport ar)

</div></pre>
<a name='sub_lrbuildz'></a><h3 class=pageheader><code>lrbuildz</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like LRBuild but builds model

    Y = A(0)*X[0] + ... + A(N-1)*X[N-1]

i.e. with zero constant term.

  -- ALGLIB --
     Copyright 30.10.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lrbuildz(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> linearmodel lm,
    <font color=navy>out</font> lrreport ar)

</div></pre>
<a name='sub_lrbuildzs'></a><h3 class=pageheader><code>lrbuildzs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like LRBuildS, but builds model

    Y = A(0)*X[0] + ... + A(N-1)*X[N-1]

i.e. with zero constant term.

  -- ALGLIB --
     Copyright 30.10.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lrbuildzs(
    <font color=navy>double</font>[,] xy,
    <font color=navy>double</font>[] s,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> linearmodel lm,
    <font color=navy>out</font> lrreport ar)

</div></pre>
<a name='sub_lrpack'></a><h3 class=pageheader><code>lrpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
&quot;Packs&quot; coefficients and creates linear model in ALGLIB format (LRUnpack
reversed).

INPUT PARAMETERS:
    V           -   coefficients, array[0..NVars]
    NVars       -   number of independent variables

OUTPUT PAREMETERS:
    LM          -   linear model.

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lrpack(
    <font color=navy>double</font>[] v,
    <font color=navy>int</font> nvars,
    <font color=navy>out</font> linearmodel lm)

</div></pre>
<a name='sub_lrprocess'></a><h3 class=pageheader><code>lrprocess</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procesing

INPUT PARAMETERS:
    LM      -   linear model
    X       -   input vector,  array[0..NVars-1].

Result:
    value of linear model regression estimate

  -- ALGLIB --
     Copyright 03.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.lrprocess(linearmodel lm, <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_lrrmserror'></a><h3 class=pageheader><code>lrrmserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set

INPUT PARAMETERS:
    LM      -   linear model
    XY      -   test set
    NPoints -   test set size

RESULT:
    root mean square error.

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.lrrmserror(
    linearmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_lrunpack'></a><h3 class=pageheader><code>lrunpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacks coefficients of linear model.

INPUT PARAMETERS:
    LM          -   linear model in ALGLIB format

OUTPUT PARAMETERS:
    V           -   coefficients, array[0..NVars]
                    constant term (intercept) is stored in the V[NVars].
    NVars       -   number of independent variables (one less than number
                    of coefficients)

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lrunpack(
    linearmodel lm,
    <font color=navy>out</font> <font color=navy>double</font>[] v,
    <font color=navy>out</font> <font color=navy>int</font> nvars)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_linreg_d_basic' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_linreg_d_basic'></a><h3 class=pageheader>linreg_d_basic example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate linear fitting by f(x|a) = a*exp(0.5*x).</font>
    <font color=green>//</font>
    <font color=green>// We have:</font>
    <font color=green>// * xy - matrix of basic function values (exp(0.5*x)) and expected values</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{0.606531,1.133719},{0.670320,1.306522},{0.740818,1.504604},{0.818731,1.554663},{0.904837,1.884638},{1.000000,2.072436},{1.105171,2.257285},{1.221403,2.534068},{1.349859,2.622017},{1.491825,2.897713},{1.648721,3.219371}};
    <font color=navy>int</font> info;
    <font color=navy>int</font> nvars;
    alglib.linearmodel model;
    alglib.lrreport rep;
    <font color=navy>double</font>[] c;

    alglib.lrbuildz(xy, 11, 1, <font color=navy>out</font> info, <font color=navy>out</font> model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    alglib.lrunpack(model, <font color=navy>out</font> c, <font color=navy>out</font> nvars);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,4)); <font color=green>// EXPECTED: [1.98650,0.00000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_logit></a><h2 class=pageheader><code>logit</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_logitmodel' class=toc>logitmodel</a><br>
<a href='#struct_mnlreport' class=toc>mnlreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mnlavgce' class=toc>mnlavgce</a><br>
<a href='#sub_mnlavgerror' class=toc>mnlavgerror</a><br>
<a href='#sub_mnlavgrelerror' class=toc>mnlavgrelerror</a><br>
<a href='#sub_mnlclserror' class=toc>mnlclserror</a><br>
<a href='#sub_mnlpack' class=toc>mnlpack</a><br>
<a href='#sub_mnlprocess' class=toc>mnlprocess</a><br>
<a href='#sub_mnlprocessi' class=toc>mnlprocessi</a><br>
<a href='#sub_mnlrelclserror' class=toc>mnlrelclserror</a><br>
<a href='#sub_mnlrmserror' class=toc>mnlrmserror</a><br>
<a href='#sub_mnltrainh' class=toc>mnltrainh</a><br>
<a href='#sub_mnlunpack' class=toc>mnlunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_logitmodel'></a><h3 class=pageheader><code>logitmodel</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class logitmodel
{
}

</div></pre>
<a name='struct_mnlreport'></a><h3 class=pageheader><code>mnlreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
MNLReport structure contains information about training process:
* NGrad     -   number of gradient calculations
* NHess     -   number of Hessian calculations
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mnlreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  ngrad;
    <font color=navy>public</font> <font color=navy>int</font>                  nhess;
}

</div></pre>
<a name='sub_mnlavgce'></a><h3 class=pageheader><code>mnlavgce</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average cross-entropy (in bits per element) on the test set

INPUT PARAMETERS:
    LM      -   logit model
    XY      -   test set
    NPoints -   test set size

RESULT:
    CrossEntropy/(NPoints*ln(2)).

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mnlavgce(
    logitmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mnlavgerror'></a><h3 class=pageheader><code>mnlavgerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average error on the test set

INPUT PARAMETERS:
    LM      -   logit model
    XY      -   test set
    NPoints -   test set size

RESULT:
    average error (error when estimating posterior probabilities).

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mnlavgerror(
    logitmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mnlavgrelerror'></a><h3 class=pageheader><code>mnlavgrelerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average relative error on the test set

INPUT PARAMETERS:
    LM      -   logit model
    XY      -   test set
    NPoints -   test set size

RESULT:
    average relative error (error when estimating posterior probabilities).

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mnlavgrelerror(
    logitmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize)

</div></pre>
<a name='sub_mnlclserror'></a><h3 class=pageheader><code>mnlclserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Classification error on test set = MNLRelClsError*NPoints

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mnlclserror(
    logitmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mnlpack'></a><h3 class=pageheader><code>mnlpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
&quot;Packs&quot; coefficients and creates logit model in ALGLIB format (MNLUnpack
reversed).

INPUT PARAMETERS:
    A           -   model (see MNLUnpack)
    NVars       -   number of independent variables
    NClasses    -   number of classes

OUTPUT PARAMETERS:
    LM          -   logit model.

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mnlpack(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>out</font> logitmodel lm)

</div></pre>
<a name='sub_mnlprocess'></a><h3 class=pageheader><code>mnlprocess</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procesing

INPUT PARAMETERS:
    LM      -   logit model, passed by non-constant reference
                (some fields of structure are used as temporaries
                when calculating model output).
    X       -   input vector,  array[0..NVars-1].
    Y       -   (possibly) preallocated buffer; if size of Y is less than
                NClasses, it will be reallocated.If it is large enough, it
                is NOT reallocated, so we can save some time on reallocation.

OUTPUT PARAMETERS:
    Y       -   result, array[0..NClasses-1]
                Vector of posterior probabilities for classification task.

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mnlprocess(
    logitmodel lm,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_mnlprocessi'></a><h3 class=pageheader><code>mnlprocessi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
'interactive'  variant  of  MNLProcess  for  languages  like  Python which
support constructs like &quot;Y = MNLProcess(LM,X)&quot; and interactive mode of the
interpreter

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mnlprocessi(
    logitmodel lm,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_mnlrelclserror'></a><h3 class=pageheader><code>mnlrelclserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Relative classification error on the test set

INPUT PARAMETERS:
    LM      -   logit model
    XY      -   test set
    NPoints -   test set size

RESULT:
    percent of incorrectly classified cases.

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mnlrelclserror(
    logitmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mnlrmserror'></a><h3 class=pageheader><code>mnlrmserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set

INPUT PARAMETERS:
    LM      -   logit model
    XY      -   test set
    NPoints -   test set size

RESULT:
    root mean square error (error when estimating posterior probabilities).

  -- ALGLIB --
     Copyright 30.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mnlrmserror(
    logitmodel lm,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mnltrainh'></a><h3 class=pageheader><code>mnltrainh</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine trains logit model.

INPUT PARAMETERS:
    XY          -   training set, array[0..NPoints-1,0..NVars]
                    First NVars columns store values of independent
                    variables, next column stores number of class (from 0
                    to NClasses-1) which dataset element belongs to. Fractional
                    values are rounded to nearest integer.
    NPoints     -   training set size, NPoints&gt;=1
    NVars       -   number of independent variables, NVars&gt;=1
    NClasses    -   number of classes, NClasses&gt;=2

OUTPUT PARAMETERS:
    Info        -   return code:
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed
                          (NPoints&lt;NVars+2, NVars&lt;1, NClasses&lt;2).
                    *  1, if task has been solved
    LM          -   model built
    Rep         -   training report

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mnltrainh(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>int</font> nclasses,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> logitmodel lm,
    <font color=navy>out</font> mnlreport rep)

</div></pre>
<a name='sub_mnlunpack'></a><h3 class=pageheader><code>mnlunpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacks coefficients of logit model. Logit model have form:

    P(class=i) = S(i) / (S(0) + S(1) + ... +S(M-1))
          S(i) = Exp(A[i,0]*X[0] + ... + A[i,N-1]*X[N-1] + A[i,N]), when i&lt;M-1
        S(M-1) = 1

INPUT PARAMETERS:
    LM          -   logit model in ALGLIB format

OUTPUT PARAMETERS:
    V           -   coefficients, array[0..NClasses-2,0..NVars]
    NVars       -   number of independent variables
    NClasses    -   number of classes

  -- ALGLIB --
     Copyright 10.09.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mnlunpack(
    logitmodel lm,
    <font color=navy>out</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> nvars,
    <font color=navy>out</font> <font color=navy>int</font> nclasses)

</div></pre>
<a name=unit_lsfit></a><h2 class=pageheader><code>lsfit</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_barycentricfitreport' class=toc>barycentricfitreport</a><br>
<a href='#struct_lsfitreport' class=toc>lsfitreport</a><br>
<a href='#struct_lsfitstate' class=toc>lsfitstate</a><br>
<a href='#struct_polynomialfitreport' class=toc>polynomialfitreport</a><br>
<a href='#struct_spline1dfitreport' class=toc>spline1dfitreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_barycentricfitfloaterhormann' class=toc>barycentricfitfloaterhormann</a><br>
<a href='#sub_barycentricfitfloaterhormannwc' class=toc>barycentricfitfloaterhormannwc</a><br>
<a href='#sub_logisticcalc4' class=toc>logisticcalc4</a><br>
<a href='#sub_logisticcalc5' class=toc>logisticcalc5</a><br>
<a href='#sub_logisticfit4' class=toc>logisticfit4</a><br>
<a href='#sub_logisticfit45x' class=toc>logisticfit45x</a><br>
<a href='#sub_logisticfit4ec' class=toc>logisticfit4ec</a><br>
<a href='#sub_logisticfit5' class=toc>logisticfit5</a><br>
<a href='#sub_logisticfit5ec' class=toc>logisticfit5ec</a><br>
<a href='#sub_lsfitcreatef' class=toc>lsfitcreatef</a><br>
<a href='#sub_lsfitcreatefg' class=toc>lsfitcreatefg</a><br>
<a href='#sub_lsfitcreatefgh' class=toc>lsfitcreatefgh</a><br>
<a href='#sub_lsfitcreatewf' class=toc>lsfitcreatewf</a><br>
<a href='#sub_lsfitcreatewfg' class=toc>lsfitcreatewfg</a><br>
<a href='#sub_lsfitcreatewfgh' class=toc>lsfitcreatewfgh</a><br>
<a href='#sub_lsfitfit' class=toc>lsfitfit</a><br>
<a href='#sub_lsfitlinear' class=toc>lsfitlinear</a><br>
<a href='#sub_lsfitlinearc' class=toc>lsfitlinearc</a><br>
<a href='#sub_lsfitlinearw' class=toc>lsfitlinearw</a><br>
<a href='#sub_lsfitlinearwc' class=toc>lsfitlinearwc</a><br>
<a href='#sub_lsfitresults' class=toc>lsfitresults</a><br>
<a href='#sub_lsfitsetbc' class=toc>lsfitsetbc</a><br>
<a href='#sub_lsfitsetcond' class=toc>lsfitsetcond</a><br>
<a href='#sub_lsfitsetgradientcheck' class=toc>lsfitsetgradientcheck</a><br>
<a href='#sub_lsfitsetscale' class=toc>lsfitsetscale</a><br>
<a href='#sub_lsfitsetstpmax' class=toc>lsfitsetstpmax</a><br>
<a href='#sub_lsfitsetxrep' class=toc>lsfitsetxrep</a><br>
<a href='#sub_lstfitpiecewiselinearrdp' class=toc>lstfitpiecewiselinearrdp</a><br>
<a href='#sub_lstfitpiecewiselinearrdpfixed' class=toc>lstfitpiecewiselinearrdpfixed</a><br>
<a href='#sub_polynomialfit' class=toc>polynomialfit</a><br>
<a href='#sub_polynomialfitwc' class=toc>polynomialfitwc</a><br>
<a href='#sub_spline1dfitcubic' class=toc>spline1dfitcubic</a><br>
<a href='#sub_spline1dfitcubicwc' class=toc>spline1dfitcubicwc</a><br>
<a href='#sub_spline1dfithermite' class=toc>spline1dfithermite</a><br>
<a href='#sub_spline1dfithermitewc' class=toc>spline1dfithermitewc</a><br>
<a href='#sub_spline1dfitpenalized' class=toc>spline1dfitpenalized</a><br>
<a href='#sub_spline1dfitpenalizedw' class=toc>spline1dfitpenalizedw</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_lsfit_d_lin' class=toc>lsfit_d_lin</a></td><td width=15>&nbsp;</td><td>Unconstrained (general) linear least squares fitting with and without weights</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_linc' class=toc>lsfit_d_linc</a></td><td width=15>&nbsp;</td><td>Constrained (general) linear least squares fitting with and without weights</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_nlf' class=toc>lsfit_d_nlf</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting using function value only</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_nlfb' class=toc>lsfit_d_nlfb</a></td><td width=15>&nbsp;</td><td>Bound contstrained nonlinear fitting using function value only</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_nlfg' class=toc>lsfit_d_nlfg</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting using gradient</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_nlfgh' class=toc>lsfit_d_nlfgh</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting using gradient and Hessian</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_nlscale' class=toc>lsfit_d_nlscale</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting with custom scaling and bound constraints</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_pol' class=toc>lsfit_d_pol</a></td><td width=15>&nbsp;</td><td>Unconstrained polynomial fitting</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_polc' class=toc>lsfit_d_polc</a></td><td width=15>&nbsp;</td><td>Constrained polynomial fitting</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_spline' class=toc>lsfit_d_spline</a></td><td width=15>&nbsp;</td><td>Unconstrained fitting by penalized regression spline</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_t_4pl' class=toc>lsfit_t_4pl</a></td><td width=15>&nbsp;</td><td>4-parameter logistic fitting</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_t_5pl' class=toc>lsfit_t_5pl</a></td><td width=15>&nbsp;</td><td>5-parameter logistic fitting</td></tr>
</table></div>
<a name='struct_barycentricfitreport'></a><h3 class=pageheader><code>barycentricfitreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Barycentric fitting report:
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error
    TaskRCond       reciprocal of task's condition number
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class barycentricfitreport
{
    <font color=navy>public</font> <font color=navy>double</font>               taskrcond;
    <font color=navy>public</font> <font color=navy>int</font>                  dbest;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>double</font>               maxerror;
}

</div></pre>
<a name='struct_lsfitreport'></a><h3 class=pageheader><code>lsfitreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting report. This structure contains informational fields
which are set by fitting functions provided by this unit.

Different functions initialize different sets of  fields,  so  you  should
read documentation on specific function you used in order  to  know  which
fields are initialized.

    TaskRCond       reciprocal of task's condition number
    IterationsCount number of internal iterations

    VarIdx          if user-supplied gradient contains errors  which  were
                    detected by nonlinear fitter, this  field  is  set  to
                    index  of  the  first  component  of gradient which is
                    suspected to be spoiled by bugs.

    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error

    WRMSError       weighted RMS error

    CovPar          covariance matrix for parameters, filled by some solvers
    ErrPar          vector of errors in parameters, filled by some solvers
    ErrCurve        vector of fit errors -  variability  of  the  best-fit
                    curve, filled by some solvers.
    Noise           vector of per-point noise estimates, filled by
                    some solvers.
    R2              coefficient of determination (non-weighted, non-adjusted),
                    filled by some solvers.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class lsfitreport
{
    <font color=navy>public</font> <font color=navy>double</font>               taskrcond;
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>double</font>               maxerror;
    <font color=navy>public</font> <font color=navy>double</font>               wrmserror;
    <font color=navy>public</font> <font color=navy>double</font>[,]            covpar;
    <font color=navy>public</font> <font color=navy>double</font>[]             errpar;
    <font color=navy>public</font> <font color=navy>double</font>[]             errcurve;
    <font color=navy>public</font> <font color=navy>double</font>[]             noise;
    <font color=navy>public</font> <font color=navy>double</font>               r2;
}

</div></pre>
<a name='struct_lsfitstate'></a><h3 class=pageheader><code>lsfitstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear fitter.

You should use ALGLIB functions to work with fitter.
Never try to access its fields directly!
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class lsfitstate
{
}

</div></pre>
<a name='struct_polynomialfitreport'></a><h3 class=pageheader><code>polynomialfitreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Polynomial fitting report:
    TaskRCond       reciprocal of task's condition number
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class polynomialfitreport
{
    <font color=navy>public</font> <font color=navy>double</font>               taskrcond;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>double</font>               maxerror;
}

</div></pre>
<a name='struct_spline1dfitreport'></a><h3 class=pageheader><code>spline1dfitreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Spline fitting report:
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error

Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
    TaskRCond       reciprocal of task's condition number
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class spline1dfitreport
{
    <font color=navy>public</font> <font color=navy>double</font>               taskrcond;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>double</font>               maxerror;
}

</div></pre>
<a name='sub_barycentricfitfloaterhormann'></a><h3 class=pageheader><code>barycentricfitfloaterhormann</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational least squares fitting using  Floater-Hormann  rational  functions
with optimal D chosen from [0,9].

Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
functions. Different values of D are tried, optimal  D  (least  root  mean
square error) is chosen.  Task  is  linear, so linear least squares solver
is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
dominated by the least squares solver).

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    N   -   number of points, N&gt;0.
    M   -   number of basis functions ( = number_of_nodes), M&gt;=2.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
    B   -   barycentric interpolant.
    Rep -   report, same format as in LSFitLinearWC() subroutine.
            Following fields are set:
            * DBest         best value of the D parameter
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricfitfloaterhormann(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant b,
    <font color=navy>out</font> barycentricfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_barycentricfitfloaterhormann(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant b,
    <font color=navy>out</font> barycentricfitreport rep)

</div></pre>
<a name='sub_barycentricfitfloaterhormannwc'></a><h3 class=pageheader><code>barycentricfitfloaterhormannwc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weghted rational least  squares  fitting  using  Floater-Hormann  rational
functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
individual weights.

Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
functions. Different values of D are tried, optimal D (least WEIGHTED root
mean square error) is chosen.  Task  is  linear,  so  linear least squares
solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
(mostly dominated by the least squares solver).

SEE ALSO
* BarycentricFitFloaterHormann(), &quot;lightweight&quot; fitting without invididual
  weights and constraints.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points, N&gt;0.
    XC  -   points where function values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that S(XC[i])=YC[i]
            * DC[i]=1   means that S'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints, 0&lt;=K&lt;M.
            K=0 means no constraints (XC/YC/DC are not used in such cases)
    M   -   number of basis functions ( = number_of_nodes), M&gt;=2.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
                        -1 means another errors in parameters passed
                           (N&lt;=0, for example)
    B   -   barycentric interpolant.
    Rep -   report, same format as in LSFitLinearWC() subroutine.
            Following fields are set:
            * DBest         best value of the D parameter
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroutine doesn't calculate task's condition number for K&lt;&gt;0.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained barycentric interpolants:
* excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
  functions aren't as flexible as splines (although they are very smooth).
* the more evenly constraints are spread across [min(x),max(x)],  the more
  chances that they will be consistent
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints IS NOT GUARANTEED.
* in the several special cases, however, we CAN guarantee consistency.
* one of this cases is constraints on the function  VALUES at the interval
  boundaries. Note that consustency of the  constraints  on  the  function
  DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
  which are more flexible).
* another  special  case  is ONE constraint on the function value (OR, but
  not AND, derivative) anywhere in the interval

Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricfitfloaterhormannwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant b,
    <font color=navy>out</font> barycentricfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_barycentricfitfloaterhormannwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant b,
    <font color=navy>out</font> barycentricfitreport rep)

</div></pre>
<a name='sub_logisticcalc4'></a><h3 class=pageheader><code>logisticcalc4</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates value of four-parameter logistic (4PL)  model  at
specified point X. 4PL model has following form:

    F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

INPUT PARAMETERS:
    X       -   current point, X&gt;=0:
                * zero X is correctly handled even for B&lt;=0
                * negative X results in exception.
    A, B, C, D- parameters of 4PL model:
                * A is unconstrained
                * B is unconstrained; zero or negative values are handled
                  correctly.
                * C&gt;0, non-positive value results in exception
                * D is unconstrained

RESULT:
    model value at X

NOTE: if B=0, denominator is assumed to be equal to 2.0 even  for  zero  X
      (strictly speaking, 0^0 is undefined).

NOTE: this function also throws exception  if  all  input  parameters  are
      correct, but overflow was detected during calculations.

NOTE: this function performs a lot of checks;  if  you  need  really  high
      performance, consider evaluating model  yourself,  without  checking
      for degenerate cases.


  -- ALGLIB PROJECT --
     Copyright 14.05.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.logisticcalc4(
    <font color=navy>double</font> x,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font> c,
    <font color=navy>double</font> d)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_t_4pl' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_logisticcalc5'></a><h3 class=pageheader><code>logisticcalc5</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates value of five-parameter logistic (5PL)  model  at
specified point X. 5PL model has following form:

    F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

INPUT PARAMETERS:
    X       -   current point, X&gt;=0:
                * zero X is correctly handled even for B&lt;=0
                * negative X results in exception.
    A, B, C, D, G- parameters of 5PL model:
                * A is unconstrained
                * B is unconstrained; zero or negative values are handled
                  correctly.
                * C&gt;0, non-positive value results in exception
                * D is unconstrained
                * G&gt;0, non-positive value results in exception

RESULT:
    model value at X

NOTE: if B=0, denominator is assumed to be equal to Power(2.0,G) even  for
      zero X (strictly speaking, 0^0 is undefined).

NOTE: this function also throws exception  if  all  input  parameters  are
      correct, but overflow was detected during calculations.

NOTE: this function performs a lot of checks;  if  you  need  really  high
      performance, consider evaluating model  yourself,  without  checking
      for degenerate cases.


  -- ALGLIB PROJECT --
     Copyright 14.05.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.logisticcalc5(
    <font color=navy>double</font> x,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font> c,
    <font color=navy>double</font> d,
    <font color=navy>double</font> g)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_t_5pl' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_logisticfit4'></a><h3 class=pageheader><code>logisticfit4</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function fits four-parameter logistic (4PL) model  to  data  provided
by user. 4PL model has following form:

    F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

Here:
    * A, D - unconstrained (see LogisticFit4EC() for constrained 4PL)
    * B&gt;=0
    * C&gt;0

IMPORTANT: output of this function is constrained in  such  way that  B&gt;0.
           Because 4PL model is symmetric with respect to B, there  is  no
           need to explore  B&lt;0.  Constraining  B  makes  algorithm easier
           to stabilize and debug.
           Users  who  for  some  reason  prefer to work with negative B's
           should transform output themselves (swap A and D, replace B  by
           -B).

4PL fitting is implemented as follows:
* we perform small number of restarts from random locations which helps to
  solve problem of bad local extrema. Locations are only partially  random
  - we use input data to determine good  initial  guess,  but  we  include
  controlled amount of randomness.
* we perform Levenberg-Marquardt fitting with very  tight  constraints  on
  parameters B and C - it allows us to find good  initial  guess  for  the
  second stage without risk of running into &quot;flat spot&quot;.
* second  Levenberg-Marquardt  round  is   performed   without   excessive
  constraints. Results from the previous round are used as initial guess.
* after fitting is done, we compare results with best values found so far,
  rewrite &quot;best solution&quot; if needed, and move to next random location.

Overall algorithm is very stable and is not prone to  bad  local  extrema.
Furthermore, it automatically scales when input data have  very  large  or
very small range.

INPUT PARAMETERS:
    X       -   array[N], stores X-values.
                MUST include only non-negative numbers  (but  may  include
                zero values). Can be unsorted.
    Y       -   array[N], values to fit.
    N       -   number of points. If N is less than  length  of  X/Y, only
                leading N elements are used.

OUTPUT PARAMETERS:
    A, B, C, D- parameters of 4PL model
    Rep     -   fitting report. This structure has many fields,  but  ONLY
                ONES LISTED BELOW ARE SET:
                * Rep.IterationsCount - number of iterations performed
                * Rep.RMSError - root-mean-square error
                * Rep.AvgError - average absolute error
                * Rep.AvgRelError - average relative error (calculated for
                  non-zero Y-values)
                * Rep.MaxError - maximum absolute error
                * Rep.R2 - coefficient of determination,  R-squared.  This
                  coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                  of nonlinear  regression  there  are  multiple  ways  to
                  define R2, each of them giving different results).

NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
      LogisticCalc4() function.

NOTE: if you need better control over fitting process than provided by this
      function, you may use LogisticFit45X().

NOTE: step is automatically scaled according to scale of parameters  being
      fitted before we compare its length with EpsX. Thus,  this  function
      can be used to fit data with very small or very large values without
      changing EpsX.


  -- ALGLIB PROJECT --
     Copyright 14.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.logisticfit4(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font> a,
    <font color=navy>out</font> <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>double</font> c,
    <font color=navy>out</font> <font color=navy>double</font> d,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_t_4pl' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_logisticfit45x'></a><h3 class=pageheader><code>logisticfit45x</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is &quot;expert&quot; 4PL/5PL fitting function, which can be used if  you  need
better control over fitting process than provided  by  LogisticFit4()  or
LogisticFit5().

This function fits model of the form

    F(x|A,B,C,D)   = D+(A-D)/(1+Power(x/C,B))           (4PL model)

or

    F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)    (5PL model)

Here:
    * A, D - unconstrained
    * B&gt;=0 for 4PL, unconstrained for 5PL
    * C&gt;0
    * G&gt;0 (if present)

INPUT PARAMETERS:
    X       -   array[N], stores X-values.
                MUST include only non-negative numbers  (but  may  include
                zero values). Can be unsorted.
    Y       -   array[N], values to fit.
    N       -   number of points. If N is less than  length  of  X/Y, only
                leading N elements are used.
    CnstrLeft-  optional equality constraint for model value at the   left
                boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                not need constraint on the model value at X=0 (in C++  you
                can pass alglib::fp_nan as parameter, in  C#  it  will  be
                Double.NaN).
                See  below,  section  &quot;EQUALITY  CONSTRAINTS&quot;   for   more
                information about constraints.
    CnstrRight- optional equality constraint for model value at X=infinity.
                Specify NAN (Not-a-Number) if you do not  need  constraint
                on the model value (in C++  you can pass alglib::fp_nan as
                parameter, in  C# it will  be Double.NaN).
                See  below,  section  &quot;EQUALITY  CONSTRAINTS&quot;   for   more
                information about constraints.
    Is4PL   -   whether 4PL or 5PL models are fitted
    LambdaV -   regularization coefficient, LambdaV&gt;=0.
                Set it to zero unless you know what you are doing.
    EpsX    -   stopping condition (step size), EpsX&gt;=0.
                Zero value means that small step is automatically chosen.
                See notes below for more information.
    RsCnt   -   number of repeated restarts from  random  points.  4PL/5PL
                models are prone to problem of bad local extrema. Utilizing
                multiple random restarts allows  us  to  improve algorithm
                convergence.
                RsCnt&gt;=0.
                Zero value means that function automatically choose  small
                amount of restarts (recommended).

OUTPUT PARAMETERS:
    A, B, C, D- parameters of 4PL model
    G       -   parameter of 5PL model; for Is4PL=True, G=1 is returned.
    Rep     -   fitting report. This structure has many fields,  but  ONLY
                ONES LISTED BELOW ARE SET:
                * Rep.IterationsCount - number of iterations performed
                * Rep.RMSError - root-mean-square error
                * Rep.AvgError - average absolute error
                * Rep.AvgRelError - average relative error (calculated for
                  non-zero Y-values)
                * Rep.MaxError - maximum absolute error
                * Rep.R2 - coefficient of determination,  R-squared.  This
                  coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                  of nonlinear  regression  there  are  multiple  ways  to
                  define R2, each of them giving different results).

NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
      LogisticCalc5() function.

NOTE: step is automatically scaled according to scale of parameters  being
      fitted before we compare its length with EpsX. Thus,  this  function
      can be used to fit data with very small or very large values without
      changing EpsX.

EQUALITY CONSTRAINTS ON PARAMETERS

4PL/5PL solver supports equality constraints on model values at  the  left
boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
completely optional and you can specify both of them, only  one  -  or  no
constraints at all.

Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
D. That's because 4PL model is normalized in such way that B&gt;=0.

For 5PL model things are different. Unlike  4PL  one,  5PL  model  is  NOT
symmetric with respect to  change  in  sign  of  B. Thus, negative B's are
possible, and left constraint may constrain parameter A (for positive B's)
- or parameter D (for negative B's). Similarly changes  meaning  of  right
constraint.

You do not have to decide what parameter to  constrain  -  algorithm  will
automatically determine correct parameters as fitting progresses. However,
question highlighted above is important when you interpret fitting results.


  -- ALGLIB PROJECT --
     Copyright 14.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.logisticfit45x(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>double</font> cnstrleft,
    <font color=navy>double</font> cnstrright,
    <font color=navy>bool</font> is4pl,
    <font color=navy>double</font> lambdav,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> rscnt,
    <font color=navy>out</font> <font color=navy>double</font> a,
    <font color=navy>out</font> <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>double</font> c,
    <font color=navy>out</font> <font color=navy>double</font> d,
    <font color=navy>out</font> <font color=navy>double</font> g,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<a name='sub_logisticfit4ec'></a><h3 class=pageheader><code>logisticfit4ec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function fits four-parameter logistic (4PL) model  to  data  provided
by user, with optional constraints on parameters A and D.  4PL  model  has
following form:

    F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

Here:
    * A, D - with optional equality constraints
    * B&gt;=0
    * C&gt;0

IMPORTANT: output of this function is constrained in  such  way that  B&gt;0.
           Because 4PL model is symmetric with respect to B, there  is  no
           need to explore  B&lt;0.  Constraining  B  makes  algorithm easier
           to stabilize and debug.
           Users  who  for  some  reason  prefer to work with negative B's
           should transform output themselves (swap A and D, replace B  by
           -B).

4PL fitting is implemented as follows:
* we perform small number of restarts from random locations which helps to
  solve problem of bad local extrema. Locations are only partially  random
  - we use input data to determine good  initial  guess,  but  we  include
  controlled amount of randomness.
* we perform Levenberg-Marquardt fitting with very  tight  constraints  on
  parameters B and C - it allows us to find good  initial  guess  for  the
  second stage without risk of running into &quot;flat spot&quot;.
* second  Levenberg-Marquardt  round  is   performed   without   excessive
  constraints. Results from the previous round are used as initial guess.
* after fitting is done, we compare results with best values found so far,
  rewrite &quot;best solution&quot; if needed, and move to next random location.

Overall algorithm is very stable and is not prone to  bad  local  extrema.
Furthermore, it automatically scales when input data have  very  large  or
very small range.

INPUT PARAMETERS:
    X       -   array[N], stores X-values.
                MUST include only non-negative numbers  (but  may  include
                zero values). Can be unsorted.
    Y       -   array[N], values to fit.
    N       -   number of points. If N is less than  length  of  X/Y, only
                leading N elements are used.
    CnstrLeft-  optional equality constraint for model value at the   left
                boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                not need constraint on the model value at X=0 (in C++  you
                can pass alglib::fp_nan as parameter, in  C#  it  will  be
                Double.NaN).
                See  below,  section  &quot;EQUALITY  CONSTRAINTS&quot;   for   more
                information about constraints.
    CnstrRight- optional equality constraint for model value at X=infinity.
                Specify NAN (Not-a-Number) if you do not  need  constraint
                on the model value (in C++  you can pass alglib::fp_nan as
                parameter, in  C# it will  be Double.NaN).
                See  below,  section  &quot;EQUALITY  CONSTRAINTS&quot;   for   more
                information about constraints.

OUTPUT PARAMETERS:
    A, B, C, D- parameters of 4PL model
    Rep     -   fitting report. This structure has many fields,  but  ONLY
                ONES LISTED BELOW ARE SET:
                * Rep.IterationsCount - number of iterations performed
                * Rep.RMSError - root-mean-square error
                * Rep.AvgError - average absolute error
                * Rep.AvgRelError - average relative error (calculated for
                  non-zero Y-values)
                * Rep.MaxError - maximum absolute error
                * Rep.R2 - coefficient of determination,  R-squared.  This
                  coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                  of nonlinear  regression  there  are  multiple  ways  to
                  define R2, each of them giving different results).

NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
      LogisticCalc4() function.

NOTE: if you need better control over fitting process than provided by this
      function, you may use LogisticFit45X().

NOTE: step is automatically scaled according to scale of parameters  being
      fitted before we compare its length with EpsX. Thus,  this  function
      can be used to fit data with very small or very large values without
      changing EpsX.

EQUALITY CONSTRAINTS ON PARAMETERS

4PL/5PL solver supports equality constraints on model values at  the  left
boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
completely optional and you can specify both of them, only  one  -  or  no
constraints at all.

Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
D. That's because 4PL model is normalized in such way that B&gt;=0.


  -- ALGLIB PROJECT --
     Copyright 14.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.logisticfit4ec(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>double</font> cnstrleft,
    <font color=navy>double</font> cnstrright,
    <font color=navy>out</font> <font color=navy>double</font> a,
    <font color=navy>out</font> <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>double</font> c,
    <font color=navy>out</font> <font color=navy>double</font> d,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<a name='sub_logisticfit5'></a><h3 class=pageheader><code>logisticfit5</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function fits five-parameter logistic (5PL) model  to  data  provided
by user. 5PL model has following form:

    F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

Here:
    * A, D - unconstrained
    * B - unconstrained
    * C&gt;0
    * G&gt;0

IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
           constrained in  such  way that B is guaranteed to be  positive.
           Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
           respect to B, so you can NOT transform model to equivalent one,
           with B having desired sign (&gt;0 or &lt;0).

5PL fitting is implemented as follows:
* we perform small number of restarts from random locations which helps to
  solve problem of bad local extrema. Locations are only partially  random
  - we use input data to determine good  initial  guess,  but  we  include
  controlled amount of randomness.
* we perform Levenberg-Marquardt fitting with very  tight  constraints  on
  parameters B and C - it allows us to find good  initial  guess  for  the
  second stage without risk of running into &quot;flat spot&quot;.  Parameter  G  is
  fixed at G=1.
* second  Levenberg-Marquardt  round  is   performed   without   excessive
  constraints on B and C, but with G still equal to 1.  Results  from  the
  previous round are used as initial guess.
* third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
  different models - one with B&gt;0 and one with B&lt;0.
* after fitting is done, we compare results with best values found so far,
  rewrite &quot;best solution&quot; if needed, and move to next random location.

Overall algorithm is very stable and is not prone to  bad  local  extrema.
Furthermore, it automatically scales when input data have  very  large  or
very small range.

INPUT PARAMETERS:
    X       -   array[N], stores X-values.
                MUST include only non-negative numbers  (but  may  include
                zero values). Can be unsorted.
    Y       -   array[N], values to fit.
    N       -   number of points. If N is less than  length  of  X/Y, only
                leading N elements are used.

OUTPUT PARAMETERS:
    A,B,C,D,G-  parameters of 5PL model
    Rep     -   fitting report. This structure has many fields,  but  ONLY
                ONES LISTED BELOW ARE SET:
                * Rep.IterationsCount - number of iterations performed
                * Rep.RMSError - root-mean-square error
                * Rep.AvgError - average absolute error
                * Rep.AvgRelError - average relative error (calculated for
                  non-zero Y-values)
                * Rep.MaxError - maximum absolute error
                * Rep.R2 - coefficient of determination,  R-squared.  This
                  coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                  of nonlinear  regression  there  are  multiple  ways  to
                  define R2, each of them giving different results).

NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
      LogisticCalc5() function.

NOTE: if you need better control over fitting process than provided by this
      function, you may use LogisticFit45X().

NOTE: step is automatically scaled according to scale of parameters  being
      fitted before we compare its length with EpsX. Thus,  this  function
      can be used to fit data with very small or very large values without
      changing EpsX.


  -- ALGLIB PROJECT --
     Copyright 14.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.logisticfit5(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font> a,
    <font color=navy>out</font> <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>double</font> c,
    <font color=navy>out</font> <font color=navy>double</font> d,
    <font color=navy>out</font> <font color=navy>double</font> g,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_t_5pl' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_logisticfit5ec'></a><h3 class=pageheader><code>logisticfit5ec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function fits five-parameter logistic (5PL) model  to  data  provided
by user, subject to optional equality constraints on parameters A  and  D.
5PL model has following form:

    F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

Here:
    * A, D - with optional equality constraints
    * B - unconstrained
    * C&gt;0
    * G&gt;0

IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
           constrained in  such  way that B is guaranteed to be  positive.
           Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
           respect to B, so you can NOT transform model to equivalent one,
           with B having desired sign (&gt;0 or &lt;0).

5PL fitting is implemented as follows:
* we perform small number of restarts from random locations which helps to
  solve problem of bad local extrema. Locations are only partially  random
  - we use input data to determine good  initial  guess,  but  we  include
  controlled amount of randomness.
* we perform Levenberg-Marquardt fitting with very  tight  constraints  on
  parameters B and C - it allows us to find good  initial  guess  for  the
  second stage without risk of running into &quot;flat spot&quot;.  Parameter  G  is
  fixed at G=1.
* second  Levenberg-Marquardt  round  is   performed   without   excessive
  constraints on B and C, but with G still equal to 1.  Results  from  the
  previous round are used as initial guess.
* third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
  different models - one with B&gt;0 and one with B&lt;0.
* after fitting is done, we compare results with best values found so far,
  rewrite &quot;best solution&quot; if needed, and move to next random location.

Overall algorithm is very stable and is not prone to  bad  local  extrema.
Furthermore, it automatically scales when input data have  very  large  or
very small range.

INPUT PARAMETERS:
    X       -   array[N], stores X-values.
                MUST include only non-negative numbers  (but  may  include
                zero values). Can be unsorted.
    Y       -   array[N], values to fit.
    N       -   number of points. If N is less than  length  of  X/Y, only
                leading N elements are used.
    CnstrLeft-  optional equality constraint for model value at the   left
                boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                not need constraint on the model value at X=0 (in C++  you
                can pass alglib::fp_nan as parameter, in  C#  it  will  be
                Double.NaN).
                See  below,  section  &quot;EQUALITY  CONSTRAINTS&quot;   for   more
                information about constraints.
    CnstrRight- optional equality constraint for model value at X=infinity.
                Specify NAN (Not-a-Number) if you do not  need  constraint
                on the model value (in C++  you can pass alglib::fp_nan as
                parameter, in  C# it will  be Double.NaN).
                See  below,  section  &quot;EQUALITY  CONSTRAINTS&quot;   for   more
                information about constraints.

OUTPUT PARAMETERS:
    A,B,C,D,G-  parameters of 5PL model
    Rep     -   fitting report. This structure has many fields,  but  ONLY
                ONES LISTED BELOW ARE SET:
                * Rep.IterationsCount - number of iterations performed
                * Rep.RMSError - root-mean-square error
                * Rep.AvgError - average absolute error
                * Rep.AvgRelError - average relative error (calculated for
                  non-zero Y-values)
                * Rep.MaxError - maximum absolute error
                * Rep.R2 - coefficient of determination,  R-squared.  This
                  coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                  of nonlinear  regression  there  are  multiple  ways  to
                  define R2, each of them giving different results).

NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
      LogisticCalc5() function.

NOTE: if you need better control over fitting process than provided by this
      function, you may use LogisticFit45X().

NOTE: step is automatically scaled according to scale of parameters  being
      fitted before we compare its length with EpsX. Thus,  this  function
      can be used to fit data with very small or very large values without
      changing EpsX.

EQUALITY CONSTRAINTS ON PARAMETERS

5PL solver supports equality constraints on model  values  at   the   left
boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
completely optional and you can specify both of them, only  one  -  or  no
constraints at all.

Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
fitting), and CnstrRight contains right  one.

Unlike 4PL one, 5PL model is NOT symmetric with respect to  change in sign
of B. Thus, negative B's are possible, and left constraint  may  constrain
parameter A (for positive B's)  -  or  parameter  D  (for  negative  B's).
Similarly changes meaning of right constraint.

You do not have to decide what parameter to  constrain  -  algorithm  will
automatically determine correct parameters as fitting progresses. However,
question highlighted above is important when you interpret fitting results.


  -- ALGLIB PROJECT --
     Copyright 14.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.logisticfit5ec(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>double</font> cnstrleft,
    <font color=navy>double</font> cnstrright,
    <font color=navy>out</font> <font color=navy>double</font> a,
    <font color=navy>out</font> <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>double</font> c,
    <font color=navy>out</font> <font color=navy>double</font> d,
    <font color=navy>out</font> <font color=navy>double</font> g,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<a name='sub_lsfitcreatef'></a><h3 class=pageheader><code>lsfitcreatef</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting using function values only.

Combination of numerical differentiation and secant updates is used to
obtain function Jacobian.

Nonlinear task min(F(c)) is solved, where

    F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * w is an N-dimensional vector of weight coefficients,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses only f(c,x[i]).

INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted
    DiffStep-   numerical differentiation step;
                should not be very small or large;
                large = loss of accuracy
                small = growth of round-off errors

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 18.10.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatef(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] c,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> lsfitstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatef(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> lsfitstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlf' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfb' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlscale' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatefg'></a><h3 class=pageheader><code>lsfitcreatefg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting using gradient only, without individual
weights.

Nonlinear task min(F(c)) is solved, where

    F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses only f(c,x[i]) and its gradient.

INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted
    CheapFG -   boolean flag, which is:
                * True  if both function and gradient calculation complexity
                        are less than O(M^2).  An improved  algorithm  can
                        be  used  which corresponds  to  FGJ  scheme  from
                        MINLM unit.
                * False otherwise.
                        Standard Jacibian-bases  Levenberg-Marquardt  algo
                        will be used (FJ scheme).

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatefg(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] c,
    <font color=navy>bool</font> cheapfg,
    <font color=navy>out</font> lsfitstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatefg(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>bool</font> cheapfg,
    <font color=navy>out</font> lsfitstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlfg' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatefgh'></a><h3 class=pageheader><code>lsfitcreatefgh</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting using gradient/Hessian, without individial
weights.

Nonlinear task min(F(c)) is solved, where

    F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses f(c,x[i]), its gradient and its Hessian.

INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatefgh(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatefgh(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>out</font> lsfitstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlfgh' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatewf'></a><h3 class=pageheader><code>lsfitcreatewf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted nonlinear least squares fitting using function values only.

Combination of numerical differentiation and secant updates is used to
obtain function Jacobian.

Nonlinear task min(F(c)) is solved, where

    F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * w is an N-dimensional vector of weight coefficients,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses only f(c,x[i]).

INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    W       -   weights, array[0..N-1]
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted
    DiffStep-   numerical differentiation step;
                should not be very small or large;
                large = loss of accuracy
                small = growth of round-off errors

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 18.10.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatewf(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] c,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> lsfitstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatewf(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> lsfitstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlf' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfb' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatewfg'></a><h3 class=pageheader><code>lsfitcreatewfg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted nonlinear least squares fitting using gradient only.

Nonlinear task min(F(c)) is solved, where

    F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * w is an N-dimensional vector of weight coefficients,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses only f(c,x[i]) and its gradient.

INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    W       -   weights, array[0..N-1]
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted
    CheapFG -   boolean flag, which is:
                * True  if both function and gradient calculation complexity
                        are less than O(M^2).  An improved  algorithm  can
                        be  used  which corresponds  to  FGJ  scheme  from
                        MINLM unit.
                * False otherwise.
                        Standard Jacibian-bases  Levenberg-Marquardt  algo
                        will be used (FJ scheme).

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

See also:
    LSFitResults
    LSFitCreateFG (fitting without weights)
    LSFitCreateWFGH (fitting using Hessian)
    LSFitCreateFGH (fitting using Hessian, without weights)

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatewfg(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] c,
    <font color=navy>bool</font> cheapfg,
    <font color=navy>out</font> lsfitstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatewfg(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>bool</font> cheapfg,
    <font color=navy>out</font> lsfitstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlfg' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatewfgh'></a><h3 class=pageheader><code>lsfitcreatewfgh</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted nonlinear least squares fitting using gradient/Hessian.

Nonlinear task min(F(c)) is solved, where

    F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * w is an N-dimensional vector of weight coefficients,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses f(c,x[i]), its gradient and its Hessian.

INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    W       -   weights, array[0..N-1]
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatewfgh(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitcreatewfgh(
    <font color=navy>double</font>[,] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] c,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>out</font> lsfitstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlfgh' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitfit'></a><h3 class=pageheader><code>lsfitfit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear fitter

These functions accept following parameters:
    state   -   algorithm state
    func    -   callback which calculates function (or merit function)
                value func at given point x
    grad    -   callback which calculates function (or merit function)
                value func and gradient grad at given point x
    hess    -   callback which calculates function (or merit function)
                value func, gradient grad and Hessian hess at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL

NOTES:

1. this algorithm is somewhat unusual because it works with  parameterized
   function f(C,X), where X is a function argument (we  have  many  points
   which are characterized by different  argument  values),  and  C  is  a
   parameter to fit.

   For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
   x will be argument, and {c0,c1} will be parameters.

   It is important to understand that this algorithm finds minimum in  the
   space of function PARAMETERS (not arguments), so it  needs  derivatives
   of f() with respect to C, not X.

   In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
   instead of {df/dx} = {c0}.

2. Callback functions accept C as the first parameter, and X as the second

3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
   function   and   its   gradient,   but   if   state   was  created with
   LSFitCreateFGH(), algorithm will need function, gradient and Hessian.

   According  to  the  said  above,  there  ase  several  versions of this
   function, which accept different sets of callbacks.

   This flexibility opens way to subtle errors - you may create state with
   LSFitCreateFGH() (optimization using Hessian), but call function  which
   does not accept Hessian. So when algorithm will request Hessian,  there
   will be no callback to call. In this case exception will be thrown.

   Be careful to avoid such errors because there is no way to find them at
   compile time - you can see them at runtime only.

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_phess hess, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlf' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfg' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfb' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlscale' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinear'></a><h3 class=pageheader><code>lsfitlinear</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Linear least squares fitting.

QR decomposition is used to reduce task to MxM, then triangular solver  or
SVD-based solver is used depending on condition number of the  system.  It
allows to maximize speed and retain decent accuracy.

IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
           convenient to use PolynomialFit() function. This function gives
           best  results  on  polynomial  problems  and  solves  numerical
           stability  issues  which  arise  when   you   fit   high-degree
           polynomials to your data.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    Y       -   array[0..N-1] Function values in  N  points.
    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                FMatrix[I, J] - value of J-th basis function in I-th point.
    N       -   number of points used. N&gt;=1.
    M       -   number of basis functions, M&gt;=1.

OUTPUT PARAMETERS:
    Info    -   error code:
                * -4    internal SVD decomposition subroutine failed (very
                        rare and for degenerate systems only)
                *  1    task is solved
    C       -   decomposition coefficients, array[0..M-1]
    Rep     -   fitting report. Following fields are set:
                * Rep.TaskRCond     reciprocal of condition number
                * R2                non-adjusted coefficient of determination
                                    (non-weighted)
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

ERRORS IN PARAMETERS

This  solver  also  calculates different kinds of errors in parameters and
fills corresponding fields of report:
* Rep.CovPar        covariance matrix for parameters, array[K,K].
* Rep.ErrPar        errors in parameters, array[K],
                    errpar = sqrt(diag(CovPar))
* Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                    best-fit curve from &quot;ideal&quot; best-fit curve built  with
                    infinite number of samples, array[N].
                    errcurve = sqrt(diag(F*CovPar*F')),
                    where F is functions matrix.
* Rep.Noise         vector of per-point estimates of noise, array[N]

NOTE:       noise in the data is estimated as follows:
            * for fitting without user-supplied  weights  all  points  are
              assumed to have same level of noise, which is estimated from
              the data
            * for fitting with user-supplied weights we assume that  noise
              level in I-th point is inversely proportional to Ith weight.
              Coefficient of proportionality is estimated from the data.

NOTE:       we apply small amount of regularization when we invert squared
            Jacobian and calculate covariance matrix. It  guarantees  that
            algorithm won't divide by zero  during  inversion,  but  skews
            error estimates a bit (fractional error is about 10^-9).

            However, we believe that this difference is insignificant  for
            all practical purposes except for the situation when you  want
            to compare ALGLIB results with &quot;reference&quot;  implementation  up
            to the last significant digit.

NOTE:       covariance matrix is estimated using  correction  for  degrees
            of freedom (covariances are divided by N-M instead of dividing
            by N).

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinear(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinear(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinear(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinear(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_lin' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearc'></a><h3 class=pageheader><code>lsfitlinearc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Constained linear least squares fitting.

This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
that  K  additional  constaints  C*x=bc are satisfied. It reduces original
task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
is called.

IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
           convenient to use PolynomialFit() function. This function gives
           best  results  on  polynomial  problems  and  solves  numerical
           stability  issues  which  arise  when   you   fit   high-degree
           polynomials to your data.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    Y       -   array[0..N-1] Function values in  N  points.
    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                FMatrix[I,J] - value of J-th basis function in I-th point.
    CMatrix -   a table of constaints, array[0..K-1,0..M].
                I-th row of CMatrix corresponds to I-th linear constraint:
                CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
    N       -   number of points used. N&gt;=1.
    M       -   number of basis functions, M&gt;=1.
    K       -   number of constraints, 0 &lt;= K &lt; M
                K=0 corresponds to absence of constraints.

OUTPUT PARAMETERS:
    Info    -   error code:
                * -4    internal SVD decomposition subroutine failed (very
                        rare and for degenerate systems only)
                * -3    either   too   many  constraints  (M   or   more),
                        degenerate  constraints   (some   constraints  are
                        repetead twice) or inconsistent  constraints  were
                        specified.
                *  1    task is solved
    C       -   decomposition coefficients, array[0..M-1]
    Rep     -   fitting report. Following fields are set:
                * R2                non-adjusted coefficient of determination
                                    (non-weighted)
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

ERRORS IN PARAMETERS

This  solver  also  calculates different kinds of errors in parameters and
fills corresponding fields of report:
* Rep.CovPar        covariance matrix for parameters, array[K,K].
* Rep.ErrPar        errors in parameters, array[K],
                    errpar = sqrt(diag(CovPar))
* Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                    best-fit curve from &quot;ideal&quot; best-fit curve built  with
                    infinite number of samples, array[N].
                    errcurve = sqrt(diag(F*CovPar*F')),
                    where F is functions matrix.
* Rep.Noise         vector of per-point estimates of noise, array[N]

IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
            account boundary/linear constraints! Presence  of  constraints
            changes distribution of errors, but there is no  easy  way  to
            account for constraints when you calculate covariance matrix.

NOTE:       noise in the data is estimated as follows:
            * for fitting without user-supplied  weights  all  points  are
              assumed to have same level of noise, which is estimated from
              the data
            * for fitting with user-supplied weights we assume that  noise
              level in I-th point is inversely proportional to Ith weight.
              Coefficient of proportionality is estimated from the data.

NOTE:       we apply small amount of regularization when we invert squared
            Jacobian and calculate covariance matrix. It  guarantees  that
            algorithm won't divide by zero  during  inversion,  but  skews
            error estimates a bit (fractional error is about 10^-9).

            However, we believe that this difference is insignificant  for
            all practical purposes except for the situation when you  want
            to compare ALGLIB results with &quot;reference&quot;  implementation  up
            to the last significant digit.

NOTE:       covariance matrix is estimated using  correction  for  degrees
            of freedom (covariances are divided by N-M instead of dividing
            by N).

  -- ALGLIB --
     Copyright 07.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinearc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinearc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinearc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinearc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_linc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearw'></a><h3 class=pageheader><code>lsfitlinearw</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted linear least squares fitting.

QR decomposition is used to reduce task to MxM, then triangular solver  or
SVD-based solver is used depending on condition number of the  system.  It
allows to maximize speed and retain decent accuracy.

IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
           convenient to use PolynomialFit() function. This function gives
           best  results  on  polynomial  problems  and  solves  numerical
           stability  issues  which  arise  when   you   fit   high-degree
           polynomials to your data.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    Y       -   array[0..N-1] Function values in  N  points.
    W       -   array[0..N-1]  Weights  corresponding to function  values.
                Each summand in square  sum  of  approximation  deviations
                from  given  values  is  multiplied  by  the   square   of
                corresponding weight.
    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                FMatrix[I, J] - value of J-th basis function in I-th point.
    N       -   number of points used. N&gt;=1.
    M       -   number of basis functions, M&gt;=1.

OUTPUT PARAMETERS:
    Info    -   error code:
                * -4    internal SVD decomposition subroutine failed (very
                        rare and for degenerate systems only)
                * -1    incorrect N/M were specified
                *  1    task is solved
    C       -   decomposition coefficients, array[0..M-1]
    Rep     -   fitting report. Following fields are set:
                * Rep.TaskRCond     reciprocal of condition number
                * R2                non-adjusted coefficient of determination
                                    (non-weighted)
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

ERRORS IN PARAMETERS

This  solver  also  calculates different kinds of errors in parameters and
fills corresponding fields of report:
* Rep.CovPar        covariance matrix for parameters, array[K,K].
* Rep.ErrPar        errors in parameters, array[K],
                    errpar = sqrt(diag(CovPar))
* Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                    best-fit curve from &quot;ideal&quot; best-fit curve built  with
                    infinite number of samples, array[N].
                    errcurve = sqrt(diag(F*CovPar*F')),
                    where F is functions matrix.
* Rep.Noise         vector of per-point estimates of noise, array[N]

NOTE:       noise in the data is estimated as follows:
            * for fitting without user-supplied  weights  all  points  are
              assumed to have same level of noise, which is estimated from
              the data
            * for fitting with user-supplied weights we assume that  noise
              level in I-th point is inversely proportional to Ith weight.
              Coefficient of proportionality is estimated from the data.

NOTE:       we apply small amount of regularization when we invert squared
            Jacobian and calculate covariance matrix. It  guarantees  that
            algorithm won't divide by zero  during  inversion,  but  skews
            error estimates a bit (fractional error is about 10^-9).

            However, we believe that this difference is insignificant  for
            all practical purposes except for the situation when you  want
            to compare ALGLIB results with &quot;reference&quot;  implementation  up
            to the last significant digit.

NOTE:       covariance matrix is estimated using  correction  for  degrees
            of freedom (covariances are divided by N-M instead of dividing
            by N).

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinearw(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinearw(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinearw(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinearw(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_lin' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearwc'></a><h3 class=pageheader><code>lsfitlinearwc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted constained linear least squares fitting.

This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
that  K  additional  constaints  C*x=bc are satisfied. It reduces original
task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
is called.

IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
           convenient to use PolynomialFit() function. This function gives
           best  results  on  polynomial  problems  and  solves  numerical
           stability  issues  which  arise  when   you   fit   high-degree
           polynomials to your data.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    Y       -   array[0..N-1] Function values in  N  points.
    W       -   array[0..N-1]  Weights  corresponding to function  values.
                Each summand in square  sum  of  approximation  deviations
                from  given  values  is  multiplied  by  the   square   of
                corresponding weight.
    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                FMatrix[I,J] - value of J-th basis function in I-th point.
    CMatrix -   a table of constaints, array[0..K-1,0..M].
                I-th row of CMatrix corresponds to I-th linear constraint:
                CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
    N       -   number of points used. N&gt;=1.
    M       -   number of basis functions, M&gt;=1.
    K       -   number of constraints, 0 &lt;= K &lt; M
                K=0 corresponds to absence of constraints.

OUTPUT PARAMETERS:
    Info    -   error code:
                * -4    internal SVD decomposition subroutine failed (very
                        rare and for degenerate systems only)
                * -3    either   too   many  constraints  (M   or   more),
                        degenerate  constraints   (some   constraints  are
                        repetead twice) or inconsistent  constraints  were
                        specified.
                *  1    task is solved
    C       -   decomposition coefficients, array[0..M-1]
    Rep     -   fitting report. Following fields are set:
                * R2                non-adjusted coefficient of determination
                                    (non-weighted)
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

ERRORS IN PARAMETERS

This  solver  also  calculates different kinds of errors in parameters and
fills corresponding fields of report:
* Rep.CovPar        covariance matrix for parameters, array[K,K].
* Rep.ErrPar        errors in parameters, array[K],
                    errpar = sqrt(diag(CovPar))
* Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                    best-fit curve from &quot;ideal&quot; best-fit curve built  with
                    infinite number of samples, array[N].
                    errcurve = sqrt(diag(F*CovPar*F')),
                    where F is functions matrix.
* Rep.Noise         vector of per-point estimates of noise, array[N]

IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
            account boundary/linear constraints! Presence  of  constraints
            changes distribution of errors, but there is no  easy  way  to
            account for constraints when you calculate covariance matrix.

NOTE:       noise in the data is estimated as follows:
            * for fitting without user-supplied  weights  all  points  are
              assumed to have same level of noise, which is estimated from
              the data
            * for fitting with user-supplied weights we assume that  noise
              level in I-th point is inversely proportional to Ith weight.
              Coefficient of proportionality is estimated from the data.

NOTE:       we apply small amount of regularization when we invert squared
            Jacobian and calculate covariance matrix. It  guarantees  that
            algorithm won't divide by zero  during  inversion,  but  skews
            error estimates a bit (fractional error is about 10^-9).

            However, we believe that this difference is insignificant  for
            all practical purposes except for the situation when you  want
            to compare ALGLIB results with &quot;reference&quot;  implementation  up
            to the last significant digit.

NOTE:       covariance matrix is estimated using  correction  for  degrees
            of freedom (covariances are divided by N-M instead of dividing
            by N).

  -- ALGLIB --
     Copyright 07.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinearwc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitlinearwc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinearwc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_lsfitlinearwc(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[,] fmatrix,
    <font color=navy>double</font>[,] cmatrix,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_linc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitresults'></a><h3 class=pageheader><code>lsfitresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting results.

Called after return from LSFitFit().

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    Info    -   completion code:
                    * -7    gradient verification failed.
                            See LSFitSetGradientCheck() for more information.
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
    C       -   array[0..K-1], solution
    Rep     -   optimization report. On success following fields are set:
                * R2                non-adjusted coefficient of determination
                                    (non-weighted)
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED
                * WRMSError         weighted rms error on the (X,Y).

ERRORS IN PARAMETERS

This  solver  also  calculates different kinds of errors in parameters and
fills corresponding fields of report:
* Rep.CovPar        covariance matrix for parameters, array[K,K].
* Rep.ErrPar        errors in parameters, array[K],
                    errpar = sqrt(diag(CovPar))
* Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                    best-fit curve from &quot;ideal&quot; best-fit curve built  with
                    infinite number of samples, array[N].
                    errcurve = sqrt(diag(J*CovPar*J')),
                    where J is Jacobian matrix.
* Rep.Noise         vector of per-point estimates of noise, array[N]

IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
            account boundary/linear constraints! Presence  of  constraints
            changes distribution of errors, but there is no  easy  way  to
            account for constraints when you calculate covariance matrix.

NOTE:       noise in the data is estimated as follows:
            * for fitting without user-supplied  weights  all  points  are
              assumed to have same level of noise, which is estimated from
              the data
            * for fitting with user-supplied weights we assume that  noise
              level in I-th point is inversely proportional to Ith weight.
              Coefficient of proportionality is estimated from the data.

NOTE:       we apply small amount of regularization when we invert squared
            Jacobian and calculate covariance matrix. It  guarantees  that
            algorithm won't divide by zero  during  inversion,  but  skews
            error estimates a bit (fractional error is about 10^-9).

            However, we believe that this difference is insignificant  for
            all practical purposes except for the situation when you  want
            to compare ALGLIB results with &quot;reference&quot;  implementation  up
            to the last significant digit.

NOTE:       covariance matrix is estimated using  correction  for  degrees
            of freedom (covariances are divided by N-M instead of dividing
            by N).

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitresults(
    lsfitstate state,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] c,
    <font color=navy>out</font> lsfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlf' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfg' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfb' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlscale' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitsetbc'></a><h3 class=pageheader><code>lsfitsetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets boundary constraints for underlying optimizer

Boundary constraints are inactive by default (after initial creation).
They are preserved until explicitly turned off with another SetBC() call.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    BndL    -   lower bounds, array[K].
                If some (all) variables are unbounded, you may specify
                very small number or -INF (latter is recommended because
                it will allow solver to use better algorithm).
    BndU    -   upper bounds, array[K].
                If some (all) variables are unbounded, you may specify
                very large number or +INF (latter is recommended because
                it will allow solver to use better algorithm).

NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
variable will be &quot;frozen&quot; at X[i]=BndL[i]=BndU[i].

NOTE 2: unlike other constrained optimization algorithms, this solver  has
following useful properties:
* bound constraints are always satisfied exactly
* function is evaluated only INSIDE area specified by bound constraints

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitsetbc(
    lsfitstate state,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<a name='sub_lsfitsetcond'></a><h3 class=pageheader><code>lsfitsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Stopping conditions for nonlinear least squares fitting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsF    -   stopping criterion. Algorithm stops if
                |F(k+1)-F(k)| &lt;= EpsF*max{|F(k)|, |F(k+1)|, 1}
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |v|&lt;=EpsX is fulfilled, where:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - ste pvector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by LSFitSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations   is    unlimited.   Only   Levenberg-Marquardt
                iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
                counted because their cost is very low compared to that of
                LM).

NOTE

Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
stopping criterion selection (according to the scheme used by MINLM unit).


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitsetcond(
    lsfitstate state,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlf' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfg' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlfb' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_nlscale' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitsetgradientcheck'></a><h3 class=pageheader><code>lsfitsetgradientcheck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  turns  on  verification  of  the  user-supplied analytic
gradient:
* user calls this subroutine before fitting begins
* LSFitFit() is called
* prior to actual fitting, for  each  point  in  data  set  X_i  and  each
  component  of  parameters  being  fited C_j algorithm performs following
  steps:
  * two trial steps are made to C_j-TestStep*S[j] and C_j+TestStep*S[j],
    where C_j is j-th parameter and S[j] is a scale of j-th parameter
  * if needed, steps are bounded with respect to constraints on C[]
  * F(X_i|C) is evaluated at these trial points
  * we perform one more evaluation in the middle point of the interval
  * we  build  cubic  model using function values and derivatives at trial
    points and we compare its prediction with actual value in  the  middle
    point
  * in case difference between prediction and actual value is higher  than
    some predetermined threshold, algorithm stops with completion code -7;
    Rep.VarIdx is set to index of the parameter with incorrect derivative.
* after verification is over, algorithm proceeds to the actual optimization.

NOTE 1: verification needs N*K (points count * parameters count)  gradient
        evaluations. It is very costly and you should use it only for  low
        dimensional  problems,  when  you  want  to  be  sure  that you've
        correctly calculated analytic derivatives. You should not  use  it
        in the production code  (unless  you  want  to  check  derivatives
        provided by some third party).

NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
        (so large that function behaviour is significantly non-cubic) will
        lead to false alarms. You may use  different  step  for  different
        parameters by means of setting scale with LSFitSetScale().

NOTE 3: this function may lead to false positives. In case it reports that
        I-th  derivative was calculated incorrectly, you may decrease test
        step  and  try  one  more  time  - maybe your function changes too
        sharply  and  your  step  is  too  large for such rapidly chanding
        function.

NOTE 4: this function works only for optimizers created with LSFitCreateWFG()
        or LSFitCreateFG() constructors.

INPUT PARAMETERS:
    State       -   structure used to store algorithm state
    TestStep    -   verification step:
                    * TestStep=0 turns verification off
                    * TestStep&gt;0 activates verification

  -- ALGLIB --
     Copyright 15.06.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitsetgradientcheck(
    lsfitstate state,
    <font color=navy>double</font> teststep)

</div></pre>
<a name='sub_lsfitsetscale'></a><h3 class=pageheader><code>lsfitsetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for underlying optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Generally, scale is NOT considered to be a form of preconditioner.  But LM
optimizer is unique in that it uses scaling matrix both  in  the  stopping
condition tests and as Marquardt damping factor.

Proper scaling is very important for the algorithm performance. It is less
important for the quality of results, but still has some influence (it  is
easier  to  converge  when  variables  are  properly  scaled, so premature
stopping is possible when very badly scalled variables are  combined  with
relaxed stopping conditions).

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitsetscale(lsfitstate state, <font color=navy>double</font>[] s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_nlscale' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitsetstpmax'></a><h3 class=pageheader><code>lsfitsetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

NOTE: non-zero StpMax leads to moderate  performance  degradation  because
intermediate  step  of  preconditioned L-BFGS optimization is incompatible
with limits on step size.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitsetstpmax(lsfitstate state, <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_lsfitsetxrep'></a><h3 class=pageheader><code>lsfitsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

When reports are needed, State.C (current parameters) and State.F (current
value of fitting function) are reported.


  -- ALGLIB --
     Copyright 15.08.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lsfitsetxrep(lsfitstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='sub_lstfitpiecewiselinearrdp'></a><h3 class=pageheader><code>lstfitpiecewiselinearrdp</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
Peucker algorithm, which stops after achieving desired precision.

IMPORTANT:
* it performs non-least-squares fitting; it builds curve, but  this  curve
  does not minimize some least squares  metric.  See  description  of  RDP
  algorithm (say, in Wikipedia) for more details on WHAT is performed.
* this function does NOT work with parametric curves  (i.e.  curves  which
  can be represented as {X(t),Y(t)}. It works with curves   which  can  be
  represented as Y(X). Thus, it is impossible to model figures like circles
  with this functions.
  If  you  want  to  work  with  parametric   curves,   you   should   use
  ParametricRDPFixed() function provided  by  &quot;Parametric&quot;  subpackage  of
  &quot;Interpolation&quot; package.

INPUT PARAMETERS:
    X       -   array of X-coordinates:
                * at least N elements
                * can be unordered (points are automatically sorted)
                * this function may accept non-distinct X (see below for
                  more information on handling of such inputs)
    Y       -   array of Y-coordinates:
                * at least N elements
    N       -   number of elements in X/Y
    Eps     -   positive number, desired precision.


OUTPUT PARAMETERS:
    X2      -   X-values of corner points for piecewise approximation,
                has length NSections+1 or zero (for NSections=0).
    Y2      -   Y-values of corner points,
                has length NSections+1 or zero (for NSections=0).
    NSections-  number of sections found by algorithm,
                NSections can be zero for degenerate datasets
                (N&lt;=1 or all X[] are non-distinct).

NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
      curve, (X2[NSection-1],Y2[NSection-1]) is the last point.

  -- ALGLIB --
     Copyright 02.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lstfitpiecewiselinearrdp(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>double</font> eps,
    <font color=navy>out</font> <font color=navy>double</font>[] x2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2,
    <font color=navy>out</font> <font color=navy>int</font> nsections)

</div></pre>
<a name='sub_lstfitpiecewiselinearrdpfixed'></a><h3 class=pageheader><code>lstfitpiecewiselinearrdpfixed</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
Peucker algorithm, which stops after generating specified number of linear
sections.

IMPORTANT:
* it does NOT perform least-squares fitting; it  builds  curve,  but  this
  curve does not minimize some least squares metric.  See  description  of
  RDP algorithm (say, in Wikipedia) for more details on WHAT is performed.
* this function does NOT work with parametric curves  (i.e.  curves  which
  can be represented as {X(t),Y(t)}. It works with curves   which  can  be
  represented as Y(X). Thus,  it  is  impossible  to  model  figures  like
  circles  with  this  functions.
  If  you  want  to  work  with  parametric   curves,   you   should   use
  ParametricRDPFixed() function provided  by  &quot;Parametric&quot;  subpackage  of
  &quot;Interpolation&quot; package.

INPUT PARAMETERS:
    X       -   array of X-coordinates:
                * at least N elements
                * can be unordered (points are automatically sorted)
                * this function may accept non-distinct X (see below for
                  more information on handling of such inputs)
    Y       -   array of Y-coordinates:
                * at least N elements
    N       -   number of elements in X/Y
    M       -   desired number of sections:
                * at most M sections are generated by this function
                * less than M sections can be generated if we have N&lt;M
                  (or some X are non-distinct).

OUTPUT PARAMETERS:
    X2      -   X-values of corner points for piecewise approximation,
                has length NSections+1 or zero (for NSections=0).
    Y2      -   Y-values of corner points,
                has length NSections+1 or zero (for NSections=0).
    NSections-  number of sections found by algorithm, NSections&lt;=M,
                NSections can be zero for degenerate datasets
                (N&lt;=1 or all X[] are non-distinct).

NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
      curve, (X2[NSection-1],Y2[NSection-1]) is the last point.

  -- ALGLIB --
     Copyright 02.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.lstfitpiecewiselinearrdpfixed(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[] x2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2,
    <font color=navy>out</font> <font color=navy>int</font> nsections)

</div></pre>
<a name='sub_polynomialfit'></a><h3 class=pageheader><code>polynomialfit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fitting by polynomials in barycentric form. This function provides  simple
unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
you need constrained fitting.

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO:
    PolynomialFitWC()

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    N   -   number of points, N&gt;0
            * if given, only leading N elements of X/Y are used
            * if not given, automatically determined from sizes of X/Y
    M   -   number of basis functions (= polynomial_degree + 1), M&gt;=1

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearW() subroutine:
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
    P   -   interpolant in barycentric form.
    Rep -   report, same format as in LSFitLinearW() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

NOTES:
    you can convert P from barycentric form  to  the  power  or  Chebyshev
    basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
    POLINT subpackage.

  -- ALGLIB PROJECT --
     Copyright 10.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialfit(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialfit(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_polynomialfit(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_polynomialfit(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_pol' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialfitwc'></a><h3 class=pageheader><code>polynomialfitwc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted  fitting by polynomials in barycentric form, with constraints  on
function values or first derivatives.

Small regularizing term is used when solving constrained tasks (to improve
stability).

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO:
    PolynomialFit()

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points, N&gt;0.
            * if given, only leading N elements of X/Y/W are used
            * if not given, automatically determined from sizes of X/Y/W
    XC  -   points where polynomial values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that P(XC[i])=YC[i]
            * DC[i]=1   means that P'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints, 0&lt;=K&lt;M.
            K=0 means no constraints (XC/YC/DC are not used in such cases)
    M   -   number of basis functions (= polynomial_degree + 1), M&gt;=1

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearW() subroutine:
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
    P   -   interpolant in barycentric form.
    Rep -   report, same format as in LSFitLinearW() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

NOTES:
    you can convert P from barycentric form  to  the  power  or  Chebyshev
    basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
    POLINT subpackage.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained regression splines:
* even simple constraints can be inconsistent, see  Wikipedia  article  on
  this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints is NOT GUARANTEED.
* in the one special cases, however, we can  guarantee  consistency.  This
  case  is:  M&gt;1  and constraints on the function values (NOT DERIVATIVES)

Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.

  -- ALGLIB PROJECT --
     Copyright 10.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialfitwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialfitwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_polynomialfitwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_polynomialfitwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> barycentricinterpolant p,
    <font color=navy>out</font> polynomialfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_polc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfitcubic'></a><h3 class=pageheader><code>spline1dfitcubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting by cubic spline.

This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
about subroutine parameters (we don't duplicate it here because of length)

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)

</div></pre>
<a name='sub_spline1dfitcubicwc'></a><h3 class=pageheader><code>spline1dfitcubicwc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted fitting by cubic  spline,  with constraints on function values or
derivatives.

Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
basis functions. Basis functions are cubic splines with continuous  second
derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
regularizing term is used  when  solving  constrained  tasks  (to  improve
stability).

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO
    Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
                                less smooth)
    Spline1DFitCubic()      -   &quot;lightweight&quot; fitting  by  cubic  splines,
                                without invididual weights and constraints

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points (optional):
            * N&gt;0
            * if given, only first N elements of X/Y/W are processed
            * if not given, automatically determined from X/Y/W sizes
    XC  -   points where spline values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that S(XC[i])=YC[i]
            * DC[i]=1   means that S'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints (optional):
            * 0&lt;=K&lt;M.
            * K=0 means no constraints (XC/YC/DC are not used)
            * if given, only first K elements of XC/YC/DC are used
            * if not given, automatically determined from XC/YC/DC
    M   -   number of basis functions ( = number_of_nodes+2), M&gt;=4.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
    S   -   spline interpolant.
    Rep -   report, same format as in LSFitLinearWC() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained regression splines:
* excessive constraints can be inconsistent. Splines are  piecewise  cubic
  functions, and it is easy to create an example, where  large  number  of
  constraints  concentrated  in  small  area will result in inconsistency.
  Just because spline is not flexible enough to satisfy all of  them.  And
  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
  consistent.
* the more evenly constraints are spread across [min(x),max(x)],  the more
  chances that they will be consistent
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints IS NOT GUARANTEED.
* in the several special cases, however, we CAN guarantee consistency.
* one of this cases is constraints  on  the  function  values  AND/OR  its
  derivatives at the interval boundaries.
* another  special  case  is ONE constraint on the function value (OR, but
  not AND, derivative) anywhere in the interval

Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.


  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitcubicwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitcubicwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitcubicwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitcubicwc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)

</div></pre>
<a name='sub_spline1dfithermite'></a><h3 class=pageheader><code>spline1dfithermite</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting by Hermite spline.

This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
more information about subroutine parameters (we don't duplicate  it  here
because of length).

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfithermite(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfithermite(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfithermite(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfithermite(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)

</div></pre>
<a name='sub_spline1dfithermitewc'></a><h3 class=pageheader><code>spline1dfithermitewc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted  fitting  by Hermite spline,  with constraints on function values
or first derivatives.

Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
basis functions. Basis functions are Hermite splines.  Small  regularizing
term is used when solving constrained tasks (to improve stability).

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO
    Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
                                more smooth)
    Spline1DFitHermite()    -   &quot;lightweight&quot; Hermite fitting, without
                                invididual weights and constraints

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points (optional):
            * N&gt;0
            * if given, only first N elements of X/Y/W are processed
            * if not given, automatically determined from X/Y/W sizes
    XC  -   points where spline values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that S(XC[i])=YC[i]
            * DC[i]=1   means that S'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints (optional):
            * 0&lt;=K&lt;M.
            * K=0 means no constraints (XC/YC/DC are not used)
            * if given, only first K elements of XC/YC/DC are used
            * if not given, automatically determined from XC/YC/DC
    M   -   number of basis functions (= 2 * number of nodes),
            M&gt;=4,
            M IS EVEN!

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearW() subroutine:
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
                        -2 means odd M was passed (which is not supported)
                        -1 means another errors in parameters passed
                           (N&lt;=0, for example)
    S   -   spline interpolant.
    Rep -   report, same format as in LSFitLinearW() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

IMPORTANT:
    this subroitine supports only even M's


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained regression splines:
* excessive constraints can be inconsistent. Splines are  piecewise  cubic
  functions, and it is easy to create an example, where  large  number  of
  constraints  concentrated  in  small  area will result in inconsistency.
  Just because spline is not flexible enough to satisfy all of  them.  And
  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
  consistent.
* the more evenly constraints are spread across [min(x),max(x)],  the more
  chances that they will be consistent
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints is NOT GUARANTEED.
* in the several special cases, however, we can guarantee consistency.
* one of this cases is  M&gt;=4  and   constraints  on   the  function  value
  (AND/OR its derivative) at the interval boundaries.
* another special case is M&gt;=4  and  ONE  constraint on the function value
  (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]

Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfithermitewc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfithermitewc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfithermitewc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfithermitewc(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] xc,
    <font color=navy>double</font>[] yc,
    <font color=navy>int</font>[] dc,
    <font color=navy>int</font> k,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)

</div></pre>
<a name='sub_spline1dfitpenalized'></a><h3 class=pageheader><code>spline1dfitpenalized</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fitting by penalized cubic spline.

Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
basis functions. Basis functions are cubic splines with  natural  boundary
conditions. Problem is regularized by  adding non-linearity penalty to the
usual least squares penalty function:

    S(x) = arg min { LS + P }, where
    LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
    P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
    rho  - tunable constant given by user
    C    - automatically determined scale parameter,
           makes penalty invariant with respect to scaling of X, Y, W.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    N   -   number of points (optional):
            * N&gt;0
            * if given, only first N elements of X/Y are processed
            * if not given, automatically determined from X/Y sizes
    M   -   number of basis functions ( = number_of_nodes), M&gt;=4.
    Rho -   regularization  constant  passed   by   user.   It   penalizes
            nonlinearity in the regression spline. It  is  logarithmically
            scaled,  i.e.  actual  value  of  regularization  constant  is
            calculated as 10^Rho. It is automatically scaled so that:
            * Rho=2.0 corresponds to moderate amount of nonlinearity
            * generally, it should be somewhere in the [-8.0,+8.0]
            If you do not want to penalize nonlineary,
            pass small Rho. Values as low as -15 should work.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD or
                           Cholesky decomposition; problem may be
                           too ill-conditioned (very rare)
    S   -   spline interpolant.
    Rep -   Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

NOTE 1: additional nodes are added to the spline outside  of  the  fitting
interval to force linearity when x&lt;min(x,xc) or x&gt;max(x,xc).  It  is  done
for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
it is natural to force linearity outside of this interval.

NOTE 2: function automatically sorts points,  so  caller may pass unsorted
array.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitpenalized(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitpenalized(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitpenalized(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitpenalized(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_spline' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfitpenalizedw'></a><h3 class=pageheader><code>spline1dfitpenalizedw</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted fitting by penalized cubic spline.

Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
basis functions. Basis functions are cubic splines with  natural  boundary
conditions. Problem is regularized by  adding non-linearity penalty to the
usual least squares penalty function:

    S(x) = arg min { LS + P }, where
    LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
    P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
    rho  - tunable constant given by user
    C    - automatically determined scale parameter,
           makes penalty invariant with respect to scaling of X, Y, W.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multithreading support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Speed-up provided by multithreading greatly depends  on  problem  size
  ! - only large problems (number of coefficients is more than 500) can be
  ! efficiently multithreaded.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            problem.
    N   -   number of points (optional):
            * N&gt;0
            * if given, only first N elements of X/Y/W are processed
            * if not given, automatically determined from X/Y/W sizes
    M   -   number of basis functions ( = number_of_nodes), M&gt;=4.
    Rho -   regularization  constant  passed   by   user.   It   penalizes
            nonlinearity in the regression spline. It  is  logarithmically
            scaled,  i.e.  actual  value  of  regularization  constant  is
            calculated as 10^Rho. It is automatically scaled so that:
            * Rho=2.0 corresponds to moderate amount of nonlinearity
            * generally, it should be somewhere in the [-8.0,+8.0]
            If you do not want to penalize nonlineary,
            pass small Rho. Values as low as -15 should work.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD or
                           Cholesky decomposition; problem may be
                           too ill-conditioned (very rare)
    S   -   spline interpolant.
    Rep -   Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

NOTE 1: additional nodes are added to the spline outside  of  the  fitting
interval to force linearity when x&lt;min(x,xc) or x&gt;max(x,xc).  It  is  done
for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
it is natural to force linearity outside of this interval.

NOTE 2: function automatically sorts points,  so  caller may pass unsorted
array.

  -- ALGLIB PROJECT --
     Copyright 19.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitpenalizedw(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dfitpenalizedw(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitpenalizedw(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spline1dfitpenalizedw(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font> rho,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> spline1dinterpolant s,
    <font color=navy>out</font> spline1dfitreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_spline' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_lsfit_d_lin'></a><h3 class=pageheader>lsfit_d_lin example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate linear fitting by f(x|a) = a*exp(0.5*x).</font>
    <font color=green>//</font>
    <font color=green>// We have:</font>
    <font color=green>// * y - vector of experimental data</font>
    <font color=green>// * fmatrix -  matrix of basis functions calculated at sample points</font>
    <font color=green>//              Actually, we have only one basis function F0 = exp(0.5*x).</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] fmatrix = new <font color=navy>double</font>[,]{{0.606531},{0.670320},{0.740818},{0.818731},{0.904837},{1.000000},{1.105171},{1.221403},{1.349859},{1.491825},{1.648721}};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{1.133719,1.306522,1.504604,1.554663,1.884638,2.072436,2.257285,2.534068,2.622017,2.897713,3.219371};
    <font color=navy>int</font> info;
    <font color=navy>double</font>[] c;
    alglib.lsfitreport rep;

    <font color=green>//</font>
    <font color=green>// Linear fitting without weights</font>
    <font color=green>//</font>
    alglib.lsfitlinear(y, fmatrix, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,4)); <font color=green>// EXPECTED: [1.98650]</font>

    <font color=green>//</font>
    <font color=green>// Linear fitting with individual weights.</font>
    <font color=green>// Slightly different result is returned.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1.414213,1,1,1,1,1,1,1,1,1,1};
    alglib.lsfitlinearw(y, w, fmatrix, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,4)); <font color=green>// EXPECTED: [1.983354]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_linc'></a><h3 class=pageheader>lsfit_d_linc example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate linear fitting by f(x|a,b) = a*x+b</font>
    <font color=green>// with simple constraint f(0)=0.</font>
    <font color=green>//</font>
    <font color=green>// We have:</font>
    <font color=green>// * y - vector of experimental data</font>
    <font color=green>// * fmatrix -  matrix of basis functions sampled at [0,1] with step 0.2:</font>
    <font color=green>//                  [ 1.0   0.0 ]</font>
    <font color=green>//                  [ 1.0   0.2 ]</font>
    <font color=green>//                  [ 1.0   0.4 ]</font>
    <font color=green>//                  [ 1.0   0.6 ]</font>
    <font color=green>//                  [ 1.0   0.8 ]</font>
    <font color=green>//                  [ 1.0   1.0 ]</font>
    <font color=green>//              first column contains value of first basis function (constant term)</font>
    <font color=green>//              second column contains second basis function (linear term)</font>
    <font color=green>// * cmatrix -  matrix of linear constraints:</font>
    <font color=green>//                  [ 1.0  0.0  0.0 ]</font>
    <font color=green>//              first two columns contain coefficients before basis functions,</font>
    <font color=green>//              last column contains desired value of their sum.</font>
    <font color=green>//              So [1,0,0] means <font color=blue><b>&quot;1*constant_term + 0*linear_term = 0&quot;</b></font> </font>
    <font color=green>//</font>
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.072436,0.246944,0.491263,0.522300,0.714064,0.921929};
    <font color=navy>double</font>[,] fmatrix = new <font color=navy>double</font>[,]{{1,0.0},{1,0.2},{1,0.4},{1,0.6},{1,0.8},{1,1.0}};
    <font color=navy>double</font>[,] cmatrix = new <font color=navy>double</font>[,]{{1,0,0}};
    <font color=navy>int</font> info;
    <font color=navy>double</font>[] c;
    alglib.lsfitreport rep;

    <font color=green>//</font>
    <font color=green>// Constrained fitting without weights</font>
    <font color=green>//</font>
    alglib.lsfitlinearc(y, fmatrix, cmatrix, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [0,0.932933]</font>

    <font color=green>//</font>
    <font color=green>// Constrained fitting with individual weights</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1,1.414213,1,1,1,1};
    alglib.lsfitlinearwc(y, w, fmatrix, cmatrix, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,3)); <font color=green>// EXPECTED: [0,0.938322]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_nlf'></a><h3 class=pageheader>lsfit_d_nlf example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_func(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter</font>
    func = System.Math.Exp(-c[0]*x[0]*x[0]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate exponential fitting</font>
    <font color=green>// by f(x) = exp(-c*x^2)</font>
    <font color=green>// using function value only.</font>
    <font color=green>//</font>
    <font color=green>// Gradient is estimated using combination of numerical differences</font>
    <font color=green>// and secant updates. diffstep variable stores differentiation step </font>
    <font color=green>// (we have to tell algorithm what step to use).</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{-1},{-0.8},{-0.6},{-0.4},{-0.2},{0},{0.2},{0.4},{0.6},{0.8},{1.0}};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.223130,0.382893,0.582748,0.786628,0.941765,1.000000,0.941765,0.786628,0.582748,0.382893,0.223130};
    <font color=navy>double</font>[] c = new <font color=navy>double</font>[]{0.3};
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> info;
    alglib.lsfitstate state;
    alglib.lsfitreport rep;
    <font color=navy>double</font> diffstep = 0.0001;

    <font color=green>//</font>
    <font color=green>// Fitting without weights</font>
    <font color=green>//</font>
    alglib.lsfitcreatef(x, y, c, diffstep, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.5]</font>

    <font color=green>//</font>
    <font color=green>// Fitting with weights</font>
    <font color=green>// (you can change weights and see how it changes result)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1,1,1,1,1,1,1,1,1,1,1};
    alglib.lsfitcreatewf(x, y, w, c, diffstep, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.5]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_nlfb'></a><h3 class=pageheader>lsfit_d_nlfb example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_func(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter</font>
    func = System.Math.Exp(-c[0]*x[0]*x[0]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate exponential fitting by</font>
    <font color=green>//     f(x) = exp(-c*x^2)</font>
    <font color=green>// subject to bound constraints</font>
    <font color=green>//     0.0 &lt;= c &lt;= 1.0</font>
    <font color=green>// using function value only.</font>
    <font color=green>//</font>
    <font color=green>// Gradient is estimated using combination of numerical differences</font>
    <font color=green>// and secant updates. diffstep variable stores differentiation step </font>
    <font color=green>// (we have to tell algorithm what step to use).</font>
    <font color=green>//</font>
    <font color=green>// Unconstrained solution is c=1.5, but because of constraints we should</font>
    <font color=green>// get c=1.0 (at the boundary).</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{-1},{-0.8},{-0.6},{-0.4},{-0.2},{0},{0.2},{0.4},{0.6},{0.8},{1.0}};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.223130,0.382893,0.582748,0.786628,0.941765,1.000000,0.941765,0.786628,0.582748,0.382893,0.223130};
    <font color=navy>double</font>[] c = new <font color=navy>double</font>[]{0.3};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{0.0};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{1.0};
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> info;
    alglib.lsfitstate state;
    alglib.lsfitreport rep;
    <font color=navy>double</font> diffstep = 0.0001;

    alglib.lsfitcreatef(x, y, c, diffstep, <font color=navy>out</font> state);
    alglib.lsfitsetbc(state, bndl, bndu);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.0]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_nlfg'></a><h3 class=pageheader>lsfit_d_nlfg example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_func(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter</font>
    func = System.Math.Exp(-c[0]*x[0]*x[0]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_grad(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0)) and gradient G={df/dc[i]}</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter.</font>
    <font color=green>// IMPORTANT: gradient is calculated with respect to C, not to X</font>
    func = System.Math.Exp(-c[0]*System.Math.Pow(x[0],2));
    grad[0] = -System.Math.Pow(x[0],2)*func;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate exponential fitting</font>
    <font color=green>// by f(x) = exp(-c*x^2)</font>
    <font color=green>// using function value and gradient (with respect to c).</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{-1},{-0.8},{-0.6},{-0.4},{-0.2},{0},{0.2},{0.4},{0.6},{0.8},{1.0}};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.223130,0.382893,0.582748,0.786628,0.941765,1.000000,0.941765,0.786628,0.582748,0.382893,0.223130};
    <font color=navy>double</font>[] c = new <font color=navy>double</font>[]{0.3};
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> info;
    alglib.lsfitstate state;
    alglib.lsfitreport rep;

    <font color=green>//</font>
    <font color=green>// Fitting without weights</font>
    <font color=green>//</font>
    alglib.lsfitcreatefg(x, y, c, true, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, function_cx_1_grad, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.5]</font>

    <font color=green>//</font>
    <font color=green>// Fitting with weights</font>
    <font color=green>// (you can change weights and see how it changes result)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1,1,1,1,1,1,1,1,1,1,1};
    alglib.lsfitcreatewfg(x, y, w, c, true, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, function_cx_1_grad, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.5]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_nlfgh'></a><h3 class=pageheader>lsfit_d_nlfgh example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_func(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter</font>
    func = System.Math.Exp(-c[0]*x[0]*x[0]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_grad(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0)) and gradient G={df/dc[i]}</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter.</font>
    <font color=green>// IMPORTANT: gradient is calculated with respect to C, not to X</font>
    func = System.Math.Exp(-c[0]*System.Math.Pow(x[0],2));
    grad[0] = -System.Math.Pow(x[0],2)*func;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_cx_1_hess(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, <font color=navy>double</font>[,] hess, object obj)
{
    <font color=green>// this callback calculates f(c,x)=exp(-c0*sqr(x0)), gradient G={df/dc[i]} and Hessian H={d2f/(dc[i]*dc[j])}</font>
    <font color=green>// where x is a position on X-axis and c is adjustable parameter.</font>
    <font color=green>// IMPORTANT: gradient/Hessian are calculated with respect to C, not to X</font>
    func = System.Math.Exp(-c[0]*System.Math.Pow(x[0],2));
    grad[0] = -System.Math.Pow(x[0],2)*func;
    hess[0,0] = System.Math.Pow(x[0],4)*func;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate exponential fitting</font>
    <font color=green>// by f(x) = exp(-c*x^2)</font>
    <font color=green>// using function value, gradient and Hessian (with respect to c)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{-1},{-0.8},{-0.6},{-0.4},{-0.2},{0},{0.2},{0.4},{0.6},{0.8},{1.0}};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.223130,0.382893,0.582748,0.786628,0.941765,1.000000,0.941765,0.786628,0.582748,0.382893,0.223130};
    <font color=navy>double</font>[] c = new <font color=navy>double</font>[]{0.3};
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> info;
    alglib.lsfitstate state;
    alglib.lsfitreport rep;

    <font color=green>//</font>
    <font color=green>// Fitting without weights</font>
    <font color=green>//</font>
    alglib.lsfitcreatefgh(x, y, c, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, function_cx_1_grad, function_cx_1_hess, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.5]</font>

    <font color=green>//</font>
    <font color=green>// Fitting with weights</font>
    <font color=green>// (you can change weights and see how it changes result)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1,1,1,1,1,1,1,1,1,1,1};
    alglib.lsfitcreatewfgh(x, y, w, c, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitfit(state, function_cx_1_func, function_cx_1_grad, function_cx_1_hess, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,1)); <font color=green>// EXPECTED: [1.5]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_nlscale'></a><h3 class=pageheader>lsfit_d_nlscale example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function_debt_func(<font color=navy>double</font>[] c, <font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates f(c,x)=c[0]*(1+c[1]*(pow(x[0]-1999,c[2])-1))</font>
    <font color=green>//</font>
    func = c[0]*(1+c[1]*(System.Math.Pow(x[0]-1999,c[2])-1));
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate fitting by</font>
    <font color=green>//     f(x) = c[0]*(1+c[1]*((x-1999)^c[2]-1))</font>
    <font color=green>// subject to bound constraints</font>
    <font color=green>//     -INF  &lt; c[0] &lt; +INF</font>
    <font color=green>//      -10 &lt;= c[1] &lt;= +10</font>
    <font color=green>//      0.1 &lt;= c[2] &lt;= 2.0</font>
    <font color=green>// Data we want to fit are time series of Japan national debt</font>
    <font color=green>// collected from 2000 to 2008 measured in USD (dollars, not</font>
    <font color=green>// millions of dollars).</font>
    <font color=green>//</font>
    <font color=green>// Our variables are:</font>
    <font color=green>//     c[0] - debt value at initial moment (2000),</font>
    <font color=green>//     c[1] - direction coefficient (growth or decrease),</font>
    <font color=green>//     c[2] - curvature coefficient.</font>
    <font color=green>// You may see that our variables are badly scaled - first one </font>
    <font color=green>// is order of 10^12, and next two are somewhere about 1 in </font>
    <font color=green>// magnitude. Such problem is difficult to solve without some</font>
    <font color=green>// kind of scaling.</font>
    <font color=green>// That is exactly where lsfitsetscale() function can be used.</font>
    <font color=green>// We set scale of our variables to [1.0E12, 1, 1], which allows</font>
    <font color=green>// us to easily solve this problem.</font>
    <font color=green>//</font>
    <font color=green>// You can try commenting <font color=navy>out</font> lsfitsetscale() call - and you will </font>
    <font color=green>// see that algorithm will fail to converge.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{2000},{2001},{2002},{2003},{2004},{2005},{2006},{2007},{2008}};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{4323239600000.0,4560913100000.0,5564091500000.0,6743189300000.0,7284064600000.0,7050129600000.0,7092221500000.0,8483907600000.0,8625804400000.0};
    <font color=navy>double</font>[] c = new <font color=navy>double</font>[]{1.0e+13,1,1};
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 1.0e-5;
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{-System.Double.PositiveInfinity,-10,0.1};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{System.Double.PositiveInfinity,+10,2.0};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1.0e+12,1,1};
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> info;
    alglib.lsfitstate state;
    alglib.lsfitreport rep;
    <font color=navy>double</font> diffstep = 1.0e-5;

    alglib.lsfitcreatef(x, y, c, diffstep, <font color=navy>out</font> state);
    alglib.lsfitsetcond(state, epsf, epsx, maxits);
    alglib.lsfitsetbc(state, bndl, bndu);
    alglib.lsfitsetscale(state, s);
    alglib.lsfitfit(state, function_debt_func, null, null);
    alglib.lsfitresults(state, <font color=navy>out</font> info, <font color=navy>out</font> c, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,-2)); <font color=green>// EXPECTED: [4.142560E+12, 0.434240, 0.565376]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_pol'></a><h3 class=pageheader>lsfit_d_pol example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates polynomial fitting.</font>
    <font color=green>//</font>
    <font color=green>// Fitting is done by two (M=2) functions from polynomial basis:</font>
    <font color=green>//     f0 = 1</font>
    <font color=green>//     f1 = x</font>
    <font color=green>// Basically, it just a linear fit; more complex polynomials may be used</font>
    <font color=green>// (e.g. parabolas with M=3, cubic with M=4), but even such simple fit allows</font>
    <font color=green>// us to demonstrate polynomialfit() function in action.</font>
    <font color=green>//</font>
    <font color=green>// We have:</font>
    <font color=green>// * x      set of abscissas</font>
    <font color=green>// * y      experimental data</font>
    <font color=green>//</font>
    <font color=green>// Additionally we demonstrate weighted fitting, where second point has</font>
    <font color=green>// more weight than other ones.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.00,0.05,0.26,0.32,0.33,0.43,0.60,0.60,0.77,0.98,1.02};
    <font color=navy>int</font> m = 2;
    <font color=navy>double</font> t = 2;
    <font color=navy>int</font> info;
    alglib.barycentricinterpolant p;
    alglib.polynomialfitreport rep;
    <font color=navy>double</font> v;

    <font color=green>//</font>
    <font color=green>// Fitting without individual weights</font>
    <font color=green>//</font>
    <font color=green>// NOTE: result is returned as barycentricinterpolant structure.</font>
    <font color=green>//       <font color=navy>if</font> you want to get representation in the power basis,</font>
    <font color=green>//       you can use barycentricbar2pow() function to convert</font>
    <font color=green>//       from barycentric to power representation (see docs <font color=navy>for</font> </font>
    <font color=green>//       POLINT subpackage <font color=navy>for</font> more info).</font>
    <font color=green>//</font>
    alglib.polynomialfit(x, y, m, <font color=navy>out</font> info, <font color=navy>out</font> p, <font color=navy>out</font> rep);
    v = alglib.barycentriccalc(p, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.011</font>

    <font color=green>//</font>
    <font color=green>// Fitting with individual weights</font>
    <font color=green>//</font>
    <font color=green>// NOTE: slightly different result is returned</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1,1.414213562,1,1,1,1,1,1,1,1,1};
    <font color=navy>double</font>[] xc = new <font color=navy>double</font>[0];
    <font color=navy>double</font>[] yc = new <font color=navy>double</font>[0];
    <font color=navy>int</font>[] dc = new <font color=navy>int</font>[0];
    alglib.polynomialfitwc(x, y, w, xc, yc, dc, m, <font color=navy>out</font> info, <font color=navy>out</font> p, <font color=navy>out</font> rep);
    v = alglib.barycentriccalc(p, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.023</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_polc'></a><h3 class=pageheader>lsfit_d_polc example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates polynomial fitting.</font>
    <font color=green>//</font>
    <font color=green>// Fitting is done by two (M=2) functions from polynomial basis:</font>
    <font color=green>//     f0 = 1</font>
    <font color=green>//     f1 = x</font>
    <font color=green>// with simple constraint on function value</font>
    <font color=green>//     f(0) = 0</font>
    <font color=green>// Basically, it just a linear fit; more complex polynomials may be used</font>
    <font color=green>// (e.g. parabolas with M=3, cubic with M=4), but even such simple fit allows</font>
    <font color=green>// us to demonstrate polynomialfit() function in action.</font>
    <font color=green>//</font>
    <font color=green>// We have:</font>
    <font color=green>// * x      set of abscissas</font>
    <font color=green>// * y      experimental data</font>
    <font color=green>// * xc     points where constraints are placed</font>
    <font color=green>// * yc     constraints on derivatives</font>
    <font color=green>// * dc     derivative indices</font>
    <font color=green>//          (0 means function itself, 1 means first derivative)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1.0,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.9,1.1};
    <font color=navy>double</font>[] w = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] xc = new <font color=navy>double</font>[]{0};
    <font color=navy>double</font>[] yc = new <font color=navy>double</font>[]{0};
    <font color=navy>int</font>[] dc = new <font color=navy>int</font>[]{0};
    <font color=navy>double</font> t = 2;
    <font color=navy>int</font> m = 2;
    <font color=navy>int</font> info;
    alglib.barycentricinterpolant p;
    alglib.polynomialfitreport rep;
    <font color=navy>double</font> v;

    alglib.polynomialfitwc(x, y, w, xc, yc, dc, m, <font color=navy>out</font> info, <font color=navy>out</font> p, <font color=navy>out</font> rep);
    v = alglib.barycentriccalc(p, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.000</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_d_spline'></a><h3 class=pageheader>lsfit_d_spline example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// In this example we demonstrate penalized spline fitting of noisy data</font>
    <font color=green>//</font>
    <font color=green>// We have:</font>
    <font color=green>// * x - abscissas</font>
    <font color=green>// * y - vector of experimental data, straight line with small noise</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.00,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.10,0.00,0.30,0.40,0.30,0.40,0.62,0.68,0.75,0.95};
    <font color=navy>int</font> info;
    <font color=navy>double</font> v;
    alglib.spline1dinterpolant s;
    alglib.spline1dfitreport rep;
    <font color=navy>double</font> rho;

    <font color=green>//</font>
    <font color=green>// Fit with VERY small amount of smoothing (rho = -5.0)</font>
    <font color=green>// and large number of basis functions (M=50).</font>
    <font color=green>//</font>
    <font color=green>// With such small regularization penalized spline almost fully reproduces function values</font>
    <font color=green>//</font>
    rho = -5.0;
    alglib.spline1dfitpenalized(x, y, 50, rho, <font color=navy>out</font> info, <font color=navy>out</font> s, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    v = alglib.spline1dcalc(s, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, v); <font color=green>// EXPECTED: 0.10</font>

    <font color=green>//</font>
    <font color=green>// Fit with VERY large amount of smoothing (rho = 10.0)</font>
    <font color=green>// and large number of basis functions (M=50).</font>
    <font color=green>//</font>
    <font color=green>// With such regularization our spline should become close to the straight line fit.</font>
    <font color=green>// We will compare its value in x=1.0 with results obtained from such fit.</font>
    <font color=green>//</font>
    rho = +10.0;
    alglib.spline1dfitpenalized(x, y, 50, rho, <font color=navy>out</font> info, <font color=navy>out</font> s, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    v = alglib.spline1dcalc(s, 1.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.969</font>

    <font color=green>//</font>
    <font color=green>// In real life applications you may need some moderate degree of fitting,</font>
    <font color=green>// so we try to fit once more with rho=3.0.</font>
    <font color=green>//</font>
    rho = +3.0;
    alglib.spline1dfitpenalized(x, y, 50, rho, <font color=navy>out</font> info, <font color=navy>out</font> s, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_t_4pl'></a><h3 class=pageheader>lsfit_t_4pl example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1,2,3,4,5,6,7,8};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.06313223,0.44552624,0.61838364,0.71385108,0.77345838,0.81383140,0.84280033,0.86449822};
    <font color=navy>int</font> n = 8;
    <font color=navy>double</font> a;
    <font color=navy>double</font> b;
    <font color=navy>double</font> c;
    <font color=navy>double</font> d;
    alglib.lsfitreport rep;

    <font color=green>//</font>
    <font color=green>// Test logisticfit4() on carefully designed data with a priori known answer.</font>
    <font color=green>//</font>
    alglib.logisticfit4(x, y, n, <font color=navy>out</font> a, <font color=navy>out</font> b, <font color=navy>out</font> c, <font color=navy>out</font> d, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, a); <font color=green>// EXPECTED: -1.000</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, b); <font color=green>// EXPECTED: 1.200</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, c); <font color=green>// EXPECTED: 0.900</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, d); <font color=green>// EXPECTED: 1.000</font>

    <font color=green>//</font>
    <font color=green>// Evaluate model at point x=0.5</font>
    <font color=green>//</font>
    <font color=navy>double</font> v;
    v = alglib.logisticcalc4(0.5, a, b, c, d);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: -0.33874308</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_lsfit_t_5pl'></a><h3 class=pageheader>lsfit_t_5pl example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1,2,3,4,5,6,7,8};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.1949776139,0.5710060208,0.726002637,0.8060434158,0.8534547965,0.8842071579,0.9054773317,0.9209088299};
    <font color=navy>int</font> n = 8;
    <font color=navy>double</font> a;
    <font color=navy>double</font> b;
    <font color=navy>double</font> c;
    <font color=navy>double</font> d;
    <font color=navy>double</font> g;
    alglib.lsfitreport rep;

    <font color=green>//</font>
    <font color=green>// Test logisticfit5() on carefully designed data with a priori known answer.</font>
    <font color=green>//</font>
    alglib.logisticfit5(x, y, n, <font color=navy>out</font> a, <font color=navy>out</font> b, <font color=navy>out</font> c, <font color=navy>out</font> d, <font color=navy>out</font> g, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, a); <font color=green>// EXPECTED: -1.000</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, b); <font color=green>// EXPECTED: 1.200</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, c); <font color=green>// EXPECTED: 0.900</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, d); <font color=green>// EXPECTED: 1.000</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, g); <font color=green>// EXPECTED: 1.200</font>

    <font color=green>//</font>
    <font color=green>// Evaluate model at point x=0.5</font>
    <font color=green>//</font>
    <font color=navy>double</font> v;
    v = alglib.logisticcalc5(0.5, a, b, c, d, g);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: -0.2354656824</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_mannwhitneyu></a><h2 class=pageheader><code>mannwhitneyu</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mannwhitneyutest' class=toc>mannwhitneyutest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_mannwhitneyutest'></a><h3 class=pageheader><code>mannwhitneyutest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Mann-Whitney U-test

This test checks hypotheses about whether X  and  Y  are  samples  of  two
continuous distributions of the same shape  and  same  median  or  whether
their medians are different.

The following tests are performed:
    * two-tailed test (null hypothesis - the medians are equal)
    * left-tailed test (null hypothesis - the median of the  first  sample
      is greater than or equal to the median of the second sample)
    * right-tailed test (null hypothesis - the median of the first  sample
      is less than or equal to the median of the second sample).

Requirements:
    * the samples are independent
    * X and Y are continuous distributions (or discrete distributions well-
      approximating continuous distributions)
    * distributions of X and Y have the  same  shape.  The  only  possible
      difference is their position (i.e. the value of the median)
    * the number of elements in each sample is not less than 5
    * the scale of measurement should be ordinal, interval or ratio  (i.e.
      the test could not be applied to nominal variables).

The test is non-parametric and doesn't require distributions to be normal.

Input parameters:
    X   -   sample 1. Array whose index goes from 0 to N-1.
    N   -   size of the sample. N&gt;=5
    Y   -   sample 2. Array whose index goes from 0 to M-1.
    M   -   size of the sample. M&gt;=5

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

To calculate p-values, special approximation is used. This method lets  us
calculate p-values with satisfactory  accuracy  in  interval  [0.0001, 1].
There is no approximation outside the [0.0001, 1] interval. Therefore,  if
the significance level outlies this interval, the test returns 0.0001.

Relative precision of approximation of p-value:

N          M          Max.err.   Rms.err.
5..10      N..10      1.4e-02    6.0e-04
5..10      N..100     2.2e-02    5.3e-06
10..15     N..15      1.0e-02    3.2e-04
10..15     N..100     1.0e-02    2.2e-05
15..100    N..100     6.1e-03    2.7e-06

For N,M&gt;100 accuracy checks weren't put into  practice,  but  taking  into
account characteristics of asymptotic approximation used, precision should
not be sharply different from the values for interval [5, 100].

NOTE: P-value approximation was  optimized  for  0.0001&lt;=p&lt;=0.2500.  Thus,
      P's outside of this interval are enforced to these bounds. Say,  you
      may quite often get P equal to exactly 0.25 or 0.0001.

  -- ALGLIB --
     Copyright 09.04.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mannwhitneyutest(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name=unit_matdet></a><h2 class=pageheader><code>matdet</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixdet' class=toc>cmatrixdet</a><br>
<a href='#sub_cmatrixludet' class=toc>cmatrixludet</a><br>
<a href='#sub_rmatrixdet' class=toc>rmatrixdet</a><br>
<a href='#sub_rmatrixludet' class=toc>rmatrixludet</a><br>
<a href='#sub_spdmatrixcholeskydet' class=toc>spdmatrixcholeskydet</a><br>
<a href='#sub_spdmatrixdet' class=toc>spdmatrixdet</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_matdet_d_1' class=toc>matdet_d_1</a></td><td width=15>&nbsp;</td><td>Determinant calculation, real matrix, short form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_2' class=toc>matdet_d_2</a></td><td width=15>&nbsp;</td><td>Determinant calculation, real matrix, full form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_3' class=toc>matdet_d_3</a></td><td width=15>&nbsp;</td><td>Determinant calculation, complex matrix, short form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_4' class=toc>matdet_d_4</a></td><td width=15>&nbsp;</td><td>Determinant calculation, complex matrix, full form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_5' class=toc>matdet_d_5</a></td><td width=15>&nbsp;</td><td>Determinant calculation, complex matrix with zero imaginary part, short form</td></tr>
</table></div>
<a name='sub_cmatrixdet'></a><h3 class=pageheader><code>cmatrixdet</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the determinant of a general matrix

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1]
    N       -   (optional) size of matrix A:
                * if given, only principal NxN submatrix is processed and
                  overwritten. other elements are unchanged.
                * if not given, automatically determined from matrix size
                  (A must be square matrix)

Result: determinant of matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> complex alglib.cmatrixdet(complex[,] a)
<font color=navy>public</font> <font color=navy>static</font> complex alglib.cmatrixdet(complex[,] a, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matdet_d_3' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_matdet_d_4' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_matdet_d_5' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixludet'></a><h3 class=pageheader><code>cmatrixludet</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by its LU decomposition.

Input parameters:
    A       -   LU decomposition of the matrix (output of
                RMatrixLU subroutine).
    Pivots  -   table of permutations which were made during
                the LU decomposition.
                Output of RMatrixLU subroutine.
    N       -   (optional) size of matrix A:
                * if given, only principal NxN submatrix is processed and
                  overwritten. other elements are unchanged.
                * if not given, automatically determined from matrix size
                  (A must be square matrix)

Result: matrix determinant.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> complex alglib.cmatrixludet(complex[,] a, <font color=navy>int</font>[] pivots)
<font color=navy>public</font> <font color=navy>static</font> complex alglib.cmatrixludet(
    complex[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_rmatrixdet'></a><h3 class=pageheader><code>rmatrixdet</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the determinant of a general matrix

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1]
    N       -   (optional) size of matrix A:
                * if given, only principal NxN submatrix is processed and
                  overwritten. other elements are unchanged.
                * if not given, automatically determined from matrix size
                  (A must be square matrix)

Result: determinant of matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixdet(<font color=navy>double</font>[,] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixdet(<font color=navy>double</font>[,] a, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matdet_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_matdet_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixludet'></a><h3 class=pageheader><code>rmatrixludet</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by its LU decomposition.

Input parameters:
    A       -   LU decomposition of the matrix (output of
                RMatrixLU subroutine).
    Pivots  -   table of permutations which were made during
                the LU decomposition.
                Output of RMatrixLU subroutine.
    N       -   (optional) size of matrix A:
                * if given, only principal NxN submatrix is processed and
                  overwritten. other elements are unchanged.
                * if not given, automatically determined from matrix size
                  (A must be square matrix)

Result: matrix determinant.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixludet(<font color=navy>double</font>[,] a, <font color=navy>int</font>[] pivots)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixludet(<font color=navy>double</font>[,] a, <font color=navy>int</font>[] pivots, <font color=navy>int</font> n)

</div></pre>
<a name='sub_spdmatrixcholeskydet'></a><h3 class=pageheader><code>spdmatrixcholeskydet</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by the Cholesky decomposition.

Input parameters:
    A       -   Cholesky decomposition,
                output of SMatrixCholesky subroutine.
    N       -   (optional) size of matrix A:
                * if given, only principal NxN submatrix is processed and
                  overwritten. other elements are unchanged.
                * if not given, automatically determined from matrix size
                  (A must be square matrix)

As the determinant is equal to the product of squares of diagonal elements,
its not necessary to specify which triangle - lower or upper - the matrix
is stored in.

Result:
    matrix determinant.

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spdmatrixcholeskydet(<font color=navy>double</font>[,] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spdmatrixcholeskydet(<font color=navy>double</font>[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_spdmatrixdet'></a><h3 class=pageheader><code>spdmatrixdet</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the symmetric positive definite matrix.

Input parameters:
    A       -   matrix. Array with elements [0..N-1, 0..N-1].
    N       -   (optional) size of matrix A:
                * if given, only principal NxN submatrix is processed and
                  overwritten. other elements are unchanged.
                * if not given, automatically determined from matrix size
                  (A must be square matrix)
    IsUpper -   (optional) storage type:
                * if True, symmetric matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt used/changed  by
                  function
                * if False, symmetric matrix  A  is  given  by  its lower
                  triangle, and the upper triangle isnt used/changed  by
                  function
                * if not given, both lower and upper  triangles  must  be
                  filled.

Result:
    determinant of matrix A.
    If matrix A is not positive definite, exception is thrown.

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spdmatrixdet(<font color=navy>double</font>[,] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spdmatrixdet(<font color=navy>double</font>[,] a, <font color=navy>int</font> n, <font color=navy>bool</font> isupper)

</div></pre>
<a name='example_matdet_d_1'></a><h3 class=pageheader>matdet_d_1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] b = new <font color=navy>double</font>[,]{{1,2},{2,1}};
    <font color=navy>double</font> a;
    a = alglib.rmatrixdet(b);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F3&quot;</b></font>, a); <font color=green>// EXPECTED: -3</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matdet_d_2'></a><h3 class=pageheader>matdet_d_2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] b = new <font color=navy>double</font>[,]{{5,4},{4,5}};
    <font color=navy>double</font> a;
    a = alglib.rmatrixdet(b, 2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F3&quot;</b></font>, a); <font color=green>// EXPECTED: 9</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matdet_d_3'></a><h3 class=pageheader>matdet_d_3 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    alglib.complex[,] b = new alglib.complex[,]{{new alglib.complex(1,+1),2},{2,new alglib.complex(1,-1)}};
    alglib.complex a;
    a = alglib.cmatrixdet(b);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,3)); <font color=green>// EXPECTED: -2</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matdet_d_4'></a><h3 class=pageheader>matdet_d_4 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    alglib.complex a;
    alglib.complex[,] b = new alglib.complex[,]{{new alglib.complex(0,5),4},{new alglib.complex(0,4),5}};
    a = alglib.cmatrixdet(b, 2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,3)); <font color=green>// EXPECTED: 9i</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matdet_d_5'></a><h3 class=pageheader>matdet_d_5 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    alglib.complex a;
    alglib.complex[,] b = new alglib.complex[,]{{9,1},{2,1}};
    a = alglib.cmatrixdet(b);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,3)); <font color=green>// EXPECTED: 7</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_matgen></a><h2 class=pageheader><code>matgen</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixrndcond' class=toc>cmatrixrndcond</a><br>
<a href='#sub_cmatrixrndorthogonal' class=toc>cmatrixrndorthogonal</a><br>
<a href='#sub_cmatrixrndorthogonalfromtheleft' class=toc>cmatrixrndorthogonalfromtheleft</a><br>
<a href='#sub_cmatrixrndorthogonalfromtheright' class=toc>cmatrixrndorthogonalfromtheright</a><br>
<a href='#sub_hmatrixrndcond' class=toc>hmatrixrndcond</a><br>
<a href='#sub_hmatrixrndmultiply' class=toc>hmatrixrndmultiply</a><br>
<a href='#sub_hpdmatrixrndcond' class=toc>hpdmatrixrndcond</a><br>
<a href='#sub_rmatrixrndcond' class=toc>rmatrixrndcond</a><br>
<a href='#sub_rmatrixrndorthogonal' class=toc>rmatrixrndorthogonal</a><br>
<a href='#sub_rmatrixrndorthogonalfromtheleft' class=toc>rmatrixrndorthogonalfromtheleft</a><br>
<a href='#sub_rmatrixrndorthogonalfromtheright' class=toc>rmatrixrndorthogonalfromtheright</a><br>
<a href='#sub_smatrixrndcond' class=toc>smatrixrndcond</a><br>
<a href='#sub_smatrixrndmultiply' class=toc>smatrixrndmultiply</a><br>
<a href='#sub_spdmatrixrndcond' class=toc>spdmatrixrndcond</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixrndcond'></a><h3 class=pageheader><code>cmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN complex matrix with given condition number C and
norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixrndcond(
    <font color=navy>int</font> n,
    <font color=navy>double</font> c,
    <font color=navy>out</font> complex[,] a)

</div></pre>
<a name='sub_cmatrixrndorthogonal'></a><h3 class=pageheader><code>cmatrixrndorthogonal</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of a random Haar distributed orthogonal complex matrix

INPUT PARAMETERS:
    N   -   matrix size, N&gt;=1

OUTPUT PARAMETERS:
    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),
      &quot;The Efficient Generation of  Random  Orthogonal  Matrices  with  an
      Application to Condition Estimators&quot;.

      Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:
      * takes an NxN one
      * takes uniformly distributed unit vector of dimension N+1.
      * constructs a Householder reflection from the vector, then applies
        it to the smaller matrix (embedded in the larger size with a 1 at
        the bottom right corner).

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixrndorthogonal(<font color=navy>int</font> n, <font color=navy>out</font> complex[,] a)

</div></pre>
<a name='sub_cmatrixrndorthogonalfromtheleft'></a><h3 class=pageheader><code>cmatrixrndorthogonalfromtheleft</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN complex matrix by MxM random Haar distributed
complex orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   Q*A, where Q is random MxM orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixrndorthogonalfromtheleft(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_cmatrixrndorthogonalfromtheright'></a><h3 class=pageheader><code>cmatrixrndorthogonalfromtheright</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN complex matrix by NxN random Haar distributed
complex orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixrndorthogonalfromtheright(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_hmatrixrndcond'></a><h3 class=pageheader><code>hmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN Hermitian matrix with given condition number  and
norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hmatrixrndcond(
    <font color=navy>int</font> n,
    <font color=navy>double</font> c,
    <font color=navy>out</font> complex[,] a)

</div></pre>
<a name='sub_hmatrixrndmultiply'></a><h3 class=pageheader><code>hmatrixrndmultiply</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Hermitian multiplication of NxN matrix by random Haar distributed
complex orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..N-1, 0..N-1]
    N   -   matrix size

OUTPUT PARAMETERS:
    A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hmatrixrndmultiply(<font color=navy>ref</font> complex[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_hpdmatrixrndcond'></a><h3 class=pageheader><code>hpdmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN Hermitian positive definite matrix with given
condition number and norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random HPD matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixrndcond(
    <font color=navy>int</font> n,
    <font color=navy>double</font> c,
    <font color=navy>out</font> complex[,] a)

</div></pre>
<a name='sub_rmatrixrndcond'></a><h3 class=pageheader><code>rmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN matrix with given condition number and norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixrndcond(<font color=navy>int</font> n, <font color=navy>double</font> c, <font color=navy>out</font> <font color=navy>double</font>[,] a)

</div></pre>
<a name='sub_rmatrixrndorthogonal'></a><h3 class=pageheader><code>rmatrixrndorthogonal</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of a random uniformly distributed (Haar) orthogonal matrix

INPUT PARAMETERS:
    N   -   matrix size, N&gt;=1

OUTPUT PARAMETERS:
    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

NOTE: this function uses algorithm  described  in  Stewart, G. W.  (1980),
      &quot;The Efficient Generation of  Random  Orthogonal  Matrices  with  an
      Application to Condition Estimators&quot;.

      Speaking short, to generate an (N+1)x(N+1) orthogonal matrix, it:
      * takes an NxN one
      * takes uniformly distributed unit vector of dimension N+1.
      * constructs a Householder reflection from the vector, then applies
        it to the smaller matrix (embedded in the larger size with a 1 at
        the bottom right corner).

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixrndorthogonal(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[,] a)

</div></pre>
<a name='sub_rmatrixrndorthogonalfromtheleft'></a><h3 class=pageheader><code>rmatrixrndorthogonalfromtheleft</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   Q*A, where Q is random MxM orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixrndorthogonalfromtheleft(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_rmatrixrndorthogonalfromtheright'></a><h3 class=pageheader><code>rmatrixrndorthogonalfromtheright</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixrndorthogonalfromtheright(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n)

</div></pre>
<a name='sub_smatrixrndcond'></a><h3 class=pageheader><code>smatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN symmetric matrix with given condition number  and
norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smatrixrndcond(<font color=navy>int</font> n, <font color=navy>double</font> c, <font color=navy>out</font> <font color=navy>double</font>[,] a)

</div></pre>
<a name='sub_smatrixrndmultiply'></a><h3 class=pageheader><code>smatrixrndmultiply</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Symmetric multiplication of NxN matrix by random Haar distributed
orthogonal  matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..N-1, 0..N-1]
    N   -   matrix size

OUTPUT PARAMETERS:
    A   -   Q'*A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smatrixrndmultiply(<font color=navy>ref</font> <font color=navy>double</font>[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_spdmatrixrndcond'></a><h3 class=pageheader><code>spdmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN symmetric positive definite matrix with given
condition number and norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random SPD matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixrndcond(
    <font color=navy>int</font> n,
    <font color=navy>double</font> c,
    <font color=navy>out</font> <font color=navy>double</font>[,] a)

</div></pre>
<a name=unit_matinv></a><h2 class=pageheader><code>matinv</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_matinvreport' class=toc>matinvreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixinverse' class=toc>cmatrixinverse</a><br>
<a href='#sub_cmatrixluinverse' class=toc>cmatrixluinverse</a><br>
<a href='#sub_cmatrixtrinverse' class=toc>cmatrixtrinverse</a><br>
<a href='#sub_hpdmatrixcholeskyinverse' class=toc>hpdmatrixcholeskyinverse</a><br>
<a href='#sub_hpdmatrixinverse' class=toc>hpdmatrixinverse</a><br>
<a href='#sub_rmatrixinverse' class=toc>rmatrixinverse</a><br>
<a href='#sub_rmatrixluinverse' class=toc>rmatrixluinverse</a><br>
<a href='#sub_rmatrixtrinverse' class=toc>rmatrixtrinverse</a><br>
<a href='#sub_spdmatrixcholeskyinverse' class=toc>spdmatrixcholeskyinverse</a><br>
<a href='#sub_spdmatrixinverse' class=toc>spdmatrixinverse</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_matinv_d_c1' class=toc>matinv_d_c1</a></td><td width=15>&nbsp;</td><td>Complex matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#example_matinv_d_hpd1' class=toc>matinv_d_hpd1</a></td><td width=15>&nbsp;</td><td>HPD matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#example_matinv_d_r1' class=toc>matinv_d_r1</a></td><td width=15>&nbsp;</td><td>Real matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#example_matinv_d_spd1' class=toc>matinv_d_spd1</a></td><td width=15>&nbsp;</td><td>SPD matrix inverse</td></tr>
</table></div>
<a name='struct_matinvreport'></a><h3 class=pageheader><code>matinvreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Matrix inverse report:
* R1    reciprocal of condition number in 1-norm
* RInf  reciprocal of condition number in inf-norm
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class matinvreport
{
    <font color=navy>public</font> <font color=navy>double</font>               r1;
    <font color=navy>public</font> <font color=navy>double</font>               rinf;
}

</div></pre>
<a name='sub_cmatrixinverse'></a><h3 class=pageheader><code>cmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a general matrix.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that matrix inversion  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_c1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixluinverse'></a><h3 class=pageheader><code>cmatrixluinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a matrix given by its LU decomposition.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that matrix inversion  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   LU decomposition of the matrix
                (output of CMatrixLU subroutine).
    Pivots  -   table of permutations
                (the output of CMatrixLU subroutine).
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)

OUTPUT PARAMETERS:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     05.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixluinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixluinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixluinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixluinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<a name='sub_cmatrixtrinverse'></a><h3 class=pageheader><code>cmatrixtrinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix inverse (complex)

The subroutine inverts the following types of matrices:
    * upper triangular
    * upper triangular with unit diagonal
    * lower triangular
    * lower triangular with unit diagonal

In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
also be upper (lower) triangular, and after the end of the algorithm,  the
inverse matrix replaces the source matrix. The elements  below (above) the
main diagonal are not changed by the algorithm.

If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
diagonal, and the diagonal elements are not passed to the algorithm.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that triangular inverse is harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1].
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   diagonal type (optional):
                * if True, matrix has unit diagonal (a[i,i] are NOT used)
                * if False, matrix diagonal is arbitrary
                * if not given, False is assumed

Output parameters:
    Info    -   same as for RMatrixLUInverse
    Rep     -   same as for RMatrixLUInverse
    A       -   same as for RMatrixLUInverse.

  -- ALGLIB --
     Copyright 05.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixtrinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixtrinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixtrinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixtrinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<a name='sub_hpdmatrixcholeskyinverse'></a><h3 class=pageheader><code>hpdmatrixcholeskyinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a Hermitian positive definite matrix which is given
by Cholesky decomposition.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  However,  Cholesky  inversion  is  a  &quot;difficult&quot;
  ! algorithm  -  it  has  lots  of  internal synchronization points which
  ! prevents efficient  parallelization  of  algorithm.  Only  very  large
  ! problems (N=thousands) can be efficiently parallelized.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   Cholesky decomposition of the matrix to be inverted:
                A=U*U or A = L*L'.
                Output of  HPDMatrixCholesky subroutine.
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)
    IsUpper -   storage type (optional):
                * if True, symmetric  matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt  used/changed  by
                  function
                * if False,  symmetric matrix  A  is  given  by  its lower
                  triangle, and the  upper triangle isnt used/changed  by
                  function
                * if not given, lower half is used.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixcholeskyinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixcholeskyinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixcholeskyinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixcholeskyinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<a name='sub_hpdmatrixinverse'></a><h3 class=pageheader><code>hpdmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a Hermitian positive definite matrix.

Given an upper or lower triangle of a Hermitian positive definite matrix,
the algorithm generates matrix A^-1 and saves the upper or lower triangle
depending on the input.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  However,  Cholesky  inversion  is  a  &quot;difficult&quot;
  ! algorithm  -  it  has  lots  of  internal synchronization points which
  ! prevents efficient  parallelization  of  algorithm.  Only  very  large
  ! problems (N=thousands) can be efficiently parallelized.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix to be inverted (upper or lower triangle).
                Array with elements [0..N-1,0..N-1].
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)
    IsUpper -   storage type (optional):
                * if True, symmetric  matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt  used/changed  by
                  function
                * if False,  symmetric matrix  A  is  given  by  its lower
                  triangle, and the  upper triangle isnt used/changed  by
                  function
                * if not given,  both lower and upper  triangles  must  be
                  filled.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hpdmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_hpdmatrixinverse(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_hpd1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixinverse'></a><h3 class=pageheader><code>rmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a general matrix.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that matrix inversion  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix.
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

Result:
    True, if the matrix is not singular.
    False, if the matrix is singular.

  -- ALGLIB --
     Copyright 2005-2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_r1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixluinverse'></a><h3 class=pageheader><code>rmatrixluinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a matrix given by its LU decomposition.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that matrix inversion  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   LU decomposition of the matrix
                (output of RMatrixLU subroutine).
    Pivots  -   table of permutations
                (the output of RMatrixLU subroutine).
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    A is singular, or VERY close to singular.
                        it is filled by zeros in such cases.
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   solver report, see below for more info
    A       -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].

SOLVER REPORT

Subroutine sets following fields of the Rep structure:
* R1        reciprocal of condition number: 1/cond(A), 1-norm.
* RInf      reciprocal of condition number: 1/cond(A), inf-norm.

  -- ALGLIB routine --
     05.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixluinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixluinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixluinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixluinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font>[] pivots,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<a name='sub_rmatrixtrinverse'></a><h3 class=pageheader><code>rmatrixtrinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix inverse (real)

The subroutine inverts the following types of matrices:
    * upper triangular
    * upper triangular with unit diagonal
    * lower triangular
    * lower triangular with unit diagonal

In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
also be upper (lower) triangular, and after the end of the algorithm,  the
inverse matrix replaces the source matrix. The elements  below (above) the
main diagonal are not changed by the algorithm.

If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
diagonal, and the diagonal elements are not passed to the algorithm.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that triangular inverse is harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1].
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   diagonal type (optional):
                * if True, matrix has unit diagonal (a[i,i] are NOT used)
                * if False, matrix diagonal is arbitrary
                * if not given, False is assumed

Output parameters:
    Info    -   same as for RMatrixLUInverse
    Rep     -   same as for RMatrixLUInverse
    A       -   same as for RMatrixLUInverse.

  -- ALGLIB --
     Copyright 05.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixtrinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixtrinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixtrinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixtrinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<a name='sub_spdmatrixcholeskyinverse'></a><h3 class=pageheader><code>spdmatrixcholeskyinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a symmetric positive definite matrix which is given
by Cholesky decomposition.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  However,  Cholesky  inversion  is  a  &quot;difficult&quot;
  ! algorithm  -  it  has  lots  of  internal synchronization points which
  ! prevents efficient  parallelization  of  algorithm.  Only  very  large
  ! problems (N=thousands) can be efficiently parallelized.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   Cholesky decomposition of the matrix to be inverted:
                A=U*U or A = L*L'.
                Output of  SPDMatrixCholesky subroutine.
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)
    IsUpper -   storage type (optional):
                * if True, symmetric  matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt  used/changed  by
                  function
                * if False,  symmetric matrix  A  is  given  by  its lower
                  triangle, and the  upper triangle isnt used/changed  by
                  function
                * if not given, lower half is used.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskyinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskyinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixcholeskyinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixcholeskyinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<a name='sub_spdmatrixinverse'></a><h3 class=pageheader><code>spdmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a symmetric positive definite matrix.

Given an upper or lower triangle of a symmetric positive definite matrix,
the algorithm generates matrix A^-1 and saves the upper or lower triangle
depending on the input.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of  this  function.  However,  Cholesky  inversion  is  a  &quot;difficult&quot;
  ! algorithm  -  it  has  lots  of  internal synchronization points which
  ! prevents efficient  parallelization  of  algorithm.  Only  very  large
  ! problems (N=thousands) can be efficiently parallelized.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix to be inverted (upper or lower triangle).
                Array with elements [0..N-1,0..N-1].
    N       -   size of matrix A (optional) :
                * if given, only principal NxN submatrix is processed  and
                  overwritten. other elements are unchanged.
                * if not given,  size  is  automatically  determined  from
                  matrix size (A must be square matrix)
    IsUpper -   storage type (optional):
                * if True, symmetric  matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt  used/changed  by
                  function
                * if False,  symmetric matrix  A  is  given  by  its lower
                  triangle, and the  upper triangle isnt used/changed  by
                  function
                * if not given,  both lower and upper  triangles  must  be
                  filled.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_spdmatrixinverse(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> matinvreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_spd1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_matinv_d_c1'></a><h3 class=pageheader>matinv_d_c1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    alglib.complex[,] a = new alglib.complex[,]{{new alglib.complex(0,1),-1},{new alglib.complex(0,1),1}};
    <font color=navy>int</font> info;
    alglib.matinvreport rep;
    alglib.cmatrixinverse(<font color=navy>ref</font> a, <font color=navy>out</font> info, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,4)); <font color=green>// EXPECTED: [[-0.5i,-0.5i],[-0.5,0.5]]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, rep.r1); <font color=green>// EXPECTED: 0.5</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, rep.rinf); <font color=green>// EXPECTED: 0.5</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matinv_d_hpd1'></a><h3 class=pageheader>matinv_d_hpd1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    alglib.complex[,] a = new alglib.complex[,]{{2,1},{1,2}};
    <font color=navy>int</font> info;
    alglib.matinvreport rep;
    alglib.hpdmatrixinverse(<font color=navy>ref</font> a, <font color=navy>out</font> info, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,4)); <font color=green>// EXPECTED: [[0.666666,-0.333333],[-0.333333,0.666666]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matinv_d_r1'></a><h3 class=pageheader>matinv_d_r1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{1,-1},{1,1}};
    <font color=navy>int</font> info;
    alglib.matinvreport rep;
    alglib.rmatrixinverse(<font color=navy>ref</font> a, <font color=navy>out</font> info, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,4)); <font color=green>// EXPECTED: [[0.5,0.5],[-0.5,0.5]]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, rep.r1); <font color=green>// EXPECTED: 0.5</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, rep.rinf); <font color=green>// EXPECTED: 0.5</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_matinv_d_spd1'></a><h3 class=pageheader>matinv_d_spd1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{2,1},{1,2}};
    <font color=navy>int</font> info;
    alglib.matinvreport rep;
    alglib.spdmatrixinverse(<font color=navy>ref</font> a, <font color=navy>out</font> info, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, info); <font color=green>// EXPECTED: 1</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a,4)); <font color=green>// EXPECTED: [[0.666666,-0.333333],[-0.333333,0.666666]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_mcpd></a><h2 class=pageheader><code>mcpd</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mcpdreport' class=toc>mcpdreport</a><br>
<a href='#struct_mcpdstate' class=toc>mcpdstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mcpdaddbc' class=toc>mcpdaddbc</a><br>
<a href='#sub_mcpdaddec' class=toc>mcpdaddec</a><br>
<a href='#sub_mcpdaddtrack' class=toc>mcpdaddtrack</a><br>
<a href='#sub_mcpdcreate' class=toc>mcpdcreate</a><br>
<a href='#sub_mcpdcreateentry' class=toc>mcpdcreateentry</a><br>
<a href='#sub_mcpdcreateentryexit' class=toc>mcpdcreateentryexit</a><br>
<a href='#sub_mcpdcreateexit' class=toc>mcpdcreateexit</a><br>
<a href='#sub_mcpdresults' class=toc>mcpdresults</a><br>
<a href='#sub_mcpdsetbc' class=toc>mcpdsetbc</a><br>
<a href='#sub_mcpdsetec' class=toc>mcpdsetec</a><br>
<a href='#sub_mcpdsetlc' class=toc>mcpdsetlc</a><br>
<a href='#sub_mcpdsetpredictionweights' class=toc>mcpdsetpredictionweights</a><br>
<a href='#sub_mcpdsetprior' class=toc>mcpdsetprior</a><br>
<a href='#sub_mcpdsettikhonovregularizer' class=toc>mcpdsettikhonovregularizer</a><br>
<a href='#sub_mcpdsolve' class=toc>mcpdsolve</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_mcpd_simple1' class=toc>mcpd_simple1</a></td><td width=15>&nbsp;</td><td>Simple unconstrained MCPD model (no entry/exit states)</td></tr>
<tr align=left valign=top><td><a href='#example_mcpd_simple2' class=toc>mcpd_simple2</a></td><td width=15>&nbsp;</td><td>Simple MCPD model (no entry/exit states) with equality constraints</td></tr>
</table></div>
<a name='struct_mcpdreport'></a><h3 class=pageheader><code>mcpdreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure is a MCPD training report:
    InnerIterationsCount    -   number of inner iterations of the
                                underlying optimization algorithm
    OuterIterationsCount    -   number of outer iterations of the
                                underlying optimization algorithm
    NFEV                    -   number of merit function evaluations
    TerminationType         -   termination type
                                (same as for MinBLEIC optimizer, positive
                                values denote success, negative ones -
                                failure)

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mcpdreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  inneriterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  outeriterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_mcpdstate'></a><h3 class=pageheader><code>mcpdstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure is a MCPD (Markov Chains for Population Data) solver.

You should use ALGLIB functions in order to work with this object.

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mcpdstate
{
}

</div></pre>
<a name='sub_mcpdaddbc'></a><h3 class=pageheader><code>mcpdaddbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to add bound constraints  on  the  elements  of  the
transition matrix P.

MCPD solver has four types of constraints which can be placed on P:
* user-specified equality constraints (optional)
* user-specified bound constraints (optional)
* user-specified general linear constraints (optional)
* basic constraints (always present):
  * non-negativity: P[i,j]&gt;=0
  * consistency: every column of P sums to 1.0

Final  constraints  which  are  passed  to  the  underlying  optimizer are
calculated  as  intersection  of all present constraints. For example, you
may specify boundary constraint on P[0,0] and equality one:
    0.1&lt;=P[0,0]&lt;=0.9
    P[0,0]=0.5
Such  combination  of  constraints  will  be  silently  reduced  to  their
intersection, which is P[0,0]=0.5.

This  function  can  be  used to ADD bound constraint for one element of P
without changing constraints for other elements.

You  can  also  use  MCPDSetBC()  function  which  allows to  place  bound
constraints  on arbitrary subset of elements of P.   Set of constraints is
specified  by  BndL/BndU matrices, which may contain arbitrary combination
of finite numbers or infinities (like -INF&lt;x&lt;=0.5 or 0.1&lt;=x&lt;+INF).

These functions (MCPDSetBC and MCPDAddBC) interact as follows:
* there is internal matrix of bound constraints which is stored in the
  MCPD solver
* MCPDSetBC() replaces this matrix by another one (SET)
* MCPDAddBC() modifies one element of this matrix and  leaves  other  ones
  unchanged (ADD)
* thus  MCPDAddBC()  call  preserves  all  modifications  done by previous
  calls,  while  MCPDSetBC()  completely discards all changes  done to the
  equality constraints.

INPUT PARAMETERS:
    S       -   solver
    I       -   row index of element being constrained
    J       -   column index of element being constrained
    BndL    -   lower bound
    BndU    -   upper bound

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdaddbc(
    mcpdstate s,
    <font color=navy>int</font> i,
    <font color=navy>int</font> j,
    <font color=navy>double</font> bndl,
    <font color=navy>double</font> bndu)

</div></pre>
<a name='sub_mcpdaddec'></a><h3 class=pageheader><code>mcpdaddec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to add equality constraints on the elements  of  the
transition matrix P.

MCPD solver has four types of constraints which can be placed on P:
* user-specified equality constraints (optional)
* user-specified bound constraints (optional)
* user-specified general linear constraints (optional)
* basic constraints (always present):
  * non-negativity: P[i,j]&gt;=0
  * consistency: every column of P sums to 1.0

Final  constraints  which  are  passed  to  the  underlying  optimizer are
calculated  as  intersection  of all present constraints. For example, you
may specify boundary constraint on P[0,0] and equality one:
    0.1&lt;=P[0,0]&lt;=0.9
    P[0,0]=0.5
Such  combination  of  constraints  will  be  silently  reduced  to  their
intersection, which is P[0,0]=0.5.

This function can be used to ADD equality constraint for one element of  P
without changing constraints for other elements.

You  can  also  use  MCPDSetEC()  function  which  allows  you  to specify
arbitrary set of equality constraints in one call.

These functions (MCPDSetEC and MCPDAddEC) interact as follows:
* there is internal matrix of equality constraints which is stored in the
  MCPD solver
* MCPDSetEC() replaces this matrix by another one (SET)
* MCPDAddEC() modifies one element of this matrix and leaves  other  ones
  unchanged (ADD)
* thus  MCPDAddEC()  call  preserves  all  modifications done by previous
  calls,  while  MCPDSetEC()  completely discards all changes done to the
  equality constraints.

INPUT PARAMETERS:
    S       -   solver
    I       -   row index of element being constrained
    J       -   column index of element being constrained
    C       -   value (constraint for P[I,J]).  Can  be  either  NAN  (no
                constraint) or finite value from [0,1].

NOTES:

1. infinite values of C  will lead to exception being thrown. Values  less
than 0.0 or greater than 1.0 will lead to error code being returned  after
call to MCPDSolve().

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdaddec(mcpdstate s, <font color=navy>int</font> i, <font color=navy>int</font> j, <font color=navy>double</font> c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mcpd_simple2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_mcpdaddtrack'></a><h3 class=pageheader><code>mcpdaddtrack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  is  used to add a track - sequence of system states at the
different moments of its evolution.

You  may  add  one  or several tracks to the MCPD solver. In case you have
several tracks, they won't overwrite each other. For example,  if you pass
two tracks, A1-A2-A3 (system at t=A+1, t=A+2 and t=A+3) and B1-B2-B3, then
solver will try to model transitions from t=A+1 to t=A+2, t=A+2 to  t=A+3,
t=B+1 to t=B+2, t=B+2 to t=B+3. But it WONT mix these two tracks - i.e. it
wont try to model transition from t=A+3 to t=B+1.

INPUT PARAMETERS:
    S       -   solver
    XY      -   track, array[K,N]:
                * I-th row is a state at t=I
                * elements of XY must be non-negative (exception will be
                  thrown on negative elements)
    K       -   number of points in a track
                * if given, only leading K rows of XY are used
                * if not given, automatically determined from size of XY

NOTES:

1. Track may contain either proportional or population data:
   * with proportional data all rows of XY must sum to 1.0, i.e. we have
     proportions instead of absolute population values
   * with population data rows of XY contain population counts and generally
     do not sum to 1.0 (although they still must be non-negative)

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdaddtrack(mcpdstate s, <font color=navy>double</font>[,] xy)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdaddtrack(mcpdstate s, <font color=navy>double</font>[,] xy, <font color=navy>int</font> k)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mcpd_simple1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mcpd_simple2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mcpdcreate'></a><h3 class=pageheader><code>mcpdcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
DESCRIPTION:

This function creates MCPD (Markov Chains for Population Data) solver.

This  solver  can  be  used  to find transition matrix P for N-dimensional
prediction  problem  where transition from X[i] to X[i+1] is  modelled  as
    X[i+1] = P*X[i]
where X[i] and X[i+1] are N-dimensional population vectors (components  of
each X are non-negative), and P is a N*N transition matrix (elements of  P
are non-negative, each column sums to 1.0).

Such models arise when when:
* there is some population of individuals
* individuals can have different states
* individuals can transit from one state to another
* population size is constant, i.e. there is no new individuals and no one
  leaves population
* you want to model transitions of individuals from one state into another

USAGE:

Here we give very brief outline of the MCPD. We strongly recommend you  to
read examples in the ALGLIB Reference Manual and to read ALGLIB User Guide
on data analysis which is available at http://www.alglib.net/dataanalysis/

1. User initializes algorithm state with MCPDCreate() call

2. User  adds  one  or  more  tracks -  sequences of states which describe
   evolution of a system being modelled from different starting conditions

3. User may add optional boundary, equality  and/or  linear constraints on
   the coefficients of P by calling one of the following functions:
   * MCPDSetEC() to set equality constraints
   * MCPDSetBC() to set bound constraints
   * MCPDSetLC() to set linear constraints

4. Optionally,  user  may  set  custom  weights  for prediction errors (by
   default, algorithm assigns non-equal, automatically chosen weights  for
   errors in the prediction of different components of X). It can be  done
   with a call of MCPDSetPredictionWeights() function.

5. User calls MCPDSolve() function which takes algorithm  state and
   pointer (delegate, etc.) to callback function which calculates F/G.

6. User calls MCPDResults() to get solution

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;=1

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdcreate(<font color=navy>int</font> n, <font color=navy>out</font> mcpdstate s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mcpd_simple1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mcpd_simple2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mcpdcreateentry'></a><h3 class=pageheader><code>mcpdcreateentry</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
DESCRIPTION:

This function is a specialized version of MCPDCreate()  function,  and  we
recommend  you  to read comments for this function for general information
about MCPD solver.

This  function  creates  MCPD (Markov Chains for Population  Data)  solver
for &quot;Entry-state&quot; model,  i.e. model  where transition from X[i] to X[i+1]
is modelled as
    X[i+1] = P*X[i]
where
    X[i] and X[i+1] are N-dimensional state vectors
    P is a N*N transition matrix
and  one  selected component of X[] is called &quot;entry&quot; state and is treated
in a special way:
    system state always transits from &quot;entry&quot; state to some another state
    system state can not transit from any state into &quot;entry&quot; state
Such conditions basically mean that row of P which corresponds to  &quot;entry&quot;
state is zero.

Such models arise when:
* there is some population of individuals
* individuals can have different states
* individuals can transit from one state to another
* population size is NOT constant -  at every moment of time there is some
  (unpredictable) amount of &quot;new&quot; individuals, which can transit into  one
  of the states at the next turn, but still no one leaves population
* you want to model transitions of individuals from one state into another
* but you do NOT want to predict amount of &quot;new&quot;  individuals  because  it
  does not depends on individuals already present (hence  system  can  not
  transit INTO entry state - it can only transit FROM it).

This model is discussed  in  more  details  in  the ALGLIB User Guide (see
http://www.alglib.net/dataanalysis/ for more data).

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;=2
    EntryState- index of entry state, in 0..N-1

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdcreateentry(
    <font color=navy>int</font> n,
    <font color=navy>int</font> entrystate,
    <font color=navy>out</font> mcpdstate s)

</div></pre>
<a name='sub_mcpdcreateentryexit'></a><h3 class=pageheader><code>mcpdcreateentryexit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
DESCRIPTION:

This function is a specialized version of MCPDCreate()  function,  and  we
recommend  you  to read comments for this function for general information
about MCPD solver.

This  function  creates  MCPD (Markov Chains for Population  Data)  solver
for &quot;Entry-Exit-states&quot; model, i.e. model where  transition  from  X[i] to
X[i+1] is modelled as
    X[i+1] = P*X[i]
where
    X[i] and X[i+1] are N-dimensional state vectors
    P is a N*N transition matrix
one selected component of X[] is called &quot;entry&quot; state and is treated in  a
special way:
    system state always transits from &quot;entry&quot; state to some another state
    system state can not transit from any state into &quot;entry&quot; state
and another one component of X[] is called &quot;exit&quot; state and is treated  in
a special way too:
    system state can transit from any state into &quot;exit&quot; state
    system state can not transit from &quot;exit&quot; state into any other state
    transition operator discards &quot;exit&quot; state (makes it zero at each turn)
Such conditions basically mean that:
    row of P which corresponds to &quot;entry&quot; state is zero
    column of P which corresponds to &quot;exit&quot; state is zero
Multiplication by such P may decrease sum of vector components.

Such models arise when:
* there is some population of individuals
* individuals can have different states
* individuals can transit from one state to another
* population size is NOT constant
* at every moment of time there is some (unpredictable)  amount  of  &quot;new&quot;
  individuals, which can transit into one of the states at the next turn
* some  individuals  can  move  (predictably)  into &quot;exit&quot; state and leave
  population at the next turn
* you want to model transitions of individuals from one state into another,
  including transitions from the &quot;entry&quot; state and into the &quot;exit&quot; state.
* but you do NOT want to predict amount of &quot;new&quot;  individuals  because  it
  does not depends on individuals already present (hence  system  can  not
  transit INTO entry state - it can only transit FROM it).

This model is discussed  in  more  details  in  the ALGLIB User Guide (see
http://www.alglib.net/dataanalysis/ for more data).

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;=2
    EntryState- index of entry state, in 0..N-1
    ExitState-  index of exit state, in 0..N-1

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdcreateentryexit(
    <font color=navy>int</font> n,
    <font color=navy>int</font> entrystate,
    <font color=navy>int</font> exitstate,
    <font color=navy>out</font> mcpdstate s)

</div></pre>
<a name='sub_mcpdcreateexit'></a><h3 class=pageheader><code>mcpdcreateexit</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
DESCRIPTION:

This function is a specialized version of MCPDCreate()  function,  and  we
recommend  you  to read comments for this function for general information
about MCPD solver.

This  function  creates  MCPD (Markov Chains for Population  Data)  solver
for &quot;Exit-state&quot; model,  i.e. model  where  transition from X[i] to X[i+1]
is modelled as
    X[i+1] = P*X[i]
where
    X[i] and X[i+1] are N-dimensional state vectors
    P is a N*N transition matrix
and  one  selected component of X[] is called &quot;exit&quot;  state and is treated
in a special way:
    system state can transit from any state into &quot;exit&quot; state
    system state can not transit from &quot;exit&quot; state into any other state
    transition operator discards &quot;exit&quot; state (makes it zero at each turn)
Such  conditions  basically  mean  that  column  of P which corresponds to
&quot;exit&quot; state is zero. Multiplication by such P may decrease sum of  vector
components.

Such models arise when:
* there is some population of individuals
* individuals can have different states
* individuals can transit from one state to another
* population size is NOT constant - individuals can move into &quot;exit&quot; state
  and leave population at the next turn, but there are no new individuals
* amount of individuals which leave population can be predicted
* you want to model transitions of individuals from one state into another
  (including transitions into the &quot;exit&quot; state)

This model is discussed  in  more  details  in  the ALGLIB User Guide (see
http://www.alglib.net/dataanalysis/ for more data).

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;=2
    ExitState-  index of exit state, in 0..N-1

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdcreateexit(
    <font color=navy>int</font> n,
    <font color=navy>int</font> exitstate,
    <font color=navy>out</font> mcpdstate s)

</div></pre>
<a name='sub_mcpdresults'></a><h3 class=pageheader><code>mcpdresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
MCPD results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    P       -   array[N,N], transition matrix
    Rep     -   optimization report. You should check Rep.TerminationType
                in  order  to  distinguish  successful  termination  from
                unsuccessful one. Speaking short, positive values  denote
                success, negative ones are failures.
                More information about fields of this  structure  can  be
                found in the comments on MCPDReport datatype.


  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdresults(
    mcpdstate s,
    <font color=navy>out</font> <font color=navy>double</font>[,] p,
    <font color=navy>out</font> mcpdreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mcpd_simple1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mcpd_simple2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mcpdsetbc'></a><h3 class=pageheader><code>mcpdsetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to add bound constraints  on  the  elements  of  the
transition matrix P.

MCPD solver has four types of constraints which can be placed on P:
* user-specified equality constraints (optional)
* user-specified bound constraints (optional)
* user-specified general linear constraints (optional)
* basic constraints (always present):
  * non-negativity: P[i,j]&gt;=0
  * consistency: every column of P sums to 1.0

Final  constraints  which  are  passed  to  the  underlying  optimizer are
calculated  as  intersection  of all present constraints. For example, you
may specify boundary constraint on P[0,0] and equality one:
    0.1&lt;=P[0,0]&lt;=0.9
    P[0,0]=0.5
Such  combination  of  constraints  will  be  silently  reduced  to  their
intersection, which is P[0,0]=0.5.

This  function  can  be  used  to  place bound   constraints  on arbitrary
subset  of  elements  of  P.  Set of constraints is specified by BndL/BndU
matrices, which may contain arbitrary combination  of  finite  numbers  or
infinities (like -INF&lt;x&lt;=0.5 or 0.1&lt;=x&lt;+INF).

You can also use MCPDAddBC() function which allows to ADD bound constraint
for one element of P without changing constraints for other elements.

These functions (MCPDSetBC and MCPDAddBC) interact as follows:
* there is internal matrix of bound constraints which is stored in the
  MCPD solver
* MCPDSetBC() replaces this matrix by another one (SET)
* MCPDAddBC() modifies one element of this matrix and  leaves  other  ones
  unchanged (ADD)
* thus  MCPDAddBC()  call  preserves  all  modifications  done by previous
  calls,  while  MCPDSetBC()  completely discards all changes  done to the
  equality constraints.

INPUT PARAMETERS:
    S       -   solver
    BndL    -   lower bounds constraints, array[N,N]. Elements of BndL can
                be finite numbers or -INF.
    BndU    -   upper bounds constraints, array[N,N]. Elements of BndU can
                be finite numbers or +INF.

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsetbc(
    mcpdstate s,
    <font color=navy>double</font>[,] bndl,
    <font color=navy>double</font>[,] bndu)

</div></pre>
<a name='sub_mcpdsetec'></a><h3 class=pageheader><code>mcpdsetec</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to add equality constraints on the elements  of  the
transition matrix P.

MCPD solver has four types of constraints which can be placed on P:
* user-specified equality constraints (optional)
* user-specified bound constraints (optional)
* user-specified general linear constraints (optional)
* basic constraints (always present):
  * non-negativity: P[i,j]&gt;=0
  * consistency: every column of P sums to 1.0

Final  constraints  which  are  passed  to  the  underlying  optimizer are
calculated  as  intersection  of all present constraints. For example, you
may specify boundary constraint on P[0,0] and equality one:
    0.1&lt;=P[0,0]&lt;=0.9
    P[0,0]=0.5
Such  combination  of  constraints  will  be  silently  reduced  to  their
intersection, which is P[0,0]=0.5.

This  function  can  be  used  to  place equality constraints on arbitrary
subset of elements of P. Set of constraints is specified by EC, which  may
contain either NAN's or finite numbers from [0,1]. NAN denotes absence  of
constraint, finite number denotes equality constraint on specific  element
of P.

You can also  use  MCPDAddEC()  function  which  allows  to  ADD  equality
constraint  for  one  element  of P without changing constraints for other
elements.

These functions (MCPDSetEC and MCPDAddEC) interact as follows:
* there is internal matrix of equality constraints which is stored in  the
  MCPD solver
* MCPDSetEC() replaces this matrix by another one (SET)
* MCPDAddEC() modifies one element of this matrix and  leaves  other  ones
  unchanged (ADD)
* thus  MCPDAddEC()  call  preserves  all  modifications  done by previous
  calls,  while  MCPDSetEC()  completely discards all changes  done to the
  equality constraints.

INPUT PARAMETERS:
    S       -   solver
    EC      -   equality constraints, array[N,N]. Elements of  EC  can  be
                either NAN's or finite  numbers from  [0,1].  NAN  denotes
                absence  of  constraints,  while  finite  value    denotes
                equality constraint on the corresponding element of P.

NOTES:

1. infinite values of EC will lead to exception being thrown. Values  less
than 0.0 or greater than 1.0 will lead to error code being returned  after
call to MCPDSolve().

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsetec(mcpdstate s, <font color=navy>double</font>[,] ec)

</div></pre>
<a name='sub_mcpdsetlc'></a><h3 class=pageheader><code>mcpdsetlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to set linear equality/inequality constraints on the
elements of the transition matrix P.

This function can be used to set one or several general linear constraints
on the elements of P. Two types of constraints are supported:
* equality constraints
* inequality constraints (both less-or-equal and greater-or-equal)

Coefficients  of  constraints  are  specified  by  matrix  C (one  of  the
parameters).  One  row  of  C  corresponds  to  one  constraint.   Because
transition  matrix P has N*N elements,  we  need  N*N columns to store all
coefficients  (they  are  stored row by row), and one more column to store
right part - hence C has N*N+1 columns.  Constraint  kind is stored in the
CT array.

Thus, I-th linear constraint is
    P[0,0]*C[I,0] + P[0,1]*C[I,1] + .. + P[0,N-1]*C[I,N-1] +
        + P[1,0]*C[I,N] + P[1,1]*C[I,N+1] + ... +
        + P[N-1,N-1]*C[I,N*N-1]  ?=?  C[I,N*N]
where ?=? can be either &quot;=&quot; (CT[i]=0), &quot;&lt;=&quot; (CT[i]&lt;0) or &quot;&gt;=&quot; (CT[i]&gt;0).

Your constraint may involve only some subset of P (less than N*N elements).
For example it can be something like
    P[0,0] + P[0,1] = 0.5
In this case you still should pass matrix  with N*N+1 columns, but all its
elements (except for C[0,0], C[0,1] and C[0,N*N-1]) will be zero.

INPUT PARAMETERS:
    S       -   solver
    C       -   array[K,N*N+1] - coefficients of constraints
                (see above for complete description)
    CT      -   array[K] - constraint types
                (see above for complete description)
    K       -   number of equality/inequality constraints, K&gt;=0:
                * if given, only leading K elements of C/CT are used
                * if not given, automatically determined from sizes of C/CT

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsetlc(mcpdstate s, <font color=navy>double</font>[,] c, <font color=navy>int</font>[] ct)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsetlc(
    mcpdstate s,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct,
    <font color=navy>int</font> k)

</div></pre>
<a name='sub_mcpdsetpredictionweights'></a><h3 class=pageheader><code>mcpdsetpredictionweights</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to change prediction weights

MCPD solver scales prediction errors as follows
    Error(P) = ||W*(y-P*x)||^2
where
    x is a system state at time t
    y is a system state at time t+1
    P is a transition matrix
    W is a diagonal scaling matrix

By default, weights are chosen in order  to  minimize  relative prediction
error instead of absolute one. For example, if one component of  state  is
about 0.5 in magnitude and another one is about 0.05, then algorithm  will
make corresponding weights equal to 2.0 and 20.0.

INPUT PARAMETERS:
    S       -   solver
    PW      -   array[N], weights:
                * must be non-negative values (exception will be thrown otherwise)
                * zero values will be replaced by automatically chosen values

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsetpredictionweights(
    mcpdstate s,
    <font color=navy>double</font>[] pw)

</div></pre>
<a name='sub_mcpdsetprior'></a><h3 class=pageheader><code>mcpdsetprior</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  allows to set prior values used for regularization of your
problem.

By default, regularizing term is equal to r*||P-prior_P||^2, where r is  a
small non-zero value,  P is transition matrix, prior_P is identity matrix,
||X||^2 is a sum of squared elements of X.

This  function  allows  you to change prior values prior_P. You  can  also
change r with MCPDSetTikhonovRegularizer() function.

INPUT PARAMETERS:
    S       -   solver
    PP      -   array[N,N], matrix of prior values:
                1. elements must be real numbers from [0,1]
                2. columns must sum to 1.0.
                First property is checked (exception is thrown otherwise),
                while second one is not checked/enforced.

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsetprior(mcpdstate s, <font color=navy>double</font>[,] pp)

</div></pre>
<a name='sub_mcpdsettikhonovregularizer'></a><h3 class=pageheader><code>mcpdsettikhonovregularizer</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function allows to  tune  amount  of  Tikhonov  regularization  being
applied to your problem.

By default, regularizing term is equal to r*||P-prior_P||^2, where r is  a
small non-zero value,  P is transition matrix, prior_P is identity matrix,
||X||^2 is a sum of squared elements of X.

This  function  allows  you to change coefficient r. You can  also  change
prior values with MCPDSetPrior() function.

INPUT PARAMETERS:
    S       -   solver
    V       -   regularization  coefficient, finite non-negative value. It
                is  not  recommended  to specify zero value unless you are
                pretty sure that you want it.

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsettikhonovregularizer(
    mcpdstate s,
    <font color=navy>double</font> v)

</div></pre>
<a name='sub_mcpdsolve'></a><h3 class=pageheader><code>mcpdsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to start solution of the MCPD problem.

After return from this function, you can use MCPDResults() to get solution
and completion code.

  -- ALGLIB --
     Copyright 23.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mcpdsolve(mcpdstate s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mcpd_simple1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mcpd_simple2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='example_mcpd_simple1'></a><h3 class=pageheader>mcpd_simple1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// The very simple MCPD example</font>
    <font color=green>//</font>
    <font color=green>// We have a loan portfolio. Our loans can be in one of two states:</font>
    <font color=green>// * normal loans (<font color=blue><b>&quot;good&quot;</b></font> ones)</font>
    <font color=green>// * past due loans (<font color=blue><b>&quot;bad&quot;</b></font> ones)</font>
    <font color=green>//</font>
    <font color=green>// We assume that:</font>
    <font color=green>// * loans can transition from any state to any other state. In </font>
    <font color=green>//   particular, past due loan can become <font color=blue><b>&quot;good&quot;</b></font> one at any moment </font>
    <font color=green>//   with same (fixed) probability. Not realistic, but it is toy example :)</font>
    <font color=green>// * portfolio size does not change over time</font>
    <font color=green>//</font>
    <font color=green>// Thus, we have following model</font>
    <font color=green>//     state_new = P*state_old</font>
    <font color=green>// where</font>
    <font color=green>//         ( p00  p01 )</font>
    <font color=green>//     P = (          )</font>
    <font color=green>//         ( p10  p11 )</font>
    <font color=green>//</font>
    <font color=green>// We want to model transitions between these two states using MCPD</font>
    <font color=green>// approach (Markov Chains <font color=navy>for</font> Proportional/Population Data), i.e.</font>
    <font color=green>// to restore hidden transition matrix P using actual portfolio data.</font>
    <font color=green>// We have:</font>
    <font color=green>// * poportional data, i.e. proportion of loans in the normal and past </font>
    <font color=green>//   due states (not portfolio size measured in some currency, although </font>
    <font color=green>//   it is possible to work with population data too)</font>
    <font color=green>// * two tracks, i.e. two sequences which describe portfolio</font>
    <font color=green>//   evolution from two different starting states: [1,0] (all loans </font>
    <font color=green>//   are <font color=blue><b>&quot;good&quot;</b></font>) and [0.8,0.2] (only 80% of portfolio is in the <font color=blue><b>&quot;good&quot;</b></font></font>
    <font color=green>//   state)</font>
    <font color=green>//</font>
    alglib.mcpdstate s;
    alglib.mcpdreport rep;
    <font color=navy>double</font>[,] p;
    <font color=navy>double</font>[,] track0 = new <font color=navy>double</font>[,]{{1.00000,0.00000},{0.95000,0.05000},{0.92750,0.07250},{0.91738,0.08263},{0.91282,0.08718}};
    <font color=navy>double</font>[,] track1 = new <font color=navy>double</font>[,]{{0.80000,0.20000},{0.86000,0.14000},{0.88700,0.11300},{0.89915,0.10085}};

    alglib.mcpdcreate(2, <font color=navy>out</font> s);
    alglib.mcpdaddtrack(s, track0);
    alglib.mcpdaddtrack(s, track1);
    alglib.mcpdsolve(s);
    alglib.mcpdresults(s, <font color=navy>out</font> p, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Hidden matrix P is equal to</font>
    <font color=green>//         ( 0.95  0.50 )</font>
    <font color=green>//         (            )</font>
    <font color=green>//         ( 0.05  0.50 )</font>
    <font color=green>// which means that <font color=blue><b>&quot;good&quot;</b></font> loans can become <font color=blue><b>&quot;bad&quot;</b></font> with 5% probability, </font>
    <font color=green>// <font color=navy>while</font> <font color=blue><b>&quot;bad&quot;</b></font> loans will <font color=navy>return</font> to good state with 50% probability.</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(p,2)); <font color=green>// EXPECTED: [[0.95,0.50],[0.05,0.50]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_mcpd_simple2'></a><h3 class=pageheader>mcpd_simple2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Simple MCPD example</font>
    <font color=green>//</font>
    <font color=green>// We have a loan portfolio. Our loans can be in one of three states:</font>
    <font color=green>// * normal loans</font>
    <font color=green>// * past due loans</font>
    <font color=green>// * charged off loans</font>
    <font color=green>//</font>
    <font color=green>// We assume that:</font>
    <font color=green>// * normal loan can stay normal or become past due (but not charged off)</font>
    <font color=green>// * past due loan can stay past due, become normal or charged off</font>
    <font color=green>// * charged off loan will stay charged off <font color=navy>for</font> the rest of eternity</font>
    <font color=green>// * portfolio size does not change over time</font>
    <font color=green>// Not realistic, but it is toy example :)</font>
    <font color=green>//</font>
    <font color=green>// Thus, we have following model</font>
    <font color=green>//     state_new = P*state_old</font>
    <font color=green>// where</font>
    <font color=green>//         ( p00  p01    )</font>
    <font color=green>//     P = ( p10  p11    )</font>
    <font color=green>//         (      p21  1 )</font>
    <font color=green>// i.e. four elements of P are known a priori.</font>
    <font color=green>//</font>
    <font color=green>// Although it is possible (given enough data) to In order to enforce </font>
    <font color=green>// this property we set equality constraints on these elements.</font>
    <font color=green>//</font>
    <font color=green>// We want to model transitions between these two states using MCPD</font>
    <font color=green>// approach (Markov Chains <font color=navy>for</font> Proportional/Population Data), i.e.</font>
    <font color=green>// to restore hidden transition matrix P using actual portfolio data.</font>
    <font color=green>// We have:</font>
    <font color=green>// * poportional data, i.e. proportion of loans in the current and past </font>
    <font color=green>//   due states (not portfolio size measured in some currency, although </font>
    <font color=green>//   it is possible to work with population data too)</font>
    <font color=green>// * two tracks, i.e. two sequences which describe portfolio</font>
    <font color=green>//   evolution from two different starting states: [1,0,0] (all loans </font>
    <font color=green>//   are <font color=blue><b>&quot;good&quot;</b></font>) and [0.8,0.2,0.0] (only 80% of portfolio is in the <font color=blue><b>&quot;good&quot;</b></font></font>
    <font color=green>//   state)</font>
    <font color=green>//</font>
    alglib.mcpdstate s;
    alglib.mcpdreport rep;
    <font color=navy>double</font>[,] p;
    <font color=navy>double</font>[,] track0 = new <font color=navy>double</font>[,]{{1.000000,0.000000,0.000000},{0.950000,0.050000,0.000000},{0.927500,0.060000,0.012500},{0.911125,0.061375,0.027500},{0.896256,0.060900,0.042844}};
    <font color=navy>double</font>[,] track1 = new <font color=navy>double</font>[,]{{0.800000,0.200000,0.000000},{0.860000,0.090000,0.050000},{0.862000,0.065500,0.072500},{0.851650,0.059475,0.088875},{0.838805,0.057451,0.103744}};

    alglib.mcpdcreate(3, <font color=navy>out</font> s);
    alglib.mcpdaddtrack(s, track0);
    alglib.mcpdaddtrack(s, track1);
    alglib.mcpdaddec(s, 0, 2, 0.0);
    alglib.mcpdaddec(s, 1, 2, 0.0);
    alglib.mcpdaddec(s, 2, 2, 1.0);
    alglib.mcpdaddec(s, 2, 0, 0.0);
    alglib.mcpdsolve(s);
    alglib.mcpdresults(s, <font color=navy>out</font> p, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Hidden matrix P is equal to</font>
    <font color=green>//         ( 0.95 0.50      )</font>
    <font color=green>//         ( 0.05 0.25      )</font>
    <font color=green>//         (      0.25 1.00 ) </font>
    <font color=green>// which means that <font color=blue><b>&quot;good&quot;</b></font> loans can become past due with 5% probability, </font>
    <font color=green>// <font color=navy>while</font> past due loans will become charged off with 25% probability or</font>
    <font color=green>// <font color=navy>return</font> back to normal state with 50% probability.</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(p,2)); <font color=green>// EXPECTED: [[0.95,0.50,0.00],[0.05,0.25,0.00],[0.00,0.25,1.00]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_minbleic></a><h2 class=pageheader><code>minbleic</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minbleicreport' class=toc>minbleicreport</a><br>
<a href='#struct_minbleicstate' class=toc>minbleicstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minbleiccreate' class=toc>minbleiccreate</a><br>
<a href='#sub_minbleiccreatef' class=toc>minbleiccreatef</a><br>
<a href='#sub_minbleicoptimize' class=toc>minbleicoptimize</a><br>
<a href='#sub_minbleicrequesttermination' class=toc>minbleicrequesttermination</a><br>
<a href='#sub_minbleicrestartfrom' class=toc>minbleicrestartfrom</a><br>
<a href='#sub_minbleicresults' class=toc>minbleicresults</a><br>
<a href='#sub_minbleicresultsbuf' class=toc>minbleicresultsbuf</a><br>
<a href='#sub_minbleicsetbc' class=toc>minbleicsetbc</a><br>
<a href='#sub_minbleicsetcond' class=toc>minbleicsetcond</a><br>
<a href='#sub_minbleicsetgradientcheck' class=toc>minbleicsetgradientcheck</a><br>
<a href='#sub_minbleicsetlc' class=toc>minbleicsetlc</a><br>
<a href='#sub_minbleicsetprecdefault' class=toc>minbleicsetprecdefault</a><br>
<a href='#sub_minbleicsetprecdiag' class=toc>minbleicsetprecdiag</a><br>
<a href='#sub_minbleicsetprecscale' class=toc>minbleicsetprecscale</a><br>
<a href='#sub_minbleicsetscale' class=toc>minbleicsetscale</a><br>
<a href='#sub_minbleicsetstpmax' class=toc>minbleicsetstpmax</a><br>
<a href='#sub_minbleicsetxrep' class=toc>minbleicsetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minbleic_d_1' class=toc>minbleic_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with bound constraints</td></tr>
<tr align=left valign=top><td><a href='#example_minbleic_d_2' class=toc>minbleic_d_2</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with linear inequality constraints</td></tr>
<tr align=left valign=top><td><a href='#example_minbleic_ftrim' class=toc>minbleic_ftrim</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by BLEIC, function with singularities</td></tr>
<tr align=left valign=top><td><a href='#example_minbleic_numdiff' class=toc>minbleic_numdiff</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with bound constraints and numerical differentiation</td></tr>
</table></div>
<a name='struct_minbleicreport'></a><h3 class=pageheader><code>minbleicreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores optimization report:
* IterationsCount           number of iterations
* NFEV                      number of gradient evaluations
* TerminationType           termination type (see below)

TERMINATION CODES

TerminationType field contains completion code, which can be:
  -8    internal integrity control detected  infinite  or  NAN  values  in
        function/gradient. Abnormal termination signalled.
  -7    gradient verification failed.
        See MinBLEICSetGradientCheck() for more information.
  -3    inconsistent constraints. Feasible point is
        either nonexistent or too hard to find. Try to
        restart optimizer with better initial approximation
   1    relative function improvement is no more than EpsF.
   2    relative step is no more than EpsX.
   4    gradient norm is no more than EpsG
   5    MaxIts steps was taken
   7    stopping conditions are too stringent,
        further improvement is impossible,
        X contains best point found so far.
   8    terminated by user who called minbleicrequesttermination(). X contains
        point which was &quot;current accepted&quot; when  termination  request  was
        submitted.

ADDITIONAL FIELDS

There are additional fields which can be used for debugging:
* DebugEqErr                error in the equality constraints (2-norm)
* DebugFS                   f, calculated at projection of initial point
                            to the feasible set
* DebugFF                   f, calculated at the final point
* DebugDX                   |X_start-X_final|
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minbleicreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>double</font>               debugeqerr;
    <font color=navy>public</font> <font color=navy>double</font>               debugfs;
    <font color=navy>public</font> <font color=navy>double</font>               debugff;
    <font color=navy>public</font> <font color=navy>double</font>               debugdx;
    <font color=navy>public</font> <font color=navy>int</font>                  debugfeasqpits;
    <font color=navy>public</font> <font color=navy>int</font>                  debugfeasgpaits;
    <font color=navy>public</font> <font color=navy>int</font>                  inneriterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  outeriterationscount;
}

</div></pre>
<a name='struct_minbleicstate'></a><h3 class=pageheader><code>minbleicstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores nonlinear optimizer state.
You should use functions provided by MinBLEIC subpackage to work with this
object
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minbleicstate
{
}

</div></pre>
<a name='sub_minbleiccreate'></a><h3 class=pageheader><code>minbleiccreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                     BOUND CONSTRAINED OPTIMIZATION
       WITH ADDITIONAL LINEAR EQUALITY AND INEQUALITY CONSTRAINTS

DESCRIPTION:
The  subroutine  minimizes  function   F(x)  of N arguments subject to any
combination of:
* bound constraints
* linear inequality constraints
* linear equality constraints

REQUIREMENTS:
* user must provide function value and gradient
* starting point X0 must be feasible or
  not too far away from the feasible set
* grad(f) must be Lipschitz continuous on a level set:
  L = { x : f(x)&lt;=f(x0) }
* function must be defined everywhere on the feasible set F

USAGE:

Constrained optimization if far more complex than the unconstrained one.
Here we give very brief outline of the BLEIC optimizer. We strongly recommend
you to read examples in the ALGLIB Reference Manual and to read ALGLIB User Guide
on optimization, which is available at http://www.alglib.net/optimization/

1. User initializes algorithm state with MinBLEICCreate() call

2. USer adds boundary and/or linear constraints by calling
   MinBLEICSetBC() and MinBLEICSetLC() functions.

3. User sets stopping conditions with MinBLEICSetCond().

4. User calls MinBLEICOptimize() function which takes algorithm  state and
   pointer (delegate, etc.) to callback function which calculates F/G.

5. User calls MinBLEICResults() to get solution

6. Optionally user may call MinBLEICRestartFrom() to solve another problem
   with same N but another starting point.
   MinBLEICRestartFrom() allows to reuse already initialized structure.


INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size ofX
    X       -   starting point, array[N]:
                * it is better to set X to a feasible point
                * but X can be infeasible, in which case algorithm will try
                  to find feasible point first, using X as initial
                  approximation.

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleiccreate(
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minbleicstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleiccreate(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minbleicstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minbleic_ftrim' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleiccreatef'></a><h3 class=pageheader><code>minbleiccreatef</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The subroutine is finite difference variant of MinBLEICCreate().  It  uses
finite differences in order to differentiate target function.

Description below contains information which is specific to  this function
only. We recommend to read comments on MinBLEICCreate() in  order  to  get
more information about creation of BLEIC optimizer.

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    X       -   starting point, array[0..N-1].
    DiffStep-   differentiation step, &gt;0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTES:
1. algorithm uses 4-point central formula for differentiation.
2. differentiation step along I-th axis is equal to DiffStep*S[I] where
   S[] is scaling vector which can be set by MinBLEICSetScale() call.
3. we recommend you to use moderate values of  differentiation  step.  Too
   large step will result in too large truncation  errors, while too small
   step will result in too large numerical  errors.  1.0E-6  can  be  good
   value to start with.
4. Numerical  differentiation  is   very   inefficient  -   one   gradient
   calculation needs 4*N function evaluations. This function will work for
   any N - either small (1...10), moderate (10...100) or  large  (100...).
   However, performance penalty will be too severe for any N's except  for
   small ones.
   We should also say that code which relies on numerical  differentiation
   is  less  robust and precise. CG needs exact gradient values. Imprecise
   gradient may slow  down  convergence, especially  on  highly  nonlinear
   problems.
   Thus  we  recommend to use this function for fast prototyping on small-
   dimensional problems only, and to implement analytical gradient as soon
   as possible.

  -- ALGLIB --
     Copyright 16.05.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleiccreatef(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minbleicstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleiccreatef(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minbleicstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_numdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicoptimize'></a><h3 class=pageheader><code>minbleicoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    func    -   callback which calculates function (or merit function)
                value func at given point x
    grad    -   callback which calculates function (or merit function)
                value func and gradient grad at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL

NOTES:

1. This function has two different implementations: one which  uses  exact
   (analytical) user-supplied gradient,  and one which uses function value
   only  and  numerically  differentiates  function  in  order  to  obtain
   gradient.

   Depending  on  the  specific  function  used to create optimizer object
   (either  MinBLEICCreate() for analytical gradient or  MinBLEICCreateF()
   for numerical differentiation) you should choose appropriate variant of
   MinBLEICOptimize() - one  which  accepts  function  AND gradient or one
   which accepts function ONLY.

   Be careful to choose variant of MinBLEICOptimize() which corresponds to
   your optimization scheme! Table below lists different  combinations  of
   callback (function/gradient) passed to MinBLEICOptimize()  and specific
   function used to create optimizer.


                     |         USER PASSED TO MinBLEICOptimize()
   CREATED WITH      |  function only   |  function and gradient
   ------------------------------------------------------------
   MinBLEICCreateF() |     work                FAIL
   MinBLEICCreate()  |     FAIL                work

   Here &quot;FAIL&quot; denotes inappropriate combinations  of  optimizer  creation
   function  and  MinBLEICOptimize()  version.   Attemps   to   use   such
   combination (for  example,  to  create optimizer with MinBLEICCreateF()
   and  to  pass  gradient  information  to  MinCGOptimize()) will lead to
   exception being thrown. Either  you  did  not pass gradient when it WAS
   needed or you passed gradient when it was NOT needed.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minbleicoptimize(minbleicstate state, ndimensional_func func, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minbleicoptimize(minbleicstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minbleic_numdiff' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minbleic_ftrim' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicrequesttermination'></a><h3 class=pageheader><code>minbleicrequesttermination</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine submits request for termination of running  optimizer.  It
should be called from user-supplied callback when user decides that it  is
time to &quot;smoothly&quot; terminate optimization process.  As  result,  optimizer
stops at point which was &quot;current accepted&quot; when termination  request  was
submitted and returns error code 8 (successful termination).

INPUT PARAMETERS:
    State   -   optimizer structure

NOTE: after  request  for  termination  optimizer  may   perform   several
      additional calls to user-supplied callbacks. It does  NOT  guarantee
      to stop immediately - it just guarantees that these additional calls
      will be discarded later.

NOTE: calling this function on optimizer which is NOT running will have no
      effect.

NOTE: multiple calls to this function are possible. First call is counted,
      subsequent calls are silently ignored.

  -- ALGLIB --
     Copyright 08.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicrequesttermination(minbleicstate state)

</div></pre>
<a name='sub_minbleicrestartfrom'></a><h3 class=pageheader><code>minbleicrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine restarts algorithm from new point.
All optimization parameters (including constraints) are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have  same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure previously allocated with MinBLEICCreate call.
    X       -   new starting point.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicrestartfrom(
    minbleicstate state,
    <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_minbleicresults'></a><h3 class=pageheader><code>minbleicresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
BLEIC results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report. You should check Rep.TerminationType
                in  order  to  distinguish  successful  termination  from
                unsuccessful one:
                * -8    internal integrity control  detected  infinite or
                        NAN   values   in   function/gradient.   Abnormal
                        termination signalled.
                * -7   gradient verification failed.
                       See MinBLEICSetGradientCheck() for more information.
                * -3   inconsistent constraints. Feasible point is
                       either nonexistent or too hard to find. Try to
                       restart optimizer with better initial approximation
                *  1   relative function improvement is no more than EpsF.
                *  2   scaled step is no more than EpsX.
                *  4   scaled gradient norm is no more than EpsG.
                *  5   MaxIts steps was taken
                *  8   terminated by user who called minbleicrequesttermination().
                       X contains point which was &quot;current accepted&quot;  when
                       termination request was submitted.
                More information about fields of this  structure  can  be
                found in the comments on MinBLEICReport datatype.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicresults(
    minbleicstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minbleicreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minbleic_numdiff' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minbleic_ftrim' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicresultsbuf'></a><h3 class=pageheader><code>minbleicresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
BLEIC results

Buffered implementation of MinBLEICResults() which uses pre-allocated buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicresultsbuf(
    minbleicstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minbleicreport rep)

</div></pre>
<a name='sub_minbleicsetbc'></a><h3 class=pageheader><code>minbleicsetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets boundary constraints for BLEIC optimizer.

Boundary constraints are inactive by default (after initial creation).
They are preserved after algorithm restart with MinBLEICRestartFrom().

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    BndL    -   lower bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very small number or -INF.
    BndU    -   upper bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very large number or +INF.

NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
variable will be &quot;frozen&quot; at X[i]=BndL[i]=BndU[i].

NOTE 2: this solver has following useful properties:
* bound constraints are always satisfied exactly
* function is evaluated only INSIDE area specified by  bound  constraints,
  even  when  numerical  differentiation is used (algorithm adjusts  nodes
  according to boundary constraints)

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetbc(
    minbleicstate state,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_numdiff' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetcond'></a><h3 class=pageheader><code>minbleicsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for the optimizer.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinBLEICSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |v|&lt;=EpsX is fulfilled, where:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - step vector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinBLEICSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0 and EpsX=0 and MaxIts=0 (simultaneously) will lead
to automatic stopping criterion selection.

NOTE: when SetCond() called with non-zero MaxIts, BLEIC solver may perform
      slightly more than MaxIts iterations. I.e., MaxIts  sets  non-strict
      limit on iterations count.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetcond(
    minbleicstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minbleic_numdiff' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetgradientcheck'></a><h3 class=pageheader><code>minbleicsetgradientcheck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  turns  on  verification  of  the  user-supplied analytic
gradient:
* user calls this subroutine before optimization begins
* MinBLEICOptimize() is called
* prior to  actual  optimization, for each component  of  parameters being
  optimized X[i] algorithm performs following steps:
  * two trial steps are made to X[i]-TestStep*S[i] and X[i]+TestStep*S[i],
    where X[i] is i-th component of the initial point and S[i] is a  scale
    of i-th parameter
  * if needed, steps are bounded with respect to constraints on X[]
  * F(X) is evaluated at these trial points
  * we perform one more evaluation in the middle point of the interval
  * we  build  cubic  model using function values and derivatives at trial
    points and we compare its prediction with actual value in  the  middle
    point
  * in case difference between prediction and actual value is higher  than
    some predetermined threshold, algorithm stops with completion code -7;
    Rep.VarIdx is set to index of the parameter with incorrect derivative.
* after verification is over, algorithm proceeds to the actual optimization.

NOTE 1: verification  needs  N (parameters count) gradient evaluations. It
        is very costly and you should use  it  only  for  low  dimensional
        problems,  when  you  want  to  be  sure  that  you've   correctly
        calculated  analytic  derivatives.  You  should  not use it in the
        production code (unless you want to check derivatives provided  by
        some third party).

NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
        (so large that function behaviour is significantly non-cubic) will
        lead to false alarms. You may use  different  step  for  different
        parameters by means of setting scale with MinBLEICSetScale().

NOTE 3: this function may lead to false positives. In case it reports that
        I-th  derivative was calculated incorrectly, you may decrease test
        step  and  try  one  more  time  - maybe your function changes too
        sharply  and  your  step  is  too  large for such rapidly chanding
        function.

INPUT PARAMETERS:
    State       -   structure used to store algorithm state
    TestStep    -   verification step:
                    * TestStep=0 turns verification off
                    * TestStep&gt;0 activates verification

  -- ALGLIB --
     Copyright 15.06.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetgradientcheck(
    minbleicstate state,
    <font color=navy>double</font> teststep)

</div></pre>
<a name='sub_minbleicsetlc'></a><h3 class=pageheader><code>minbleicsetlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets linear constraints for BLEIC optimizer.

Linear constraints are inactive by default (after initial creation).
They are preserved after algorithm restart with MinBLEICRestartFrom().

INPUT PARAMETERS:
    State   -   structure previously allocated with MinBLEICCreate call.
    C       -   linear constraints, array[K,N+1].
                Each row of C represents one constraint, either equality
                or inequality (see below):
                * first N elements correspond to coefficients,
                * last element corresponds to the right part.
                All elements of C (including right part) must be finite.
    CT      -   type of constraints, array[K]:
                * if CT[i]&gt;0, then I-th constraint is C[i,*]*x &gt;= C[i,n+1]
                * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
                * if CT[i]&lt;0, then I-th constraint is C[i,*]*x &lt;= C[i,n+1]
    K       -   number of equality/inequality constraints, K&gt;=0:
                * if given, only leading K elements of C/CT are used
                * if not given, automatically determined from sizes of C/CT

NOTE 1: linear (non-bound) constraints are satisfied only approximately:
* there always exists some minor violation (about Epsilon in magnitude)
  due to rounding errors
* numerical differentiation, if used, may  lead  to  function  evaluations
  outside  of the feasible  area,   because   algorithm  does  NOT  change
  numerical differentiation formula according to linear constraints.
If you want constraints to be  satisfied  exactly, try to reformulate your
problem  in  such  manner  that  all constraints will become boundary ones
(this kind of constraints is always satisfied exactly, both in  the  final
solution and in all intermediate points).

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetlc(
    minbleicstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetlc(
    minbleicstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct,
    <font color=navy>int</font> k)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetprecdefault'></a><h3 class=pageheader><code>minbleicsetprecdefault</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification of the preconditioner: preconditioning is turned off.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetprecdefault(minbleicstate state)

</div></pre>
<a name='sub_minbleicsetprecdiag'></a><h3 class=pageheader><code>minbleicsetprecdiag</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification  of  the  preconditioner:  diagonal of approximate Hessian is
used.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    D       -   diagonal of the approximate Hessian, array[0..N-1],
                (if larger, only leading N elements are used).

NOTE 1: D[i] should be positive. Exception will be thrown otherwise.

NOTE 2: you should pass diagonal of approximate Hessian - NOT ITS INVERSE.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetprecdiag(
    minbleicstate state,
    <font color=navy>double</font>[] d)

</div></pre>
<a name='sub_minbleicsetprecscale'></a><h3 class=pageheader><code>minbleicsetprecscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification of the preconditioner: scale-based diagonal preconditioning.

This preconditioning mode can be useful when you  don't  have  approximate
diagonal of Hessian, but you know that your  variables  are  badly  scaled
(for  example,  one  variable is in [1,10], and another in [1000,100000]),
and most part of the ill-conditioning comes from different scales of vars.

In this case simple  scale-based  preconditioner,  with H[i] = 1/(s[i]^2),
can greatly improve convergence.

IMPRTANT: you should set scale of your variables  with  MinBLEICSetScale()
call  (before  or after MinBLEICSetPrecScale() call). Without knowledge of
the scale of your variables scale-based preconditioner will be  just  unit
matrix.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetprecscale(minbleicstate state)

</div></pre>
<a name='sub_minbleicsetscale'></a><h3 class=pageheader><code>minbleicsetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for BLEIC optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Scaling is also used by finite difference variant of the optimizer  - step
along I-th axis is equal to DiffStep*S[I].

In  most  optimizers  (and  in  the  BLEIC  too)  scaling is NOT a form of
preconditioning. It just  affects  stopping  conditions.  You  should  set
preconditioner  by  separate  call  to  one  of  the  MinBLEICSetPrec...()
functions.

There is a special  preconditioning  mode, however,  which  uses   scaling
coefficients to form diagonal preconditioning matrix. You  can  turn  this
mode on, if you want.   But  you should understand that scaling is not the
same thing as preconditioning - these are two different, although  related
forms of tuning solver.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetscale(
    minbleicstate state,
    <font color=navy>double</font>[] s)

</div></pre>
<a name='sub_minbleicsetstpmax'></a><h3 class=pageheader><code>minbleicsetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

IMPORTANT: this feature is hard to combine with preconditioning. You can't
set upper limit on step length, when you solve optimization  problem  with
linear (non-boundary) constraints AND preconditioner turned on.

When  non-boundary  constraints  are  present,  you  have to either a) use
preconditioner, or b) use upper limit on step length.  YOU CAN'T USE BOTH!
In this case algorithm will terminate with appropriate error code.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  lead   to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetstpmax(
    minbleicstate state,
    <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_minbleicsetxrep'></a><h3 class=pageheader><code>minbleicsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinBLEICOptimize().

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetxrep(
    minbleicstate state,
    <font color=navy>bool</font> needxrep)

</div></pre>
<a name='example_minbleic_d_1'></a><h3 class=pageheader>minbleic_d_1 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// subject to bound constraints -1&lt;=x&lt;=+1, -1&lt;=y&lt;=+1, using BLEIC optimizer.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{-1,-1};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{+1,+1};
    alglib.minbleicstate state;
    alglib.minbleicreport rep;

    <font color=green>//</font>
    <font color=green>// These variables define stopping conditions <font color=navy>for</font> the optimizer.</font>
    <font color=green>//</font>
    <font color=green>// We use very simple condition - |g|&lt;=epsg</font>
    <font color=green>//</font>
    <font color=navy>double</font> epsg = 0.000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;

    <font color=green>//</font>
    <font color=green>// Now we are ready to actually optimize something:</font>
    <font color=green>// * first we create optimizer</font>
    <font color=green>// * we add boundary constraints</font>
    <font color=green>// * we tune stopping conditions</font>
    <font color=green>// * and, finally, optimize and obtain results...</font>
    <font color=green>//</font>
    alglib.minbleiccreate(x, <font color=navy>out</font> state);
    alglib.minbleicsetbc(state, bndl, bndu);
    alglib.minbleicsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minbleicoptimize(state, function1_grad, null, null);
    alglib.minbleicresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// ...and evaluate these results</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-1,1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minbleic_d_2'></a><h3 class=pageheader>minbleic_d_2 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// subject to inequality constraints:</font>
    <font color=green>// * x&gt;=2 (posed as general linear constraint),</font>
    <font color=green>// * x+y&gt;=6</font>
    <font color=green>// using BLEIC optimizer.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{5,5};
    <font color=navy>double</font>[,] c = new <font color=navy>double</font>[,]{{1,0,2},{1,1,6}};
    <font color=navy>int</font>[] ct = new <font color=navy>int</font>[]{1,1};
    alglib.minbleicstate state;
    alglib.minbleicreport rep;

    <font color=green>//</font>
    <font color=green>// These variables define stopping conditions <font color=navy>for</font> the optimizer.</font>
    <font color=green>//</font>
    <font color=green>// We use very simple condition - |g|&lt;=epsg</font>
    <font color=green>//</font>
    <font color=navy>double</font> epsg = 0.000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;

    <font color=green>//</font>
    <font color=green>// Now we are ready to actually optimize something:</font>
    <font color=green>// * first we create optimizer</font>
    <font color=green>// * we add linear constraints</font>
    <font color=green>// * we tune stopping conditions</font>
    <font color=green>// * and, finally, optimize and obtain results...</font>
    <font color=green>//</font>
    alglib.minbleiccreate(x, <font color=navy>out</font> state);
    alglib.minbleicsetlc(state, c, ct);
    alglib.minbleicsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minbleicoptimize(state, function1_grad, null, null);
    alglib.minbleicresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// ...and evaluate these results</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [2,4]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minbleic_ftrim'></a><h3 class=pageheader>minbleic_ftrim example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> s1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates f(x) = (1+x)^(-0.2) + (1-x)^(-0.3) + 1000*x and its gradient.</font>
    <font color=green>//</font>
    <font color=green>// function is trimmed when we calculate it near the singular points or outside of the [-1,+1].</font>
    <font color=green>// Note that we <font color=navy>do</font> NOT calculate gradient in this case.</font>
    <font color=green>//</font>
    <font color=navy>if</font>( (x[0]&lt;=-0.999999999999) || (x[0]&gt;=+0.999999999999) )
    {
        func = 1.0E+300;
        <font color=navy>return</font>;
    }
    func = System.Math.Pow(1+x[0],-0.2) + System.Math.Pow(1-x[0],-0.3) + 1000*x[0];
    grad[0] = -0.2*System.Math.Pow(1+x[0],-1.2) +0.3*System.Math.Pow(1-x[0],-1.3) + 1000;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x) = (1+x)^(-0.2) + (1-x)^(-0.3) + 1000*x.</font>
    <font color=green>//</font>
    <font color=green>// This function is undefined outside of (-1,+1) and has singularities at x=-1 and x=+1.</font>
    <font color=green>// Special technique called <font color=blue><b>&quot;function trimming&quot;</b></font> allows us to solve this optimization problem </font>
    <font color=green>// - without using boundary constraints!</font>
    <font color=green>//</font>
    <font color=green>// See http://www.alglib.net/optimization/tipsandtricks.php#ftrimming <font color=navy>for</font> more information</font>
    <font color=green>// on this subject.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0};
    <font color=navy>double</font> epsg = 1.0e-6;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minbleicstate state;
    alglib.minbleicreport rep;

    alglib.minbleiccreate(x, <font color=navy>out</font> state);
    alglib.minbleicsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minbleicoptimize(state, s1_grad, null, null);
    alglib.minbleicresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,5)); <font color=green>// EXPECTED: [-0.99917305]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minbleic_numdiff'></a><h3 class=pageheader>minbleic_numdiff example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_func(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// subject to bound constraints -1&lt;=x&lt;=+1, -1&lt;=y&lt;=+1, using BLEIC optimizer.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{-1,-1};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{+1,+1};
    alglib.minbleicstate state;
    alglib.minbleicreport rep;

    <font color=green>//</font>
    <font color=green>// These variables define stopping conditions <font color=navy>for</font> the optimizer.</font>
    <font color=green>//</font>
    <font color=green>// We use very simple condition - |g|&lt;=epsg</font>
    <font color=green>//</font>
    <font color=navy>double</font> epsg = 0.000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;

    <font color=green>//</font>
    <font color=green>// This variable contains differentiation step</font>
    <font color=green>//</font>
    <font color=navy>double</font> diffstep = 1.0e-6;

    <font color=green>//</font>
    <font color=green>// Now we are ready to actually optimize something:</font>
    <font color=green>// * first we create optimizer</font>
    <font color=green>// * we add boundary constraints</font>
    <font color=green>// * we tune stopping conditions</font>
    <font color=green>// * and, finally, optimize and obtain results...</font>
    <font color=green>//</font>
    alglib.minbleiccreatef(x, diffstep, <font color=navy>out</font> state);
    alglib.minbleicsetbc(state, bndl, bndu);
    alglib.minbleicsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minbleicoptimize(state, function1_func, null, null);
    alglib.minbleicresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// ...and evaluate these results</font>
    <font color=green>//</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-1,1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_mincg></a><h2 class=pageheader><code>mincg</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mincgreport' class=toc>mincgreport</a><br>
<a href='#struct_mincgstate' class=toc>mincgstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mincgcreate' class=toc>mincgcreate</a><br>
<a href='#sub_mincgcreatef' class=toc>mincgcreatef</a><br>
<a href='#sub_mincgoptimize' class=toc>mincgoptimize</a><br>
<a href='#sub_mincgrequesttermination' class=toc>mincgrequesttermination</a><br>
<a href='#sub_mincgrestartfrom' class=toc>mincgrestartfrom</a><br>
<a href='#sub_mincgresults' class=toc>mincgresults</a><br>
<a href='#sub_mincgresultsbuf' class=toc>mincgresultsbuf</a><br>
<a href='#sub_mincgsetcgtype' class=toc>mincgsetcgtype</a><br>
<a href='#sub_mincgsetcond' class=toc>mincgsetcond</a><br>
<a href='#sub_mincgsetgradientcheck' class=toc>mincgsetgradientcheck</a><br>
<a href='#sub_mincgsetprecdefault' class=toc>mincgsetprecdefault</a><br>
<a href='#sub_mincgsetprecdiag' class=toc>mincgsetprecdiag</a><br>
<a href='#sub_mincgsetprecscale' class=toc>mincgsetprecscale</a><br>
<a href='#sub_mincgsetscale' class=toc>mincgsetscale</a><br>
<a href='#sub_mincgsetstpmax' class=toc>mincgsetstpmax</a><br>
<a href='#sub_mincgsetxrep' class=toc>mincgsetxrep</a><br>
<a href='#sub_mincgsuggeststep' class=toc>mincgsuggeststep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_mincg_d_1' class=toc>mincg_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by CG</td></tr>
<tr align=left valign=top><td><a href='#example_mincg_d_2' class=toc>mincg_d_2</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with additional settings and restarts</td></tr>
<tr align=left valign=top><td><a href='#example_mincg_ftrim' class=toc>mincg_ftrim</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by CG, function with singularities</td></tr>
<tr align=left valign=top><td><a href='#example_mincg_numdiff' class=toc>mincg_numdiff</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by CG with numerical differentiation</td></tr>
</table></div>
<a name='struct_mincgreport'></a><h3 class=pageheader><code>mincgreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores optimization report:
* IterationsCount           total number of inner iterations
* NFEV                      number of gradient evaluations
* TerminationType           termination type (see below)

TERMINATION CODES

TerminationType field contains completion code, which can be:
  -8    internal integrity control detected  infinite  or  NAN  values  in
        function/gradient. Abnormal termination signalled.
  -7    gradient verification failed.
        See MinCGSetGradientCheck() for more information.
   1    relative function improvement is no more than EpsF.
   2    relative step is no more than EpsX.
   4    gradient norm is no more than EpsG
   5    MaxIts steps was taken
   7    stopping conditions are too stringent,
        further improvement is impossible,
        X contains best point found so far.
   8    terminated by user who called mincgrequesttermination(). X contains
        point which was &quot;current accepted&quot; when  termination  request  was
        submitted.

Other fields of this structure are not documented and should not be used!
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mincgreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_mincgstate'></a><h3 class=pageheader><code>mincgstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores state of the nonlinear CG optimizer.

You should use ALGLIB functions to work with this object.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mincgstate
{
}

</div></pre>
<a name='sub_mincgcreate'></a><h3 class=pageheader><code>mincgcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
        NONLINEAR CONJUGATE GRADIENT METHOD

DESCRIPTION:
The subroutine minimizes function F(x) of N arguments by using one of  the
nonlinear conjugate gradient methods.

These CG methods are globally convergent (even on non-convex functions) as
long as grad(f) is Lipschitz continuous in  a  some  neighborhood  of  the
L = { x : f(x)&lt;=f(x0) }.


REQUIREMENTS:
Algorithm will request following information during its operation:
* function value F and its gradient G (simultaneously) at given point X


USAGE:
1. User initializes algorithm state with MinCGCreate() call
2. User tunes solver parameters with MinCGSetCond(), MinCGSetStpMax() and
   other functions
3. User calls MinCGOptimize() function which takes algorithm  state   and
   pointer (delegate, etc.) to callback function which calculates F/G.
4. User calls MinCGResults() to get solution
5. Optionally, user may call MinCGRestartFrom() to solve another  problem
   with same N but another starting point and/or another function.
   MinCGRestartFrom() allows to reuse already initialized structure.


INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    X       -   starting point, array[0..N-1].

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 25.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgcreate(<font color=navy>double</font>[] x, <font color=navy>out</font> mincgstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgcreate(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> mincgstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_mincg_ftrim' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgcreatef'></a><h3 class=pageheader><code>mincgcreatef</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The subroutine is finite difference variant of MinCGCreate(). It uses
finite differences in order to differentiate target function.

Description below contains information which is specific to this function
only. We recommend to read comments on MinCGCreate() in order to get more
information about creation of CG optimizer.

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    X       -   starting point, array[0..N-1].
    DiffStep-   differentiation step, &gt;0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTES:
1. algorithm uses 4-point central formula for differentiation.
2. differentiation step along I-th axis is equal to DiffStep*S[I] where
   S[] is scaling vector which can be set by MinCGSetScale() call.
3. we recommend you to use moderate values of  differentiation  step.  Too
   large step will result in too large truncation  errors, while too small
   step will result in too large numerical  errors.  1.0E-6  can  be  good
   value to start with.
4. Numerical  differentiation  is   very   inefficient  -   one   gradient
   calculation needs 4*N function evaluations. This function will work for
   any N - either small (1...10), moderate (10...100) or  large  (100...).
   However, performance penalty will be too severe for any N's except  for
   small ones.
   We should also say that code which relies on numerical  differentiation
   is  less  robust  and  precise.  L-BFGS  needs  exact  gradient values.
   Imprecise  gradient may slow down  convergence,  especially  on  highly
   nonlinear problems.
   Thus  we  recommend to use this function for fast prototyping on small-
   dimensional problems only, and to implement analytical gradient as soon
   as possible.

  -- ALGLIB --
     Copyright 16.05.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgcreatef(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> mincgstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgcreatef(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> mincgstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_numdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgoptimize'></a><h3 class=pageheader><code>mincgoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    func    -   callback which calculates function (or merit function)
                value func at given point x
    grad    -   callback which calculates function (or merit function)
                value func and gradient grad at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL

NOTES:

1. This function has two different implementations: one which  uses  exact
   (analytical) user-supplied  gradient, and one which uses function value
   only  and  numerically  differentiates  function  in  order  to  obtain
   gradient.

   Depending  on  the  specific  function  used to create optimizer object
   (either MinCGCreate()  for analytical gradient  or  MinCGCreateF()  for
   numerical differentiation) you should  choose  appropriate  variant  of
   MinCGOptimize() - one which accepts function AND gradient or one  which
   accepts function ONLY.

   Be careful to choose variant of MinCGOptimize()  which  corresponds  to
   your optimization scheme! Table below lists different  combinations  of
   callback (function/gradient) passed  to  MinCGOptimize()  and  specific
   function used to create optimizer.


                  |         USER PASSED TO MinCGOptimize()
   CREATED WITH   |  function only   |  function and gradient
   ------------------------------------------------------------
   MinCGCreateF() |     work                FAIL
   MinCGCreate()  |     FAIL                work

   Here &quot;FAIL&quot; denotes inappropriate combinations  of  optimizer  creation
   function and MinCGOptimize() version. Attemps to use  such  combination
   (for  example,  to create optimizer with  MinCGCreateF()  and  to  pass
   gradient information to MinCGOptimize()) will lead to  exception  being
   thrown. Either  you  did  not  pass  gradient when it WAS needed or you
   passed gradient when it was NOT needed.

  -- ALGLIB --
     Copyright 20.04.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> mincgoptimize(mincgstate state, ndimensional_func func, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> mincgoptimize(mincgstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_mincg_numdiff' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_mincg_ftrim' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgrequesttermination'></a><h3 class=pageheader><code>mincgrequesttermination</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine submits request for termination of running  optimizer.  It
should be called from user-supplied callback when user decides that it  is
time to &quot;smoothly&quot; terminate optimization process.  As  result,  optimizer
stops at point which was &quot;current accepted&quot; when termination  request  was
submitted and returns error code 8 (successful termination).

INPUT PARAMETERS:
    State   -   optimizer structure

NOTE: after  request  for  termination  optimizer  may   perform   several
      additional calls to user-supplied callbacks. It does  NOT  guarantee
      to stop immediately - it just guarantees that these additional calls
      will be discarded later.

NOTE: calling this function on optimizer which is NOT running will have no
      effect.

NOTE: multiple calls to this function are possible. First call is counted,
      subsequent calls are silently ignored.

  -- ALGLIB --
     Copyright 08.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgrequesttermination(mincgstate state)

</div></pre>
<a name='sub_mincgrestartfrom'></a><h3 class=pageheader><code>mincgrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  restarts  CG  algorithm from new point. All optimization
parameters are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure used to store algorithm state.
    X       -   new starting point.

  -- ALGLIB --
     Copyright 30.07.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgrestartfrom(mincgstate state, <font color=navy>double</font>[] x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgresults'></a><h3 class=pageheader><code>mincgresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conjugate gradient results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -8    internal integrity control  detected  infinite
                            or NAN values in  function/gradient.  Abnormal
                            termination signalled.
                    * -7    gradient verification failed.
                            See MinCGSetGradientCheck() for more information.
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible,
                            we return best X found so far
                    *  8    terminated by user
                * Rep.IterationsCount contains iterations count
                * NFEV countains number of function calculations

  -- ALGLIB --
     Copyright 20.04.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgresults(
    mincgstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> mincgreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_mincg_numdiff' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_mincg_ftrim' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgresultsbuf'></a><h3 class=pageheader><code>mincgresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conjugate gradient results

Buffered implementation of MinCGResults(), which uses pre-allocated buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 20.04.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgresultsbuf(
    mincgstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    mincgreport rep)

</div></pre>
<a name='sub_mincgsetcgtype'></a><h3 class=pageheader><code>mincgsetcgtype</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets CG algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    CGType  -   algorithm type:
                * -1    automatic selection of the best algorithm
                * 0     DY (Dai and Yuan) algorithm
                * 1     Hybrid DY-HS algorithm

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetcgtype(mincgstate state, <font color=navy>int</font> cgtype)

</div></pre>
<a name='sub_mincgsetcond'></a><h3 class=pageheader><code>mincgsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for CG optimization algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinCGSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |v|&lt;=EpsX is fulfilled, where:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - ste pvector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinCGSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetcond(
    mincgstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_mincg_numdiff' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgsetgradientcheck'></a><h3 class=pageheader><code>mincgsetgradientcheck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

This  subroutine  turns  on  verification  of  the  user-supplied analytic
gradient:
* user calls this subroutine before optimization begins
* MinCGOptimize() is called
* prior to  actual  optimization, for each component  of  parameters being
  optimized X[i] algorithm performs following steps:
  * two trial steps are made to X[i]-TestStep*S[i] and X[i]+TestStep*S[i],
    where X[i] is i-th component of the initial point and S[i] is a  scale
    of i-th parameter
  * F(X) is evaluated at these trial points
  * we perform one more evaluation in the middle point of the interval
  * we  build  cubic  model using function values and derivatives at trial
    points and we compare its prediction with actual value in  the  middle
    point
  * in case difference between prediction and actual value is higher  than
    some predetermined threshold, algorithm stops with completion code -7;
    Rep.VarIdx is set to index of the parameter with incorrect derivative.
* after verification is over, algorithm proceeds to the actual optimization.

NOTE 1: verification  needs  N (parameters count) gradient evaluations. It
        is very costly and you should use  it  only  for  low  dimensional
        problems,  when  you  want  to  be  sure  that  you've   correctly
        calculated  analytic  derivatives.  You  should  not use it in the
        production code (unless you want to check derivatives provided  by
        some third party).

NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
        (so large that function behaviour is significantly non-cubic) will
        lead to false alarms. You may use  different  step  for  different
        parameters by means of setting scale with MinCGSetScale().

NOTE 3: this function may lead to false positives. In case it reports that
        I-th  derivative was calculated incorrectly, you may decrease test
        step  and  try  one  more  time  - maybe your function changes too
        sharply  and  your  step  is  too  large for such rapidly chanding
        function.

INPUT PARAMETERS:
    State       -   structure used to store algorithm state
    TestStep    -   verification step:
                    * TestStep=0 turns verification off
                    * TestStep&gt;0 activates verification

  -- ALGLIB --
     Copyright 31.05.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetgradientcheck(
    mincgstate state,
    <font color=navy>double</font> teststep)

</div></pre>
<a name='sub_mincgsetprecdefault'></a><h3 class=pageheader><code>mincgsetprecdefault</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification of the preconditioner: preconditioning is turned off.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
iterations.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetprecdefault(mincgstate state)

</div></pre>
<a name='sub_mincgsetprecdiag'></a><h3 class=pageheader><code>mincgsetprecdiag</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification  of  the  preconditioner:  diagonal of approximate Hessian is
used.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    D       -   diagonal of the approximate Hessian, array[0..N-1],
                (if larger, only leading N elements are used).

NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
iterations.

NOTE 2: D[i] should be positive. Exception will be thrown otherwise.

NOTE 3: you should pass diagonal of approximate Hessian - NOT ITS INVERSE.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetprecdiag(mincgstate state, <font color=navy>double</font>[] d)

</div></pre>
<a name='sub_mincgsetprecscale'></a><h3 class=pageheader><code>mincgsetprecscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification of the preconditioner: scale-based diagonal preconditioning.

This preconditioning mode can be useful when you  don't  have  approximate
diagonal of Hessian, but you know that your  variables  are  badly  scaled
(for  example,  one  variable is in [1,10], and another in [1000,100000]),
and most part of the ill-conditioning comes from different scales of vars.

In this case simple  scale-based  preconditioner,  with H[i] = 1/(s[i]^2),
can greatly improve convergence.

IMPRTANT: you should set scale of your variables with MinCGSetScale() call
(before or after MinCGSetPrecScale() call). Without knowledge of the scale
of your variables scale-based preconditioner will be just unit matrix.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
iterations.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetprecscale(mincgstate state)

</div></pre>
<a name='sub_mincgsetscale'></a><h3 class=pageheader><code>mincgsetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for CG optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Scaling is also used by finite difference variant of CG optimizer  -  step
along I-th axis is equal to DiffStep*S[I].

In   most   optimizers  (and  in  the  CG  too)  scaling is NOT a form  of
preconditioning. It just  affects  stopping  conditions.  You  should  set
preconditioner by separate call to one of the MinCGSetPrec...() functions.

There  is  special  preconditioning  mode, however,  which  uses   scaling
coefficients to form diagonal preconditioning matrix. You  can  turn  this
mode on, if you want.   But  you should understand that scaling is not the
same thing as preconditioning - these are two different, although  related
forms of tuning solver.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetscale(mincgstate state, <font color=navy>double</font>[] s)

</div></pre>
<a name='sub_mincgsetstpmax'></a><h3 class=pageheader><code>mincgsetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetstpmax(mincgstate state, <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_mincgsetxrep'></a><h3 class=pageheader><code>mincgsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinCGOptimize().

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsetxrep(mincgstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='sub_mincgsuggeststep'></a><h3 class=pageheader><code>mincgsuggeststep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function allows to suggest initial step length to the CG algorithm.

Suggested  step  length  is used as starting point for the line search. It
can be useful when you have  badly  scaled  problem,  i.e.  when  ||grad||
(which is used as initial estimate for the first step) is many  orders  of
magnitude different from the desired step.

Line search  may  fail  on  such problems without good estimate of initial
step length. Imagine, for example, problem with ||grad||=10^50 and desired
step equal to 0.1 Line  search function will use 10^50  as  initial  step,
then  it  will  decrease step length by 2 (up to 20 attempts) and will get
10^44, which is still too large.

This function allows us to tell than line search should  be  started  from
some moderate step length, like 1.0, so algorithm will be able  to  detect
desired step length in a several searches.

Default behavior (when no step is suggested) is to use preconditioner,  if
it is available, to generate initial estimate of step length.

This function influences only first iteration of algorithm. It  should  be
called between MinCGCreate/MinCGRestartFrom() call and MinCGOptimize call.
Suggested step is ignored if you have preconditioner.

INPUT PARAMETERS:
    State   -   structure used to store algorithm state.
    Stp     -   initial estimate of the step length.
                Can be zero (no estimate).

  -- ALGLIB --
     Copyright 30.07.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mincgsuggeststep(mincgstate state, <font color=navy>double</font> stp)

</div></pre>
<a name='example_mincg_d_1'></a><h3 class=pageheader>mincg_d_1 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// with nonlinear conjugate gradient method.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.mincgstate state;
    alglib.mincgreport rep;

    alglib.mincgcreate(x, <font color=navy>out</font> state);
    alglib.mincgsetcond(state, epsg, epsf, epsx, maxits);
    alglib.mincgoptimize(state, function1_grad, null, null);
    alglib.mincgresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_mincg_d_2'></a><h3 class=pageheader>mincg_d_2 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// with nonlinear conjugate gradient method.</font>
    <font color=green>//</font>
    <font color=green>// Several advanced techniques are demonstrated:</font>
    <font color=green>// * upper limit on step size</font>
    <font color=green>// * restart from new point</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>double</font> stpmax = 0.1;
    <font color=navy>int</font> maxits = 0;
    alglib.mincgstate state;
    alglib.mincgreport rep;

    <font color=green>// first run</font>
    alglib.mincgcreate(x, <font color=navy>out</font> state);
    alglib.mincgsetcond(state, epsg, epsf, epsx, maxits);
    alglib.mincgsetstpmax(state, stpmax);
    alglib.mincgoptimize(state, function1_grad, null, null);
    alglib.mincgresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>

    <font color=green>// second run - algorithm is restarted with mincgrestartfrom()</font>
    x = new <font color=navy>double</font>[]{10,10};
    alglib.mincgrestartfrom(state, x);
    alglib.mincgoptimize(state, function1_grad, null, null);
    alglib.mincgresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_mincg_ftrim'></a><h3 class=pageheader>mincg_ftrim example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> s1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates f(x) = (1+x)^(-0.2) + (1-x)^(-0.3) + 1000*x and its gradient.</font>
    <font color=green>//</font>
    <font color=green>// function is trimmed when we calculate it near the singular points or outside of the [-1,+1].</font>
    <font color=green>// Note that we <font color=navy>do</font> NOT calculate gradient in this case.</font>
    <font color=green>//</font>
    <font color=navy>if</font>( (x[0]&lt;=-0.999999999999) || (x[0]&gt;=+0.999999999999) )
    {
        func = 1.0E+300;
        <font color=navy>return</font>;
    }
    func = System.Math.Pow(1+x[0],-0.2) + System.Math.Pow(1-x[0],-0.3) + 1000*x[0];
    grad[0] = -0.2*System.Math.Pow(1+x[0],-1.2) +0.3*System.Math.Pow(1-x[0],-1.3) + 1000;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x) = (1+x)^(-0.2) + (1-x)^(-0.3) + 1000*x.</font>
    <font color=green>// This function has singularities at the boundary of the [-1,+1], but technique called</font>
    <font color=green>// <font color=blue><b>&quot;function trimming&quot;</b></font> allows us to solve this optimization problem.</font>
    <font color=green>//</font>
    <font color=green>// See http://www.alglib.net/optimization/tipsandtricks.php#ftrimming <font color=navy>for</font> more information</font>
    <font color=green>// on this subject.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0};
    <font color=navy>double</font> epsg = 1.0e-6;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.mincgstate state;
    alglib.mincgreport rep;

    alglib.mincgcreate(x, <font color=navy>out</font> state);
    alglib.mincgsetcond(state, epsg, epsf, epsx, maxits);
    alglib.mincgoptimize(state, s1_grad, null, null);
    alglib.mincgresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,5)); <font color=green>// EXPECTED: [-0.99917305]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_mincg_numdiff'></a><h3 class=pageheader>mincg_numdiff example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_func(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// using numerical differentiation to calculate gradient.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>double</font> diffstep = 1.0e-6;
    <font color=navy>int</font> maxits = 0;
    alglib.mincgstate state;
    alglib.mincgreport rep;

    alglib.mincgcreatef(x, diffstep, <font color=navy>out</font> state);
    alglib.mincgsetcond(state, epsg, epsf, epsx, maxits);
    alglib.mincgoptimize(state, function1_func, null, null);
    alglib.mincgresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_mincomp></a><h2 class=pageheader><code>mincomp</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minasareport' class=toc>minasareport</a><br>
<a href='#struct_minasastate' class=toc>minasastate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minasacreate' class=toc>minasacreate</a><br>
<a href='#sub_minasaoptimize' class=toc>minasaoptimize</a><br>
<a href='#sub_minasarestartfrom' class=toc>minasarestartfrom</a><br>
<a href='#sub_minasaresults' class=toc>minasaresults</a><br>
<a href='#sub_minasaresultsbuf' class=toc>minasaresultsbuf</a><br>
<a href='#sub_minasasetalgorithm' class=toc>minasasetalgorithm</a><br>
<a href='#sub_minasasetcond' class=toc>minasasetcond</a><br>
<a href='#sub_minasasetstpmax' class=toc>minasasetstpmax</a><br>
<a href='#sub_minasasetxrep' class=toc>minasasetxrep</a><br>
<a href='#sub_minbleicsetbarrierdecay' class=toc>minbleicsetbarrierdecay</a><br>
<a href='#sub_minbleicsetbarrierwidth' class=toc>minbleicsetbarrierwidth</a><br>
<a href='#sub_minlbfgssetcholeskypreconditioner' class=toc>minlbfgssetcholeskypreconditioner</a><br>
<a href='#sub_minlbfgssetdefaultpreconditioner' class=toc>minlbfgssetdefaultpreconditioner</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_minasareport'></a><h3 class=pageheader><code>minasareport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minasareport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  activeconstraints;
}

</div></pre>
<a name='struct_minasastate'></a><h3 class=pageheader><code>minasastate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minasastate
{
}

</div></pre>
<a name='sub_minasacreate'></a><h3 class=pageheader><code>minasacreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 25.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasacreate(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu,
    <font color=navy>out</font> minasastate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasacreate(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu,
    <font color=navy>out</font> minasastate state)

</div></pre>
<a name='sub_minasaoptimize'></a><h3 class=pageheader><code>minasaoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    grad    -   callback which calculates function (or merit function)
                value func and gradient grad at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL


  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minasaoptimize(minasastate state, ndimensional_grad grad, ndimensional_rep rep, object obj)

</div></pre>
<a name='sub_minasarestartfrom'></a><h3 class=pageheader><code>minasarestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 30.07.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasarestartfrom(
    minasastate state,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<a name='sub_minasaresults'></a><h3 class=pageheader><code>minasaresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasaresults(
    minasastate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minasareport rep)

</div></pre>
<a name='sub_minasaresultsbuf'></a><h3 class=pageheader><code>minasaresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasaresultsbuf(
    minasastate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minasareport rep)

</div></pre>
<a name='sub_minasasetalgorithm'></a><h3 class=pageheader><code>minasasetalgorithm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasasetalgorithm(
    minasastate state,
    <font color=navy>int</font> algotype)

</div></pre>
<a name='sub_minasasetcond'></a><h3 class=pageheader><code>minasasetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasasetcond(
    minasastate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_minasasetstpmax'></a><h3 class=pageheader><code>minasasetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasasetstpmax(
    minasastate state,
    <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_minasasetxrep'></a><h3 class=pageheader><code>minasasetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete optimization algorithm.
Was replaced by MinBLEIC subpackage.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minasasetxrep(minasastate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='sub_minbleicsetbarrierdecay'></a><h3 class=pageheader><code>minbleicsetbarrierdecay</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is obsolete function which was used by previous version of the  BLEIC
optimizer. It does nothing in the current version of BLEIC.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetbarrierdecay(
    minbleicstate state,
    <font color=navy>double</font> mudecay)

</div></pre>
<a name='sub_minbleicsetbarrierwidth'></a><h3 class=pageheader><code>minbleicsetbarrierwidth</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is obsolete function which was used by previous version of the  BLEIC
optimizer. It does nothing in the current version of BLEIC.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minbleicsetbarrierwidth(
    minbleicstate state,
    <font color=navy>double</font> mu)

</div></pre>
<a name='sub_minlbfgssetcholeskypreconditioner'></a><h3 class=pageheader><code>minlbfgssetcholeskypreconditioner</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete function, use MinLBFGSSetCholeskyPreconditioner() instead.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetcholeskypreconditioner(
    minlbfgsstate state,
    <font color=navy>double</font>[,] p,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_minlbfgssetdefaultpreconditioner'></a><h3 class=pageheader><code>minlbfgssetdefaultpreconditioner</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Obsolete function, use MinLBFGSSetPrecDefault() instead.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetdefaultpreconditioner(
    minlbfgsstate state)

</div></pre>
<a name=unit_minlbfgs></a><h2 class=pageheader><code>minlbfgs</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minlbfgsreport' class=toc>minlbfgsreport</a><br>
<a href='#struct_minlbfgsstate' class=toc>minlbfgsstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minlbfgscreate' class=toc>minlbfgscreate</a><br>
<a href='#sub_minlbfgscreatef' class=toc>minlbfgscreatef</a><br>
<a href='#sub_minlbfgsoptimize' class=toc>minlbfgsoptimize</a><br>
<a href='#sub_minlbfgsrequesttermination' class=toc>minlbfgsrequesttermination</a><br>
<a href='#sub_minlbfgsrestartfrom' class=toc>minlbfgsrestartfrom</a><br>
<a href='#sub_minlbfgsresults' class=toc>minlbfgsresults</a><br>
<a href='#sub_minlbfgsresultsbuf' class=toc>minlbfgsresultsbuf</a><br>
<a href='#sub_minlbfgssetcond' class=toc>minlbfgssetcond</a><br>
<a href='#sub_minlbfgssetgradientcheck' class=toc>minlbfgssetgradientcheck</a><br>
<a href='#sub_minlbfgssetpreccholesky' class=toc>minlbfgssetpreccholesky</a><br>
<a href='#sub_minlbfgssetprecdefault' class=toc>minlbfgssetprecdefault</a><br>
<a href='#sub_minlbfgssetprecdiag' class=toc>minlbfgssetprecdiag</a><br>
<a href='#sub_minlbfgssetprecscale' class=toc>minlbfgssetprecscale</a><br>
<a href='#sub_minlbfgssetscale' class=toc>minlbfgssetscale</a><br>
<a href='#sub_minlbfgssetstpmax' class=toc>minlbfgssetstpmax</a><br>
<a href='#sub_minlbfgssetxrep' class=toc>minlbfgssetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minlbfgs_d_1' class=toc>minlbfgs_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by L-BFGS</td></tr>
<tr align=left valign=top><td><a href='#example_minlbfgs_d_2' class=toc>minlbfgs_d_2</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with additional settings and restarts</td></tr>
<tr align=left valign=top><td><a href='#example_minlbfgs_ftrim' class=toc>minlbfgs_ftrim</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by LBFGS, function with singularities</td></tr>
<tr align=left valign=top><td><a href='#example_minlbfgs_numdiff' class=toc>minlbfgs_numdiff</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by L-BFGS with numerical differentiation</td></tr>
</table></div>
<a name='struct_minlbfgsreport'></a><h3 class=pageheader><code>minlbfgsreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores optimization report:
* IterationsCount           total number of inner iterations
* NFEV                      number of gradient evaluations
* TerminationType           termination type (see below)

TERMINATION CODES

TerminationType field contains completion code, which can be:
  -8    internal integrity control detected  infinite  or  NAN  values  in
        function/gradient. Abnormal termination signalled.
  -7    gradient verification failed.
        See MinLBFGSSetGradientCheck() for more information.
   1    relative function improvement is no more than EpsF.
   2    relative step is no more than EpsX.
   4    gradient norm is no more than EpsG
   5    MaxIts steps was taken
   7    stopping conditions are too stringent,
        further improvement is impossible,
        X contains best point found so far.
   8    terminated    by  user  who  called  minlbfgsrequesttermination().
        X contains point which was   &quot;current accepted&quot;  when  termination
        request was submitted.

Other fields of this structure are not documented and should not be used!
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minlbfgsreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_minlbfgsstate'></a><h3 class=pageheader><code>minlbfgsstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minlbfgsstate
{
}

</div></pre>
<a name='sub_minlbfgscreate'></a><h3 class=pageheader><code>minlbfgscreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION

DESCRIPTION:
The subroutine minimizes function F(x) of N arguments by  using  a  quasi-
Newton method (LBFGS scheme) which is optimized to use  a  minimum  amount
of memory.
The subroutine generates the approximation of an inverse Hessian matrix by
using information about the last M steps of the algorithm  (instead of N).
It lessens a required amount of memory from a value  of  order  N^2  to  a
value of order 2*N*M.


REQUIREMENTS:
Algorithm will request following information during its operation:
* function value F and its gradient G (simultaneously) at given point X


USAGE:
1. User initializes algorithm state with MinLBFGSCreate() call
2. User tunes solver parameters with MinLBFGSSetCond() MinLBFGSSetStpMax()
   and other functions
3. User calls MinLBFGSOptimize() function which takes algorithm  state and
   pointer (delegate, etc.) to callback function which calculates F/G.
4. User calls MinLBFGSResults() to get solution
5. Optionally user may call MinLBFGSRestartFrom() to solve another problem
   with same N/M but another starting point and/or another function.
   MinLBFGSRestartFrom() allows to reuse already initialized structure.


INPUT PARAMETERS:
    N       -   problem dimension. N&gt;0
    M       -   number of corrections in the BFGS scheme of Hessian
                approximation update. Recommended value:  3&lt;=M&lt;=7. The smaller
                value causes worse convergence, the bigger will  not  cause  a
                considerably better convergence, but will cause a fall in  the
                performance. M&lt;=N.
    X       -   initial solution approximation, array[0..N-1].


OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state


NOTES:
1. you may tune stopping conditions with MinLBFGSSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLBFGSSetStpMax() function to bound algorithm's  steps.  However,
   L-BFGS rarely needs such a tuning.


  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgscreate(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlbfgsstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgscreate(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlbfgsstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_ftrim' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgscreatef'></a><h3 class=pageheader><code>minlbfgscreatef</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The subroutine is finite difference variant of MinLBFGSCreate().  It  uses
finite differences in order to differentiate target function.

Description below contains information which is specific to  this function
only. We recommend to read comments on MinLBFGSCreate() in  order  to  get
more information about creation of LBFGS optimizer.

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    M       -   number of corrections in the BFGS scheme of Hessian
                approximation update. Recommended value:  3&lt;=M&lt;=7. The smaller
                value causes worse convergence, the bigger will  not  cause  a
                considerably better convergence, but will cause a fall in  the
                performance. M&lt;=N.
    X       -   starting point, array[0..N-1].
    DiffStep-   differentiation step, &gt;0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTES:
1. algorithm uses 4-point central formula for differentiation.
2. differentiation step along I-th axis is equal to DiffStep*S[I] where
   S[] is scaling vector which can be set by MinLBFGSSetScale() call.
3. we recommend you to use moderate values of  differentiation  step.  Too
   large step will result in too large truncation  errors, while too small
   step will result in too large numerical  errors.  1.0E-6  can  be  good
   value to start with.
4. Numerical  differentiation  is   very   inefficient  -   one   gradient
   calculation needs 4*N function evaluations. This function will work for
   any N - either small (1...10), moderate (10...100) or  large  (100...).
   However, performance penalty will be too severe for any N's except  for
   small ones.
   We should also say that code which relies on numerical  differentiation
   is   less  robust  and  precise.  LBFGS  needs  exact  gradient values.
   Imprecise gradient may slow  down  convergence,  especially  on  highly
   nonlinear problems.
   Thus  we  recommend to use this function for fast prototyping on small-
   dimensional problems only, and to implement analytical gradient as soon
   as possible.

  -- ALGLIB --
     Copyright 16.05.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgscreatef(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minlbfgsstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgscreatef(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minlbfgsstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_numdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsoptimize'></a><h3 class=pageheader><code>minlbfgsoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    func    -   callback which calculates function (or merit function)
                value func at given point x
    grad    -   callback which calculates function (or merit function)
                value func and gradient grad at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL

NOTES:

1. This function has two different implementations: one which  uses  exact
   (analytical) user-supplied gradient,  and one which uses function value
   only  and  numerically  differentiates  function  in  order  to  obtain
   gradient.

   Depending  on  the  specific  function  used to create optimizer object
   (either MinLBFGSCreate() for analytical gradient  or  MinLBFGSCreateF()
   for numerical differentiation) you should choose appropriate variant of
   MinLBFGSOptimize() - one  which  accepts  function  AND gradient or one
   which accepts function ONLY.

   Be careful to choose variant of MinLBFGSOptimize() which corresponds to
   your optimization scheme! Table below lists different  combinations  of
   callback (function/gradient) passed to MinLBFGSOptimize()  and specific
   function used to create optimizer.


                     |         USER PASSED TO MinLBFGSOptimize()
   CREATED WITH      |  function only   |  function and gradient
   ------------------------------------------------------------
   MinLBFGSCreateF() |     work                FAIL
   MinLBFGSCreate()  |     FAIL                work

   Here &quot;FAIL&quot; denotes inappropriate combinations  of  optimizer  creation
   function  and  MinLBFGSOptimize()  version.   Attemps   to   use   such
   combination (for example, to create optimizer with MinLBFGSCreateF() and
   to pass gradient information to MinCGOptimize()) will lead to exception
   being thrown. Either  you  did  not pass gradient when it WAS needed or
   you passed gradient when it was NOT needed.

  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlbfgsoptimize(minlbfgsstate state, ndimensional_func func, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlbfgsoptimize(minlbfgsstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_numdiff' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_ftrim' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsrequesttermination'></a><h3 class=pageheader><code>minlbfgsrequesttermination</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine submits request for termination of running  optimizer.  It
should be called from user-supplied callback when user decides that it  is
time to &quot;smoothly&quot; terminate optimization process.  As  result,  optimizer
stops at point which was &quot;current accepted&quot; when termination  request  was
submitted and returns error code 8 (successful termination).

INPUT PARAMETERS:
    State   -   optimizer structure

NOTE: after  request  for  termination  optimizer  may   perform   several
      additional calls to user-supplied callbacks. It does  NOT  guarantee
      to stop immediately - it just guarantees that these additional calls
      will be discarded later.

NOTE: calling this function on optimizer which is NOT running will have no
      effect.

NOTE: multiple calls to this function are possible. First call is counted,
      subsequent calls are silently ignored.

  -- ALGLIB --
     Copyright 08.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgsrequesttermination(minlbfgsstate state)

</div></pre>
<a name='sub_minlbfgsrestartfrom'></a><h3 class=pageheader><code>minlbfgsrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine restarts LBFGS algorithm from new point. All optimization
parameters are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure used to store algorithm state
    X       -   new starting point.

  -- ALGLIB --
     Copyright 30.07.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgsrestartfrom(
    minlbfgsstate state,
    <font color=navy>double</font>[] x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsresults'></a><h3 class=pageheader><code>minlbfgsresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
L-BFGS algorithm results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -8    internal integrity control  detected  infinite
                            or NAN values in  function/gradient.  Abnormal
                            termination signalled.
                    * -7    gradient verification failed.
                            See MinLBFGSSetGradientCheck() for more information.
                    * -2    rounding errors prevent further improvement.
                            X contains best point found.
                    * -1    incorrect parameters were specified
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
                    *  8    terminated by user who called minlbfgsrequesttermination().
                            X contains point which was &quot;current accepted&quot; when
                            termination request was submitted.
                * Rep.IterationsCount contains iterations count
                * NFEV countains number of function calculations

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgsresults(
    minlbfgsstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlbfgsreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_numdiff' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_ftrim' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsresultsbuf'></a><h3 class=pageheader><code>minlbfgsresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
L-BFGS algorithm results

Buffered implementation of MinLBFGSResults which uses pre-allocated buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 20.08.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgsresultsbuf(
    minlbfgsstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minlbfgsreport rep)

</div></pre>
<a name='sub_minlbfgssetcond'></a><h3 class=pageheader><code>minlbfgssetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for L-BFGS optimization algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinLBFGSSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |v|&lt;=EpsX is fulfilled, where:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - ste pvector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinLBFGSSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetcond(
    minlbfgsstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_numdiff' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgssetgradientcheck'></a><h3 class=pageheader><code>minlbfgssetgradientcheck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  turns  on  verification  of  the  user-supplied analytic
gradient:
* user calls this subroutine before optimization begins
* MinLBFGSOptimize() is called
* prior to  actual  optimization, for each component  of  parameters being
  optimized X[i] algorithm performs following steps:
  * two trial steps are made to X[i]-TestStep*S[i] and X[i]+TestStep*S[i],
    where X[i] is i-th component of the initial point and S[i] is a  scale
    of i-th parameter
  * if needed, steps are bounded with respect to constraints on X[]
  * F(X) is evaluated at these trial points
  * we perform one more evaluation in the middle point of the interval
  * we  build  cubic  model using function values and derivatives at trial
    points and we compare its prediction with actual value in  the  middle
    point
  * in case difference between prediction and actual value is higher  than
    some predetermined threshold, algorithm stops with completion code -7;
    Rep.VarIdx is set to index of the parameter with incorrect derivative.
* after verification is over, algorithm proceeds to the actual optimization.

NOTE 1: verification  needs  N (parameters count) gradient evaluations. It
        is very costly and you should use  it  only  for  low  dimensional
        problems,  when  you  want  to  be  sure  that  you've   correctly
        calculated  analytic  derivatives.  You  should  not use it in the
        production code (unless you want to check derivatives provided  by
        some third party).

NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
        (so large that function behaviour is significantly non-cubic) will
        lead to false alarms. You may use  different  step  for  different
        parameters by means of setting scale with MinLBFGSSetScale().

NOTE 3: this function may lead to false positives. In case it reports that
        I-th  derivative was calculated incorrectly, you may decrease test
        step  and  try  one  more  time  - maybe your function changes too
        sharply  and  your  step  is  too  large for such rapidly chanding
        function.

INPUT PARAMETERS:
    State       -   structure used to store algorithm state
    TestStep    -   verification step:
                    * TestStep=0 turns verification off
                    * TestStep&gt;0 activates verification

  -- ALGLIB --
     Copyright 24.05.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetgradientcheck(
    minlbfgsstate state,
    <font color=navy>double</font> teststep)

</div></pre>
<a name='sub_minlbfgssetpreccholesky'></a><h3 class=pageheader><code>minlbfgssetpreccholesky</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification of the preconditioner: Cholesky factorization of  approximate
Hessian is used.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    P       -   triangular preconditioner, Cholesky factorization of
                the approximate Hessian. array[0..N-1,0..N-1],
                (if larger, only leading N elements are used).
    IsUpper -   whether upper or lower triangle of P is given
                (other triangle is not referenced)

After call to this function preconditioner is changed to P  (P  is  copied
into the internal buffer).

NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
iterations.

NOTE 2:  P  should  be nonsingular. Exception will be thrown otherwise.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetpreccholesky(
    minlbfgsstate state,
    <font color=navy>double</font>[,] p,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_minlbfgssetprecdefault'></a><h3 class=pageheader><code>minlbfgssetprecdefault</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification  of  the  preconditioner:  default  preconditioner    (simple
scaling, same for all elements of X) is used.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
iterations.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetprecdefault(minlbfgsstate state)

</div></pre>
<a name='sub_minlbfgssetprecdiag'></a><h3 class=pageheader><code>minlbfgssetprecdiag</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification  of  the  preconditioner:  diagonal of approximate Hessian is
used.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    D       -   diagonal of the approximate Hessian, array[0..N-1],
                (if larger, only leading N elements are used).

NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
iterations.

NOTE 2: D[i] should be positive. Exception will be thrown otherwise.

NOTE 3: you should pass diagonal of approximate Hessian - NOT ITS INVERSE.

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetprecdiag(
    minlbfgsstate state,
    <font color=navy>double</font>[] d)

</div></pre>
<a name='sub_minlbfgssetprecscale'></a><h3 class=pageheader><code>minlbfgssetprecscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Modification of the preconditioner: scale-based diagonal preconditioning.

This preconditioning mode can be useful when you  don't  have  approximate
diagonal of Hessian, but you know that your  variables  are  badly  scaled
(for  example,  one  variable is in [1,10], and another in [1000,100000]),
and most part of the ill-conditioning comes from different scales of vars.

In this case simple  scale-based  preconditioner,  with H[i] = 1/(s[i]^2),
can greatly improve convergence.

IMPRTANT: you should set scale of your variables  with  MinLBFGSSetScale()
call  (before  or after MinLBFGSSetPrecScale() call). Without knowledge of
the scale of your variables scale-based preconditioner will be  just  unit
matrix.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 13.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetprecscale(minlbfgsstate state)

</div></pre>
<a name='sub_minlbfgssetscale'></a><h3 class=pageheader><code>minlbfgssetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for LBFGS optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Scaling is also used by finite difference variant of the optimizer  - step
along I-th axis is equal to DiffStep*S[I].

In  most  optimizers  (and  in  the  LBFGS  too)  scaling is NOT a form of
preconditioning. It just  affects  stopping  conditions.  You  should  set
preconditioner  by  separate  call  to  one  of  the  MinLBFGSSetPrec...()
functions.

There  is  special  preconditioning  mode, however,  which  uses   scaling
coefficients to form diagonal preconditioning matrix. You  can  turn  this
mode on, if you want.   But  you should understand that scaling is not the
same thing as preconditioning - these are two different, although  related
forms of tuning solver.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetscale(
    minlbfgsstate state,
    <font color=navy>double</font>[] s)

</div></pre>
<a name='sub_minlbfgssetstpmax'></a><h3 class=pageheader><code>minlbfgssetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0 (default),  if
                you don't want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetstpmax(
    minlbfgsstate state,
    <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_minlbfgssetxrep'></a><h3 class=pageheader><code>minlbfgssetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinLBFGSOptimize().


  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlbfgssetxrep(
    minlbfgsstate state,
    <font color=navy>bool</font> needxrep)

</div></pre>
<a name='example_minlbfgs_d_1'></a><h3 class=pageheader>minlbfgs_d_1 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// using LBFGS method.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlbfgsstate state;
    alglib.minlbfgsreport rep;

    alglib.minlbfgscreate(1, x, <font color=navy>out</font> state);
    alglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlbfgsoptimize(state, function1_grad, null, null);
    alglib.minlbfgsresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlbfgs_d_2'></a><h3 class=pageheader>minlbfgs_d_2 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// using LBFGS method.</font>
    <font color=green>//</font>
    <font color=green>// Several advanced techniques are demonstrated:</font>
    <font color=green>// * upper limit on step size</font>
    <font color=green>// * restart from new point</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>double</font> stpmax = 0.1;
    <font color=navy>int</font> maxits = 0;
    alglib.minlbfgsstate state;
    alglib.minlbfgsreport rep;

    <font color=green>// first run</font>
    alglib.minlbfgscreate(1, x, <font color=navy>out</font> state);
    alglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlbfgssetstpmax(state, stpmax);
    alglib.minlbfgsoptimize(state, function1_grad, null, null);
    alglib.minlbfgsresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>

    <font color=green>// second run - algorithm is restarted</font>
    x = new <font color=navy>double</font>[]{10,10};
    alglib.minlbfgsrestartfrom(state, x);
    alglib.minlbfgsoptimize(state, function1_grad, null, null);
    alglib.minlbfgsresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlbfgs_ftrim'></a><h3 class=pageheader>minlbfgs_ftrim example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> s1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates f(x) = (1+x)^(-0.2) + (1-x)^(-0.3) + 1000*x and its gradient.</font>
    <font color=green>//</font>
    <font color=green>// function is trimmed when we calculate it near the singular points or outside of the [-1,+1].</font>
    <font color=green>// Note that we <font color=navy>do</font> NOT calculate gradient in this case.</font>
    <font color=green>//</font>
    <font color=navy>if</font>( (x[0]&lt;=-0.999999999999) || (x[0]&gt;=+0.999999999999) )
    {
        func = 1.0E+300;
        <font color=navy>return</font>;
    }
    func = System.Math.Pow(1+x[0],-0.2) + System.Math.Pow(1-x[0],-0.3) + 1000*x[0];
    grad[0] = -0.2*System.Math.Pow(1+x[0],-1.2) +0.3*System.Math.Pow(1-x[0],-1.3) + 1000;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x) = (1+x)^(-0.2) + (1-x)^(-0.3) + 1000*x.</font>
    <font color=green>// This function has singularities at the boundary of the [-1,+1], but technique called</font>
    <font color=green>// <font color=blue><b>&quot;function trimming&quot;</b></font> allows us to solve this optimization problem.</font>
    <font color=green>//</font>
    <font color=green>// See http://www.alglib.net/optimization/tipsandtricks.php#ftrimming <font color=navy>for</font> more information</font>
    <font color=green>// on this subject.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0};
    <font color=navy>double</font> epsg = 1.0e-6;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlbfgsstate state;
    alglib.minlbfgsreport rep;

    alglib.minlbfgscreate(1, x, <font color=navy>out</font> state);
    alglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlbfgsoptimize(state, s1_grad, null, null);
    alglib.minlbfgsresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,5)); <font color=green>// EXPECTED: [-0.99917305]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlbfgs_numdiff'></a><h3 class=pageheader>minlbfgs_numdiff example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_func(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
    <font color=green>// using numerical differentiation to calculate gradient.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>double</font> diffstep = 1.0e-6;
    <font color=navy>int</font> maxits = 0;
    alglib.minlbfgsstate state;
    alglib.minlbfgsreport rep;

    alglib.minlbfgscreatef(1, x, diffstep, <font color=navy>out</font> state);
    alglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlbfgsoptimize(state, function1_func, null, null);
    alglib.minlbfgsresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_minlm></a><h2 class=pageheader><code>minlm</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minlmreport' class=toc>minlmreport</a><br>
<a href='#struct_minlmstate' class=toc>minlmstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minlmcreatefgh' class=toc>minlmcreatefgh</a><br>
<a href='#sub_minlmcreatefgj' class=toc>minlmcreatefgj</a><br>
<a href='#sub_minlmcreatefj' class=toc>minlmcreatefj</a><br>
<a href='#sub_minlmcreatev' class=toc>minlmcreatev</a><br>
<a href='#sub_minlmcreatevgj' class=toc>minlmcreatevgj</a><br>
<a href='#sub_minlmcreatevj' class=toc>minlmcreatevj</a><br>
<a href='#sub_minlmoptimize' class=toc>minlmoptimize</a><br>
<a href='#sub_minlmrequesttermination' class=toc>minlmrequesttermination</a><br>
<a href='#sub_minlmrestartfrom' class=toc>minlmrestartfrom</a><br>
<a href='#sub_minlmresults' class=toc>minlmresults</a><br>
<a href='#sub_minlmresultsbuf' class=toc>minlmresultsbuf</a><br>
<a href='#sub_minlmsetacctype' class=toc>minlmsetacctype</a><br>
<a href='#sub_minlmsetbc' class=toc>minlmsetbc</a><br>
<a href='#sub_minlmsetcond' class=toc>minlmsetcond</a><br>
<a href='#sub_minlmsetgradientcheck' class=toc>minlmsetgradientcheck</a><br>
<a href='#sub_minlmsetscale' class=toc>minlmsetscale</a><br>
<a href='#sub_minlmsetstpmax' class=toc>minlmsetstpmax</a><br>
<a href='#sub_minlmsetxrep' class=toc>minlmsetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minlm_d_fgh' class=toc>minlm_d_fgh</a></td><td width=15>&nbsp;</td><td>Nonlinear Hessian-based optimization for general functions</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_restarts' class=toc>minlm_d_restarts</a></td><td width=15>&nbsp;</td><td>Efficient restarts of LM optimizer</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_v' class=toc>minlm_d_v</a></td><td width=15>&nbsp;</td><td>Nonlinear least squares optimization using function vector only</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_vb' class=toc>minlm_d_vb</a></td><td width=15>&nbsp;</td><td>Bound constrained nonlinear least squares optimization</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_vj' class=toc>minlm_d_vj</a></td><td width=15>&nbsp;</td><td>Nonlinear least squares optimization using function vector and Jacobian</td></tr>
</table></div>
<a name='struct_minlmreport'></a><h3 class=pageheader><code>minlmreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Optimization report, filled by MinLMResults() function

FIELDS:
* TerminationType, completetion code:
    * -7    derivative correctness check failed;
            see rep.funcidx, rep.varidx for
            more information.
    * -3    constraints are inconsistent
    *  1    relative function improvement is no more than
            EpsF.
    *  2    relative step is no more than EpsX.
    *  4    gradient is no more than EpsG.
    *  5    MaxIts steps was taken
    *  7    stopping conditions are too stringent,
            further improvement is impossible
    *  8    terminated   by  user  who  called  MinLMRequestTermination().
            X contains point which was &quot;current accepted&quot; when termination
            request was submitted.
* IterationsCount, contains iterations count
* NFunc, number of function calculations
* NJac, number of Jacobi matrix calculations
* NGrad, number of gradient calculations
* NHess, number of Hessian calculations
* NCholesky, number of Cholesky decomposition calculations
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minlmreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  funcidx;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>int</font>                  nfunc;
    <font color=navy>public</font> <font color=navy>int</font>                  njac;
    <font color=navy>public</font> <font color=navy>int</font>                  ngrad;
    <font color=navy>public</font> <font color=navy>int</font>                  nhess;
    <font color=navy>public</font> <font color=navy>int</font>                  ncholesky;
}

</div></pre>
<a name='struct_minlmstate'></a><h3 class=pageheader><code>minlmstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Levenberg-Marquardt optimizer.

This structure should be created using one of the MinLMCreate???()
functions. You should not access its fields directly; use ALGLIB functions
to work with it.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minlmstate
{
}

</div></pre>
<a name='sub_minlmcreatefgh'></a><h3 class=pageheader><code>minlmcreatefgh</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
    LEVENBERG-MARQUARDT-LIKE METHOD FOR NON-LINEAR OPTIMIZATION

DESCRIPTION:
This  function  is  used  to  find  minimum  of general form (not &quot;sum-of-
-squares&quot;) function
    F = F(x[0], ..., x[n-1])
using  its  gradient  and  Hessian.  Levenberg-Marquardt modification with
L-BFGS pre-optimization and internal pre-conditioned  L-BFGS  optimization
after each Levenberg-Marquardt step is used.


REQUIREMENTS:
This algorithm will request following information during its operation:

* function value F at given point X
* F and gradient G (simultaneously) at given point X
* F, G and Hessian H (simultaneously) at given point X

There are several overloaded versions of  MinLMOptimize()  function  which
correspond  to  different LM-like optimization algorithms provided by this
unit. You should choose version which accepts func(),  grad()  and  hess()
function pointers. First pointer is used to calculate F  at  given  point,
second  one  calculates  F(x)  and  grad F(x),  third one calculates F(x),
grad F(x), hess F(x).

You can try to initialize MinLMState structure with FGH-function and  then
use incorrect version of MinLMOptimize() (for example, version which  does
not provide Hessian matrix), but it will lead to  exception  being  thrown
after first attempt to calculate Hessian.


USAGE:
1. User initializes algorithm state with MinLMCreateFGH() call
2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
   other functions
3. User calls MinLMOptimize() function which  takes algorithm  state   and
   pointers (delegates, etc.) to callback functions.
4. User calls MinLMResults() to get solution
5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
   with same N but another starting point and/or another function.
   MinLMRestartFrom() allows to reuse already initialized structure.


INPUT PARAMETERS:
    N       -   dimension, N&gt;1
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    X       -   initial solution, array[0..N-1]

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTES:
1. you may tune stopping conditions with MinLMSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLMSetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatefgh(<font color=navy>double</font>[] x, <font color=navy>out</font> minlmstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatefgh(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmcreatefgj'></a><h3 class=pageheader><code>minlmcreatefgj</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is obsolete function.

Since ALGLIB 3.3 it is equivalent to MinLMCreateFJ().

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatefgj(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatefgj(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)

</div></pre>
<a name='sub_minlmcreatefj'></a><h3 class=pageheader><code>minlmcreatefj</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is considered obsolete since ALGLIB 3.1.0 and is present for
backward  compatibility  only.  We  recommend  to use MinLMCreateVJ, which
provides similar, but more consistent and feature-rich interface.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatefj(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatefj(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)

</div></pre>
<a name='sub_minlmcreatev'></a><h3 class=pageheader><code>minlmcreatev</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                IMPROVED LEVENBERG-MARQUARDT METHOD FOR
                 NON-LINEAR LEAST SQUARES OPTIMIZATION

DESCRIPTION:
This function is used to find minimum of function which is represented  as
sum of squares:
    F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
using value of function vector f[] only. Finite differences  are  used  to
calculate Jacobian.


REQUIREMENTS:
This algorithm will request following information during its operation:
* function vector f[] at given point X

There are several overloaded versions of  MinLMOptimize()  function  which
correspond  to  different LM-like optimization algorithms provided by this
unit. You should choose version which accepts fvec() callback.

You can try to initialize MinLMState structure with VJ  function and  then
use incorrect version  of  MinLMOptimize()  (for  example,  version  which
works with general form function and does not accept function vector), but
it will  lead  to  exception being thrown after first attempt to calculate
Jacobian.


USAGE:
1. User initializes algorithm state with MinLMCreateV() call
2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
   other functions
3. User calls MinLMOptimize() function which  takes algorithm  state   and
   callback functions.
4. User calls MinLMResults() to get solution
5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
   with same N/M but another starting point and/or another function.
   MinLMRestartFrom() allows to reuse already initialized structure.


INPUT PARAMETERS:
    N       -   dimension, N&gt;1
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    M       -   number of functions f[i]
    X       -   initial solution, array[0..N-1]
    DiffStep-   differentiation step, &gt;0

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

See also MinLMIteration, MinLMResults.

NOTES:
1. you may tune stopping conditions with MinLMSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLMSetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatev(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minlmstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatev(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minlmstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vb' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmcreatevgj'></a><h3 class=pageheader><code>minlmcreatevgj</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is obsolete function.

Since ALGLIB 3.3 it is equivalent to MinLMCreateVJ().

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatevgj(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatevgj(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)

</div></pre>
<a name='sub_minlmcreatevj'></a><h3 class=pageheader><code>minlmcreatevj</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                IMPROVED LEVENBERG-MARQUARDT METHOD FOR
                 NON-LINEAR LEAST SQUARES OPTIMIZATION

DESCRIPTION:
This function is used to find minimum of function which is represented  as
sum of squares:
    F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
using value of function vector f[] and Jacobian of f[].


REQUIREMENTS:
This algorithm will request following information during its operation:

* function vector f[] at given point X
* function vector f[] and Jacobian of f[] (simultaneously) at given point

There are several overloaded versions of  MinLMOptimize()  function  which
correspond  to  different LM-like optimization algorithms provided by this
unit. You should choose version which accepts fvec()  and jac() callbacks.
First  one  is used to calculate f[] at given point, second one calculates
f[] and Jacobian df[i]/dx[j].

You can try to initialize MinLMState structure with VJ  function and  then
use incorrect version  of  MinLMOptimize()  (for  example,  version  which
works  with  general  form function and does not provide Jacobian), but it
will  lead  to  exception  being  thrown  after first attempt to calculate
Jacobian.


USAGE:
1. User initializes algorithm state with MinLMCreateVJ() call
2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
   other functions
3. User calls MinLMOptimize() function which  takes algorithm  state   and
   callback functions.
4. User calls MinLMResults() to get solution
5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
   with same N/M but another starting point and/or another function.
   MinLMRestartFrom() allows to reuse already initialized structure.


INPUT PARAMETERS:
    N       -   dimension, N&gt;1
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    M       -   number of functions f[i]
    X       -   initial solution, array[0..N-1]

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state

NOTES:
1. you may tune stopping conditions with MinLMSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLMSetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatevj(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmcreatevj(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmoptimize'></a><h3 class=pageheader><code>minlmoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    func    -   callback which calculates function (or merit function)
                value func at given point x
    grad    -   callback which calculates function (or merit function)
                value func and gradient grad at given point x
    hess    -   callback which calculates function (or merit function)
                value func, gradient grad and Hessian hess at given point x
    fvec    -   callback which calculates function vector fi[]
                at given point x
    jac     -   callback which calculates function vector fi[]
                and Jacobian jac at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL

NOTES:

1. Depending on function used to create state  structure,  this  algorithm
   may accept Jacobian and/or Hessian and/or gradient.  According  to  the
   said above, there ase several versions of this function,  which  accept
   different sets of callbacks.

   This flexibility opens way to subtle errors - you may create state with
   MinLMCreateFGH() (optimization using Hessian), but call function  which
   does not accept Hessian. So when algorithm will request Hessian,  there
   will be no callback to call. In this case exception will be thrown.

   Be careful to avoid such errors because there is no way to find them at
   compile time - you can see them at runtime only.

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_jac  jac, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_hess hess, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_jac  jac, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vb' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmrequesttermination'></a><h3 class=pageheader><code>minlmrequesttermination</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine submits request for termination of running  optimizer.  It
should be called from user-supplied callback when user decides that it  is
time to &quot;smoothly&quot; terminate optimization process.  As  result,  optimizer
stops at point which was &quot;current accepted&quot; when termination  request  was
submitted and returns error code 8 (successful termination).

INPUT PARAMETERS:
    State   -   optimizer structure

NOTE: after  request  for  termination  optimizer  may   perform   several
      additional calls to user-supplied callbacks. It does  NOT  guarantee
      to stop immediately - it just guarantees that these additional calls
      will be discarded later.

NOTE: calling this function on optimizer which is NOT running will have no
      effect.

NOTE: multiple calls to this function are possible. First call is counted,
      subsequent calls are silently ignored.

  -- ALGLIB --
     Copyright 08.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmrequesttermination(minlmstate state)

</div></pre>
<a name='sub_minlmrestartfrom'></a><h3 class=pageheader><code>minlmrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  restarts  LM  algorithm from new point. All optimization
parameters are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure used for reverse communication previously
                allocated with MinLMCreateXXX call.
    X       -   new starting point.

  -- ALGLIB --
     Copyright 30.07.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmrestartfrom(minlmstate state, <font color=navy>double</font>[] x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmresults'></a><h3 class=pageheader><code>minlmresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Levenberg-Marquardt algorithm results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization  report;  includes  termination   codes   and
                additional information. Termination codes are listed below,
                see comments for this structure for more info.
                Termination code is stored in rep.terminationtype field:
                * -7    derivative correctness check failed;
                        see rep.funcidx, rep.varidx for
                        more information.
                * -3    constraints are inconsistent
                *  1    relative function improvement is no more than
                        EpsF.
                *  2    relative step is no more than EpsX.
                *  4    gradient is no more than EpsG.
                *  5    MaxIts steps was taken
                *  7    stopping conditions are too stringent,
                        further improvement is impossible
                *  8    terminated by user who called minlmrequesttermination().
                        X contains point which was &quot;current accepted&quot; when
                        termination request was submitted.

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmresults(
    minlmstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minlmreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vb' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmresultsbuf'></a><h3 class=pageheader><code>minlmresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Levenberg-Marquardt algorithm results

Buffered implementation of MinLMResults(), which uses pre-allocated buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmresultsbuf(
    minlmstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minlmreport rep)

</div></pre>
<a name='sub_minlmsetacctype'></a><h3 class=pageheader><code>minlmsetacctype</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to change acceleration settings

You can choose between three acceleration strategies:
* AccType=0, no acceleration.
* AccType=1, secant updates are used to update quadratic model after  each
  iteration. After fixed number of iterations (or after  model  breakdown)
  we  recalculate  quadratic  model  using  analytic  Jacobian  or  finite
  differences. Number of secant-based iterations depends  on  optimization
  settings: about 3 iterations - when we have analytic Jacobian, up to 2*N
  iterations - when we use finite differences to calculate Jacobian.

AccType=1 is recommended when Jacobian  calculation  cost  is  prohibitive
high (several Mx1 function vector calculations  followed  by  several  NxN
Cholesky factorizations are faster than calculation of one M*N  Jacobian).
It should also be used when we have no Jacobian, because finite difference
approximation takes too much time to compute.

Table below list  optimization  protocols  (XYZ  protocol  corresponds  to
MinLMCreateXYZ) and acceleration types they support (and use by  default).

ACCELERATION TYPES SUPPORTED BY OPTIMIZATION PROTOCOLS:

protocol    0   1   comment
V           +   +
VJ          +   +
FGH         +

DAFAULT VALUES:

protocol    0   1   comment
V               x   without acceleration it is so slooooooooow
VJ          x
FGH         x

NOTE: this  function should be called before optimization. Attempt to call
it during algorithm iterations may result in unexpected behavior.

NOTE: attempt to call this function with unsupported protocol/acceleration
combination will result in exception being thrown.

  -- ALGLIB --
     Copyright 14.10.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetacctype(minlmstate state, <font color=navy>int</font> acctype)

</div></pre>
<a name='sub_minlmsetbc'></a><h3 class=pageheader><code>minlmsetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets boundary constraints for LM optimizer

Boundary constraints are inactive by default (after initial creation).
They are preserved until explicitly turned off with another SetBC() call.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    BndL    -   lower bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very small number or -INF (latter is recommended because
                it will allow solver to use better algorithm).
    BndU    -   upper bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very large number or +INF (latter is recommended because
                it will allow solver to use better algorithm).

NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
variable will be &quot;frozen&quot; at X[i]=BndL[i]=BndU[i].

NOTE 2: this solver has following useful properties:
* bound constraints are always satisfied exactly
* function is evaluated only INSIDE area specified by bound constraints
  or at its boundary

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetbc(
    minlmstate state,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<a name='sub_minlmsetcond'></a><h3 class=pageheader><code>minlmsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for Levenberg-Marquardt optimization
algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinLMSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |v|&lt;=EpsX is fulfilled, where:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - ste pvector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinLMSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations   is    unlimited.   Only   Levenberg-Marquardt
                iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
                counted because their cost is very low compared to that of
                LM).

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetcond(
    minlmstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vb' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmsetgradientcheck'></a><h3 class=pageheader><code>minlmsetgradientcheck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  turns  on  verification  of  the  user-supplied analytic
gradient:
* user calls this subroutine before optimization begins
* MinLMOptimize() is called
* prior to actual optimization, for  each  function Fi and each  component
  of parameters  being  optimized X[j] algorithm performs following steps:
  * two trial steps are made to X[j]-TestStep*S[j] and X[j]+TestStep*S[j],
    where X[j] is j-th parameter and S[j] is a scale of j-th parameter
  * if needed, steps are bounded with respect to constraints on X[]
  * Fi(X) is evaluated at these trial points
  * we perform one more evaluation in the middle point of the interval
  * we  build  cubic  model using function values and derivatives at trial
    points and we compare its prediction with actual value in  the  middle
    point
  * in case difference between prediction and actual value is higher  than
    some predetermined threshold, algorithm stops with completion code -7;
    Rep.VarIdx is set to index of the parameter with incorrect derivative,
    Rep.FuncIdx is set to index of the function.
* after verification is over, algorithm proceeds to the actual optimization.

NOTE 1: verification  needs  N (parameters count) Jacobian evaluations. It
        is  very  costly  and  you  should use it only for low dimensional
        problems,  when  you  want  to  be  sure  that  you've   correctly
        calculated  analytic  derivatives.  You should not  use  it in the
        production code  (unless  you  want  to check derivatives provided
        by some third party).

NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
        (so large that function behaviour is significantly non-cubic) will
        lead to false alarms. You may use  different  step  for  different
        parameters by means of setting scale with MinLMSetScale().

NOTE 3: this function may lead to false positives. In case it reports that
        I-th  derivative was calculated incorrectly, you may decrease test
        step  and  try  one  more  time  - maybe your function changes too
        sharply  and  your  step  is  too  large for such rapidly chanding
        function.

INPUT PARAMETERS:
    State       -   structure used to store algorithm state
    TestStep    -   verification step:
                    * TestStep=0 turns verification off
                    * TestStep&gt;0 activates verification

  -- ALGLIB --
     Copyright 15.06.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetgradientcheck(
    minlmstate state,
    <font color=navy>double</font> teststep)

</div></pre>
<a name='sub_minlmsetscale'></a><h3 class=pageheader><code>minlmsetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for LM optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Generally, scale is NOT considered to be a form of preconditioner.  But LM
optimizer is unique in that it uses scaling matrix both  in  the  stopping
condition tests and as Marquardt damping factor.

Proper scaling is very important for the algorithm performance. It is less
important for the quality of results, but still has some influence (it  is
easier  to  converge  when  variables  are  properly  scaled, so premature
stopping is possible when very badly scalled variables are  combined  with
relaxed stopping conditions).

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetscale(minlmstate state, <font color=navy>double</font>[] s)

</div></pre>
<a name='sub_minlmsetstpmax'></a><h3 class=pageheader><code>minlmsetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

NOTE: non-zero StpMax leads to moderate  performance  degradation  because
intermediate  step  of  preconditioned L-BFGS optimization is incompatible
with limits on step size.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetstpmax(minlmstate state, <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_minlmsetxrep'></a><h3 class=pageheader><code>minlmsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinLMOptimize(). Both Levenberg-Marquardt and internal  L-BFGS
iterations are reported.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minlmsetxrep(minlmstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='example_minlm_d_fgh'></a><h3 class=pageheader>minlm_d_fgh example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_func(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_grad(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// and its derivatives df/d0 and df/dx1</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> function1_hess(<font color=navy>double</font>[] x, <font color=navy>ref</font> <font color=navy>double</font> func, <font color=navy>double</font>[] grad, <font color=navy>double</font>[,] hess, object obj)
{
    <font color=green>// this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=green>// its derivatives df/d0 and df/dx1</font>
    <font color=green>// and its Hessian.</font>
    func = 100*System.Math.Pow(x[0]+3,4) + System.Math.Pow(x[1]-3,4);
    grad[0] = 400*System.Math.Pow(x[0]+3,3);
    grad[1] = 4*System.Math.Pow(x[1]-3,3);
    hess[0,0] = 1200*System.Math.Pow(x[0]+3,2);
    hess[0,1] = 0;
    hess[1,0] = 0;
    hess[1,1] = 12*System.Math.Pow(x[1]-3,2);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = 100*(x0+3)^4+(x1-3)^4</font>
    <font color=green>// using <font color=blue><b>&quot;FGH&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
    <font color=green>//</font>
    <font color=green>// F is treated like a monolitic function without internal structure,</font>
    <font color=green>// i.e. we <font color=navy>do</font> NOT represent it as a sum of squares.</font>
    <font color=green>//</font>
    <font color=green>// Optimization algorithm uses:</font>
    <font color=green>// * function value F(x0,x1)</font>
    <font color=green>// * gradient G={dF/dxi}</font>
    <font color=green>// * Hessian H={d2F/(dxi*dxj)}</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlmstate state;
    alglib.minlmreport rep;

    alglib.minlmcreatefgh(x, <font color=navy>out</font> state);
    alglib.minlmsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlmoptimize(state, function1_func, function1_grad, function1_hess, null, null);
    alglib.minlmresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,+3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlm_d_restarts'></a><h3 class=pageheader>minlm_d_restarts example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  function1_fvec(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>// f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=green>// f1(x0,x1) = (x1-3)^4</font>
    <font color=green>//</font>
    fi[0] = 10*System.Math.Pow(x[0]+3,2);
    fi[1] = System.Math.Pow(x[1]-3,2);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  function2_fvec(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>// f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=green>// f1(x0,x1) = (x1-3)^4</font>
    <font color=green>//</font>
    fi[0] = x[0]*x[0]+1;
    fi[1] = x[1]-1;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 10*(x0+3)^2</font>
    <font color=green>//     f1(x0,x1) = (x1-3)^2</font>
    <font color=green>//</font>
    <font color=green>// using several starting points and efficient restarts.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x;
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlmstate state;
    alglib.minlmreport rep;

    <font color=green>//</font>
    <font color=green>// create optimizer using minlmcreatev()</font>
    <font color=green>//</font>
    x = new <font color=navy>double</font>[]{10,10};
    alglib.minlmcreatev(2, x, 0.0001, <font color=navy>out</font> state);
    alglib.minlmsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlmoptimize(state, function1_fvec, null, null);
    alglib.minlmresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,+3]</font>

    <font color=green>//</font>
    <font color=green>// restart optimizer using minlmrestartfrom()</font>
    <font color=green>//</font>
    <font color=green>// we can use different starting point, different function,</font>
    <font color=green>// different stopping conditions, but problem size</font>
    <font color=green>// must remain unchanged.</font>
    <font color=green>//</font>
    x = new <font color=navy>double</font>[]{4,4};
    alglib.minlmrestartfrom(state, x);
    alglib.minlmoptimize(state, function2_fvec, null, null);
    alglib.minlmresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [0,1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlm_d_v'></a><h3 class=pageheader>minlm_d_v example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  function1_fvec(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>// f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=green>// f1(x0,x1) = (x1-3)^4</font>
    <font color=green>//</font>
    fi[0] = 10*System.Math.Pow(x[0]+3,2);
    fi[1] = System.Math.Pow(x[1]-3,2);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 10*(x0+3)^2</font>
    <font color=green>//     f1(x0,x1) = (x1-3)^2</font>
    <font color=green>//</font>
    <font color=green>// using <font color=blue><b>&quot;V&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
    <font color=green>//</font>
    <font color=green>// Optimization algorithm uses:</font>
    <font color=green>// * function vector f[] = {f1,f2}</font>
    <font color=green>//</font>
    <font color=green>// No other information (Jacobian, gradient, etc.) is needed.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlmstate state;
    alglib.minlmreport rep;

    alglib.minlmcreatev(2, x, 0.0001, <font color=navy>out</font> state);
    alglib.minlmsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlmoptimize(state, function1_fvec, null, null);
    alglib.minlmresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,+3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlm_d_vb'></a><h3 class=pageheader>minlm_d_vb example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  function1_fvec(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>// f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=green>// f1(x0,x1) = (x1-3)^4</font>
    <font color=green>//</font>
    fi[0] = 10*System.Math.Pow(x[0]+3,2);
    fi[1] = System.Math.Pow(x[1]-3,2);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 10*(x0+3)^2</font>
    <font color=green>//     f1(x0,x1) = (x1-3)^2</font>
    <font color=green>//</font>
    <font color=green>// with boundary constraints</font>
    <font color=green>//</font>
    <font color=green>//     -1 &lt;= x0 &lt;= +1</font>
    <font color=green>//     -1 &lt;= x1 &lt;= +1</font>
    <font color=green>//</font>
    <font color=green>// using <font color=blue><b>&quot;V&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
    <font color=green>//</font>
    <font color=green>// Optimization algorithm uses:</font>
    <font color=green>// * function vector f[] = {f1,f2}</font>
    <font color=green>//</font>
    <font color=green>// No other information (Jacobian, gradient, etc.) is needed.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{-1,-1};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{+1,+1};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlmstate state;
    alglib.minlmreport rep;

    alglib.minlmcreatev(2, x, 0.0001, <font color=navy>out</font> state);
    alglib.minlmsetbc(state, bndl, bndu);
    alglib.minlmsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlmoptimize(state, function1_fvec, null, null);
    alglib.minlmresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-1,+1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minlm_d_vj'></a><h3 class=pageheader>minlm_d_vj example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  function1_fvec(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>// f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=green>// f1(x0,x1) = (x1-3)^4</font>
    <font color=green>//</font>
    fi[0] = 10*System.Math.Pow(x[0]+3,2);
    fi[1] = System.Math.Pow(x[1]-3,2);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  function1_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>// this callback calculates</font>
    <font color=green>// f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=green>// f1(x0,x1) = (x1-3)^4</font>
    <font color=green>// and Jacobian matrix J = [dfi/dxj]</font>
    fi[0] = 10*System.Math.Pow(x[0]+3,2);
    fi[1] = System.Math.Pow(x[1]-3,2);
    jac[0,0] = 20*(x[0]+3);
    jac[0,1] = 0;
    jac[1,0] = 0;
    jac[1,1] = 2*(x[1]-3);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 10*(x0+3)^2</font>
    <font color=green>//     f1(x0,x1) = (x1-3)^2</font>
    <font color=green>//</font>
    <font color=green>// using <font color=blue><b>&quot;VJ&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
    <font color=green>//</font>
    <font color=green>// Optimization algorithm uses:</font>
    <font color=green>// * function vector f[] = {f1,f2}</font>
    <font color=green>// * Jacobian matrix J = {dfi/dxj}.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font> epsg = 0.0000000001;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0;
    <font color=navy>int</font> maxits = 0;
    alglib.minlmstate state;
    alglib.minlmreport rep;

    alglib.minlmcreatevj(2, x, <font color=navy>out</font> state);
    alglib.minlmsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minlmoptimize(state, function1_fvec, function1_jac, null, null);
    alglib.minlmresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);

    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [-3,+3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_minnlc></a><h2 class=pageheader><code>minnlc</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minnlcreport' class=toc>minnlcreport</a><br>
<a href='#struct_minnlcstate' class=toc>minnlcstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minnlccreate' class=toc>minnlccreate</a><br>
<a href='#sub_minnlccreatef' class=toc>minnlccreatef</a><br>
<a href='#sub_minnlcoptimize' class=toc>minnlcoptimize</a><br>
<a href='#sub_minnlcrestartfrom' class=toc>minnlcrestartfrom</a><br>
<a href='#sub_minnlcresults' class=toc>minnlcresults</a><br>
<a href='#sub_minnlcresultsbuf' class=toc>minnlcresultsbuf</a><br>
<a href='#sub_minnlcsetalgoaul' class=toc>minnlcsetalgoaul</a><br>
<a href='#sub_minnlcsetbc' class=toc>minnlcsetbc</a><br>
<a href='#sub_minnlcsetcond' class=toc>minnlcsetcond</a><br>
<a href='#sub_minnlcsetgradientcheck' class=toc>minnlcsetgradientcheck</a><br>
<a href='#sub_minnlcsetlc' class=toc>minnlcsetlc</a><br>
<a href='#sub_minnlcsetnlc' class=toc>minnlcsetnlc</a><br>
<a href='#sub_minnlcsetprecexactlowrank' class=toc>minnlcsetprecexactlowrank</a><br>
<a href='#sub_minnlcsetprecinexact' class=toc>minnlcsetprecinexact</a><br>
<a href='#sub_minnlcsetprecnone' class=toc>minnlcsetprecnone</a><br>
<a href='#sub_minnlcsetscale' class=toc>minnlcsetscale</a><br>
<a href='#sub_minnlcsetxrep' class=toc>minnlcsetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minnlc_d_equality' class=toc>minnlc_d_equality</a></td><td width=15>&nbsp;</td><td>Nonlinearly constrained optimization (equality constraints)</td></tr>
<tr align=left valign=top><td><a href='#example_minnlc_d_inequality' class=toc>minnlc_d_inequality</a></td><td width=15>&nbsp;</td><td>Nonlinearly constrained optimization (inequality constraints)</td></tr>
<tr align=left valign=top><td><a href='#example_minnlc_d_mixed' class=toc>minnlc_d_mixed</a></td><td width=15>&nbsp;</td><td>Nonlinearly constrained optimization with mixed equality/inequality constraints</td></tr>
</table></div>
<a name='struct_minnlcreport'></a><h3 class=pageheader><code>minnlcreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores optimization report:
* IterationsCount           total number of inner iterations
* NFEV                      number of gradient evaluations
* TerminationType           termination type (see below)

TERMINATION CODES

TerminationType field contains completion code, which can be:
  -8    internal integrity control detected  infinite  or  NAN  values  in
        function/gradient. Abnormal termination signalled.
  -7    gradient verification failed.
        See MinNLCSetGradientCheck() for more information.
   1    relative function improvement is no more than EpsF.
   2    relative step is no more than EpsX.
   4    gradient norm is no more than EpsG
   5    MaxIts steps was taken
   7    stopping conditions are too stringent,
        further improvement is impossible,
        X contains best point found so far.

Other fields of this structure are not documented and should not be used!
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minnlcreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>int</font>                  funcidx;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  dbgphase0its;
}

</div></pre>
<a name='struct_minnlcstate'></a><h3 class=pageheader><code>minnlcstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores nonlinear optimizer state.
You should use functions provided by MinNLC subpackage to work  with  this
object
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minnlcstate
{
}

</div></pre>
<a name='sub_minnlccreate'></a><h3 class=pageheader><code>minnlccreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                  NONLINEARLY  CONSTRAINED  OPTIMIZATION
            WITH PRECONDITIONED AUGMENTED LAGRANGIAN ALGORITHM

DESCRIPTION:
The  subroutine  minimizes  function   F(x)  of N arguments subject to any
combination of:
* bound constraints
* linear inequality constraints
* linear equality constraints
* nonlinear equality constraints Gi(x)=0
* nonlinear inequality constraints Hi(x)&lt;=0

REQUIREMENTS:
* user must provide function value and gradient for F(), H(), G()
* starting point X0 must be feasible or not too far away from the feasible
  set
* F(), G(), H() are twice continuously differentiable on the feasible  set
  and its neighborhood
* nonlinear constraints G() and H() must have non-zero gradient at  G(x)=0
  and at H(x)=0. Say, constraint like x^2&gt;=1 is supported, but x^2&gt;=0   is
  NOT supported.

USAGE:

Constrained optimization if far more complex than the  unconstrained  one.
Nonlinearly constrained optimization is one of the most esoteric numerical
procedures.

Here we give very brief outline  of  the  MinNLC  optimizer.  We  strongly
recommend you to study examples in the ALGLIB Reference Manual and to read
ALGLIB User Guide on optimization, which is available at
http://www.alglib.net/optimization/

1. User initializes algorithm state with MinNLCCreate() call  and  chooses
   what NLC solver to use. There is some solver which is used by  default,
   with default settings, but you should NOT rely on  default  choice.  It
   may change in future releases of ALGLIB without notice, and no one  can
   guarantee that new solver will be  able  to  solve  your  problem  with
   default settings.

   From the other side, if you choose solver explicitly, you can be pretty
   sure that it will work with new ALGLIB releases.

   In the current release following solvers can be used:
   * AUL solver (activated with MinNLCSetAlgoAUL() function)

2. User adds boundary and/or linear and/or nonlinear constraints by  means
   of calling one of the following functions:
   a) MinNLCSetBC() for boundary constraints
   b) MinNLCSetLC() for linear constraints
   c) MinNLCSetNLC() for nonlinear constraints
   You may combine (a), (b) and (c) in one optimization problem.

3. User sets scale of the variables with MinNLCSetScale() function. It  is
   VERY important to set  scale  of  the  variables,  because  nonlinearly
   constrained problems are hard to solve when variables are badly scaled.

4. User sets  stopping  conditions  with  MinNLCSetCond(). If  NLC  solver
   uses  inner/outer  iteration  layout,  this  function   sets   stopping
   conditions for INNER iterations.

5. User chooses one of the  preconditioning  methods.  Preconditioning  is
   very  important  for  efficient  handling  of boundary/linear/nonlinear
   constraints. Without preconditioning algorithm would require  thousands
   of iterations even for simple problems.  Two  preconditioners  can   be
   used:
   * approximate LBFGS-based  preconditioner  which  should  be  used  for
     problems with almost orthogonal  constraints  (activated  by  calling
     MinNLCSetPrecInexact)
   * exact low-rank preconditiner (activated by MinNLCSetPrecExactLowRank)
     which should be used for problems with moderate number of constraints
     which do not have to be orthogonal.

6. Finally, user calls MinNLCOptimize()  function  which  takes  algorithm
   state and pointer (delegate, etc.) to callback function which calculates
   F/G/H.

7. User calls MinNLCResults() to get solution

8. Optionally user may call MinNLCRestartFrom() to solve  another  problem
   with same N but another starting point. MinNLCRestartFrom()  allows  to
   reuse already initialized structure.


INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size ofX
    X       -   starting point, array[N]:
                * it is better to set X to a feasible point
                * but X can be infeasible, in which case algorithm will try
                  to find feasible point first, using X as initial
                  approximation.

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlccreate(<font color=navy>double</font>[] x, <font color=navy>out</font> minnlcstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlccreate(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minnlcstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlccreatef'></a><h3 class=pageheader><code>minnlccreatef</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine is a finite  difference variant of MinNLCCreate(). It uses
finite differences in order to differentiate target function.

Description below contains information which is specific to this  function
only. We recommend to read comments on MinNLCCreate() in order to get more
information about creation of NLC optimizer.

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size ofX
    X       -   starting point, array[N]:
                * it is better to set X to a feasible point
                * but X can be infeasible, in which case algorithm will try
                  to find feasible point first, using X as initial
                  approximation.
    DiffStep-   differentiation step, &gt;0

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

NOTES:
1. algorithm uses 4-point central formula for differentiation.
2. differentiation step along I-th axis is equal to DiffStep*S[I] where
   S[] is scaling vector which can be set by MinNLCSetScale() call.
3. we recommend you to use moderate values of  differentiation  step.  Too
   large step will result in too large TRUNCATION  errors, while too small
   step will result in too large NUMERICAL  errors.  1.0E-4  can  be  good
   value to start from.
4. Numerical  differentiation  is   very   inefficient  -   one   gradient
   calculation needs 4*N function evaluations. This function will work for
   any N - either small (1...10), moderate (10...100) or  large  (100...).
   However, performance penalty will be too severe for any N's except  for
   small ones.
   We should also say that code which relies on numerical  differentiation
   is  less   robust   and  precise.  Imprecise  gradient  may  slow  down
   convergence, especially on highly nonlinear problems.
   Thus  we  recommend to use this function for fast prototyping on small-
   dimensional problems only, and to implement analytical gradient as soon
   as possible.

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlccreatef(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minnlcstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlccreatef(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minnlcstate state)

</div></pre>
<a name='sub_minnlcoptimize'></a><h3 class=pageheader><code>minnlcoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    fvec    -   callback which calculates function vector fi[]
                at given point x
    jac     -   callback which calculates function vector fi[]
                and Jacobian jac at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL


NOTES:

1. This function has two different implementations: one which  uses  exact
   (analytical) user-supplied Jacobian, and one which uses  only  function
   vector and numerically  differentiates  function  in  order  to  obtain
   gradient.

   Depending  on  the  specific  function  used to create optimizer object
   you should choose appropriate variant of MinNLCOptimize() -  one  which
   accepts function AND Jacobian or one which accepts ONLY function.

   Be careful to choose variant of MinNLCOptimize()  which  corresponds to
   your optimization scheme! Table below lists different  combinations  of
   callback (function/gradient) passed to MinNLCOptimize()   and  specific
   function used to create optimizer.


                     |         USER PASSED TO MinNLCOptimize()
   CREATED WITH      |  function only   |  function and gradient
   ------------------------------------------------------------
   MinNLCCreateF()   |     works               FAILS
   MinNLCCreate()    |     FAILS               works

   Here &quot;FAILS&quot; denotes inappropriate combinations  of  optimizer creation
   function  and  MinNLCOptimize()  version.   Attemps   to    use    such
   combination will lead to exception. Either  you  did  not pass gradient
   when it WAS needed or you passed gradient when it was NOT needed.

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minnlcoptimize(minnlcstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minnlcoptimize(minnlcstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcrestartfrom'></a><h3 class=pageheader><code>minnlcrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine restarts algorithm from new point.
All optimization parameters (including constraints) are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have  same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure previously allocated with MinNLCCreate call.
    X       -   new starting point.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcrestartfrom(minnlcstate state, <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_minnlcresults'></a><h3 class=pageheader><code>minnlcresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
MinNLC results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report. You should check Rep.TerminationType
                in  order  to  distinguish  successful  termination  from
                unsuccessful one:
                * -8    internal integrity control  detected  infinite or
                        NAN   values   in   function/gradient.   Abnormal
                        termination signalled.
                * -7   gradient verification failed.
                       See MinNLCSetGradientCheck() for more information.
                *  1   relative function improvement is no more than EpsF.
                *  2   scaled step is no more than EpsX.
                *  4   scaled gradient norm is no more than EpsG.
                *  5   MaxIts steps was taken
                More information about fields of this  structure  can  be
                found in the comments on MinNLCReport datatype.

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcresults(
    minnlcstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minnlcreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcresultsbuf'></a><h3 class=pageheader><code>minnlcresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
NLC results

Buffered implementation of MinNLCResults() which uses pre-allocated buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcresultsbuf(
    minnlcstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minnlcreport rep)

</div></pre>
<a name='sub_minnlcsetalgoaul'></a><h3 class=pageheader><code>minnlcsetalgoaul</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  tells MinNLC unit to use  Augmented  Lagrangian  algorithm
for nonlinearly constrained  optimization.  This  algorithm  is  a  slight
modification of one described in &quot;A Modified Barrier-Augmented  Lagrangian
Method for  Constrained  Minimization  (1999)&quot;  by  D.GOLDFARB,  R.POLYAK,
K. SCHEINBERG, I.YUZEFOVICH.

Augmented Lagrangian algorithm works by converting problem  of  minimizing
F(x) subject to equality/inequality constraints   to unconstrained problem
of the form

    min[ f(x) +
        + Rho*PENALTY_EQ(x)   + SHIFT_EQ(x,Nu1) +
        + Rho*PENALTY_INEQ(x) + SHIFT_INEQ(x,Nu2) ]

where:
* Rho is a fixed penalization coefficient
* PENALTY_EQ(x) is a penalty term, which is used to APPROXIMATELY  enforce
  equality constraints
* SHIFT_EQ(x) is a special &quot;shift&quot;  term  which  is  used  to  &quot;fine-tune&quot;
  equality constraints, greatly increasing precision
* PENALTY_INEQ(x) is a penalty term which is used to approximately enforce
  inequality constraints
* SHIFT_INEQ(x) is a special &quot;shift&quot;  term  which  is  used to &quot;fine-tune&quot;
  inequality constraints, greatly increasing precision
* Nu1/Nu2 are vectors of Lagrange coefficients which are fine-tuned during
  outer iterations of algorithm

This  version  of  AUL  algorithm  uses   preconditioner,  which   greatly
accelerates convergence. Because this  algorithm  is  similar  to  penalty
methods,  it  may  perform  steps  into  infeasible  area.  All  kinds  of
constraints (boundary, linear and nonlinear ones) may   be   violated   in
intermediate points - and in the solution.  However,  properly  configured
AUL method is significantly better at handling  constraints  than  barrier
and/or penalty methods.

The very basic outline of algorithm is given below:
1) first outer iteration is performed with &quot;default&quot;  values  of  Lagrange
   multipliers Nu1/Nu2. Solution quality is low (candidate  point  can  be
   too  far  away  from  true  solution; large violation of constraints is
   possible) and is comparable with that of penalty methods.
2) subsequent outer iterations  refine  Lagrange  multipliers  and improve
   quality of the solution.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    Rho     -   penalty coefficient, Rho&gt;0:
                * large enough  that  algorithm  converges  with   desired
                  precision. Minimum value is 10*max(S'*diag(H)*S),  where
                  S is a scale matrix (set by MinNLCSetScale) and H  is  a
                  Hessian of the function being minimized. If you can  not
                  easily estimate Hessian norm,  see  our  recommendations
                  below.
                * not TOO large to prevent ill-conditioning
                * for unit-scale problems (variables and Hessian have unit
                  magnitude), Rho=100 or Rho=1000 can be used.
                * it is important to note that Rho is internally multiplied
                  by scaling matrix, i.e. optimum value of Rho depends  on
                  scale of variables specified  by  MinNLCSetScale().
    ItsCnt  -   number of outer iterations:
                * ItsCnt=0 means that small number of outer iterations  is
                  automatically chosen (10 iterations in current version).
                * ItsCnt=1 means that AUL algorithm performs just as usual
                  barrier method.
                * ItsCnt&gt;1 means that  AUL  algorithm  performs  specified
                  number of outer iterations

HOW TO CHOOSE PARAMETERS

Nonlinear optimization is a tricky area and Augmented Lagrangian algorithm
is sometimes hard to tune. Good values of  Rho  and  ItsCnt  are  problem-
specific.  In  order  to  help  you   we   prepared   following   set   of
recommendations:

* for  unit-scale  problems  (variables  and Hessian have unit magnitude),
  Rho=100 or Rho=1000 can be used.

* start from  some  small  value of Rho and solve problem  with  just  one
  outer iteration (ItcCnt=1). In this case algorithm behaves like  penalty
  method. Increase Rho in 2x or 10x steps until you  see  that  one  outer
  iteration returns point which is &quot;rough approximation to solution&quot;.

  It is very important to have Rho so  large  that  penalty  term  becomes
  constraining i.e. modified function becomes highly convex in constrained
  directions.

  From the other side, too large Rho may prevent you  from  converging  to
  the solution. You can diagnose it by studying number of inner iterations
  performed by algorithm: too few (5-10 on  1000-dimensional  problem)  or
  too many (orders of magnitude more than  dimensionality)  usually  means
  that Rho is too large.

* with just one outer iteration you  usually  have  low-quality  solution.
  Some constraints can be violated with very  large  margin,  while  other
  ones (which are NOT violated in the true solution) can push final  point
  too far in the inner area of the feasible set.

  For example, if you have constraint x0&gt;=0 and true solution  x0=1,  then
  merely a presence of &quot;x0&gt;=0&quot; will introduce a bias towards larger values
  of x0. Say, algorithm may stop at x0=1.5 instead of 1.0.

* after you found good Rho, you may increase number of  outer  iterations.
  ItsCnt=10 is a good value. Subsequent outer iteration will refine values
  of  Lagrange  multipliers.  Constraints  which  were  violated  will  be
  enforced, inactive constraints will be dropped (corresponding multipliers
  will be decreased). Ideally, you  should  see  10-1000x  improvement  in
  constraint handling (constraint violation is reduced).

* if  you  see  that  algorithm  converges  to  vicinity  of solution, but
  additional outer iterations do not refine solution,  it  may  mean  that
  algorithm is unstable - it wanders around true  solution,  but  can  not
  approach it. Sometimes algorithm may be stabilized by increasing Rho one
  more time, making it 5x or 10x larger.

SCALING OF CONSTRAINTS [IMPORTANT]

AUL optimizer scales   variables   according   to   scale   specified   by
MinNLCSetScale() function, so it can handle  problems  with  badly  scaled
variables (as long as we KNOW their scales).   However,  because  function
being optimized is a mix  of  original  function and  constraint-dependent
penalty  functions, it  is   important  to   rescale  both  variables  AND
constraints.

Say,  if  you  minimize f(x)=x^2 subject to 1000000*x&gt;=0,  then  you  have
constraint whose scale is different from that of target  function (another
example is 0.000001*x&gt;=0). It is also possible to have constraints   whose
scales  are   misaligned:   1000000*x0&gt;=0, 0.000001*x1&lt;=0.   Inappropriate
scaling may ruin convergence because minimizing x^2 subject to x&gt;=0 is NOT
same as minimizing it subject to 1000000*x&gt;=0.

Because we  know  coefficients  of  boundary/linear  constraints,  we  can
automatically rescale and normalize them. However,  there  is  no  way  to
automatically rescale nonlinear constraints Gi(x) and  Hi(x)  -  they  are
black boxes.

It means that YOU are the one who is  responsible  for  correct scaling of
nonlinear constraints  Gi(x)  and  Hi(x).  We  recommend  you  to  rescale
nonlinear constraints in such way that I-th component of dG/dX (or  dH/dx)
has magnitude approximately equal to 1/S[i] (where S  is  a  scale  set by
MinNLCSetScale() function).

WHAT IF IT DOES NOT CONVERGE?

It is possible that AUL algorithm fails to converge to precise  values  of
Lagrange multipliers. It stops somewhere around true solution, but candidate
point is still too far from solution, and some constraints  are  violated.
Such kind of failure is specific for Lagrangian algorithms -  technically,
they stop at some point, but this point is not constrained solution.

There are exist several reasons why algorithm may fail to converge:
a) too loose stopping criteria for inner iteration
b) degenerate, redundant constraints
c) target function has unconstrained extremum exactly at the  boundary  of
   some constraint
d) numerical noise in the target function

In all these cases algorithm is unstable - each outer iteration results in
large and almost random step which improves handling of some  constraints,
but violates other ones (ideally  outer iterations should form a  sequence
of progressively decreasing steps towards solution).

First reason possible is  that  too  loose  stopping  criteria  for  inner
iteration were specified. Augmented Lagrangian algorithm solves a sequence
of intermediate problems, and requries each of them to be solved with high
precision. Insufficient precision results in incorrect update of  Lagrange
multipliers.

Another reason is that you may have specified degenerate constraints: say,
some constraint was repeated twice. In most cases AUL algorithm gracefully
handles such situations, but sometimes it may spend too much time figuring
out subtle degeneracies in constraint matrix.

Third reason is tricky and hard to diagnose. Consider situation  when  you
minimize  f=x^2  subject to constraint x&gt;=0.  Unconstrained   extremum  is
located  exactly  at  the  boundary  of  constrained  area.  In  this case
algorithm will tend to oscillate between negative  and  positive  x.  Each
time it stops at x&lt;0 it &quot;reinforces&quot; constraint x&gt;=0, and each time it  is
bounced to x&gt;0 it &quot;relaxes&quot; constraint (and is  attracted  to  x&lt;0).

Such situation  sometimes  happens  in  problems  with  hidden  symetries.
Algorithm  is  got  caught  in  a  loop with  Lagrange  multipliers  being
continuously increased/decreased. Luckily, such loop forms after at  least
three iterations, so this problem can be solved by  DECREASING  number  of
outer iterations down to 1-2 and increasing  penalty  coefficient  Rho  as
much as possible.

Final reason is numerical noise. AUL algorithm is robust against  moderate
noise (more robust than, say, active set methods),  but  large  noise  may
destabilize algorithm.

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetalgoaul(
    minnlcstate state,
    <font color=navy>double</font> rho,
    <font color=navy>int</font> itscnt)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcsetbc'></a><h3 class=pageheader><code>minnlcsetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets boundary constraints for NLC optimizer.

Boundary constraints are inactive by  default  (after  initial  creation).
They are preserved after algorithm restart with  MinNLCRestartFrom().

You may combine boundary constraints with  general  linear ones - and with
nonlinear ones! Boundary constraints are  handled  more  efficiently  than
other types.  Thus,  if  your  problem  has  mixed  constraints,  you  may
explicitly specify some of them as boundary and save some time/space.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    BndL    -   lower bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very small number or -INF.
    BndU    -   upper bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very large number or +INF.

NOTE 1:  it is possible to specify  BndL[i]=BndU[i].  In  this  case  I-th
variable will be &quot;frozen&quot; at X[i]=BndL[i]=BndU[i].

NOTE 2:  when you solve your problem  with  augmented  Lagrangian  solver,
         boundary constraints are  satisfied  only  approximately!  It  is
         possible   that  algorithm  will  evaluate  function  outside  of
         feasible area!

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetbc(
    minnlcstate state,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<a name='sub_minnlcsetcond'></a><h3 class=pageheader><code>minnlcsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for inner iterations of  optimizer.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinNLCSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |v|&lt;=EpsX is fulfilled, where:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - step vector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinNLCSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0 and EpsX=0 and MaxIts=0 (simultaneously) will lead
to automatic stopping criterion selection.

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetcond(
    minnlcstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcsetgradientcheck'></a><h3 class=pageheader><code>minnlcsetgradientcheck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  turns  on  verification  of  the  user-supplied analytic
gradient:
* user calls this subroutine before optimization begins
* MinNLCOptimize() is called
* prior to  actual  optimization, for each component  of  parameters being
  optimized X[i] algorithm performs following steps:
  * two trial steps are made to X[i]-TestStep*S[i] and X[i]+TestStep*S[i],
    where X[i] is i-th component of the initial point and S[i] is a  scale
    of i-th parameter
  * F(X) is evaluated at these trial points
  * we perform one more evaluation in the middle point of the interval
  * we  build  cubic  model using function values and derivatives at trial
    points and we compare its prediction with actual value in  the  middle
    point
  * in case difference between prediction and actual value is higher  than
    some predetermined threshold, algorithm stops with completion code -7;
    Rep.VarIdx is set to index of the parameter with incorrect derivative,
    and Rep.FuncIdx is set to index of the function.
* after verification is over, algorithm proceeds to the actual optimization.

NOTE 1: verification  needs  N (parameters count) gradient evaluations. It
        is very costly and you should use  it  only  for  low  dimensional
        problems,  when  you  want  to  be  sure  that  you've   correctly
        calculated  analytic  derivatives.  You  should  not use it in the
        production code (unless you want to check derivatives provided  by
        some third party).

NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
        (so large that function behaviour is significantly non-cubic) will
        lead to false alarms. You may use  different  step  for  different
        parameters by means of setting scale with MinNLCSetScale().

NOTE 3: this function may lead to false positives. In case it reports that
        I-th  derivative was calculated incorrectly, you may decrease test
        step  and  try  one  more  time  - maybe your function changes too
        sharply  and  your  step  is  too  large for such rapidly chanding
        function.

INPUT PARAMETERS:
    State       -   structure used to store algorithm state
    TestStep    -   verification step:
                    * TestStep=0 turns verification off
                    * TestStep&gt;0 activates verification

  -- ALGLIB --
     Copyright 15.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetgradientcheck(
    minnlcstate state,
    <font color=navy>double</font> teststep)

</div></pre>
<a name='sub_minnlcsetlc'></a><h3 class=pageheader><code>minnlcsetlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets linear constraints for MinNLC optimizer.

Linear constraints are inactive by default (after initial creation).  They
are preserved after algorithm restart with MinNLCRestartFrom().

You may combine linear constraints with boundary ones - and with nonlinear
ones! If your problem has mixed constraints, you  may  explicitly  specify
some of them as linear. It  may  help  optimizer   to   handle  them  more
efficiently.

INPUT PARAMETERS:
    State   -   structure previously allocated with MinNLCCreate call.
    C       -   linear constraints, array[K,N+1].
                Each row of C represents one constraint, either equality
                or inequality (see below):
                * first N elements correspond to coefficients,
                * last element corresponds to the right part.
                All elements of C (including right part) must be finite.
    CT      -   type of constraints, array[K]:
                * if CT[i]&gt;0, then I-th constraint is C[i,*]*x &gt;= C[i,n+1]
                * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
                * if CT[i]&lt;0, then I-th constraint is C[i,*]*x &lt;= C[i,n+1]
    K       -   number of equality/inequality constraints, K&gt;=0:
                * if given, only leading K elements of C/CT are used
                * if not given, automatically determined from sizes of C/CT

NOTE 1: when you solve your problem  with  augmented  Lagrangian   solver,
        linear constraints are  satisfied  only   approximately!   It   is
        possible   that  algorithm  will  evaluate  function  outside   of
        feasible area!

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetlc(
    minnlcstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetlc(
    minnlcstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct,
    <font color=navy>int</font> k)

</div></pre>
<a name='sub_minnlcsetnlc'></a><h3 class=pageheader><code>minnlcsetnlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets nonlinear constraints for MinNLC optimizer.

In fact, this function sets NUMBER of nonlinear  constraints.  Constraints
itself (constraint functions) are passed to MinNLCOptimize() method.  This
method requires user-defined vector function F[]  and  its  Jacobian  J[],
where:
* first component of F[] and first row  of  Jacobian  J[]  corresponds  to
  function being minimized
* next NLEC components of F[] (and rows  of  J)  correspond  to  nonlinear
  equality constraints G_i(x)=0
* next NLIC components of F[] (and rows  of  J)  correspond  to  nonlinear
  inequality constraints H_i(x)&lt;=0

NOTE: you may combine nonlinear constraints with linear/boundary ones.  If
      your problem has mixed constraints, you  may explicitly specify some
      of them as linear ones. It may help optimizer to  handle  them  more
      efficiently.

INPUT PARAMETERS:
    State   -   structure previously allocated with MinNLCCreate call.
    NLEC    -   number of Non-Linear Equality Constraints (NLEC), &gt;=0
    NLIC    -   number of Non-Linear Inquality Constraints (NLIC), &gt;=0

NOTE 1: when you solve your problem  with  augmented  Lagrangian   solver,
        nonlinear constraints are satisfied only  approximately!   It   is
        possible   that  algorithm  will  evaluate  function  outside   of
        feasible area!

NOTE 2: algorithm scales variables  according  to   scale   specified   by
        MinNLCSetScale()  function,  so  it can handle problems with badly
        scaled variables (as long as we KNOW their scales).

        However,  there  is  no  way  to  automatically  scale   nonlinear
        constraints Gi(x) and Hi(x). Inappropriate scaling  of  Gi/Hi  may
        ruin convergence. Solving problem with  constraint  &quot;1000*G0(x)=0&quot;
        is NOT same as solving it with constraint &quot;0.001*G0(x)=0&quot;.

        It  means  that  YOU  are  the  one who is responsible for correct
        scaling of nonlinear constraints Gi(x) and Hi(x). We recommend you
        to scale nonlinear constraints in such way that I-th component  of
        dG/dX (or dH/dx) has approximately unit  magnitude  (for  problems
        with unit scale)  or  has  magnitude approximately equal to 1/S[i]
        (where S is a scale set by MinNLCSetScale() function).


  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetnlc(
    minnlcstate state,
    <font color=navy>int</font> nlec,
    <font color=navy>int</font> nlic)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcsetprecexactlowrank'></a><h3 class=pageheader><code>minnlcsetprecexactlowrank</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets preconditioner to &quot;exact low rank&quot; mode.

Preconditioning is very important for convergence of  Augmented Lagrangian
algorithm because presence of penalty term makes problem  ill-conditioned.
Difference between  performance  of  preconditioned  and  unpreconditioned
methods can be as large as 100x!

MinNLC optimizer may  utilize  two  preconditioners,  each  with  its  own
benefits and drawbacks: a) inexact LBFGS-based, and b) exact low rank one.
It also provides special unpreconditioned mode of operation which  can  be
used for test purposes. Comments below discuss low rank preconditioner.

Exact low-rank preconditioner  uses  Woodbury  matrix  identity  to  build
quadratic model of the penalized function. It has no  special  assumptions
about orthogonality, so it is quite general. However, for a  N-dimensional
problem with K general linear or nonlinear constraints (boundary ones  are
not counted) it has O(N*K^2) cost per iteration (for  comparison:  inexact
LBFGS-based preconditioner has O(N*K) cost).

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    UpdateFreq- update frequency. Preconditioner is  rebuilt  after  every
                UpdateFreq iterations. Recommended value: 10 or higher.
                Zero value means that good default value will be used.

  -- ALGLIB --
     Copyright 26.09.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetprecexactlowrank(
    minnlcstate state,
    <font color=navy>int</font> updatefreq)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcsetprecinexact'></a><h3 class=pageheader><code>minnlcsetprecinexact</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets preconditioner to &quot;inexact LBFGS-based&quot; mode.

Preconditioning is very important for convergence of  Augmented Lagrangian
algorithm because presence of penalty term makes problem  ill-conditioned.
Difference between  performance  of  preconditioned  and  unpreconditioned
methods can be as large as 100x!

MinNLC optimizer may  utilize  two  preconditioners,  each  with  its  own
benefits and drawbacks: a) inexact LBFGS-based, and b) exact low rank one.
It also provides special unpreconditioned mode of operation which  can  be
used for test purposes. Comments below discuss LBFGS-based preconditioner.

Inexact  LBFGS-based  preconditioner  uses L-BFGS  formula  combined  with
orthogonality assumption to perform very fast updates. For a N-dimensional
problem with K general linear or nonlinear constraints (boundary ones  are
not counted) it has O(N*K) cost per iteration.  This   preconditioner  has
best  quality  (less  iterations)  when   general   linear  and  nonlinear
constraints are orthogonal to each other (orthogonality  with  respect  to
boundary constraints is not required). Number of iterations increases when
constraints  are  non-orthogonal, because algorithm assumes orthogonality,
but still it is better than no preconditioner at all.

INPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 26.09.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetprecinexact(minnlcstate state)

</div></pre>
<a name='sub_minnlcsetprecnone'></a><h3 class=pageheader><code>minnlcsetprecnone</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets preconditioner to &quot;turned off&quot; mode.

Preconditioning is very important for convergence of  Augmented Lagrangian
algorithm because presence of penalty term makes problem  ill-conditioned.
Difference between  performance  of  preconditioned  and  unpreconditioned
methods can be as large as 100x!

MinNLC optimizer may  utilize  two  preconditioners,  each  with  its  own
benefits and drawbacks: a) inexact LBFGS-based, and b) exact low rank one.
It also provides special unpreconditioned mode of operation which  can  be
used for test purposes.

This function activates this test mode. Do not use it in  production  code
to solve real-life problems.

INPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 26.09.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetprecnone(minnlcstate state)

</div></pre>
<a name='sub_minnlcsetscale'></a><h3 class=pageheader><code>minnlcsetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for NLC optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Scaling is also used by finite difference variant of the optimizer  - step
along I-th axis is equal to DiffStep*S[I].

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 06.06.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetscale(minnlcstate state, <font color=navy>double</font>[] s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minnlc_d_inequality' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_equality' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minnlc_d_mixed' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnlcsetxrep'></a><h3 class=pageheader><code>minnlcsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to MinNLCOptimize().

NOTE: algorithm passes two parameters to rep() callback  -  current  point
      and penalized function value at current point. Important -  function
      value which is returned is NOT function being minimized. It  is  sum
      of the value of the function being minimized - and penalty term.

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnlcsetxrep(minnlcstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='example_minnlc_d_equality'></a><h3 class=pageheader>minnlc_d_equality example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nlcfunc1_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = -x0+x1</font>
    <font color=green>//     f1(x0,x1) = x0^2+x1^2-1</font>
    <font color=green>//</font>
    <font color=green>// and Jacobian matrix J = [dfi/dxj]</font>
    <font color=green>//</font>
    fi[0] = -x[0]+x[1];
    fi[1] = x[0]*x[0] + x[1]*x[1] - 1.0;
    jac[0,0] = -1.0;
    jac[0,1] = +1.0;
    jac[1,0] = 2*x[0];
    jac[1,1] = 2*x[1];
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = -x0+x1</font>
    <font color=green>//</font>
    <font color=green>// subject to nonlinear equality constraint</font>
    <font color=green>//</font>
    <font color=green>//    x0^2 + x1^2 - 1 = 0</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font> epsg = 0;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> outerits = 5;
    <font color=navy>int</font> updatefreq = 10;
    <font color=navy>double</font> rho = 1000;
    alglib.minnlcstate state;
    alglib.minnlcreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AUL algorithm and tune its settings:</font>
    <font color=green>// * rho=1000       penalty coefficient</font>
    <font color=green>// * outerits=5     number of outer iterations to tune Lagrange coefficients</font>
    <font color=green>// * epsx=0.000001  stopping condition <font color=navy>for</font> inner iterations</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>// * exact low-rank preconditioner is used, updated after each 10 iterations</font>
    <font color=green>//</font>
    alglib.minnlccreate(2, x0, <font color=navy>out</font> state);
    alglib.minnlcsetalgoaul(state, rho, outerits);
    alglib.minnlcsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minnlcsetscale(state, s);
    alglib.minnlcsetprecexactlowrank(state, updatefreq);

    <font color=green>//</font>
    <font color=green>// Set constraints:</font>
    <font color=green>//</font>
    <font color=green>// Nonlinear constraints are tricky - you can not <font color=blue><b>&quot;pack&quot;</b></font> general</font>
    <font color=green>// nonlinear function into <font color=navy>double</font> precision array. That's why</font>
    <font color=green>// minnlcsetnlc() does not accept constraints itself - only constraint</font>
    <font color=green>// counts are passed: first parameter is number of equality constraints,</font>
    <font color=green>// second one is number of inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>// As <font color=navy>for</font> constraining functions - these functions are passed as part</font>
    <font color=green>// of problem Jacobian (see below).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: MinNLC optimizer supports arbitrary combination of boundary, general</font>
    <font color=green>//       linear and general nonlinear constraints. This example does not</font>
    <font color=green>//       show how to work with general linear constraints, but you can</font>
    <font color=green>//       easily find it in documentation on minnlcsetbc() and</font>
    <font color=green>//       minnlcsetlc() functions.</font>
    <font color=green>//</font>
    alglib.minnlcsetnlc(state, 1, 0);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function and its Jacobian, with first</font>
    <font color=green>// component (Jacobian row) being target function, and next components</font>
    <font color=green>// (Jacobian rows) being nonlinear equality and inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0,f1} = { -x0+x1 , x0^2+x1^2-1 }</font>
    <font color=green>//</font>
    <font color=green>// with Jacobian</font>
    <font color=green>//</font>
    <font color=green>//         [  -1    +1  ]</font>
    <font color=green>//     J = [            ]</font>
    <font color=green>//         [ 2*x0  2*x1 ]</font>
    <font color=green>//</font>
    <font color=green>// with f0 being target function, f1 being constraining function. Number</font>
    <font color=green>// of equality/inequality constraints is specified by minnlcsetnlc(),</font>
    <font color=green>// with equality ones always being first, inequality ones being last.</font>
    <font color=green>//</font>
    alglib.minnlcoptimize(state, nlcfunc1_jac, null, null);
    alglib.minnlcresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [0.70710,-0.70710]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minnlc_d_inequality'></a><h3 class=pageheader>minnlc_d_inequality example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nlcfunc1_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = -x0+x1</font>
    <font color=green>//     f1(x0,x1) = x0^2+x1^2-1</font>
    <font color=green>//</font>
    <font color=green>// and Jacobian matrix J = [dfi/dxj]</font>
    <font color=green>//</font>
    fi[0] = -x[0]+x[1];
    fi[1] = x[0]*x[0] + x[1]*x[1] - 1.0;
    jac[0,0] = -1.0;
    jac[0,1] = +1.0;
    jac[1,0] = 2*x[0];
    jac[1,1] = 2*x[1];
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = -x0+x1</font>
    <font color=green>//</font>
    <font color=green>// subject to boundary constraints</font>
    <font color=green>//</font>
    <font color=green>//    x0&gt;=0, x1&gt;=0</font>
    <font color=green>//</font>
    <font color=green>// and nonlinear inequality constraint</font>
    <font color=green>//</font>
    <font color=green>//    x0^2 + x1^2 - 1 &lt;= 0</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font> epsg = 0;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> outerits = 5;
    <font color=navy>int</font> updatefreq = 10;
    <font color=navy>double</font> rho = 1000;
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{0,0};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{System.Double.PositiveInfinity,+System.Double.PositiveInfinity};
    alglib.minnlcstate state;
    alglib.minnlcreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AUL algorithm and tune its settings:</font>
    <font color=green>// * rho=1000       penalty coefficient</font>
    <font color=green>// * outerits=5     number of outer iterations to tune Lagrange coefficients</font>
    <font color=green>// * epsx=0.000001  stopping condition <font color=navy>for</font> inner iterations</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>// * exact low-rank preconditioner is used, updated after each 10 iterations</font>
    <font color=green>//</font>
    alglib.minnlccreate(2, x0, <font color=navy>out</font> state);
    alglib.minnlcsetalgoaul(state, rho, outerits);
    alglib.minnlcsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minnlcsetscale(state, s);
    alglib.minnlcsetprecexactlowrank(state, updatefreq);

    <font color=green>//</font>
    <font color=green>// Set constraints:</font>
    <font color=green>//</font>
    <font color=green>// 1. boundary constraints are passed with minnlcsetbc() call</font>
    <font color=green>//</font>
    <font color=green>// 2. nonlinear constraints are more tricky - you can not <font color=blue><b>&quot;pack&quot;</b></font> general</font>
    <font color=green>//    nonlinear function into <font color=navy>double</font> precision array. That's why</font>
    <font color=green>//    minnlcsetnlc() does not accept constraints itself - only constraint</font>
    <font color=green>//    counts are passed: first parameter is number of equality constraints,</font>
    <font color=green>//    second one is number of inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>//    As <font color=navy>for</font> constraining functions - these functions are passed as part</font>
    <font color=green>//    of problem Jacobian (see below).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: MinNLC optimizer supports arbitrary combination of boundary, general</font>
    <font color=green>//       linear and general nonlinear constraints. This example does not</font>
    <font color=green>//       show how to work with general linear constraints, but you can</font>
    <font color=green>//       easily find it in documentation on minnlcsetlc() function.</font>
    <font color=green>//</font>
    alglib.minnlcsetbc(state, bndl, bndu);
    alglib.minnlcsetnlc(state, 0, 1);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function and its Jacobian, with first</font>
    <font color=green>// component (Jacobian row) being target function, and next components</font>
    <font color=green>// (Jacobian rows) being nonlinear equality and inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0,f1} = { -x0+x1 , x0^2+x1^2-1 }</font>
    <font color=green>//</font>
    <font color=green>// with Jacobian</font>
    <font color=green>//</font>
    <font color=green>//         [  -1    +1  ]</font>
    <font color=green>//     J = [            ]</font>
    <font color=green>//         [ 2*x0  2*x1 ]</font>
    <font color=green>//</font>
    <font color=green>// with f0 being target function, f1 being constraining function. Number</font>
    <font color=green>// of equality/inequality constraints is specified by minnlcsetnlc(),</font>
    <font color=green>// with equality ones always being first, inequality ones being last.</font>
    <font color=green>//</font>
    alglib.minnlcoptimize(state, nlcfunc1_jac, null, null);
    alglib.minnlcresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [1.0000,0.0000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minnlc_d_mixed'></a><h3 class=pageheader>minnlc_d_mixed example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nlcfunc2_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1,x2) = x0+x1</font>
    <font color=green>//     f1(x0,x1,x2) = x2-exp(x0)</font>
    <font color=green>//     f2(x0,x1,x2) = x0^2+x1^2-1</font>
    <font color=green>//</font>
    <font color=green>// and Jacobian matrix J = [dfi/dxj]</font>
    <font color=green>//</font>
    fi[0] = x[0]+x[1];
    fi[1] = x[2]-System.Math.Exp(x[0]);
    fi[2] = x[0]*x[0] + x[1]*x[1] - 1.0;
    jac[0,0] = 1.0;
    jac[0,1] = 1.0;
    jac[0,2] = 0.0;
    jac[1,0] = -System.Math.Exp(x[0]);
    jac[1,1] = 0.0;
    jac[1,2] = 1.0;
    jac[2,0] = 2*x[0];
    jac[2,1] = 2*x[1];
    jac[2,2] = 0.0;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = x0+x1</font>
    <font color=green>//</font>
    <font color=green>// subject to nonlinear inequality constraint</font>
    <font color=green>//</font>
    <font color=green>//    x0^2 + x1^2 - 1 &lt;= 0</font>
    <font color=green>//</font>
    <font color=green>// and nonlinear equality constraint</font>
    <font color=green>//</font>
    <font color=green>//    x2-exp(x0) = 0</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{0,0,0};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1,1};
    <font color=navy>double</font> epsg = 0;
    <font color=navy>double</font> epsf = 0;
    <font color=navy>double</font> epsx = 0.000001;
    <font color=navy>int</font> maxits = 0;
    <font color=navy>int</font> outerits = 5;
    <font color=navy>int</font> updatefreq = 10;
    <font color=navy>double</font> rho = 1000;
    alglib.minnlcstate state;
    alglib.minnlcreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AUL algorithm and tune its settings:</font>
    <font color=green>// * rho=1000       penalty coefficient</font>
    <font color=green>// * outerits=5     number of outer iterations to tune Lagrange coefficients</font>
    <font color=green>// * epsx=0.000001  stopping condition <font color=navy>for</font> inner iterations</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>// * exact low-rank preconditioner is used, updated after each 10 iterations</font>
    <font color=green>//</font>
    alglib.minnlccreate(3, x0, <font color=navy>out</font> state);
    alglib.minnlcsetalgoaul(state, rho, outerits);
    alglib.minnlcsetcond(state, epsg, epsf, epsx, maxits);
    alglib.minnlcsetscale(state, s);
    alglib.minnlcsetprecexactlowrank(state, updatefreq);

    <font color=green>//</font>
    <font color=green>// Set constraints:</font>
    <font color=green>//</font>
    <font color=green>// Nonlinear constraints are tricky - you can not <font color=blue><b>&quot;pack&quot;</b></font> general</font>
    <font color=green>// nonlinear function into <font color=navy>double</font> precision array. That's why</font>
    <font color=green>// minnlcsetnlc() does not accept constraints itself - only constraint</font>
    <font color=green>// counts are passed: first parameter is number of equality constraints,</font>
    <font color=green>// second one is number of inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>// As <font color=navy>for</font> constraining functions - these functions are passed as part</font>
    <font color=green>// of problem Jacobian (see below).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: MinNLC optimizer supports arbitrary combination of boundary, general</font>
    <font color=green>//       linear and general nonlinear constraints. This example does not</font>
    <font color=green>//       show how to work with boundary or general linear constraints, but you</font>
    <font color=green>//       can easily find it in documentation on minnlcsetbc() and</font>
    <font color=green>//       minnlcsetlc() functions.</font>
    <font color=green>//</font>
    alglib.minnlcsetnlc(state, 1, 1);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function and its Jacobian, with first</font>
    <font color=green>// component (Jacobian row) being target function, and next components</font>
    <font color=green>// (Jacobian rows) being nonlinear equality and inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0,f1,f2} = { x0+x1 , x2-exp(x0) , x0^2+x1^2-1 }</font>
    <font color=green>//</font>
    <font color=green>// with Jacobian</font>
    <font color=green>//</font>
    <font color=green>//         [  +1      +1       0 ]</font>
    <font color=green>//     J = [-exp(x0)  0        1 ]</font>
    <font color=green>//         [ 2*x0    2*x1      0 ]</font>
    <font color=green>//</font>
    <font color=green>// with f0 being target function, f1 being equality constraint <font color=blue><b>&quot;f1=0&quot;</b></font>,</font>
    <font color=green>// f2 being inequality constraint <font color=blue><b>&quot;f2&lt;=0&quot;</b></font>. Number of equality/inequality</font>
    <font color=green>// constraints is specified by minnlcsetnlc(), with equality ones always</font>
    <font color=green>// being first, inequality ones being last.</font>
    <font color=green>//</font>
    alglib.minnlcoptimize(state, nlcfunc2_jac, null, null);
    alglib.minnlcresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [-0.70710,-0.70710,0.49306]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_minns></a><h2 class=pageheader><code>minns</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minnsreport' class=toc>minnsreport</a><br>
<a href='#struct_minnsstate' class=toc>minnsstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minnscreate' class=toc>minnscreate</a><br>
<a href='#sub_minnscreatef' class=toc>minnscreatef</a><br>
<a href='#sub_minnsoptimize' class=toc>minnsoptimize</a><br>
<a href='#sub_minnsrequesttermination' class=toc>minnsrequesttermination</a><br>
<a href='#sub_minnsrestartfrom' class=toc>minnsrestartfrom</a><br>
<a href='#sub_minnsresults' class=toc>minnsresults</a><br>
<a href='#sub_minnsresultsbuf' class=toc>minnsresultsbuf</a><br>
<a href='#sub_minnssetalgoags' class=toc>minnssetalgoags</a><br>
<a href='#sub_minnssetbc' class=toc>minnssetbc</a><br>
<a href='#sub_minnssetcond' class=toc>minnssetcond</a><br>
<a href='#sub_minnssetlc' class=toc>minnssetlc</a><br>
<a href='#sub_minnssetnlc' class=toc>minnssetnlc</a><br>
<a href='#sub_minnssetscale' class=toc>minnssetscale</a><br>
<a href='#sub_minnssetxrep' class=toc>minnssetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minns_d_bc' class=toc>minns_d_bc</a></td><td width=15>&nbsp;</td><td>Nonsmooth box constrained optimization</td></tr>
<tr align=left valign=top><td><a href='#example_minns_d_diff' class=toc>minns_d_diff</a></td><td width=15>&nbsp;</td><td>Nonsmooth unconstrained optimization with numerical differentiation</td></tr>
<tr align=left valign=top><td><a href='#example_minns_d_nlc' class=toc>minns_d_nlc</a></td><td width=15>&nbsp;</td><td>Nonsmooth nonlinearly constrained optimization</td></tr>
<tr align=left valign=top><td><a href='#example_minns_d_unconstrained' class=toc>minns_d_unconstrained</a></td><td width=15>&nbsp;</td><td>Nonsmooth unconstrained optimization</td></tr>
</table></div>
<a name='struct_minnsreport'></a><h3 class=pageheader><code>minnsreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores optimization report:
* IterationsCount           total number of inner iterations
* NFEV                      number of gradient evaluations
* TerminationType           termination type (see below)
* CErr                      maximum violation of all types of constraints
* LCErr                     maximum violation of linear constraints
* NLCErr                    maximum violation of nonlinear constraints

TERMINATION CODES

TerminationType field contains completion code, which can be:
  -8    internal integrity control detected  infinite  or  NAN  values  in
        function/gradient. Abnormal termination signalled.
  -3    box constraints are inconsistent
  -1    inconsistent parameters were passed:
        * penalty parameter for minnssetalgoags() is zero,
          but we have nonlinear constraints set by minnssetnlc()
   2    sampling radius decreased below epsx
   5    MaxIts steps was taken
   7    stopping conditions are too stringent,
        further improvement is impossible,
        X contains best point found so far.
   8    User requested termination via MinNSRequestTermination()

Other fields of this structure are not documented and should not be used!
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minnsreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>double</font>               cerr;
    <font color=navy>public</font> <font color=navy>double</font>               lcerr;
    <font color=navy>public</font> <font color=navy>double</font>               nlcerr;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
    <font color=navy>public</font> <font color=navy>int</font>                  varidx;
    <font color=navy>public</font> <font color=navy>int</font>                  funcidx;
}

</div></pre>
<a name='struct_minnsstate'></a><h3 class=pageheader><code>minnsstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores nonlinear optimizer state.
You should use functions provided by MinNS subpackage to work  with  this
object
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minnsstate
{
}

</div></pre>
<a name='sub_minnscreate'></a><h3 class=pageheader><code>minnscreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                  NONSMOOTH NONCONVEX OPTIMIZATION
            SUBJECT TO BOX/LINEAR/NONLINEAR-NONSMOOTH CONSTRAINTS

DESCRIPTION:

The  subroutine  minimizes  function   F(x)  of N arguments subject to any
combination of:
* bound constraints
* linear inequality constraints
* linear equality constraints
* nonlinear equality constraints Gi(x)=0
* nonlinear inequality constraints Hi(x)&lt;=0

IMPORTANT: see MinNSSetAlgoAGS for important  information  on  performance
           restrictions of AGS solver.

REQUIREMENTS:
* starting point X0 must be feasible or not too far away from the feasible
  set
* F(), G(), H() are continuous, locally Lipschitz  and  continuously  (but
  not necessarily twice) differentiable in an open dense  subset  of  R^N.
  Functions F(), G() and H() may be nonsmooth and non-convex.
  Informally speaking, it means  that  functions  are  composed  of  large
  differentiable &quot;patches&quot; with nonsmoothness having  place  only  at  the
  boundaries between these &quot;patches&quot;.
  Most real-life nonsmooth  functions  satisfy  these  requirements.  Say,
  anything which involves finite number of abs(), min() and max() is  very
  likely to pass the test.
  Say, it is possible to optimize anything of the following:
  * f=abs(x0)+2*abs(x1)
  * f=max(x0,x1)
  * f=sin(max(x0,x1)+abs(x2))
* for nonlinearly constrained problems: F()  must  be  bounded from  below
  without nonlinear constraints (this requirement is due to the fact that,
  contrary to box and linear constraints, nonlinear ones  require  special
  handling).
* user must provide function value and gradient for F(), H(), G()  at  all
  points where function/gradient can be calculated. If optimizer  requires
  value exactly at the boundary between &quot;patches&quot; (say, at x=0 for f=abs(x)),
  where gradient is not defined, user may resolve tie arbitrarily (in  our
  case - return +1 or -1 at its discretion).
* NS solver supports numerical differentiation, i.e. it may  differentiate
  your function for you,  but  it  results  in  2N  increase  of  function
  evaluations. Not recommended unless you solve really small problems. See
  minnscreatef() for more information on this functionality.

USAGE:

1. User initializes algorithm state with MinNSCreate() call  and   chooses
   what NLC solver to use. There is some solver which is used by  default,
   with default settings, but you should NOT rely on  default  choice.  It
   may change in future releases of ALGLIB without notice, and no one  can
   guarantee that new solver will be  able  to  solve  your  problem  with
   default settings.

   From the other side, if you choose solver explicitly, you can be pretty
   sure that it will work with new ALGLIB releases.

   In the current release following solvers can be used:
   * AGS solver (activated with MinNSSetAlgoAGS() function)

2. User adds boundary and/or linear and/or nonlinear constraints by  means
   of calling one of the following functions:
   a) MinNSSetBC() for boundary constraints
   b) MinNSSetLC() for linear constraints
   c) MinNSSetNLC() for nonlinear constraints
   You may combine (a), (b) and (c) in one optimization problem.

3. User sets scale of the variables with MinNSSetScale() function. It   is
   VERY important to set  scale  of  the  variables,  because  nonlinearly
   constrained problems are hard to solve when variables are badly scaled.

4. User sets stopping conditions with MinNSSetCond().

5. Finally, user calls MinNSOptimize()  function  which  takes   algorithm
   state and pointer (delegate, etc) to callback function which calculates
   F/G/H.

7. User calls MinNSResults() to get solution

8. Optionally user may call MinNSRestartFrom() to solve   another  problem
   with same N but another starting point. MinNSRestartFrom()  allows   to
   reuse already initialized structure.


INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    X       -   starting point, array[N]:
                * it is better to set X to a feasible point
                * but X can be infeasible, in which case algorithm will try
                  to find feasible point first, using X as initial
                  approximation.

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

NOTE: minnscreatef() function may be used if  you  do  not  have  analytic
      gradient.   This   function  creates  solver  which  uses  numerical
      differentiation with user-specified step.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnscreate(<font color=navy>double</font>[] x, <font color=navy>out</font> minnsstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnscreate(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> minnsstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_unconstrained' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_minnscreatef'></a><h3 class=pageheader><code>minnscreatef</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Version of minnscreatef() which uses numerical differentiation. I.e.,  you
do not have to calculate derivatives yourself. However, this version needs
2N times more function evaluations.

2-point differentiation formula is  used,  because  more  precise  4-point
formula is unstable when used on non-smooth functions.

INPUT PARAMETERS:
    N       -   problem dimension, N&gt;0:
                * if given, only leading N elements of X are used
                * if not given, automatically determined from size of X
    X       -   starting point, array[N]:
                * it is better to set X to a feasible point
                * but X can be infeasible, in which case algorithm will try
                  to find feasible point first, using X as initial
                  approximation.
    DiffStep-   differentiation  step,  DiffStep&gt;0.   Algorithm   performs
                numerical differentiation  with  step  for  I-th  variable
                being equal to DiffStep*S[I] (here S[] is a  scale vector,
                set by minnssetscale() function).
                Do not use  too  small  steps,  because  it  may  lead  to
                catastrophic cancellation during intermediate calculations.

OUTPUT PARAMETERS:
    State   -   structure stores algorithm state

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnscreatef(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minnsstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnscreatef(
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> diffstep,
    <font color=navy>out</font> minnsstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_diff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minnsoptimize'></a><h3 class=pageheader><code>minnsoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear optimizer

These functions accept following parameters:
    state   -   algorithm state
    fvec    -   callback which calculates function vector fi[]
                at given point x
    jac     -   callback which calculates function vector fi[]
                and Jacobian jac at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL


NOTES:

1. This function has two different implementations: one which  uses  exact
   (analytical) user-supplied Jacobian, and one which uses  only  function
   vector and numerically  differentiates  function  in  order  to  obtain
   gradient.

   Depending  on  the  specific  function  used to create optimizer object
   you should choose appropriate variant of  minnsoptimize() -  one  which
   accepts function AND Jacobian or one which accepts ONLY function.

   Be careful to choose variant of minnsoptimize()  which  corresponds  to
   your optimization scheme! Table below lists different  combinations  of
   callback (function/gradient) passed to minnsoptimize()    and  specific
   function used to create optimizer.


                     |         USER PASSED TO minnsoptimize()
   CREATED WITH      |  function only   |  function and gradient
   ------------------------------------------------------------
   minnscreatef()    |     works               FAILS
   minnscreate()     |     FAILS               works

   Here &quot;FAILS&quot; denotes inappropriate combinations  of  optimizer creation
   function  and  minnsoptimize()  version.   Attemps   to    use     such
   combination will lead to exception. Either  you  did  not pass gradient
   when it WAS needed or you passed gradient when it was NOT needed.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minnsoptimize(minnsstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> minnsoptimize(minnsstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_unconstrained' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minns_d_diff' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minnsrequesttermination'></a><h3 class=pageheader><code>minnsrequesttermination</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine submits request for termination of running  optimizer.  It
should be called from user-supplied callback when user decides that it  is
time to &quot;smoothly&quot; terminate optimization process.  As  result,  optimizer
stops at point which was &quot;current accepted&quot; when termination  request  was
submitted and returns error code 8 (successful termination).

INPUT PARAMETERS:
    State   -   optimizer structure

NOTE: after  request  for  termination  optimizer  may   perform   several
      additional calls to user-supplied callbacks. It does  NOT  guarantee
      to stop immediately - it just guarantees that these additional calls
      will be discarded later.

NOTE: calling this function on optimizer which is NOT running will have no
      effect.

NOTE: multiple calls to this function are possible. First call is counted,
      subsequent calls are silently ignored.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnsrequesttermination(minnsstate state)

</div></pre>
<a name='sub_minnsrestartfrom'></a><h3 class=pageheader><code>minnsrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine restarts algorithm from new point.
All optimization parameters (including constraints) are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have  same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure previously allocated with minnscreate() call.
    X       -   new starting point.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnsrestartfrom(minnsstate state, <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_minnsresults'></a><h3 class=pageheader><code>minnsresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
MinNS results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report. You should check Rep.TerminationType
                in  order  to  distinguish  successful  termination  from
                unsuccessful one:
                * -8   internal integrity control  detected  infinite  or
                       NAN   values   in   function/gradient.    Abnormal
                       termination signalled.
                * -3   box constraints are inconsistent
                * -1   inconsistent parameters were passed:
                       * penalty parameter for minnssetalgoags() is zero,
                         but we have nonlinear constraints set by minnssetnlc()
                *  2   sampling radius decreased below epsx
                *  7    stopping conditions are too stringent,
                        further improvement is impossible,
                        X contains best point found so far.
                *  8    User requested termination via minnsrequesttermination()

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnsresults(
    minnsstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minnsreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_unconstrained' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minns_d_diff' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minnsresultsbuf'></a><h3 class=pageheader><code>minnsresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

Buffered implementation of minnsresults() which uses pre-allocated  buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnsresultsbuf(
    minnsstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minnsreport rep)

</div></pre>
<a name='sub_minnssetalgoags'></a><h3 class=pageheader><code>minnssetalgoags</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function tells MinNS unit to use  AGS  (adaptive  gradient  sampling)
algorithm for nonsmooth constrained  optimization.  This  algorithm  is  a
slight modification of one described in  &quot;An  Adaptive  Gradient  Sampling
Algorithm for Nonsmooth Optimization&quot; by Frank E. Curtisy and Xiaocun Quez.

This optimizer has following benefits and drawbacks:
+ robustness; it can be used with nonsmooth and nonconvex functions.
+ relatively easy tuning; most of the metaparameters are easy to select.
- it has convergence of steepest descent, slower than CG/LBFGS.
- each iteration involves evaluation of ~2N gradient values  and  solution
  of 2Nx2N quadratic programming problem, which  limits  applicability  of
  algorithm by small-scale problems (up to 50-100).

IMPORTANT: this  algorithm  has  convergence  guarantees,   i.e.  it  will
           steadily move towards some stationary point of the function.

           However, &quot;stationary point&quot; does not  always  mean  &quot;solution&quot;.
           Nonsmooth problems often have &quot;flat spots&quot;,  i.e.  areas  where
           function do not change at all. Such &quot;flat spots&quot; are stationary
           points by definition, and algorithm may be caught here.

           Nonsmooth CONVEX tasks are not prone to  this  problem. Say, if
           your function has form f()=MAX(f0,f1,...), and f_i are  convex,
           then f() is convex too and you have guaranteed  convergence  to
           solution.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    Radius  -   initial sampling radius, &gt;=0.

                Internally multiplied  by  vector of  per-variable  scales
                specified by minnssetscale()).

                You should select relatively large sampling radius, roughly
                proportional to scaled length of the first  steps  of  the
                algorithm. Something close to 0.1 in magnitude  should  be
                good for most problems.

                AGS solver can automatically decrease radius, so too large
                radius is  not a problem (assuming that you  won't  choose
                so large radius that algorithm  will  sample  function  in
                too far away points, where gradient value is irrelevant).

                Too small radius won't cause algorithm to fail, but it may
                slow down algorithm (it may  have  to  perform  too  short
                steps).
    Penalty -   penalty coefficient for nonlinear constraints:
                * for problem with nonlinear constraints  should  be  some
                  problem-specific  positive   value,  large  enough  that
                  penalty term changes shape of the function.
                  Starting  from  some  problem-specific   value   penalty
                  coefficient becomes  large  enough  to  exactly  enforce
                  nonlinear constraints;  larger  values  do  not  improve
                  precision.
                  Increasing it too much may slow down convergence, so you
                  should choose it carefully.
                * can be zero for problems WITHOUT  nonlinear  constraints
                  (i.e. for unconstrained ones or ones with  just  box  or
                  linear constraints)
                * if you specify zero value for problem with at least  one
                  nonlinear  constraint,  algorithm  will  terminate  with
                  error code -1.

ALGORITHM OUTLINE

The very basic outline of unconstrained AGS algorithm is given below:

0. If sampling radius is below EpsX  or  we  performed  more  then  MaxIts
   iterations - STOP.
1. sample O(N) gradient values at random locations  around  current point;
   informally speaking, this sample is an implicit piecewise  linear model
   of the function, although algorithm formulation does  not  mention that
   explicitly
2. solve quadratic programming problem in order to find descent direction
3. if QP solver tells us that we  are  near  solution,  decrease  sampling
   radius and move to (0)
4. perform backtracking line search
5. after moving to new point, goto (0)

As for the constraints:
* box constraints are handled exactly  by  modification  of  the  function
  being minimized
* linear/nonlinear constraints are handled by adding L1  penalty.  Because
  our solver can handle nonsmoothness, we can  use  L1  penalty  function,
  which is an exact one  (i.e.  exact  solution  is  returned  under  such
  penalty).
* penalty coefficient for  linear  constraints  is  chosen  automatically;
  however, penalty coefficient for nonlinear constraints must be specified
  by user.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetalgoags(
    minnsstate state,
    <font color=navy>double</font> radius,
    <font color=navy>double</font> penalty)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_unconstrained' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minns_d_diff' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minnssetbc'></a><h3 class=pageheader><code>minnssetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets boundary constraints.

Boundary constraints are inactive by default (after initial creation).
They are preserved after algorithm restart with minnsrestartfrom().

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    BndL    -   lower bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very small number or -INF.
    BndU    -   upper bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very large number or +INF.

NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
variable will be &quot;frozen&quot; at X[i]=BndL[i]=BndU[i].

NOTE 2: AGS solver has following useful properties:
* bound constraints are always satisfied exactly
* function is evaluated only INSIDE area specified by  bound  constraints,
  even  when  numerical  differentiation is used (algorithm adjusts  nodes
  according to boundary constraints)

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetbc(
    minnsstate state,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minnssetcond'></a><h3 class=pageheader><code>minnssetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for iterations of optimizer.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsX    -   &gt;=0
                The AGS solver finishes its work if  on  k+1-th  iteration
                sampling radius decreases below EpsX.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsX=0  and  MaxIts=0  (simultaneously)  will  lead  to  automatic
stopping criterion selection. We do not recommend you to rely  on  default
choice in production code.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetcond(
    minnsstate state,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_unconstrained' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minns_d_diff' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minnssetlc'></a><h3 class=pageheader><code>minnssetlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets linear constraints.

Linear constraints are inactive by default (after initial creation).
They are preserved after algorithm restart with minnsrestartfrom().

INPUT PARAMETERS:
    State   -   structure previously allocated with minnscreate() call.
    C       -   linear constraints, array[K,N+1].
                Each row of C represents one constraint, either equality
                or inequality (see below):
                * first N elements correspond to coefficients,
                * last element corresponds to the right part.
                All elements of C (including right part) must be finite.
    CT      -   type of constraints, array[K]:
                * if CT[i]&gt;0, then I-th constraint is C[i,*]*x &gt;= C[i,n+1]
                * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
                * if CT[i]&lt;0, then I-th constraint is C[i,*]*x &lt;= C[i,n+1]
    K       -   number of equality/inequality constraints, K&gt;=0:
                * if given, only leading K elements of C/CT are used
                * if not given, automatically determined from sizes of C/CT

NOTE: linear (non-bound) constraints are satisfied only approximately:

* there always exists some minor violation (about current sampling  radius
  in magnitude during optimization, about EpsX in the solution) due to use
  of penalty method to handle constraints.
* numerical differentiation, if used, may  lead  to  function  evaluations
  outside  of the feasible  area,   because   algorithm  does  NOT  change
  numerical differentiation formula according to linear constraints.

If you want constraints to be  satisfied  exactly, try to reformulate your
problem  in  such  manner  that  all constraints will become boundary ones
(this kind of constraints is always satisfied exactly, both in  the  final
solution and in all intermediate points).

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetlc(
    minnsstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetlc(
    minnsstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct,
    <font color=navy>int</font> k)

</div></pre>
<a name='sub_minnssetnlc'></a><h3 class=pageheader><code>minnssetnlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets nonlinear constraints.

In fact, this function sets NUMBER of nonlinear  constraints.  Constraints
itself (constraint functions) are passed to minnsoptimize() method.   This
method requires user-defined vector function F[]  and  its  Jacobian  J[],
where:
* first component of F[] and first row  of  Jacobian  J[]  correspond   to
  function being minimized
* next NLEC components of F[] (and rows  of  J)  correspond  to  nonlinear
  equality constraints G_i(x)=0
* next NLIC components of F[] (and rows  of  J)  correspond  to  nonlinear
  inequality constraints H_i(x)&lt;=0

NOTE: you may combine nonlinear constraints with linear/boundary ones.  If
      your problem has mixed constraints, you  may explicitly specify some
      of them as linear ones. It may help optimizer to  handle  them  more
      efficiently.

INPUT PARAMETERS:
    State   -   structure previously allocated with minnscreate() call.
    NLEC    -   number of Non-Linear Equality Constraints (NLEC), &gt;=0
    NLIC    -   number of Non-Linear Inquality Constraints (NLIC), &gt;=0

NOTE 1: nonlinear constraints are satisfied only  approximately!   It   is
        possible   that  algorithm  will  evaluate  function  outside   of
        the feasible area!

NOTE 2: algorithm scales variables  according  to   scale   specified   by
        minnssetscale()  function,  so  it can handle problems with  badly
        scaled variables (as long as we KNOW their scales).

        However,  there  is  no  way  to  automatically  scale   nonlinear
        constraints Gi(x) and Hi(x). Inappropriate scaling  of  Gi/Hi  may
        ruin convergence. Solving problem with  constraint  &quot;1000*G0(x)=0&quot;
        is NOT same as solving it with constraint &quot;0.001*G0(x)=0&quot;.

        It  means  that  YOU  are  the  one who is responsible for correct
        scaling of nonlinear constraints Gi(x) and Hi(x). We recommend you
        to scale nonlinear constraints in such way that I-th component  of
        dG/dX (or dH/dx) has approximately unit  magnitude  (for  problems
        with unit scale)  or  has  magnitude approximately equal to 1/S[i]
        (where S is a scale set by minnssetscale() function).

NOTE 3: nonlinear constraints are always hard to handle,  no  matter  what
        algorithm you try to use. Even basic box/linear constraints modify
        function  curvature   by  adding   valleys  and  ridges.  However,
        nonlinear constraints add valleys which are very  hard  to  follow
        due to their &quot;curved&quot; nature.

        It means that optimization with single nonlinear constraint may be
        significantly slower than optimization with multiple linear  ones.
        It is normal situation, and we recommend you to  carefully  choose
        Rho parameter of minnssetalgoags(), because too  large  value  may
        slow down convergence.


  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetnlc(
    minnsstate state,
    <font color=navy>int</font> nlec,
    <font color=navy>int</font> nlic)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minnssetscale'></a><h3 class=pageheader><code>minnssetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients for NLC optimizer.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

Scaling is also used by finite difference variant of the optimizer  - step
along I-th axis is equal to DiffStep*S[I].

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 18.05.2015 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetscale(minnsstate state, <font color=navy>double</font>[] s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minns_d_unconstrained' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minns_d_diff' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minns_d_bc' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minns_d_nlc' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minnssetxrep'></a><h3 class=pageheader><code>minnssetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to minnsoptimize().

  -- ALGLIB --
     Copyright 28.11.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minnssetxrep(minnsstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='example_minns_d_bc'></a><h3 class=pageheader>minns_d_bc example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nsfunc1_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    <font color=green>// and Jacobian matrix J = [ df0/dx0, df0/dx1 ]</font>
    <font color=green>//</font>
    fi[0] = 2*System.Math.Abs(x[0])+System.Math.Abs(x[1]);
    jac[0,0] = 2*System.Math.Sign(x[0]);
    jac[0,1] = System.Math.Sign(x[1]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    <font color=green>// subject to box constraints</font>
    <font color=green>//</font>
    <font color=green>//        1 &lt;= x0 &lt; +INF</font>
    <font color=green>//     -INF &lt;= x1 &lt; +INF</font>
    <font color=green>//</font>
    <font color=green>// using nonsmooth nonlinear optimizer.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{1,-System.Double.PositiveInfinity};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{System.Double.PositiveInfinity,+System.Double.PositiveInfinity};
    <font color=navy>double</font> epsx = 0.00001;
    <font color=navy>double</font> radius = 0.1;
    <font color=navy>double</font> rho = 0.0;
    <font color=navy>int</font> maxits = 0;
    alglib.minnsstate state;
    alglib.minnsreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AGS algorithm and tune its settings:</font>
    <font color=green>// * radius=0.1     good initial value; will be automatically decreased later.</font>
    <font color=green>// * rho=0.0        penalty coefficient <font color=navy>for</font> nonlinear constraints; can be zero</font>
    <font color=green>//                  because we <font color=navy>do</font> not have such constraints</font>
    <font color=green>// * epsx=0.000001  stopping conditions</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>//</font>
    alglib.minnscreate(2, x0, <font color=navy>out</font> state);
    alglib.minnssetalgoags(state, radius, rho);
    alglib.minnssetcond(state, epsx, maxits);
    alglib.minnssetscale(state, s);

    <font color=green>//</font>
    <font color=green>// Set box constraints.</font>
    <font color=green>//</font>
    <font color=green>// General linear constraints are set in similar way (see comments on</font>
    <font color=green>// minnssetlc() function <font color=navy>for</font> more information).</font>
    <font color=green>//</font>
    <font color=green>// You may combine box, linear and nonlinear constraints in one optimization</font>
    <font color=green>// problem.</font>
    <font color=green>//</font>
    alglib.minnssetbc(state, bndl, bndu);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function and its Jacobian, with first</font>
    <font color=green>// component (Jacobian row) being target function, and next components</font>
    <font color=green>// (Jacobian rows) being nonlinear equality and inequality constraints</font>
    <font color=green>// (box/linear ones are passed separately by means of minnssetbc() and</font>
    <font color=green>// minnssetlc() calls).</font>
    <font color=green>//</font>
    <font color=green>// If you <font color=navy>do</font> not have nonlinear constraints (exactly our situation), then</font>
    <font color=green>// you will have one-component function vector and 1xN Jacobian matrix.</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0} = { 2*|x0|+|x1| }</font>
    <font color=green>//</font>
    <font color=green>// with Jacobian</font>
    <font color=green>//</font>
    <font color=green>//         [                       ]</font>
    <font color=green>//     J = [ 2*sign(x0)   sign(x1) ]</font>
    <font color=green>//         [                       ]</font>
    <font color=green>//</font>
    <font color=green>// NOTE: nonsmooth optimizer requires considerably more function</font>
    <font color=green>//       evaluations than smooth solver - about 2N times more. Using</font>
    <font color=green>//       numerical differentiation introduces additional (multiplicative)</font>
    <font color=green>//       2N speedup.</font>
    <font color=green>//</font>
    <font color=green>//       It means that <font color=navy>if</font> smooth optimizer WITH user-supplied gradient</font>
    <font color=green>//       needs 100 function evaluations to solve 50-dimensional problem,</font>
    <font color=green>//       then AGS solver with user-supplied gradient will need about 10.000</font>
    <font color=green>//       function evaluations, and with numerical gradient about 1.000.000</font>
    <font color=green>//       function evaluations will be performed.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: AGS solver used by us can handle nonsmooth and nonconvex</font>
    <font color=green>//       optimization problems. It has convergence guarantees, i.e. it will</font>
    <font color=green>//       converge to stationary point of the function after running <font color=navy>for</font> some</font>
    <font color=green>//       time.</font>
    <font color=green>//</font>
    <font color=green>//       However, it is important to remember that <font color=blue><b>&quot;stationary point&quot;</b></font> is not</font>
    <font color=green>//       equal to <font color=blue><b>&quot;solution&quot;</b></font>. If your problem is convex, everything is OK.</font>
    <font color=green>//       But nonconvex optimization problems may have <font color=blue><b>&quot;flat spots&quot;</b></font> - large</font>
    <font color=green>//       areas where gradient is exactly zero, but function value is far away</font>
    <font color=green>//       from optimal. Such areas are stationary points too, and optimizer</font>
    <font color=green>//       may be trapped here.</font>
    <font color=green>//</font>
    <font color=green>//       <font color=blue><b>&quot;Flat spots&quot;</b></font> are nonsmooth equivalent of the saddle points, but with</font>
    <font color=green>//       orders of magnitude worse properties - they may be quite large and</font>
    <font color=green>//       hard to avoid. All nonsmooth optimizers are prone to this kind of the</font>
    <font color=green>//       problem, because it is impossible to automatically distinguish &quot;flat</font>
    <font color=green>//       spot&quot; from true solution.</font>
    <font color=green>//</font>
    <font color=green>//       This note is here to warn you that you should be very careful when</font>
    <font color=green>//       you solve nonsmooth optimization problems. Visual inspection of</font>
    <font color=green>//       results is essential.</font>
    <font color=green>//</font>
    <font color=green>//</font>
    alglib.minnsoptimize(state, nsfunc1_jac, null, null);
    alglib.minnsresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [1.0000,0.0000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minns_d_diff'></a><h3 class=pageheader>minns_d_diff example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nsfunc1_fvec(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    fi[0] = 2*System.Math.Abs(x[0])+System.Math.Abs(x[1]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    <font color=green>// using nonsmooth nonlinear optimizer with numerical</font>
    <font color=green>// differentiation provided by ALGLIB.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: nonsmooth optimizer requires considerably more function</font>
    <font color=green>//       evaluations than smooth solver - about 2N times more. Using</font>
    <font color=green>//       numerical differentiation introduces additional (multiplicative)</font>
    <font color=green>//       2N speedup.</font>
    <font color=green>//</font>
    <font color=green>//       It means that <font color=navy>if</font> smooth optimizer WITH user-supplied gradient</font>
    <font color=green>//       needs 100 function evaluations to solve 50-dimensional problem,</font>
    <font color=green>//       then AGS solver with user-supplied gradient will need about 10.000</font>
    <font color=green>//       function evaluations, and with numerical gradient about 1.000.000</font>
    <font color=green>//       function evaluations will be performed.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font> epsx = 0.00001;
    <font color=navy>double</font> diffstep = 0.000001;
    <font color=navy>double</font> radius = 0.1;
    <font color=navy>double</font> rho = 0.0;
    <font color=navy>int</font> maxits = 0;
    alglib.minnsstate state;
    alglib.minnsreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AGS algorithm and tune its settings:</font>
    <font color=green>// * radius=0.1     good initial value; will be automatically decreased later.</font>
    <font color=green>// * rho=0.0        penalty coefficient <font color=navy>for</font> nonlinear constraints; can be zero</font>
    <font color=green>//                  because we <font color=navy>do</font> not have such constraints</font>
    <font color=green>// * epsx=0.000001  stopping conditions</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>//</font>
    alglib.minnscreatef(2, x0, diffstep, <font color=navy>out</font> state);
    alglib.minnssetalgoags(state, radius, rho);
    alglib.minnssetcond(state, epsx, maxits);
    alglib.minnssetscale(state, s);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function, with first component</font>
    <font color=green>// being target function, and next components being nonlinear equality</font>
    <font color=green>// and inequality constraints (box/linear ones are passed separately</font>
    <font color=green>// by means of minnssetbc() and minnssetlc() calls).</font>
    <font color=green>//</font>
    <font color=green>// If you <font color=navy>do</font> not have nonlinear constraints (exactly our situation), then</font>
    <font color=green>// you will have one-component function vector.</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0} = { 2*|x0|+|x1| }</font>
    <font color=green>//</font>
    alglib.minnsoptimize(state, nsfunc1_fvec, null, null);
    alglib.minnsresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [0.0000,0.0000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minns_d_nlc'></a><h3 class=pageheader>minns_d_nlc example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nsfunc2_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates function vector</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 2*|x0|+x1</font>
    <font color=green>//     f1(x0,x1) = x0-1</font>
    <font color=green>//     f2(x0,x1) = -x1-1</font>
    <font color=green>//</font>
    <font color=green>// and Jacobian matrix J</font>
    <font color=green>//</font>
    <font color=green>//         [ df0/dx0   df0/dx1 ]</font>
    <font color=green>//     J = [ df1/dx0   df1/dx1 ]</font>
    <font color=green>//         [ df2/dx0   df2/dx1 ]</font>
    <font color=green>//</font>
    fi[0] = 2*System.Math.Abs(x[0])+System.Math.Abs(x[1]);
    jac[0,0] = 2*System.Math.Sign(x[0]);
    jac[0,1] = System.Math.Sign(x[1]);
    fi[1] = x[0]-1;
    jac[1,0] = 1;
    jac[1,1] = 0;
    fi[2] = -x[1]-1;
    jac[2,0] = 0;
    jac[2,1] = -1;
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    <font color=green>// subject to combination of equality and inequality constraints</font>
    <font color=green>//</font>
    <font color=green>//      x0  =  1</font>
    <font color=green>//      x1 &gt;= -1</font>
    <font color=green>//</font>
    <font color=green>// using nonsmooth nonlinear optimizer. Although these constraints</font>
    <font color=green>// are linear, we treat them as general nonlinear ones in order to</font>
    <font color=green>// demonstrate nonlinearly constrained optimization setup.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font> epsx = 0.00001;
    <font color=navy>double</font> radius = 0.1;
    <font color=navy>double</font> rho = 50.0;
    <font color=navy>int</font> maxits = 0;
    alglib.minnsstate state;
    alglib.minnsreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AGS algorithm and tune its settings:</font>
    <font color=green>// * radius=0.1     good initial value; will be automatically decreased later.</font>
    <font color=green>// * rho=50.0       penalty coefficient <font color=navy>for</font> nonlinear constraints. It is your</font>
    <font color=green>//                  responsibility to choose good one - large enough that it</font>
    <font color=green>//                  enforces constraints, but small enough in order to avoid</font>
    <font color=green>//                  extreme slowdown due to ill-conditioning.</font>
    <font color=green>// * epsx=0.000001  stopping conditions</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>//</font>
    alglib.minnscreate(2, x0, <font color=navy>out</font> state);
    alglib.minnssetalgoags(state, radius, rho);
    alglib.minnssetcond(state, epsx, maxits);
    alglib.minnssetscale(state, s);

    <font color=green>//</font>
    <font color=green>// Set general nonlinear constraints.</font>
    <font color=green>//</font>
    <font color=green>// This part is more tricky than working with box/linear constraints - you</font>
    <font color=green>// can not <font color=blue><b>&quot;pack&quot;</b></font> general nonlinear function into <font color=navy>double</font> precision array.</font>
    <font color=green>// That's why minnssetnlc() does not accept constraints itself - only</font>
    <font color=green>// constraint COUNTS are passed: first parameter is number of equality</font>
    <font color=green>// constraints, second one is number of inequality constraints.</font>
    <font color=green>//</font>
    <font color=green>// As <font color=navy>for</font> constraining functions - these functions are passed as part</font>
    <font color=green>// of problem Jacobian (see below).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: MinNS optimizer supports arbitrary combination of boundary, general</font>
    <font color=green>//       linear and general nonlinear constraints. This example does not</font>
    <font color=green>//       show how to work with general linear constraints, but you can</font>
    <font color=green>//       easily find it in documentation on minnlcsetlc() function.</font>
    <font color=green>//</font>
    alglib.minnssetnlc(state, 1, 1);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function and its Jacobian, with first</font>
    <font color=green>// component (Jacobian row) being target function, and next components</font>
    <font color=green>// (Jacobian rows) being nonlinear equality and inequality constraints</font>
    <font color=green>// (box/linear ones are passed separately by means of minnssetbc() and</font>
    <font color=green>// minnssetlc() calls).</font>
    <font color=green>//</font>
    <font color=green>// Nonlinear equality constraints have form Gi(x)=0, inequality ones</font>
    <font color=green>// have form Hi(x)&lt;=0, so we may have to <font color=blue><b>&quot;normalize&quot;</b></font> constraints prior</font>
    <font color=green>// to passing them to optimizer (right side is zero, constraints are</font>
    <font color=green>// sorted, multiplied by -1 when needed).</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0,f1,f2} = { 2*|x0|+|x1|,  x0-1, -x1-1 }</font>
    <font color=green>//</font>
    <font color=green>// with Jacobian</font>
    <font color=green>//</font>
    <font color=green>//         [ 2*sign(x0)   sign(x1) ]</font>
    <font color=green>//     J = [     1           0     ]</font>
    <font color=green>//         [     0          -1     ]</font>
    <font color=green>//</font>
    <font color=green>// which means that we have optimization problem</font>
    <font color=green>//</font>
    <font color=green>//     min{f0} subject to f1=0, f2&lt;=0</font>
    <font color=green>//</font>
    <font color=green>// which is essentially same as</font>
    <font color=green>//</font>
    <font color=green>//     min { 2*|x0|+|x1| } subject to x0=1, x1&gt;=-1</font>
    <font color=green>//</font>
    <font color=green>// NOTE: AGS solver used by us can handle nonsmooth and nonconvex</font>
    <font color=green>//       optimization problems. It has convergence guarantees, i.e. it will</font>
    <font color=green>//       converge to stationary point of the function after running <font color=navy>for</font> some</font>
    <font color=green>//       time.</font>
    <font color=green>//</font>
    <font color=green>//       However, it is important to remember that <font color=blue><b>&quot;stationary point&quot;</b></font> is not</font>
    <font color=green>//       equal to <font color=blue><b>&quot;solution&quot;</b></font>. If your problem is convex, everything is OK.</font>
    <font color=green>//       But nonconvex optimization problems may have <font color=blue><b>&quot;flat spots&quot;</b></font> - large</font>
    <font color=green>//       areas where gradient is exactly zero, but function value is far away</font>
    <font color=green>//       from optimal. Such areas are stationary points too, and optimizer</font>
    <font color=green>//       may be trapped here.</font>
    <font color=green>//</font>
    <font color=green>//       <font color=blue><b>&quot;Flat spots&quot;</b></font> are nonsmooth equivalent of the saddle points, but with</font>
    <font color=green>//       orders of magnitude worse properties - they may be quite large and</font>
    <font color=green>//       hard to avoid. All nonsmooth optimizers are prone to this kind of the</font>
    <font color=green>//       problem, because it is impossible to automatically distinguish &quot;flat</font>
    <font color=green>//       spot&quot; from true solution.</font>
    <font color=green>//</font>
    <font color=green>//       This note is here to warn you that you should be very careful when</font>
    <font color=green>//       you solve nonsmooth optimization problems. Visual inspection of</font>
    <font color=green>//       results is essential.</font>
    <font color=green>//</font>
    alglib.minnsoptimize(state, nsfunc2_jac, null, null);
    alglib.minnsresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [1.0000,0.0000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minns_d_unconstrained'></a><h3 class=pageheader>minns_d_unconstrained example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font>  nsfunc1_jac(<font color=navy>double</font>[] x, <font color=navy>double</font>[] fi, <font color=navy>double</font>[,] jac, object obj)
{
    <font color=green>//</font>
    <font color=green>// this callback calculates</font>
    <font color=green>//</font>
    <font color=green>//     f0(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    <font color=green>// and Jacobian matrix J = [ df0/dx0, df0/dx1 ]</font>
    <font color=green>//</font>
    fi[0] = 2*System.Math.Abs(x[0])+System.Math.Abs(x[1]);
    jac[0,0] = 2*System.Math.Sign(x[0]);
    jac[0,1] = System.Math.Sign(x[1]);
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of</font>
    <font color=green>//</font>
    <font color=green>//     f(x0,x1) = 2*|x0|+|x1|</font>
    <font color=green>//</font>
    <font color=green>// using nonsmooth nonlinear optimizer.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font> epsx = 0.00001;
    <font color=navy>double</font> radius = 0.1;
    <font color=navy>double</font> rho = 0.0;
    <font color=navy>int</font> maxits = 0;
    alglib.minnsstate state;
    alglib.minnsreport rep;
    <font color=navy>double</font>[] x1;

    <font color=green>//</font>
    <font color=green>// Create optimizer object, choose AGS algorithm and tune its settings:</font>
    <font color=green>// * radius=0.1     good initial value; will be automatically decreased later.</font>
    <font color=green>// * rho=0.0        penalty coefficient <font color=navy>for</font> nonlinear constraints; can be zero</font>
    <font color=green>//                  because we <font color=navy>do</font> not have such constraints</font>
    <font color=green>// * epsx=0.000001  stopping conditions</font>
    <font color=green>// * s=[1,1]        all variables have unit scale</font>
    <font color=green>//</font>
    alglib.minnscreate(2, x0, <font color=navy>out</font> state);
    alglib.minnssetalgoags(state, radius, rho);
    alglib.minnssetcond(state, epsx, maxits);
    alglib.minnssetscale(state, s);

    <font color=green>//</font>
    <font color=green>// Optimize and test results.</font>
    <font color=green>//</font>
    <font color=green>// Optimizer object accepts vector function and its Jacobian, with first</font>
    <font color=green>// component (Jacobian row) being target function, and next components</font>
    <font color=green>// (Jacobian rows) being nonlinear equality and inequality constraints</font>
    <font color=green>// (box/linear ones are passed separately by means of minnssetbc() and</font>
    <font color=green>// minnssetlc() calls).</font>
    <font color=green>//</font>
    <font color=green>// If you <font color=navy>do</font> not have nonlinear constraints (exactly our situation), then</font>
    <font color=green>// you will have one-component function vector and 1xN Jacobian matrix.</font>
    <font color=green>//</font>
    <font color=green>// So, our vector function has form</font>
    <font color=green>//</font>
    <font color=green>//     {f0} = { 2*|x0|+|x1| }</font>
    <font color=green>//</font>
    <font color=green>// with Jacobian</font>
    <font color=green>//</font>
    <font color=green>//         [                       ]</font>
    <font color=green>//     J = [ 2*sign(x0)   sign(x1) ]</font>
    <font color=green>//         [                       ]</font>
    <font color=green>//</font>
    <font color=green>// NOTE: nonsmooth optimizer requires considerably more function</font>
    <font color=green>//       evaluations than smooth solver - about 2N times more. Using</font>
    <font color=green>//       numerical differentiation introduces additional (multiplicative)</font>
    <font color=green>//       2N speedup.</font>
    <font color=green>//</font>
    <font color=green>//       It means that <font color=navy>if</font> smooth optimizer WITH user-supplied gradient</font>
    <font color=green>//       needs 100 function evaluations to solve 50-dimensional problem,</font>
    <font color=green>//       then AGS solver with user-supplied gradient will need about 10.000</font>
    <font color=green>//       function evaluations, and with numerical gradient about 1.000.000</font>
    <font color=green>//       function evaluations will be performed.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: AGS solver used by us can handle nonsmooth and nonconvex</font>
    <font color=green>//       optimization problems. It has convergence guarantees, i.e. it will</font>
    <font color=green>//       converge to stationary point of the function after running <font color=navy>for</font> some</font>
    <font color=green>//       time.</font>
    <font color=green>//</font>
    <font color=green>//       However, it is important to remember that <font color=blue><b>&quot;stationary point&quot;</b></font> is not</font>
    <font color=green>//       equal to <font color=blue><b>&quot;solution&quot;</b></font>. If your problem is convex, everything is OK.</font>
    <font color=green>//       But nonconvex optimization problems may have <font color=blue><b>&quot;flat spots&quot;</b></font> - large</font>
    <font color=green>//       areas where gradient is exactly zero, but function value is far away</font>
    <font color=green>//       from optimal. Such areas are stationary points too, and optimizer</font>
    <font color=green>//       may be trapped here.</font>
    <font color=green>//</font>
    <font color=green>//       <font color=blue><b>&quot;Flat spots&quot;</b></font> are nonsmooth equivalent of the saddle points, but with</font>
    <font color=green>//       orders of magnitude worse properties - they may be quite large and</font>
    <font color=green>//       hard to avoid. All nonsmooth optimizers are prone to this kind of the</font>
    <font color=green>//       problem, because it is impossible to automatically distinguish &quot;flat</font>
    <font color=green>//       spot&quot; from true solution.</font>
    <font color=green>//</font>
    <font color=green>//       This note is here to warn you that you should be very careful when</font>
    <font color=green>//       you solve nonsmooth optimization problems. Visual inspection of</font>
    <font color=green>//       results is essential.</font>
    <font color=green>//</font>
    alglib.minnsoptimize(state, nsfunc1_jac, null, null);
    alglib.minnsresults(state, <font color=navy>out</font> x1, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x1,2)); <font color=green>// EXPECTED: [0.0000,0.0000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_minqp></a><h2 class=pageheader><code>minqp</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minqpreport' class=toc>minqpreport</a><br>
<a href='#struct_minqpstate' class=toc>minqpstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minqpcreate' class=toc>minqpcreate</a><br>
<a href='#sub_minqpoptimize' class=toc>minqpoptimize</a><br>
<a href='#sub_minqpresults' class=toc>minqpresults</a><br>
<a href='#sub_minqpresultsbuf' class=toc>minqpresultsbuf</a><br>
<a href='#sub_minqpsetalgobleic' class=toc>minqpsetalgobleic</a><br>
<a href='#sub_minqpsetalgocholesky' class=toc>minqpsetalgocholesky</a><br>
<a href='#sub_minqpsetalgoquickqp' class=toc>minqpsetalgoquickqp</a><br>
<a href='#sub_minqpsetbc' class=toc>minqpsetbc</a><br>
<a href='#sub_minqpsetlc' class=toc>minqpsetlc</a><br>
<a href='#sub_minqpsetlinearterm' class=toc>minqpsetlinearterm</a><br>
<a href='#sub_minqpsetorigin' class=toc>minqpsetorigin</a><br>
<a href='#sub_minqpsetquadraticterm' class=toc>minqpsetquadraticterm</a><br>
<a href='#sub_minqpsetquadratictermsparse' class=toc>minqpsetquadratictermsparse</a><br>
<a href='#sub_minqpsetscale' class=toc>minqpsetscale</a><br>
<a href='#sub_minqpsetstartingpoint' class=toc>minqpsetstartingpoint</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minqp_d_bc1' class=toc>minqp_d_bc1</a></td><td width=15>&nbsp;</td><td>Bound constrained dense quadratic programming</td></tr>
<tr align=left valign=top><td><a href='#example_minqp_d_lc1' class=toc>minqp_d_lc1</a></td><td width=15>&nbsp;</td><td>Linearly constrained dense quadratic programming</td></tr>
<tr align=left valign=top><td><a href='#example_minqp_d_nonconvex' class=toc>minqp_d_nonconvex</a></td><td width=15>&nbsp;</td><td>Nonconvex quadratic programming</td></tr>
<tr align=left valign=top><td><a href='#example_minqp_d_u1' class=toc>minqp_d_u1</a></td><td width=15>&nbsp;</td><td>Unconstrained dense quadratic programming</td></tr>
<tr align=left valign=top><td><a href='#example_minqp_d_u2' class=toc>minqp_d_u2</a></td><td width=15>&nbsp;</td><td>Unconstrained sparse quadratic programming</td></tr>
</table></div>
<a name='struct_minqpreport'></a><h3 class=pageheader><code>minqpreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores optimization report:
* InnerIterationsCount      number of inner iterations
* OuterIterationsCount      number of outer iterations
* NCholesky                 number of Cholesky decomposition
* NMV                       number of matrix-vector products
                            (only products calculated as part of iterative
                            process are counted)
* TerminationType           completion code (see below)

Completion codes:
* -5    inappropriate solver was used:
        * QuickQP solver for problem with general linear constraints
        * Cholesky solver for semidefinite or indefinite problems
        * Cholesky solver for problems with non-boundary constraints
* -4    BLEIC-QP or QuickQP solver found unconstrained direction
        of negative curvature (function is unbounded from
        below  even  under  constraints),  no  meaningful
        minimum can be found.
* -3    inconsistent constraints (or, maybe, feasible point is
        too hard to find). If you are sure that constraints are feasible,
        try to restart optimizer with better initial approximation.
* -1    solver error
*  1..4 successful completion
*  5    MaxIts steps was taken
*  7    stopping conditions are too stringent,
        further improvement is impossible,
        X contains best point found so far.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minqpreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  inneriterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  outeriterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nmv;
    <font color=navy>public</font> <font color=navy>int</font>                  ncholesky;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_minqpstate'></a><h3 class=pageheader><code>minqpstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores nonlinear optimizer state.
You should use functions provided by MinQP subpackage to work with this
object
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class minqpstate
{
}

</div></pre>
<a name='sub_minqpcreate'></a><h3 class=pageheader><code>minqpcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                    CONSTRAINED QUADRATIC PROGRAMMING

The subroutine creates QP optimizer. After initial creation,  it  contains
default optimization problem with zero quadratic and linear terms  and  no
constraints. You should set quadratic/linear terms with calls to functions
provided by MinQP subpackage.

You should also choose appropriate QP solver and set it  and  its stopping
criteria by means of MinQPSetAlgo??????() function. Then, you should start
solution process by means of MinQPOptimize() call. Solution itself can  be
obtained with MinQPResults() function.

INPUT PARAMETERS:
    N       -   problem size

OUTPUT PARAMETERS:
    State   -   optimizer with zero quadratic/linear terms
                and no constraints

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpcreate(<font color=navy>int</font> n, <font color=navy>out</font> minqpstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minqp_d_u2' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minqp_d_nonconvex' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpoptimize'></a><h3 class=pageheader><code>minqpoptimize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves quadratic programming problem.

Prior to calling this function you should choose solver by means of one of
the following functions:

* MinQPSetAlgoQuickQP() - for QuickQP solver
* MinQPSetAlgoBLEIC() - for BLEIC-QP solver

These functions also allow you to control stopping criteria of the solver.
If you did not set solver,  MinQP  subpackage  will  automatically  select
solver for your problem and will run it with default stopping criteria.

However, it is better to set explicitly solver and its stopping criteria.

INPUT PARAMETERS:
    State   -   algorithm state

You should use MinQPResults() function to access results after calls
to this function.

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey.
     Special thanks to Elvira Illarionova  for  important  suggestions  on
     the linearly constrained QP algorithm.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpoptimize(minqpstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minqp_d_u2' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minqp_d_nonconvex' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpresults'></a><h3 class=pageheader><code>minqpresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
QP solver results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution.
                This array is allocated and initialized only when
                Rep.TerminationType parameter is positive (success).
    Rep     -   optimization report. You should check Rep.TerminationType,
                which contains completion code, and you may check  another
                fields which contain another information  about  algorithm
                functioning.

                Failure codes returned by algorithm are:
                * -5    inappropriate solver was used:
                        * Cholesky solver for (semi)indefinite problems
                        * Cholesky solver for problems with sparse matrix
                        * QuickQP solver for problem with  general  linear
                          constraints
                * -4    BLEIC-QP/QuickQP   solver    found   unconstrained
                        direction  of   negative  curvature  (function  is
                        unbounded from below even under constraints),   no
                        meaningful minimum can be found.
                * -3    inconsistent constraints (or maybe  feasible point
                        is too  hard  to  find).  If  you  are  sure  that
                        constraints are feasible, try to restart optimizer
                        with better initial approximation.

                Completion codes specific for Cholesky algorithm:
                *  4   successful completion

                Completion codes specific for BLEIC/QuickQP algorithms:
                *  1   relative function improvement is no more than EpsF.
                *  2   scaled step is no more than EpsX.
                *  4   scaled gradient norm is no more than EpsG.
                *  5   MaxIts steps was taken

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpresults(
    minqpstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> minqpreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minqp_d_u2' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minqp_d_nonconvex' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpresultsbuf'></a><h3 class=pageheader><code>minqpresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
QP results

Buffered implementation of MinQPResults() which uses pre-allocated  buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpresultsbuf(
    minqpstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    minqpreport rep)

</div></pre>
<a name='sub_minqpsetalgobleic'></a><h3 class=pageheader><code>minqpsetalgobleic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function tells solver to use BLEIC-based algorithm and sets  stopping
criteria for the algorithm.

ALGORITHM FEATURES:

* supports dense and sparse QP problems
* supports boundary and general linear equality/inequality constraints
* can solve all types of problems  (convex,  semidefinite,  nonconvex)  as
  long as they are bounded from below under constraints.
  Say, it is possible to solve &quot;min{-x^2} subject to -1&lt;=x&lt;=+1&quot;.
  Of course, global  minimum  is found only  for  positive  definite   and
  semidefinite  problems.  As  for indefinite ones - only local minimum is
  found.

ALGORITHM OUTLINE:

* BLEIC-QP solver is just a driver function for MinBLEIC solver; it solves
  quadratic  programming   problem   as   general   linearly   constrained
  optimization problem, which is solved by means of BLEIC solver  (part of
  ALGLIB, active set method).

ALGORITHM LIMITATIONS:

* unlike QuickQP solver, this algorithm does not perform Newton steps  and
  does not use Level 3 BLAS. Being general-purpose active set  method,  it
  can activate constraints only one-by-one. Thus, its performance is lower
  than that of QuickQP.
* its precision is also a bit  inferior  to  that  of   QuickQP.  BLEIC-QP
  performs only LBFGS steps (no Newton steps), which are good at detecting
  neighborhood of the solution, buy need many iterations to find  solution
  with more than 6 digits of precision.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled constrained gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinQPSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes its work if exploratory steepest
                descent  step  on  k+1-th iteration  satisfies   following
                condition:  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
    EpsX    -   &gt;=0
                The  subroutine  finishes its work if exploratory steepest
                descent  step  on  k+1-th iteration  satisfies   following
                condition:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - step vector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinQPSetScale()
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited. NOTE: this  algorithm uses  LBFGS
                iterations,  which  are  relatively  cheap,  but   improve
                function value only a bit. So you will need many iterations
                to converge - from 0.1*N to 10*N, depending  on  problem's
                condition number.

IT IS VERY IMPORTANT TO CALL MinQPSetScale() WHEN YOU USE THIS  ALGORITHM
BECAUSE ITS STOPPING CRITERIA ARE SCALE-DEPENDENT!

Passing EpsG=0, EpsF=0 and EpsX=0 and MaxIts=0 (simultaneously) will lead
to automatic stopping criterion selection (presently it is  small    step
length, but it may change in the future versions of ALGLIB).

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetalgobleic(
    minqpstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_minqpsetalgocholesky'></a><h3 class=pageheader><code>minqpsetalgocholesky</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function tells solver to use Cholesky-based algorithm. This algorithm
was deprecated in ALGLIB 3.9.0 because its performance is inferior to that
of BLEIC-QP or  QuickQP  on  high-dimensional  problems.  Furthermore,  it
supports only dense convex QP problems.

This solver is no longer active by default.

We recommend you to switch to BLEIC-QP or QuickQP solver.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetalgocholesky(minqpstate state)

</div></pre>
<a name='sub_minqpsetalgoquickqp'></a><h3 class=pageheader><code>minqpsetalgoquickqp</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function tells solver to use QuickQP  algorithm:  special  extra-fast
algorithm   for   problems  with  boundary-only constrants. It  may  solve
non-convex  problems  as  long  as  they  are  bounded  from  below  under
constraints.

ALGORITHM FEATURES:
* many times (from 5x to 50x!) faster than BLEIC-based QP solver; utilizes
  accelerated methods for activation of constraints.
* supports dense and sparse QP problems
* supports ONLY boundary constraints; general linear constraints  are  NOT
  supported by this solver
* can solve all types of problems  (convex,  semidefinite,  nonconvex)  as
  long as they are bounded from below under constraints.
  Say, it is possible to solve &quot;min{-x^2} subject to -1&lt;=x&lt;=+1&quot;.
  In convex/semidefinite case global minimum  is  returned,  in  nonconvex
  case - algorithm returns one of the local minimums.

ALGORITHM OUTLINE:

* algorithm  performs  two kinds of iterations: constrained CG  iterations
  and constrained Newton iterations
* initially it performs small number of constrained CG  iterations,  which
  can efficiently activate/deactivate multiple constraints
* after CG phase algorithm tries to calculate Cholesky  decomposition  and
  to perform several constrained Newton steps. If  Cholesky  decomposition
  failed (matrix is indefinite even under constraints),  we  perform  more
  CG iterations until we converge to such set of constraints  that  system
  matrix becomes  positive  definite.  Constrained  Newton  steps  greatly
  increase convergence speed and precision.
* algorithm interleaves CG and Newton iterations which  allows  to  handle
  indefinite matrices (CG phase) and quickly converge after final  set  of
  constraints is found (Newton phase). Combination of CG and Newton phases
  is called &quot;outer iteration&quot;.
* it is possible to turn off Newton  phase  (beneficial  for  semidefinite
  problems - Cholesky decomposition will fail too often)

ALGORITHM LIMITATIONS:

* algorithm does not support general  linear  constraints;  only  boundary
  ones are supported
* Cholesky decomposition for sparse problems  is  performed  with  Skyline
  Cholesky solver, which is intended for low-profile matrices. No profile-
  reducing reordering of variables is performed in this version of ALGLIB.
* problems with near-zero negative eigenvalues (or exacty zero  ones)  may
  experience about 2-3x performance penalty. The reason is  that  Cholesky
  decomposition can not be performed until we identify directions of  zero
  and negative curvature and activate corresponding boundary constraints -
  but we need a lot of trial and errors because these directions  are hard
  to notice in the matrix spectrum.
  In this case you may turn off Newton phase of algorithm.
  Large negative eigenvalues  are  not  an  issue,  so  highly  non-convex
  problems can be solved very efficiently.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                |v|&lt;EpsG is satisfied, where:
                * |.| means Euclidian norm
                * v - scaled constrained gradient vector, v[i]=g[i]*s[i]
                * g - gradient
                * s - scaling coefficients set by MinQPSetScale()
    EpsF    -   &gt;=0
                The  subroutine  finishes its work if exploratory steepest
                descent  step  on  k+1-th iteration  satisfies   following
                condition:  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
    EpsX    -   &gt;=0
                The  subroutine  finishes its work if exploratory steepest
                descent  step  on  k+1-th iteration  satisfies   following
                condition:
                * |.| means Euclidian norm
                * v - scaled step vector, v[i]=dx[i]/s[i]
                * dx - step vector, dx=X(k+1)-X(k)
                * s - scaling coefficients set by MinQPSetScale()
    MaxOuterIts-maximum number of OUTER iterations.  One  outer  iteration
                includes some amount of CG iterations (from 5 to  ~N)  and
                one or several (usually small amount) Newton steps.  Thus,
                one outer iteration has high cost, but can greatly  reduce
                funcation value.
    UseNewton-  use Newton phase or not:
                * Newton phase improves performance of  positive  definite
                  dense problems (about 2 times improvement can be observed)
                * can result in some performance penalty  on  semidefinite
                  or slightly negative definite  problems  -  each  Newton
                  phase will bring no improvement (Cholesky failure),  but
                  still will require computational time.
                * if you doubt, you can turn off this  phase  -  optimizer
                  will retain its most of its high speed.

IT IS VERY IMPORTANT TO CALL MinQPSetScale() WHEN YOU USE THIS  ALGORITHM
BECAUSE ITS STOPPING CRITERIA ARE SCALE-DEPENDENT!

Passing EpsG=0, EpsF=0 and EpsX=0 and MaxIts=0 (simultaneously) will lead
to automatic stopping criterion selection (presently it is  small    step
length, but it may change in the future versions of ALGLIB).

  -- ALGLIB --
     Copyright 22.05.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetalgoquickqp(
    minqpstate state,
    <font color=navy>double</font> epsg,
    <font color=navy>double</font> epsf,
    <font color=navy>double</font> epsx,
    <font color=navy>int</font> maxouterits,
    <font color=navy>bool</font> usenewton)

</div></pre>
<a name='sub_minqpsetbc'></a><h3 class=pageheader><code>minqpsetbc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets boundary constraints for QP solver

Boundary constraints are inactive by default (after initial creation).
After  being  set,  they  are  preserved  until explicitly turned off with
another SetBC() call.

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    BndL    -   lower bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very small number or -INF (latter is recommended because
                it will allow solver to use better algorithm).
    BndU    -   upper bounds, array[N].
                If some (all) variables are unbounded, you may specify
                very large number or +INF (latter is recommended because
                it will allow solver to use better algorithm).

NOTE: it is possible to specify BndL[i]=BndU[i]. In this case I-th
variable will be &quot;frozen&quot; at X[i]=BndL[i]=BndU[i].

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetbc(
    minqpstate state,
    <font color=navy>double</font>[] bndl,
    <font color=navy>double</font>[] bndu)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpsetlc'></a><h3 class=pageheader><code>minqpsetlc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets linear constraints for QP optimizer.

Linear constraints are inactive by default (after initial creation).

INPUT PARAMETERS:
    State   -   structure previously allocated with MinQPCreate call.
    C       -   linear constraints, array[K,N+1].
                Each row of C represents one constraint, either equality
                or inequality (see below):
                * first N elements correspond to coefficients,
                * last element corresponds to the right part.
                All elements of C (including right part) must be finite.
    CT      -   type of constraints, array[K]:
                * if CT[i]&gt;0, then I-th constraint is C[i,*]*x &gt;= C[i,n+1]
                * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
                * if CT[i]&lt;0, then I-th constraint is C[i,*]*x &lt;= C[i,n+1]
    K       -   number of equality/inequality constraints, K&gt;=0:
                * if given, only leading K elements of C/CT are used
                * if not given, automatically determined from sizes of C/CT

NOTE 1: linear (non-bound) constraints are satisfied only approximately  -
        there always exists some minor violation (about 10^-10...10^-13)
        due to numerical errors.

  -- ALGLIB --
     Copyright 19.06.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetlc(
    minqpstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetlc(
    minqpstate state,
    <font color=navy>double</font>[,] c,
    <font color=navy>int</font>[] ct,
    <font color=navy>int</font> k)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpsetlinearterm'></a><h3 class=pageheader><code>minqpsetlinearterm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets linear term for QP solver.

By default, linear term is zero.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    B       -   linear term, array[N].

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetlinearterm(minqpstate state, <font color=navy>double</font>[] b)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minqp_d_u2' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minqp_d_nonconvex' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpsetorigin'></a><h3 class=pageheader><code>minqpsetorigin</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function sets origin for QP solver. By default, following QP program
is solved:

    min(0.5*x'*A*x+b'*x)

This function allows to solve different problem:

    min(0.5*(x-x_origin)'*A*(x-x_origin)+b'*(x-x_origin))

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    XOrigin -   origin, array[N].

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetorigin(
    minqpstate state,
    <font color=navy>double</font>[] xorigin)

</div></pre>
<a name='sub_minqpsetquadraticterm'></a><h3 class=pageheader><code>minqpsetquadraticterm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  sets  dense  quadratic  term  for  QP solver. By  default,
quadratic term is zero.

SUPPORT BY ALGLIB QP ALGORITHMS:

Dense quadratic term can be handled by any of the QP algorithms  supported
by ALGLIB QP Solver.

IMPORTANT:

This solver minimizes following  function:
    f(x) = 0.5*x'*A*x + b'*x.
Note that quadratic term has 0.5 before it. So if  you  want  to  minimize
    f(x) = x^2 + x
you should rewrite your problem as follows:
    f(x) = 0.5*(2*x^2) + x
and your matrix A will be equal to [[2.0]], not to [[1.0]]

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    A       -   matrix, array[N,N]
    IsUpper -   (optional) storage type:
                * if True, symmetric matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt used
                * if False, symmetric matrix  A  is  given  by  its lower
                  triangle, and the upper triangle isnt used
                * if not given, both lower and upper  triangles  must  be
                  filled.

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetquadraticterm(
    minqpstate state,
    <font color=navy>double</font>[,] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetquadraticterm(
    minqpstate state,
    <font color=navy>double</font>[,] a,
    <font color=navy>bool</font> isupper)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minqp_d_nonconvex' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpsetquadratictermsparse'></a><h3 class=pageheader><code>minqpsetquadratictermsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  sets  sparse  quadratic  term  for  QP solver. By default,
quadratic term is zero.

IMPORTANT:

This solver minimizes following  function:
    f(x) = 0.5*x'*A*x + b'*x.
Note that quadratic term has 0.5 before it. So if  you  want  to  minimize
    f(x) = x^2 + x
you should rewrite your problem as follows:
    f(x) = 0.5*(2*x^2) + x
and your matrix A will be equal to [[2.0]], not to [[1.0]]

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    A       -   matrix, array[N,N]
    IsUpper -   (optional) storage type:
                * if True, symmetric matrix  A  is  given  by  its  upper
                  triangle, and the lower triangle isnt used
                * if False, symmetric matrix  A  is  given  by  its lower
                  triangle, and the upper triangle isnt used
                * if not given, both lower and upper  triangles  must  be
                  filled.

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetquadratictermsparse(
    minqpstate state,
    sparsematrix a,
    <font color=navy>bool</font> isupper)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minqpsetscale'></a><h3 class=pageheader><code>minqpsetscale</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets scaling coefficients.

ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
size and gradient are scaled before comparison with tolerances).  Scale of
the I-th variable is a translation invariant measure of:
a) &quot;how large&quot; the variable is
b) how large the step should be to make significant changes in the function

BLEIC-based QP solver uses scale for two purposes:
* to evaluate stopping conditions
* for preconditioning of the underlying BLEIC solver

INPUT PARAMETERS:
    State   -   structure stores algorithm state
    S       -   array[N], non-zero scaling coefficients
                S[i] may be negative, sign doesn't matter.

  -- ALGLIB --
     Copyright 14.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetscale(minqpstate state, <font color=navy>double</font>[] s)

</div></pre>
<a name='sub_minqpsetstartingpoint'></a><h3 class=pageheader><code>minqpsetstartingpoint</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets starting point for QP solver. It is useful to have
good initial approximation to the solution, because it will increase
speed of convergence and identification of active constraints.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    X       -   starting point, array[N].

  -- ALGLIB --
     Copyright 11.01.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.minqpsetstartingpoint(
    minqpstate state,
    <font color=navy>double</font>[] x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minqp_d_u1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minqp_d_bc1' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minqp_d_lc1' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minqp_d_u2' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_minqp_d_nonconvex' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='example_minqp_d_bc1'></a><h3 class=pageheader>minqp_d_bc1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = x0^2 + x1^2 -6*x0 - 4*x1</font>
    <font color=green>// subject to bound constraints 0&lt;=x0&lt;=2.5, 0&lt;=x1&lt;=2.5</font>
    <font color=green>//</font>
    <font color=green>// Exact solution is [x0,x1] = [2.5,2]</font>
    <font color=green>//</font>
    <font color=green>// We provide algorithm with starting point. With such small problem good starting</font>
    <font color=green>// point is not really necessary, but with high-dimensional problem it can save us</font>
    <font color=green>// a lot of time.</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT: this solver minimizes  following  function:</font>
    <font color=green>//     f(x) = 0.5*x'*A*x + b'*x.</font>
    <font color=green>// Note that quadratic term has 0.5 before it. So <font color=navy>if</font> you want to minimize</font>
    <font color=green>// quadratic function, you should rewrite it in such way that quadratic term</font>
    <font color=green>// is multiplied by 0.5 too.</font>
    <font color=green>// For example, our function is f(x)=x0^2+x1^2+..., but we rewrite it as </font>
    <font color=green>//     f(x) = 0.5*(2*x0^2+2*x1^2) + ....</font>
    <font color=green>// and pass diag(2,2) as quadratic term - NOT diag(1,1)!</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{2,0},{0,2}};
    <font color=navy>double</font>[] b = new <font color=navy>double</font>[]{-6,-4};
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{0,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{0.0,0.0};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{2.5,2.5};
    <font color=navy>double</font>[] x;
    alglib.minqpstate state;
    alglib.minqpreport rep;

    <font color=green>// create solver, set quadratic/linear terms</font>
    alglib.minqpcreate(2, <font color=navy>out</font> state);
    alglib.minqpsetquadraticterm(state, a);
    alglib.minqpsetlinearterm(state, b);
    alglib.minqpsetstartingpoint(state, x0);
    alglib.minqpsetbc(state, bndl, bndu);

    <font color=green>// Set scale of the parameters.</font>
    <font color=green>// It is strongly recommended that you set scale of your variables.</font>
    <font color=green>// Knowing their scales is essential <font color=navy>for</font> evaluation of stopping criteria</font>
    <font color=green>// and <font color=navy>for</font> preconditioning of the algorithm steps.</font>
    <font color=green>// You can find more information on scaling at http://www.alglib.net/optimization/scaling.php</font>
    alglib.minqpsetscale(state, s);

    <font color=green>// solve problem with QuickQP solver, default stopping criteria are used</font>
    alglib.minqpsetalgoquickqp(state, 0.0, 0.0, 0.0, 0, true);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [2.5,2]</font>

    <font color=green>// solve problem with BLEIC-based QP solver</font>
    <font color=green>// default stopping criteria are used.</font>
    alglib.minqpsetalgobleic(state, 0.0, 0.0, 0.0, 0);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [2.5,2]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minqp_d_lc1'></a><h3 class=pageheader>minqp_d_lc1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = x0^2 + x1^2 -6*x0 - 4*x1</font>
    <font color=green>// subject to linear constraint x0+x1&lt;=2</font>
    <font color=green>//</font>
    <font color=green>// Exact solution is [x0,x1] = [1.5,0.5]</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT: this solver minimizes  following  function:</font>
    <font color=green>//     f(x) = 0.5*x'*A*x + b'*x.</font>
    <font color=green>// Note that quadratic term has 0.5 before it. So <font color=navy>if</font> you want to minimize</font>
    <font color=green>// quadratic function, you should rewrite it in such way that quadratic term</font>
    <font color=green>// is multiplied by 0.5 too.</font>
    <font color=green>// For example, our function is f(x)=x0^2+x1^2+..., but we rewrite it as </font>
    <font color=green>//     f(x) = 0.5*(2*x0^2+2*x1^2) + ....</font>
    <font color=green>// and pass diag(2,2) as quadratic term - NOT diag(1,1)!</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{2,0},{0,2}};
    <font color=navy>double</font>[] b = new <font color=navy>double</font>[]{-6,-4};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[,] c = new <font color=navy>double</font>[,]{{1.0,1.0,2.0}};
    <font color=navy>int</font>[] ct = new <font color=navy>int</font>[]{-1};
    <font color=navy>double</font>[] x;
    alglib.minqpstate state;
    alglib.minqpreport rep;

    <font color=green>// create solver, set quadratic/linear terms</font>
    alglib.minqpcreate(2, <font color=navy>out</font> state);
    alglib.minqpsetquadraticterm(state, a);
    alglib.minqpsetlinearterm(state, b);
    alglib.minqpsetlc(state, c, ct);

    <font color=green>// Set scale of the parameters.</font>
    <font color=green>// It is strongly recommended that you set scale of your variables.</font>
    <font color=green>// Knowing their scales is essential <font color=navy>for</font> evaluation of stopping criteria</font>
    <font color=green>// and <font color=navy>for</font> preconditioning of the algorithm steps.</font>
    <font color=green>// You can find more information on scaling at http://www.alglib.net/optimization/scaling.php</font>
    alglib.minqpsetscale(state, s);

    <font color=green>// solve problem with BLEIC-based QP solver</font>
    <font color=green>// default stopping criteria are used.</font>
    alglib.minqpsetalgobleic(state, 0.0, 0.0, 0.0, 0);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,1)); <font color=green>// EXPECTED: [1.500,0.500]</font>

    <font color=green>// solve problem with QuickQP solver, default stopping criteria are used</font>
    <font color=green>// Oops! It does not support general linear constraints, -5 returned as completion code!</font>
    alglib.minqpsetalgoquickqp(state, 0.0, 0.0, 0.0, 0, true);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: -5</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minqp_d_nonconvex'></a><h3 class=pageheader>minqp_d_nonconvex example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of nonconvex function</font>
    <font color=green>//     F(x0,x1) = -(x0^2+x1^2)</font>
    <font color=green>// subject to constraints x0,x1 in [1.0,2.0]</font>
    <font color=green>// Exact solution is [x0,x1] = [2,2].</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT: this solver minimizes  following  function:</font>
    <font color=green>//     f(x) = 0.5*x'*A*x + b'*x.</font>
    <font color=green>// Note that quadratic term has 0.5 before it. So <font color=navy>if</font> you want to minimize</font>
    <font color=green>// quadratic function, you should rewrite it in such way that quadratic term</font>
    <font color=green>// is multiplied by 0.5 too.</font>
    <font color=green>//</font>
    <font color=green>// For example, our function is f(x)=-(x0^2+x1^2), but we rewrite it as </font>
    <font color=green>//     f(x) = 0.5*(-2*x0^2-2*x1^2)</font>
    <font color=green>// and pass diag(-2,-2) as quadratic term - NOT diag(-1,-1)!</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{-2,0},{0,-2}};
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] bndl = new <font color=navy>double</font>[]{1.0,1.0};
    <font color=navy>double</font>[] bndu = new <font color=navy>double</font>[]{2.0,2.0};
    <font color=navy>double</font>[] x;
    alglib.minqpstate state;
    alglib.minqpreport rep;

    <font color=green>// create solver, set quadratic/linear terms, constraints</font>
    alglib.minqpcreate(2, <font color=navy>out</font> state);
    alglib.minqpsetquadraticterm(state, a);
    alglib.minqpsetstartingpoint(state, x0);
    alglib.minqpsetbc(state, bndl, bndu);

    <font color=green>// Set scale of the parameters.</font>
    <font color=green>// It is strongly recommended that you set scale of your variables.</font>
    <font color=green>// Knowing their scales is essential <font color=navy>for</font> evaluation of stopping criteria</font>
    <font color=green>// and <font color=navy>for</font> preconditioning of the algorithm steps.</font>
    <font color=green>// You can find more information on scaling at http://www.alglib.net/optimization/scaling.php</font>
    alglib.minqpsetscale(state, s);

    <font color=green>// solve problem with BLEIC-QP solver.</font>
    <font color=green>// default stopping criteria are used.</font>
    alglib.minqpsetalgobleic(state, 0.0, 0.0, 0.0, 0);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [2,2]</font>

    <font color=green>// Hmm... this problem is bounded from below (has solution) only under constraints.</font>
    <font color=green>// What it we remove them?</font>
    <font color=green>//</font>
    <font color=green>// You may see that algorithm detects unboundedness of the problem, </font>
    <font color=green>// -4 is returned as completion code.</font>
    <font color=navy>double</font>[] nobndl = new <font color=navy>double</font>[]{-System.Double.PositiveInfinity,-System.Double.PositiveInfinity};
    <font color=navy>double</font>[] nobndu = new <font color=navy>double</font>[]{System.Double.PositiveInfinity,+System.Double.PositiveInfinity};
    alglib.minqpsetbc(state, nobndl, nobndu);
    alglib.minqpsetalgobleic(state, 0.0, 0.0, 0.0, 0);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: -4</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minqp_d_u1'></a><h3 class=pageheader>minqp_d_u1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = x0^2 + x1^2 -6*x0 - 4*x1</font>
    <font color=green>//</font>
    <font color=green>// Exact solution is [x0,x1] = [3,2]</font>
    <font color=green>//</font>
    <font color=green>// We provide algorithm with starting point, although in this case</font>
    <font color=green>// (dense matrix, no constraints) it can work without such information.</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT: this solver minimizes  following  function:</font>
    <font color=green>//     f(x) = 0.5*x'*A*x + b'*x.</font>
    <font color=green>// Note that quadratic term has 0.5 before it. So <font color=navy>if</font> you want to minimize</font>
    <font color=green>// quadratic function, you should rewrite it in such way that quadratic term</font>
    <font color=green>// is multiplied by 0.5 too.</font>
    <font color=green>//</font>
    <font color=green>// For example, our function is f(x)=x0^2+x1^2+..., but we rewrite it as </font>
    <font color=green>//     f(x) = 0.5*(2*x0^2+2*x1^2) + ....</font>
    <font color=green>// and pass diag(2,2) as quadratic term - NOT diag(1,1)!</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{2,0},{0,2}};
    <font color=navy>double</font>[] b = new <font color=navy>double</font>[]{-6,-4};
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{0,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] x;
    alglib.minqpstate state;
    alglib.minqpreport rep;

    <font color=green>// create solver, set quadratic/linear terms</font>
    alglib.minqpcreate(2, <font color=navy>out</font> state);
    alglib.minqpsetquadraticterm(state, a);
    alglib.minqpsetlinearterm(state, b);
    alglib.minqpsetstartingpoint(state, x0);

    <font color=green>// Set scale of the parameters.</font>
    <font color=green>// It is strongly recommended that you set scale of your variables.</font>
    <font color=green>// Knowing their scales is essential <font color=navy>for</font> evaluation of stopping criteria</font>
    <font color=green>// and <font color=navy>for</font> preconditioning of the algorithm steps.</font>
    <font color=green>// You can find more information on scaling at http://www.alglib.net/optimization/scaling.php</font>
    alglib.minqpsetscale(state, s);

    <font color=green>// solve problem with QuickQP solver, default stopping criteria are used, Newton phase is active</font>
    alglib.minqpsetalgoquickqp(state, 0.0, 0.0, 0.0, 0, true);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [3,2]</font>

    <font color=green>// solve problem with BLEIC-based QP solver.</font>
    <font color=green>// default stopping criteria are used.</font>
    alglib.minqpsetalgobleic(state, 0.0, 0.0, 0.0, 0);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [3,2]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_minqp_d_u2'></a><h3 class=pageheader>minqp_d_u2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates minimization of F(x0,x1) = x0^2 + x1^2 -6*x0 - 4*x1,</font>
    <font color=green>// with quadratic term given by sparse matrix structure.</font>
    <font color=green>//</font>
    <font color=green>// Exact solution is [x0,x1] = [3,2]</font>
    <font color=green>//</font>
    <font color=green>// We provide algorithm with starting point, although in this case</font>
    <font color=green>// (dense matrix, no constraints) it can work without such information.</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT: this solver minimizes  following  function:</font>
    <font color=green>//     f(x) = 0.5*x'*A*x + b'*x.</font>
    <font color=green>// Note that quadratic term has 0.5 before it. So <font color=navy>if</font> you want to minimize</font>
    <font color=green>// quadratic function, you should rewrite it in such way that quadratic term</font>
    <font color=green>// is multiplied by 0.5 too.</font>
    <font color=green>//</font>
    <font color=green>// For example, our function is f(x)=x0^2+x1^2+..., but we rewrite it as </font>
    <font color=green>//     f(x) = 0.5*(2*x0^2+2*x1^2) + ....</font>
    <font color=green>// and pass diag(2,2) as quadratic term - NOT diag(1,1)!</font>
    <font color=green>//</font>
    alglib.sparsematrix a;
    <font color=navy>double</font>[] b = new <font color=navy>double</font>[]{-6,-4};
    <font color=navy>double</font>[] x0 = new <font color=navy>double</font>[]{0,1};
    <font color=navy>double</font>[] s = new <font color=navy>double</font>[]{1,1};
    <font color=navy>double</font>[] x;
    alglib.minqpstate state;
    alglib.minqpreport rep;

    <font color=green>// initialize sparsematrix structure</font>
    alglib.sparsecreate(2, 2, 0, <font color=navy>out</font> a);
    alglib.sparseset(a, 0, 0, 2.0);
    alglib.sparseset(a, 1, 1, 2.0);

    <font color=green>// create solver, set quadratic/linear terms</font>
    alglib.minqpcreate(2, <font color=navy>out</font> state);
    alglib.minqpsetquadratictermsparse(state, a, true);
    alglib.minqpsetlinearterm(state, b);
    alglib.minqpsetstartingpoint(state, x0);

    <font color=green>// Set scale of the parameters.</font>
    <font color=green>// It is strongly recommended that you set scale of your variables.</font>
    <font color=green>// Knowing their scales is essential <font color=navy>for</font> evaluation of stopping criteria</font>
    <font color=green>// and <font color=navy>for</font> preconditioning of the algorithm steps.</font>
    <font color=green>// You can find more information on scaling at http://www.alglib.net/optimization/scaling.php</font>
    alglib.minqpsetscale(state, s);

    <font color=green>// solve problem with BLEIC-based QP solver.</font>
    <font color=green>// default stopping criteria are used.</font>
    alglib.minqpsetalgobleic(state, 0.0, 0.0, 0.0, 0);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(x,2)); <font color=green>// EXPECTED: [3,2]</font>

    <font color=green>// try to solve problem with Cholesky-based QP solver...</font>
    <font color=green>// Oops! It does not support sparse matrices, -5 returned as completion code!</font>
    alglib.minqpsetalgocholesky(state);
    alglib.minqpoptimize(state);
    alglib.minqpresults(state, <font color=navy>out</font> x, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: -5</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_mlpbase></a><h2 class=pageheader><code>mlpbase</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_modelerrors' class=toc>modelerrors</a><br>
<a href='#struct_multilayerperceptron' class=toc>multilayerperceptron</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mlpactivationfunction' class=toc>mlpactivationfunction</a><br>
<a href='#sub_mlpallerrorssparsesubset' class=toc>mlpallerrorssparsesubset</a><br>
<a href='#sub_mlpallerrorssubset' class=toc>mlpallerrorssubset</a><br>
<a href='#sub_mlpavgce' class=toc>mlpavgce</a><br>
<a href='#sub_mlpavgcesparse' class=toc>mlpavgcesparse</a><br>
<a href='#sub_mlpavgerror' class=toc>mlpavgerror</a><br>
<a href='#sub_mlpavgerrorsparse' class=toc>mlpavgerrorsparse</a><br>
<a href='#sub_mlpavgrelerror' class=toc>mlpavgrelerror</a><br>
<a href='#sub_mlpavgrelerrorsparse' class=toc>mlpavgrelerrorsparse</a><br>
<a href='#sub_mlpclserror' class=toc>mlpclserror</a><br>
<a href='#sub_mlpcopy' class=toc>mlpcopy</a><br>
<a href='#sub_mlpcopytunableparameters' class=toc>mlpcopytunableparameters</a><br>
<a href='#sub_mlpcreate0' class=toc>mlpcreate0</a><br>
<a href='#sub_mlpcreate1' class=toc>mlpcreate1</a><br>
<a href='#sub_mlpcreate2' class=toc>mlpcreate2</a><br>
<a href='#sub_mlpcreateb0' class=toc>mlpcreateb0</a><br>
<a href='#sub_mlpcreateb1' class=toc>mlpcreateb1</a><br>
<a href='#sub_mlpcreateb2' class=toc>mlpcreateb2</a><br>
<a href='#sub_mlpcreatec0' class=toc>mlpcreatec0</a><br>
<a href='#sub_mlpcreatec1' class=toc>mlpcreatec1</a><br>
<a href='#sub_mlpcreatec2' class=toc>mlpcreatec2</a><br>
<a href='#sub_mlpcreater0' class=toc>mlpcreater0</a><br>
<a href='#sub_mlpcreater1' class=toc>mlpcreater1</a><br>
<a href='#sub_mlpcreater2' class=toc>mlpcreater2</a><br>
<a href='#sub_mlperror' class=toc>mlperror</a><br>
<a href='#sub_mlperrorn' class=toc>mlperrorn</a><br>
<a href='#sub_mlperrorsparse' class=toc>mlperrorsparse</a><br>
<a href='#sub_mlperrorsparsesubset' class=toc>mlperrorsparsesubset</a><br>
<a href='#sub_mlperrorsubset' class=toc>mlperrorsubset</a><br>
<a href='#sub_mlpgetinputscaling' class=toc>mlpgetinputscaling</a><br>
<a href='#sub_mlpgetinputscount' class=toc>mlpgetinputscount</a><br>
<a href='#sub_mlpgetlayerscount' class=toc>mlpgetlayerscount</a><br>
<a href='#sub_mlpgetlayersize' class=toc>mlpgetlayersize</a><br>
<a href='#sub_mlpgetneuroninfo' class=toc>mlpgetneuroninfo</a><br>
<a href='#sub_mlpgetoutputscaling' class=toc>mlpgetoutputscaling</a><br>
<a href='#sub_mlpgetoutputscount' class=toc>mlpgetoutputscount</a><br>
<a href='#sub_mlpgetweight' class=toc>mlpgetweight</a><br>
<a href='#sub_mlpgetweightscount' class=toc>mlpgetweightscount</a><br>
<a href='#sub_mlpgrad' class=toc>mlpgrad</a><br>
<a href='#sub_mlpgradbatch' class=toc>mlpgradbatch</a><br>
<a href='#sub_mlpgradbatchsparse' class=toc>mlpgradbatchsparse</a><br>
<a href='#sub_mlpgradbatchsparsesubset' class=toc>mlpgradbatchsparsesubset</a><br>
<a href='#sub_mlpgradbatchsubset' class=toc>mlpgradbatchsubset</a><br>
<a href='#sub_mlpgradn' class=toc>mlpgradn</a><br>
<a href='#sub_mlpgradnbatch' class=toc>mlpgradnbatch</a><br>
<a href='#sub_mlphessianbatch' class=toc>mlphessianbatch</a><br>
<a href='#sub_mlphessiannbatch' class=toc>mlphessiannbatch</a><br>
<a href='#sub_mlpinitpreprocessor' class=toc>mlpinitpreprocessor</a><br>
<a href='#sub_mlpissoftmax' class=toc>mlpissoftmax</a><br>
<a href='#sub_mlpprocess' class=toc>mlpprocess</a><br>
<a href='#sub_mlpprocessi' class=toc>mlpprocessi</a><br>
<a href='#sub_mlpproperties' class=toc>mlpproperties</a><br>
<a href='#sub_mlprandomize' class=toc>mlprandomize</a><br>
<a href='#sub_mlprandomizefull' class=toc>mlprandomizefull</a><br>
<a href='#sub_mlprelclserror' class=toc>mlprelclserror</a><br>
<a href='#sub_mlprelclserrorsparse' class=toc>mlprelclserrorsparse</a><br>
<a href='#sub_mlprmserror' class=toc>mlprmserror</a><br>
<a href='#sub_mlprmserrorsparse' class=toc>mlprmserrorsparse</a><br>
<a href='#sub_mlpserialize' class=toc>mlpserialize</a><br>
<a href='#sub_mlpsetinputscaling' class=toc>mlpsetinputscaling</a><br>
<a href='#sub_mlpsetneuroninfo' class=toc>mlpsetneuroninfo</a><br>
<a href='#sub_mlpsetoutputscaling' class=toc>mlpsetoutputscaling</a><br>
<a href='#sub_mlpsetweight' class=toc>mlpsetweight</a><br>
<a href='#sub_mlpunserialize' class=toc>mlpunserialize</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_modelerrors'></a><h3 class=pageheader><code>modelerrors</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Model's errors:
    * RelCLSError   -   fraction of misclassified cases.
    * AvgCE         -   acerage cross-entropy
    * RMSError      -   root-mean-square error
    * AvgError      -   average error
    * AvgRelError   -   average relative error

NOTE 1: RelCLSError/AvgCE are zero on regression problems.

NOTE 2: on classification problems  RMSError/AvgError/AvgRelError  contain
        errors in prediction of posterior probabilities
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class modelerrors
{
    <font color=navy>public</font> <font color=navy>double</font>               relclserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgce;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
}

</div></pre>
<a name='struct_multilayerperceptron'></a><h3 class=pageheader><code>multilayerperceptron</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class multilayerperceptron
{
}

</div></pre>
<a name='sub_mlpactivationfunction'></a><h3 class=pageheader><code>mlpactivationfunction</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Neural network activation function

INPUT PARAMETERS:
    NET         -   neuron input
    K           -   function index (zero for linear function)

OUTPUT PARAMETERS:
    F           -   function
    DF          -   its derivative
    D2F         -   its second derivative

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpactivationfunction(
    <font color=navy>double</font> net,
    <font color=navy>int</font> k,
    <font color=navy>out</font> <font color=navy>double</font> f,
    <font color=navy>out</font> <font color=navy>double</font> df,
    <font color=navy>out</font> <font color=navy>double</font> d2f)

</div></pre>
<a name='sub_mlpallerrorssparsesubset'></a><h3 class=pageheader><code>mlpallerrorssparsesubset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of all types of errors on subset of dataset.

FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   original dataset given by sparse matrix;
                one sample = one row;
                first NIn columns contain inputs,
                next NOut columns - desired outputs.
    SetSize -   real size of XY, SetSize&gt;=0;
    Subset  -   subset of SubsetSize elements, array[SubsetSize];
    SubsetSize- number of elements in Subset[] array:
                * if SubsetSize&gt;0, rows of XY with indices Subset[0]...
                  ...Subset[SubsetSize-1] are processed
                * if SubsetSize=0, zeros are returned
                * if SubsetSize&lt;0, entire dataset is  processed;  Subset[]
                  array is ignored in this case.

OUTPUT PARAMETERS:
    Rep     -   it contains all type of errors.


  -- ALGLIB --
     Copyright 04.09.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpallerrorssparsesubset(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> modelerrors rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpallerrorssparsesubset(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> modelerrors rep)

</div></pre>
<a name='sub_mlpallerrorssubset'></a><h3 class=pageheader><code>mlpallerrorssubset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of all types of errors on subset of dataset.

FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   original dataset; one sample = one row;
                first NIn columns contain inputs,
                next NOut columns - desired outputs.
    SetSize -   real size of XY, SetSize&gt;=0;
    Subset  -   subset of SubsetSize elements, array[SubsetSize];
    SubsetSize- number of elements in Subset[] array:
                * if SubsetSize&gt;0, rows of XY with indices Subset[0]...
                  ...Subset[SubsetSize-1] are processed
                * if SubsetSize=0, zeros are returned
                * if SubsetSize&lt;0, entire dataset is  processed;  Subset[]
                  array is ignored in this case.

OUTPUT PARAMETERS:
    Rep     -   it contains all type of errors.

  -- ALGLIB --
     Copyright 04.09.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpallerrorssubset(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> modelerrors rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpallerrorssubset(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> modelerrors rep)

</div></pre>
<a name='sub_mlpavgce'></a><h3 class=pageheader><code>mlpavgce</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average cross-entropy  (in bits  per element) on the test set.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
CrossEntropy/(NPoints*LN(2)).
Zero if network solves regression task.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 08.01.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpavgce(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlpavgce(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpavgcesparse'></a><h3 class=pageheader><code>mlpavgcesparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average  cross-entropy  (in bits  per element)  on the  test set  given by
sparse matrix.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.  Sparse  matrix  must  use  CRS  format for
                    storage.
    NPoints     -   points count, &gt;=0.

RESULT:
CrossEntropy/(NPoints*LN(2)).
Zero if network solves regression task.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 9.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpavgcesparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlpavgcesparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpavgerror'></a><h3 class=pageheader><code>mlpavgerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average absolute error on the test set.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
Its meaning for regression task is obvious. As for classification task, it
means average error when estimating posterior probabilities.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 11.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpavgerror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlpavgerror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpavgerrorsparse'></a><h3 class=pageheader><code>mlpavgerrorsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average absolute error on the test set given by sparse matrix.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.  Sparse  matrix  must  use  CRS  format for
                    storage.
    NPoints     -   points count, &gt;=0.

RESULT:
Its meaning for regression task is obvious. As for classification task, it
means average error when estimating posterior probabilities.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 09.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpavgerrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlpavgerrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpavgrelerror'></a><h3 class=pageheader><code>mlpavgrelerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average relative error on the test set.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
Its meaning for regression task is obvious. As for classification task, it
means  average  relative  error  when  estimating posterior probability of
belonging to the correct class.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 11.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpavgrelerror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlpavgrelerror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpavgrelerrorsparse'></a><h3 class=pageheader><code>mlpavgrelerrorsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average relative error on the test set given by sparse matrix.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.  Sparse  matrix  must  use  CRS  format for
                    storage.
    NPoints     -   points count, &gt;=0.

RESULT:
Its meaning for regression task is obvious. As for classification task, it
means  average  relative  error  when  estimating posterior probability of
belonging to the correct class.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 09.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpavgrelerrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlpavgrelerrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpclserror'></a><h3 class=pageheader><code>mlpclserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Classification error of the neural network on dataset.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
    classification error (number of misclassified cases)

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mlpclserror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.smp_mlpclserror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpcopy'></a><h3 class=pageheader><code>mlpcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Copying of neural network

INPUT PARAMETERS:
    Network1 -   original

OUTPUT PARAMETERS:
    Network2 -   copy

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcopy(
    multilayerperceptron network1,
    <font color=navy>out</font> multilayerperceptron network2)

</div></pre>
<a name='sub_mlpcopytunableparameters'></a><h3 class=pageheader><code>mlpcopytunableparameters</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function copies tunable  parameters (weights/means/sigmas)  from  one
network to another with same architecture. It  performs  some  rudimentary
checks that architectures are same, and throws exception if check fails.

It is intended for fast copying of states between two  network  which  are
known to have same geometry.

INPUT PARAMETERS:
    Network1 -   source, must be correctly initialized
    Network2 -   target, must have same architecture

OUTPUT PARAMETERS:
    Network2 -   network state is copied from source to target

  -- ALGLIB --
     Copyright 20.06.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcopytunableparameters(
    multilayerperceptron network1,
    multilayerperceptron network2)

</div></pre>
<a name='sub_mlpcreate0'></a><h3 class=pageheader><code>mlpcreate0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creates  neural  network  with  NIn  inputs,  NOut outputs, without hidden
layers, with linear output layer. Network weights are  filled  with  small
random values.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreate0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreate1'></a><h3 class=pageheader><code>mlpcreate1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same  as  MLPCreate0,  but  with  one  hidden  layer  (NHid  neurons) with
non-linear activation function. Output layer is linear.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreate1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreate2'></a><h3 class=pageheader><code>mlpcreate2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreate0, but with two hidden layers (NHid1 and  NHid2  neurons)
with non-linear activation function. Output layer is linear.
 $ALL

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreate2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreateb0'></a><h3 class=pageheader><code>mlpcreateb0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creates  neural  network  with  NIn  inputs,  NOut outputs, without hidden
layers with non-linear output layer. Network weights are filled with small
random values.

Activation function of the output layer takes values:

    (B, +INF), if D&gt;=0

or

    (-INF, B), if D&lt;0.


  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreateb0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> b,
    <font color=navy>double</font> d,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreateb1'></a><h3 class=pageheader><code>mlpcreateb1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreateB0 but with non-linear hidden layer.

  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreateb1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> b,
    <font color=navy>double</font> d,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreateb2'></a><h3 class=pageheader><code>mlpcreateb2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreateB0 but with two non-linear hidden layers.

  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreateb2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> b,
    <font color=navy>double</font> d,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreatec0'></a><h3 class=pageheader><code>mlpcreatec0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creates classifier network with NIn  inputs  and  NOut  possible  classes.
Network contains no hidden layers and linear output  layer  with  SOFTMAX-
normalization  (so  outputs  sums  up  to  1.0  and  converge to posterior
probabilities).

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreatec0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreatec1'></a><h3 class=pageheader><code>mlpcreatec1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreateC0, but with one non-linear hidden layer.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreatec1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreatec2'></a><h3 class=pageheader><code>mlpcreatec2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreateC0, but with two non-linear hidden layers.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreatec2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreater0'></a><h3 class=pageheader><code>mlpcreater0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creates  neural  network  with  NIn  inputs,  NOut outputs, without hidden
layers with non-linear output layer. Network weights are filled with small
random values. Activation function of the output layer takes values [A,B].

  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreater0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreater1'></a><h3 class=pageheader><code>mlpcreater1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreateR0, but with non-linear hidden layer.

  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreater1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreater2'></a><h3 class=pageheader><code>mlpcreater2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as MLPCreateR0, but with two non-linear hidden layers.

  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreater2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> multilayerperceptron network)

</div></pre>
<a name='sub_mlperror'></a><h3 class=pageheader><code>mlperror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Error of the neural network on dataset.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore systems.
  ! Second improvement gives constant speedup (2-3x, depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
    sum-of-squares error, SUM(sqr(y[i]-desired_y[i])/2)

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlperror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlperror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlperrorn'></a><h3 class=pageheader><code>mlperrorn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Natural error function for neural network, internal subroutine.

NOTE: this function is single-threaded. Unlike other  error  function,  it
receives no speed-up from being executed in SMP mode.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlperrorn(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize)

</div></pre>
<a name='sub_mlperrorsparse'></a><h3 class=pageheader><code>mlperrorsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Error of the neural network on dataset given by sparse matrix.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore systems.
  ! Second improvement gives constant speedup (2-3x, depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.  Sparse  matrix  must  use  CRS  format for
                    storage.
    NPoints     -   points count, &gt;=0

RESULT:
    sum-of-squares error, SUM(sqr(y[i]-desired_y[i])/2)

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlperrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlperrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlperrorsparsesubset'></a><h3 class=pageheader><code>mlperrorsparsesubset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Error of the neural network on subset of sparse dataset.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network   -     neural network;
    XY        -     training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.  Sparse  matrix  must  use  CRS  format for
                    storage.
    SetSize   -     real size of XY, SetSize&gt;=0;
                    it is used when SubsetSize&lt;0;
    Subset    -     subset of SubsetSize elements, array[SubsetSize];
    SubsetSize-     number of elements in Subset[] array:
                    * if SubsetSize&gt;0, rows of XY with indices Subset[0]...
                      ...Subset[SubsetSize-1] are processed
                    * if SubsetSize=0, zeros are returned
                    * if SubsetSize&lt;0, entire dataset is  processed;  Subset[]
                      array is ignored in this case.

RESULT:
    sum-of-squares error, SUM(sqr(y[i]-desired_y[i])/2)

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 04.09.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlperrorsparsesubset(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlperrorsparsesubset(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize)

</div></pre>
<a name='sub_mlperrorsubset'></a><h3 class=pageheader><code>mlperrorsubset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Error of the neural network on subset of dataset.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network   -     neural network;
    XY        -     training  set,  see  below  for  information  on   the
                    training set format;
    SetSize   -     real size of XY, SetSize&gt;=0;
    Subset    -     subset of SubsetSize elements, array[SubsetSize];
    SubsetSize-     number of elements in Subset[] array:
                    * if SubsetSize&gt;0, rows of XY with indices Subset[0]...
                      ...Subset[SubsetSize-1] are processed
                    * if SubsetSize=0, zeros are returned
                    * if SubsetSize&lt;0, entire dataset is  processed;  Subset[]
                      array is ignored in this case.

RESULT:
    sum-of-squares error, SUM(sqr(y[i]-desired_y[i])/2)

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 04.09.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlperrorsubset(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlperrorsubset(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] subset,
    <font color=navy>int</font> subsetsize)

</div></pre>
<a name='sub_mlpgetinputscaling'></a><h3 class=pageheader><code>mlpgetinputscaling</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns offset/scaling coefficients for I-th input of the
network.

INPUT PARAMETERS:
    Network     -   network
    I           -   input index

OUTPUT PARAMETERS:
    Mean        -   mean term
    Sigma       -   sigma term, guaranteed to be nonzero.

I-th input is passed through linear transformation
    IN[i] = (IN[i]-Mean)/Sigma
before feeding to the network

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgetinputscaling(
    multilayerperceptron network,
    <font color=navy>int</font> i,
    <font color=navy>out</font> <font color=navy>double</font> mean,
    <font color=navy>out</font> <font color=navy>double</font> sigma)

</div></pre>
<a name='sub_mlpgetinputscount'></a><h3 class=pageheader><code>mlpgetinputscount</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns number of inputs.

  -- ALGLIB --
     Copyright 19.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mlpgetinputscount(multilayerperceptron network)

</div></pre>
<a name='sub_mlpgetlayerscount'></a><h3 class=pageheader><code>mlpgetlayerscount</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns total number of layers (including input, hidden and
output layers).

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mlpgetlayerscount(multilayerperceptron network)

</div></pre>
<a name='sub_mlpgetlayersize'></a><h3 class=pageheader><code>mlpgetlayersize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns size of K-th layer.

K=0 corresponds to input layer, K=CNT-1 corresponds to output layer.

Size of the output layer is always equal to the number of outputs, although
when we have softmax-normalized network, last neuron doesn't have any
connections - it is just zero.

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mlpgetlayersize(
    multilayerperceptron network,
    <font color=navy>int</font> k)

</div></pre>
<a name='sub_mlpgetneuroninfo'></a><h3 class=pageheader><code>mlpgetneuroninfo</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns information about Ith neuron of Kth layer

INPUT PARAMETERS:
    Network     -   network
    K           -   layer index
    I           -   neuron index (within layer)

OUTPUT PARAMETERS:
    FKind       -   activation function type (used by MLPActivationFunction())
                    this value is zero for input or linear neurons
    Threshold   -   also called offset, bias
                    zero for input neurons

NOTE: this function throws exception if layer or neuron with  given  index
do not exists.

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgetneuroninfo(
    multilayerperceptron network,
    <font color=navy>int</font> k,
    <font color=navy>int</font> i,
    <font color=navy>out</font> <font color=navy>int</font> fkind,
    <font color=navy>out</font> <font color=navy>double</font> threshold)

</div></pre>
<a name='sub_mlpgetoutputscaling'></a><h3 class=pageheader><code>mlpgetoutputscaling</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns offset/scaling coefficients for I-th output of the
network.

INPUT PARAMETERS:
    Network     -   network
    I           -   input index

OUTPUT PARAMETERS:
    Mean        -   mean term
    Sigma       -   sigma term, guaranteed to be nonzero.

I-th output is passed through linear transformation
    OUT[i] = OUT[i]*Sigma+Mean
before returning it to user. In case we have SOFTMAX-normalized network,
we return (Mean,Sigma)=(0.0,1.0).

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgetoutputscaling(
    multilayerperceptron network,
    <font color=navy>int</font> i,
    <font color=navy>out</font> <font color=navy>double</font> mean,
    <font color=navy>out</font> <font color=navy>double</font> sigma)

</div></pre>
<a name='sub_mlpgetoutputscount'></a><h3 class=pageheader><code>mlpgetoutputscount</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns number of outputs.

  -- ALGLIB --
     Copyright 19.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mlpgetoutputscount(multilayerperceptron network)

</div></pre>
<a name='sub_mlpgetweight'></a><h3 class=pageheader><code>mlpgetweight</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns information about connection from I0-th neuron of
K0-th layer to I1-th neuron of K1-th layer.

INPUT PARAMETERS:
    Network     -   network
    K0          -   layer index
    I0          -   neuron index (within layer)
    K1          -   layer index
    I1          -   neuron index (within layer)

RESULT:
    connection weight (zero for non-existent connections)

This function:
1. throws exception if layer or neuron with given index do not exists.
2. returns zero if neurons exist, but there is no connection between them

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpgetweight(
    multilayerperceptron network,
    <font color=navy>int</font> k0,
    <font color=navy>int</font> i0,
    <font color=navy>int</font> k1,
    <font color=navy>int</font> i1)

</div></pre>
<a name='sub_mlpgetweightscount'></a><h3 class=pageheader><code>mlpgetweightscount</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns number of weights.

  -- ALGLIB --
     Copyright 19.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.mlpgetweightscount(multilayerperceptron network)

</div></pre>
<a name='sub_mlpgrad'></a><h3 class=pageheader><code>mlpgrad</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Gradient calculation

INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    X       -   input vector, length of array must be at least NIn
    DesiredY-   desired outputs, length of array must be at least NOut
    Grad    -   possibly preallocated array. If size of array is smaller
                than WCount, it will be reallocated. It is recommended to
                reuse previously allocated array to reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E       -   error function, SUM(sqr(y[i]-desiredy[i])/2,i)
    Grad    -   gradient of E with respect to weights of network, array[WCount]

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgrad(
    multilayerperceptron network,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] desiredy,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlpgradbatch'></a><h3 class=pageheader><code>mlpgradbatch</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch gradient calculation for a set of inputs/outputs


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   original dataset in dense format; one sample = one row:
                * first NIn columns contain inputs,
                * for regression problem, next NOut columns store
                  desired outputs.
                * for classification problem, next column (just one!)
                  stores class number.
    SSize   -   number of elements in XY
    Grad    -   possibly preallocated array. If size of array is smaller
                than WCount, it will be reallocated. It is recommended to
                reuse previously allocated array to reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E       -   error function, SUM(sqr(y[i]-desiredy[i])/2,i)
    Grad    -   gradient of E with respect to weights of network, array[WCount]

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgradbatch(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpgradbatch(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlpgradbatchsparse'></a><h3 class=pageheader><code>mlpgradbatchsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch gradient calculation for a set  of inputs/outputs  given  by  sparse
matrices


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   original dataset in sparse format; one sample = one row:
                * MATRIX MUST BE STORED IN CRS FORMAT
                * first NIn columns contain inputs.
                * for regression problem, next NOut columns store
                  desired outputs.
                * for classification problem, next column (just one!)
                  stores class number.
    SSize   -   number of elements in XY
    Grad    -   possibly preallocated array. If size of array is smaller
                than WCount, it will be reallocated. It is recommended to
                reuse previously allocated array to reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E       -   error function, SUM(sqr(y[i]-desiredy[i])/2,i)
    Grad    -   gradient of E with respect to weights of network, array[WCount]

  -- ALGLIB --
     Copyright 26.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgradbatchsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpgradbatchsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlpgradbatchsparsesubset'></a><h3 class=pageheader><code>mlpgradbatchsparsesubset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch gradient calculation for a set of inputs/outputs  for  a  subset  of
dataset given by set of indexes.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   original dataset in sparse format; one sample = one row:
                * MATRIX MUST BE STORED IN CRS FORMAT
                * first NIn columns contain inputs,
                * for regression problem, next NOut columns store
                  desired outputs.
                * for classification problem, next column (just one!)
                  stores class number.
    SetSize -   real size of XY, SetSize&gt;=0;
    Idx     -   subset of SubsetSize elements, array[SubsetSize]:
                * Idx[I] stores row index in the original dataset which is
                  given by XY. Gradient is calculated with respect to rows
                  whose indexes are stored in Idx[].
                * Idx[]  must store correct indexes; this function  throws
                  an  exception  in  case  incorrect index (less than 0 or
                  larger than rows(XY)) is given
                * Idx[]  may  store  indexes  in  any  order and even with
                  repetitions.
    SubsetSize- number of elements in Idx[] array:
                * positive value means that subset given by Idx[] is processed
                * zero value results in zero gradient
                * negative value means that full dataset is processed
    Grad      - possibly  preallocated array. If size of array is  smaller
                than WCount, it will be reallocated. It is  recommended to
                reuse  previously  allocated  array  to  reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E       -   error function, SUM(sqr(y[i]-desiredy[i])/2,i)
    Grad    -   gradient  of  E  with  respect   to  weights  of  network,
                array[WCount]

NOTE: when  SubsetSize&lt;0 is used full dataset by call MLPGradBatchSparse
      function.

  -- ALGLIB --
     Copyright 26.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgradbatchsparsesubset(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] idx,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpgradbatchsparsesubset(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] idx,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlpgradbatchsubset'></a><h3 class=pageheader><code>mlpgradbatchsubset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch gradient calculation for a subset of dataset


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   original dataset in dense format; one sample = one row:
                * first NIn columns contain inputs,
                * for regression problem, next NOut columns store
                  desired outputs.
                * for classification problem, next column (just one!)
                  stores class number.
    SetSize -   real size of XY, SetSize&gt;=0;
    Idx     -   subset of SubsetSize elements, array[SubsetSize]:
                * Idx[I] stores row index in the original dataset which is
                  given by XY. Gradient is calculated with respect to rows
                  whose indexes are stored in Idx[].
                * Idx[]  must store correct indexes; this function  throws
                  an  exception  in  case  incorrect index (less than 0 or
                  larger than rows(XY)) is given
                * Idx[]  may  store  indexes  in  any  order and even with
                  repetitions.
    SubsetSize- number of elements in Idx[] array:
                * positive value means that subset given by Idx[] is processed
                * zero value results in zero gradient
                * negative value means that full dataset is processed
    Grad      - possibly  preallocated array. If size of array is  smaller
                than WCount, it will be reallocated. It is  recommended to
                reuse  previously  allocated  array  to  reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E         - error function, SUM(sqr(y[i]-desiredy[i])/2,i)
    Grad      - gradient  of  E  with  respect   to  weights  of  network,
                array[WCount]

  -- ALGLIB --
     Copyright 26.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgradbatchsubset(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] idx,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpgradbatchsubset(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> setsize,
    <font color=navy>int</font>[] idx,
    <font color=navy>int</font> subsetsize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlpgradn'></a><h3 class=pageheader><code>mlpgradn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Gradient calculation (natural error function is used)

INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    X       -   input vector, length of array must be at least NIn
    DesiredY-   desired outputs, length of array must be at least NOut
    Grad    -   possibly preallocated array. If size of array is smaller
                than WCount, it will be reallocated. It is recommended to
                reuse previously allocated array to reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E       -   error function, sum-of-squares for regression networks,
                cross-entropy for classification networks.
    Grad    -   gradient of E with respect to weights of network, array[WCount]

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgradn(
    multilayerperceptron network,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] desiredy,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlpgradnbatch'></a><h3 class=pageheader><code>mlpgradnbatch</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch gradient calculation for a set of inputs/outputs
(natural error function is used)

INPUT PARAMETERS:
    Network -   network initialized with one of the network creation funcs
    XY      -   set of inputs/outputs; one sample = one row;
                first NIn columns contain inputs,
                next NOut columns - desired outputs.
    SSize   -   number of elements in XY
    Grad    -   possibly preallocated array. If size of array is smaller
                than WCount, it will be reallocated. It is recommended to
                reuse previously allocated array to reduce allocation
                overhead.

OUTPUT PARAMETERS:
    E       -   error function, sum-of-squares for regression networks,
                cross-entropy for classification networks.
    Grad    -   gradient of E with respect to weights of network, array[WCount]

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpgradnbatch(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad)

</div></pre>
<a name='sub_mlphessianbatch'></a><h3 class=pageheader><code>mlphessianbatch</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch Hessian calculation using R-algorithm.
Internal subroutine.

  -- ALGLIB --
     Copyright 26.01.2008 by Bochkanov Sergey.

     Hessian calculation based on R-algorithm described in
     &quot;Fast Exact Multiplication by the Hessian&quot;,
     B. A. Pearlmutter,
     Neural Computation, 1994.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlphessianbatch(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad,
    <font color=navy>ref</font> <font color=navy>double</font>[,] h)

</div></pre>
<a name='sub_mlphessiannbatch'></a><h3 class=pageheader><code>mlphessiannbatch</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Batch Hessian calculation (natural error function) using R-algorithm.
Internal subroutine.

  -- ALGLIB --
     Copyright 26.01.2008 by Bochkanov Sergey.

     Hessian calculation based on R-algorithm described in
     &quot;Fast Exact Multiplication by the Hessian&quot;,
     B. A. Pearlmutter,
     Neural Computation, 1994.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlphessiannbatch(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize,
    <font color=navy>out</font> <font color=navy>double</font> e,
    <font color=navy>ref</font> <font color=navy>double</font>[] grad,
    <font color=navy>ref</font> <font color=navy>double</font>[,] h)

</div></pre>
<a name='sub_mlpinitpreprocessor'></a><h3 class=pageheader><code>mlpinitpreprocessor</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Internal subroutine.

  -- ALGLIB --
     Copyright 30.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpinitpreprocessor(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> ssize)

</div></pre>
<a name='sub_mlpissoftmax'></a><h3 class=pageheader><code>mlpissoftmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Tells whether network is SOFTMAX-normalized (i.e. classifier) or not.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.mlpissoftmax(multilayerperceptron network)

</div></pre>
<a name='sub_mlpprocess'></a><h3 class=pageheader><code>mlpprocess</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procesing

INPUT PARAMETERS:
    Network -   neural network
    X       -   input vector,  array[0..NIn-1].

OUTPUT PARAMETERS:
    Y       -   result. Regression estimate when solving regression  task,
                vector of posterior probabilities for classification task.

See also MLPProcessI

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpprocess(
    multilayerperceptron network,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_mlpprocessi'></a><h3 class=pageheader><code>mlpprocessi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
'interactive'  variant  of  MLPProcess  for  languages  like  Python which
support constructs like &quot;Y = MLPProcess(NN,X)&quot; and interactive mode of the
interpreter

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 21.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpprocessi(
    multilayerperceptron network,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_mlpproperties'></a><h3 class=pageheader><code>mlpproperties</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns information about initialized network: number of inputs, outputs,
weights.

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpproperties(
    multilayerperceptron network,
    <font color=navy>out</font> <font color=navy>int</font> nin,
    <font color=navy>out</font> <font color=navy>int</font> nout,
    <font color=navy>out</font> <font color=navy>int</font> wcount)

</div></pre>
<a name='sub_mlprandomize'></a><h3 class=pageheader><code>mlprandomize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Randomization of neural network weights

  -- ALGLIB --
     Copyright 06.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlprandomize(multilayerperceptron network)

</div></pre>
<a name='sub_mlprandomizefull'></a><h3 class=pageheader><code>mlprandomizefull</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Randomization of neural network weights and standartisator

  -- ALGLIB --
     Copyright 10.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlprandomizefull(multilayerperceptron network)

</div></pre>
<a name='sub_mlprelclserror'></a><h3 class=pageheader><code>mlprelclserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Relative classification error on the test set.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
Percent   of incorrectly   classified  cases.  Works  both  for classifier
networks and general purpose networks used as classifiers.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 25.12.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlprelclserror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlprelclserror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlprelclserrorsparse'></a><h3 class=pageheader><code>mlprelclserrorsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Relative classification error on the test set given by sparse matrix.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. Sparse matrix must use CRS format
                    for storage.
    NPoints     -   points count, &gt;=0.

RESULT:
Percent   of incorrectly   classified  cases.  Works  both  for classifier
networks and general purpose networks used as classifiers.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 09.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlprelclserrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlprelclserrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlprmserror'></a><h3 class=pageheader><code>mlprmserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set given.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format;
    NPoints     -   points count.

RESULT:
Root mean  square error. Its meaning for regression task is obvious. As for
classification  task,  RMS  error  means  error  when estimating  posterior
probabilities.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 04.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlprmserror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlprmserror(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlprmserrorsparse'></a><h3 class=pageheader><code>mlprmserrorsparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set given by sparse matrix.


FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support
  !
  ! First improvement gives close-to-linear speedup on multicore  systems.
  ! Second improvement gives constant speedup (2-3x depending on your CPU)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.


INPUT PARAMETERS:
    Network     -   neural network;
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.  Sparse  matrix  must  use  CRS  format for
                    storage.
    NPoints     -   points count, &gt;=0.

RESULT:
Root mean  square error. Its meaning for regression task is obvious. As for
classification  task,  RMS  error  means  error  when estimating  posterior
probabilities.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
dataset format is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 09.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlprmserrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.smp_mlprmserrorsparse(
    multilayerperceptron network,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpserialize'></a><h3 class=pageheader><code>mlpserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function serializes data structure to string.

Important properties of s_out:
* it contains alphanumeric characters, dots, underscores, minus signs
* these symbols are grouped into words, which are separated by spaces
  and Windows-style (CR+LF) newlines
* although  serializer  uses  spaces and CR+LF as separators, you can 
  replace any separator character by arbitrary combination of spaces,
  tabs, Windows or Unix newlines. It allows flexible reformatting  of
  the  string  in  case you want to include it into text or XML file. 
  But you should not insert separators into the middle of the &quot;words&quot;
  nor you should change case of letters.
* s_out can be freely moved between 32-bit and 64-bit systems, little
  and big endian machines, and so on. You can serialize structure  on
  32-bit machine and unserialize it on 64-bit one (or vice versa), or
  serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
  serialize  it  in  C++ version of ALGLIB and unserialize in C# one, 
  and vice versa.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> mlpserialize(multilayerperceptron obj, <font color=navy>out</font> string s_out)

</div></pre>
<a name='sub_mlpsetinputscaling'></a><h3 class=pageheader><code>mlpsetinputscaling</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets offset/scaling coefficients for I-th input of the
network.

INPUT PARAMETERS:
    Network     -   network
    I           -   input index
    Mean        -   mean term
    Sigma       -   sigma term (if zero, will be replaced by 1.0)

NTE: I-th input is passed through linear transformation
    IN[i] = (IN[i]-Mean)/Sigma
before feeding to the network. This function sets Mean and Sigma.

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetinputscaling(
    multilayerperceptron network,
    <font color=navy>int</font> i,
    <font color=navy>double</font> mean,
    <font color=navy>double</font> sigma)

</div></pre>
<a name='sub_mlpsetneuroninfo'></a><h3 class=pageheader><code>mlpsetneuroninfo</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function modifies information about Ith neuron of Kth layer

INPUT PARAMETERS:
    Network     -   network
    K           -   layer index
    I           -   neuron index (within layer)
    FKind       -   activation function type (used by MLPActivationFunction())
                    this value must be zero for input neurons
                    (you can not set activation function for input neurons)
    Threshold   -   also called offset, bias
                    this value must be zero for input neurons
                    (you can not set threshold for input neurons)

NOTES:
1. this function throws exception if layer or neuron with given index do
   not exists.
2. this function also throws exception when you try to set non-linear
   activation function for input neurons (any kind of network) or for output
   neurons of classifier network.
3. this function throws exception when you try to set non-zero threshold for
   input neurons (any kind of network).

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetneuroninfo(
    multilayerperceptron network,
    <font color=navy>int</font> k,
    <font color=navy>int</font> i,
    <font color=navy>int</font> fkind,
    <font color=navy>double</font> threshold)

</div></pre>
<a name='sub_mlpsetoutputscaling'></a><h3 class=pageheader><code>mlpsetoutputscaling</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets offset/scaling coefficients for I-th output of the
network.

INPUT PARAMETERS:
    Network     -   network
    I           -   input index
    Mean        -   mean term
    Sigma       -   sigma term (if zero, will be replaced by 1.0)

OUTPUT PARAMETERS:

NOTE: I-th output is passed through linear transformation
    OUT[i] = OUT[i]*Sigma+Mean
before returning it to user. This function sets Sigma/Mean. In case we
have SOFTMAX-normalized network, you can not set (Sigma,Mean) to anything
other than(0.0,1.0) - this function will throw exception.

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetoutputscaling(
    multilayerperceptron network,
    <font color=navy>int</font> i,
    <font color=navy>double</font> mean,
    <font color=navy>double</font> sigma)

</div></pre>
<a name='sub_mlpsetweight'></a><h3 class=pageheader><code>mlpsetweight</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function modifies information about connection from I0-th neuron of
K0-th layer to I1-th neuron of K1-th layer.

INPUT PARAMETERS:
    Network     -   network
    K0          -   layer index
    I0          -   neuron index (within layer)
    K1          -   layer index
    I1          -   neuron index (within layer)
    W           -   connection weight (must be zero for non-existent
                    connections)

This function:
1. throws exception if layer or neuron with given index do not exists.
2. throws exception if you try to set non-zero weight for non-existent
   connection

  -- ALGLIB --
     Copyright 25.03.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetweight(
    multilayerperceptron network,
    <font color=navy>int</font> k0,
    <font color=navy>int</font> i0,
    <font color=navy>int</font> k1,
    <font color=navy>int</font> i1,
    <font color=navy>double</font> w)

</div></pre>
<a name='sub_mlpunserialize'></a><h3 class=pageheader><code>mlpunserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function unserializes data structure from string.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> mlpunserialize(string s_in, <font color=navy>out</font> multilayerperceptron obj)

</div></pre>
<a name=unit_mlpe></a><h2 class=pageheader><code>mlpe</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mlpensemble' class=toc>mlpensemble</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mlpeavgce' class=toc>mlpeavgce</a><br>
<a href='#sub_mlpeavgerror' class=toc>mlpeavgerror</a><br>
<a href='#sub_mlpeavgrelerror' class=toc>mlpeavgrelerror</a><br>
<a href='#sub_mlpecreate0' class=toc>mlpecreate0</a><br>
<a href='#sub_mlpecreate1' class=toc>mlpecreate1</a><br>
<a href='#sub_mlpecreate2' class=toc>mlpecreate2</a><br>
<a href='#sub_mlpecreateb0' class=toc>mlpecreateb0</a><br>
<a href='#sub_mlpecreateb1' class=toc>mlpecreateb1</a><br>
<a href='#sub_mlpecreateb2' class=toc>mlpecreateb2</a><br>
<a href='#sub_mlpecreatec0' class=toc>mlpecreatec0</a><br>
<a href='#sub_mlpecreatec1' class=toc>mlpecreatec1</a><br>
<a href='#sub_mlpecreatec2' class=toc>mlpecreatec2</a><br>
<a href='#sub_mlpecreatefromnetwork' class=toc>mlpecreatefromnetwork</a><br>
<a href='#sub_mlpecreater0' class=toc>mlpecreater0</a><br>
<a href='#sub_mlpecreater1' class=toc>mlpecreater1</a><br>
<a href='#sub_mlpecreater2' class=toc>mlpecreater2</a><br>
<a href='#sub_mlpeissoftmax' class=toc>mlpeissoftmax</a><br>
<a href='#sub_mlpeprocess' class=toc>mlpeprocess</a><br>
<a href='#sub_mlpeprocessi' class=toc>mlpeprocessi</a><br>
<a href='#sub_mlpeproperties' class=toc>mlpeproperties</a><br>
<a href='#sub_mlperandomize' class=toc>mlperandomize</a><br>
<a href='#sub_mlperelclserror' class=toc>mlperelclserror</a><br>
<a href='#sub_mlpermserror' class=toc>mlpermserror</a><br>
<a href='#sub_mlpeserialize' class=toc>mlpeserialize</a><br>
<a href='#sub_mlpeunserialize' class=toc>mlpeunserialize</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_mlpensemble'></a><h3 class=pageheader><code>mlpensemble</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Neural networks ensemble
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mlpensemble
{
}

</div></pre>
<a name='sub_mlpeavgce'></a><h3 class=pageheader><code>mlpeavgce</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average cross-entropy (in bits per element) on the test set

INPUT PARAMETERS:
    Ensemble-   ensemble
    XY      -   test set
    NPoints -   test set size

RESULT:
    CrossEntropy/(NPoints*LN(2)).
    Zero if ensemble solves regression task.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpeavgce(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpeavgerror'></a><h3 class=pageheader><code>mlpeavgerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average error on the test set

INPUT PARAMETERS:
    Ensemble-   ensemble
    XY      -   test set
    NPoints -   test set size

RESULT:
    Its meaning for regression task is obvious. As for classification task
it means average error when estimating posterior probabilities.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpeavgerror(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpeavgrelerror'></a><h3 class=pageheader><code>mlpeavgrelerror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Average relative error on the test set

INPUT PARAMETERS:
    Ensemble-   ensemble
    XY      -   test set
    NPoints -   test set size

RESULT:
    Its meaning for regression task is obvious. As for classification task
it means average relative error when estimating posterior probabilities.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpeavgrelerror(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpecreate0'></a><h3 class=pageheader><code>mlpecreate0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreate0, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreate0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreate1'></a><h3 class=pageheader><code>mlpecreate1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreate1, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreate1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreate2'></a><h3 class=pageheader><code>mlpecreate2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreate2, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreate2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreateb0'></a><h3 class=pageheader><code>mlpecreateb0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateB0, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreateb0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> b,
    <font color=navy>double</font> d,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreateb1'></a><h3 class=pageheader><code>mlpecreateb1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateB1, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreateb1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> b,
    <font color=navy>double</font> d,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreateb2'></a><h3 class=pageheader><code>mlpecreateb2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateB2, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreateb2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> b,
    <font color=navy>double</font> d,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreatec0'></a><h3 class=pageheader><code>mlpecreatec0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateC0, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreatec0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreatec1'></a><h3 class=pageheader><code>mlpecreatec1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateC1, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreatec1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreatec2'></a><h3 class=pageheader><code>mlpecreatec2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateC2, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreatec2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreatefromnetwork'></a><h3 class=pageheader><code>mlpecreatefromnetwork</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creates ensemble from network. Only network geometry is copied.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreatefromnetwork(
    multilayerperceptron network,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreater0'></a><h3 class=pageheader><code>mlpecreater0</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateR0, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreater0(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreater1'></a><h3 class=pageheader><code>mlpecreater1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateR1, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreater1(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpecreater2'></a><h3 class=pageheader><code>mlpecreater2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Like MLPCreateR2, but for ensembles.

  -- ALGLIB --
     Copyright 18.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpecreater2(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nhid1,
    <font color=navy>int</font> nhid2,
    <font color=navy>int</font> nout,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>int</font> ensemblesize,
    <font color=navy>out</font> mlpensemble ensemble)

</div></pre>
<a name='sub_mlpeissoftmax'></a><h3 class=pageheader><code>mlpeissoftmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Return normalization type (whether ensemble is SOFTMAX-normalized or not).

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.mlpeissoftmax(mlpensemble ensemble)

</div></pre>
<a name='sub_mlpeprocess'></a><h3 class=pageheader><code>mlpeprocess</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Procesing

INPUT PARAMETERS:
    Ensemble-   neural networks ensemble
    X       -   input vector,  array[0..NIn-1].
    Y       -   (possibly) preallocated buffer; if size of Y is less than
                NOut, it will be reallocated. If it is large enough, it
                is NOT reallocated, so we can save some time on reallocation.


OUTPUT PARAMETERS:
    Y       -   result. Regression estimate when solving regression  task,
                vector of posterior probabilities for classification task.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpeprocess(
    mlpensemble ensemble,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_mlpeprocessi'></a><h3 class=pageheader><code>mlpeprocessi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
'interactive'  variant  of  MLPEProcess  for  languages  like Python which
support constructs like &quot;Y = MLPEProcess(LM,X)&quot; and interactive mode of the
interpreter

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpeprocessi(
    mlpensemble ensemble,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_mlpeproperties'></a><h3 class=pageheader><code>mlpeproperties</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Return ensemble properties (number of inputs and outputs).

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpeproperties(
    mlpensemble ensemble,
    <font color=navy>out</font> <font color=navy>int</font> nin,
    <font color=navy>out</font> <font color=navy>int</font> nout)

</div></pre>
<a name='sub_mlperandomize'></a><h3 class=pageheader><code>mlperandomize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Randomization of MLP ensemble

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlperandomize(mlpensemble ensemble)

</div></pre>
<a name='sub_mlperelclserror'></a><h3 class=pageheader><code>mlperelclserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Relative classification error on the test set

INPUT PARAMETERS:
    Ensemble-   ensemble
    XY      -   test set
    NPoints -   test set size

RESULT:
    percent of incorrectly classified cases.
    Works both for classifier betwork and for regression networks which
are used as classifiers.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlperelclserror(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpermserror'></a><h3 class=pageheader><code>mlpermserror</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RMS error on the test set

INPUT PARAMETERS:
    Ensemble-   ensemble
    XY      -   test set
    NPoints -   test set size

RESULT:
    root mean square error.
    Its meaning for regression task is obvious. As for classification task
RMS error means error when estimating posterior probabilities.

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.mlpermserror(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpeserialize'></a><h3 class=pageheader><code>mlpeserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function serializes data structure to string.

Important properties of s_out:
* it contains alphanumeric characters, dots, underscores, minus signs
* these symbols are grouped into words, which are separated by spaces
  and Windows-style (CR+LF) newlines
* although  serializer  uses  spaces and CR+LF as separators, you can 
  replace any separator character by arbitrary combination of spaces,
  tabs, Windows or Unix newlines. It allows flexible reformatting  of
  the  string  in  case you want to include it into text or XML file. 
  But you should not insert separators into the middle of the &quot;words&quot;
  nor you should change case of letters.
* s_out can be freely moved between 32-bit and 64-bit systems, little
  and big endian machines, and so on. You can serialize structure  on
  32-bit machine and unserialize it on 64-bit one (or vice versa), or
  serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
  serialize  it  in  C++ version of ALGLIB and unserialize in C# one, 
  and vice versa.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> mlpeserialize(mlpensemble obj, <font color=navy>out</font> string s_out)

</div></pre>
<a name='sub_mlpeunserialize'></a><h3 class=pageheader><code>mlpeunserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function unserializes data structure from string.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> mlpeunserialize(string s_in, <font color=navy>out</font> mlpensemble obj)

</div></pre>
<a name=unit_mlptrain></a><h2 class=pageheader><code>mlptrain</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mlpcvreport' class=toc>mlpcvreport</a><br>
<a href='#struct_mlpreport' class=toc>mlpreport</a><br>
<a href='#struct_mlptrainer' class=toc>mlptrainer</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mlpcontinuetraining' class=toc>mlpcontinuetraining</a><br>
<a href='#sub_mlpcreatetrainer' class=toc>mlpcreatetrainer</a><br>
<a href='#sub_mlpcreatetrainercls' class=toc>mlpcreatetrainercls</a><br>
<a href='#sub_mlpebagginglbfgs' class=toc>mlpebagginglbfgs</a><br>
<a href='#sub_mlpebagginglm' class=toc>mlpebagginglm</a><br>
<a href='#sub_mlpetraines' class=toc>mlpetraines</a><br>
<a href='#sub_mlpkfoldcv' class=toc>mlpkfoldcv</a><br>
<a href='#sub_mlpkfoldcvlbfgs' class=toc>mlpkfoldcvlbfgs</a><br>
<a href='#sub_mlpkfoldcvlm' class=toc>mlpkfoldcvlm</a><br>
<a href='#sub_mlpsetalgobatch' class=toc>mlpsetalgobatch</a><br>
<a href='#sub_mlpsetcond' class=toc>mlpsetcond</a><br>
<a href='#sub_mlpsetdataset' class=toc>mlpsetdataset</a><br>
<a href='#sub_mlpsetdecay' class=toc>mlpsetdecay</a><br>
<a href='#sub_mlpsetsparsedataset' class=toc>mlpsetsparsedataset</a><br>
<a href='#sub_mlpstarttraining' class=toc>mlpstarttraining</a><br>
<a href='#sub_mlptrainensemblees' class=toc>mlptrainensemblees</a><br>
<a href='#sub_mlptraines' class=toc>mlptraines</a><br>
<a href='#sub_mlptrainlbfgs' class=toc>mlptrainlbfgs</a><br>
<a href='#sub_mlptrainlm' class=toc>mlptrainlm</a><br>
<a href='#sub_mlptrainnetwork' class=toc>mlptrainnetwork</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_nn_cls2' class=toc>nn_cls2</a></td><td width=15>&nbsp;</td><td>Binary classification problem</td></tr>
<tr align=left valign=top><td><a href='#example_nn_cls3' class=toc>nn_cls3</a></td><td width=15>&nbsp;</td><td>Multiclass classification problem</td></tr>
<tr align=left valign=top><td><a href='#example_nn_crossvalidation' class=toc>nn_crossvalidation</a></td><td width=15>&nbsp;</td><td>Cross-validation</td></tr>
<tr align=left valign=top><td><a href='#example_nn_ensembles_es' class=toc>nn_ensembles_es</a></td><td width=15>&nbsp;</td><td>Early stopping ensembles</td></tr>
<tr align=left valign=top><td><a href='#example_nn_parallel' class=toc>nn_parallel</a></td><td width=15>&nbsp;</td><td>Parallel training</td></tr>
<tr align=left valign=top><td><a href='#example_nn_regr' class=toc>nn_regr</a></td><td width=15>&nbsp;</td><td>Regression problem with one output (2=>1)</td></tr>
<tr align=left valign=top><td><a href='#example_nn_regr_n' class=toc>nn_regr_n</a></td><td width=15>&nbsp;</td><td>Regression problem with multiple outputs (2=>2)</td></tr>
<tr align=left valign=top><td><a href='#example_nn_trainerobject' class=toc>nn_trainerobject</a></td><td width=15>&nbsp;</td><td>Advanced example on trainer object</td></tr>
</table></div>
<a name='struct_mlpcvreport'></a><h3 class=pageheader><code>mlpcvreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cross-validation estimates of generalization error
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mlpcvreport
{
    <font color=navy>public</font> <font color=navy>double</font>               relclserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgce;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
}

</div></pre>
<a name='struct_mlpreport'></a><h3 class=pageheader><code>mlpreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Training report:
    * RelCLSError   -   fraction of misclassified cases.
    * AvgCE         -   acerage cross-entropy
    * RMSError      -   root-mean-square error
    * AvgError      -   average error
    * AvgRelError   -   average relative error
    * NGrad         -   number of gradient calculations
    * NHess         -   number of Hessian calculations
    * NCholesky     -   number of Cholesky decompositions

NOTE 1: RelCLSError/AvgCE are zero on regression problems.

NOTE 2: on classification problems  RMSError/AvgError/AvgRelError  contain
        errors in prediction of posterior probabilities
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mlpreport
{
    <font color=navy>public</font> <font color=navy>double</font>               relclserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgce;
    <font color=navy>public</font> <font color=navy>double</font>               rmserror;
    <font color=navy>public</font> <font color=navy>double</font>               avgerror;
    <font color=navy>public</font> <font color=navy>double</font>               avgrelerror;
    <font color=navy>public</font> <font color=navy>int</font>                  ngrad;
    <font color=navy>public</font> <font color=navy>int</font>                  nhess;
    <font color=navy>public</font> <font color=navy>int</font>                  ncholesky;
}

</div></pre>
<a name='struct_mlptrainer'></a><h3 class=pageheader><code>mlptrainer</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Trainer object for neural network.

You should not try to access fields of this object directly -  use  ALGLIB
functions to work with this object.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class mlptrainer
{
}

</div></pre>
<a name='sub_mlpcontinuetraining'></a><h3 class=pageheader><code>mlpcontinuetraining</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IMPORTANT: this is an &quot;expert&quot; version of the MLPTrain() function.  We  do
           not recommend you to use it unless you are pretty sure that you
           need ability to monitor training progress.

FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support (C++ computational core)
  !
  ! Second improvement gives constant  speedup (2-3X).  First  improvement
  ! gives  close-to-linear  speedup  on   multicore   systems.   Following
  ! operations can be executed in parallel:
  ! * gradient calculation over large dataset (if dataset is large enough)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.

This function performs step-by-step training of the neural  network.  Here
&quot;step-by-step&quot; means that training starts  with  MLPStartTraining()  call,
and then user subsequently calls MLPContinueTraining() to perform one more
iteration of the training.

This  function  performs  one  more  iteration of the training and returns
either True (training continues) or False (training stopped). In case True
was returned, Network weights are updated according to the  current  state
of the optimization progress. In case False was  returned,  no  additional
updates is performed (previous update of  the  network weights moved us to
the final point, and no additional updates is needed).

EXAMPLE:
    &gt;
    &gt; [initialize network and trainer object]
    &gt;
    &gt; MLPStartTraining(Trainer, Network, True)
    &gt; while MLPContinueTraining(Trainer, Network) do
    &gt;     [visualize training progress]
    &gt;

INPUT PARAMETERS:
    S           -   trainer object
    Network     -   neural  network  structure,  which  is  used to  store
                    current state of the training process.

OUTPUT PARAMETERS:
    Network     -   weights of the neural network  are  rewritten  by  the
                    current approximation.

NOTE: this method uses sum-of-squares error function for training.

NOTE: it is expected that trainer object settings are NOT  changed  during
      step-by-step training, i.e. no  one  changes  stopping  criteria  or
      training set during training. It is possible and there is no defense
      against  such  actions,  but  algorithm  behavior  in  such cases is
      undefined and can be unpredictable.

NOTE: It  is  expected that Network is the same one which  was  passed  to
      MLPStartTraining() function.  However,  THIS  function  checks  only
      following:
      * that number of network inputs is consistent with trainer object
        settings
      * that number of network outputs/classes is consistent with  trainer
        object settings
      * that number of network weights is the same as number of weights in
        the network passed to MLPStartTraining() function
      Exception is thrown when these conditions are violated.

      It is also expected that you do not change state of the  network  on
      your own - the only party who has right to change network during its
      training is a trainer object. Any attempt to interfere with  trainer
      may lead to unpredictable results.


  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.mlpcontinuetraining(
    mlptrainer s,
    multilayerperceptron network)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smp_mlpcontinuetraining(
    mlptrainer s,
    multilayerperceptron network)

</div></pre>
<a name='sub_mlpcreatetrainer'></a><h3 class=pageheader><code>mlpcreatetrainer</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creation of the network trainer object for regression networks

INPUT PARAMETERS:
    NIn         -   number of inputs, NIn&gt;=1
    NOut        -   number of outputs, NOut&gt;=1

OUTPUT PARAMETERS:
    S           -   neural network trainer object.
                    This structure can be used to train any regression
                    network with NIn inputs and NOut outputs.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreatetrainer(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nout,
    <font color=navy>out</font> mlptrainer s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nn_regr' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nn_regr_n' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_nn_trainerobject' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_nn_crossvalidation' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_nn_ensembles_es' class=nav>[5]</a>&nbsp;&nbsp;<a href='#example_nn_parallel' class=nav>[6]</a>&nbsp;&nbsp;</p>
<a name='sub_mlpcreatetrainercls'></a><h3 class=pageheader><code>mlpcreatetrainercls</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Creation of the network trainer object for classification networks

INPUT PARAMETERS:
    NIn         -   number of inputs, NIn&gt;=1
    NClasses    -   number of classes, NClasses&gt;=2

OUTPUT PARAMETERS:
    S           -   neural network trainer object.
                    This structure can be used to train any classification
                    network with NIn inputs and NOut outputs.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpcreatetrainercls(
    <font color=navy>int</font> nin,
    <font color=navy>int</font> nclasses,
    <font color=navy>out</font> mlptrainer s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nn_cls2' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nn_cls3' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mlpebagginglbfgs'></a><h3 class=pageheader><code>mlpebagginglbfgs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Training neural networks ensemble using  bootstrap  aggregating (bagging).
L-BFGS algorithm is used as base training method.

INPUT PARAMETERS:
    Ensemble    -   model with initialized geometry
    XY          -   training set
    NPoints     -   training set size
    Decay       -   weight decay coefficient, &gt;=0.001
    Restarts    -   restarts, &gt;0.
    WStep       -   stopping criterion, same as in MLPTrainLBFGS
    MaxIts      -   stopping criterion, same as in MLPTrainLBFGS

OUTPUT PARAMETERS:
    Ensemble    -   trained model
    Info        -   return code:
                    * -8, if both WStep=0 and MaxIts=0
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed
                          (NPoints&lt;0, Restarts&lt;1).
                    *  2, if task has been solved.
    Rep         -   training report.
    OOBErrors   -   out-of-bag generalization error estimate

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpebagginglbfgs(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>double</font> wstep,
    <font color=navy>int</font> maxits,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep,
    <font color=navy>out</font> mlpcvreport ooberrors)

</div></pre>
<a name='sub_mlpebagginglm'></a><h3 class=pageheader><code>mlpebagginglm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Training neural networks ensemble using  bootstrap  aggregating (bagging).
Modified Levenberg-Marquardt algorithm is used as base training method.

INPUT PARAMETERS:
    Ensemble    -   model with initialized geometry
    XY          -   training set
    NPoints     -   training set size
    Decay       -   weight decay coefficient, &gt;=0.001
    Restarts    -   restarts, &gt;0.

OUTPUT PARAMETERS:
    Ensemble    -   trained model
    Info        -   return code:
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed
                          (NPoints&lt;0, Restarts&lt;1).
                    *  2, if task has been solved.
    Rep         -   training report.
    OOBErrors   -   out-of-bag generalization error estimate

  -- ALGLIB --
     Copyright 17.02.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpebagginglm(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep,
    <font color=navy>out</font> mlpcvreport ooberrors)

</div></pre>
<a name='sub_mlpetraines'></a><h3 class=pageheader><code>mlpetraines</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Training neural networks ensemble using early stopping.

INPUT PARAMETERS:
    Ensemble    -   model with initialized geometry
    XY          -   training set
    NPoints     -   training set size
    Decay       -   weight decay coefficient, &gt;=0.001
    Restarts    -   restarts, &gt;0.

OUTPUT PARAMETERS:
    Ensemble    -   trained model
    Info        -   return code:
                    * -2, if there is a point with class number
                          outside of [0..NClasses-1].
                    * -1, if incorrect parameters was passed
                          (NPoints&lt;0, Restarts&lt;1).
                    *  6, if task has been solved.
    Rep         -   training report.
    OOBErrors   -   out-of-bag generalization error estimate

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpetraines(
    mlpensemble ensemble,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<a name='sub_mlpkfoldcv'></a><h3 class=pageheader><code>mlpkfoldcv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function estimates generalization error using cross-validation on the
current dataset with current training settings.

FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support (C++ computational core)
  !
  ! Second improvement gives constant  speedup (2-3X).  First  improvement
  ! gives  close-to-linear  speedup  on   multicore   systems.   Following
  ! operations can be executed in parallel:
  ! * FoldsCount cross-validation rounds (always)
  ! * NRestarts training sessions performed within each of
  !   cross-validation rounds (if NRestarts&gt;1)
  ! * gradient calculation over large dataset (if dataset is large enough)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.

INPUT PARAMETERS:
    S           -   trainer object
    Network     -   neural network. It must have same number of inputs and
                    output/classes as was specified during creation of the
                    trainer object. Network is not changed  during  cross-
                    validation and is not trained - it  is  used  only  as
                    representative of its architecture. I.e., we  estimate
                    generalization properties of  ARCHITECTURE,  not  some
                    specific network.
    NRestarts   -   number of restarts, &gt;=0:
                    * NRestarts&gt;0  means  that  for  each cross-validation
                      round   specified  number   of  random  restarts  is
                      performed,  with  best  network  being  chosen after
                      training.
                    * NRestarts=0 is same as NRestarts=1
    FoldsCount  -   number of folds in k-fold cross-validation:
                    * 2&lt;=FoldsCount&lt;=size of dataset
                    * recommended value: 10.
                    * values larger than dataset size will be silently
                      truncated down to dataset size

OUTPUT PARAMETERS:
    Rep         -   structure which contains cross-validation estimates:
                    * Rep.RelCLSError - fraction of misclassified cases.
                    * Rep.AvgCE - acerage cross-entropy
                    * Rep.RMSError - root-mean-square error
                    * Rep.AvgError - average error
                    * Rep.AvgRelError - average relative error

NOTE: when no dataset was specified with MLPSetDataset/SetSparseDataset(),
      or subset with only one point  was  given,  zeros  are  returned  as
      estimates.

NOTE: this method performs FoldsCount cross-validation  rounds,  each  one
      with NRestarts random starts.  Thus,  FoldsCount*NRestarts  networks
      are trained in total.

NOTE: Rep.RelCLSError/Rep.AvgCE are zero on regression problems.

NOTE: on classification problems Rep.RMSError/Rep.AvgError/Rep.AvgRelError
      contain errors in prediction of posterior probabilities.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpkfoldcv(
    mlptrainer s,
    multilayerperceptron network,
    <font color=navy>int</font> nrestarts,
    <font color=navy>int</font> foldscount,
    <font color=navy>out</font> mlpreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlpkfoldcv(
    mlptrainer s,
    multilayerperceptron network,
    <font color=navy>int</font> nrestarts,
    <font color=navy>int</font> foldscount,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nn_crossvalidation' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nn_parallel' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mlpkfoldcvlbfgs'></a><h3 class=pageheader><code>mlpkfoldcvlbfgs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cross-validation estimate of generalization error.

Base algorithm - L-BFGS.

INPUT PARAMETERS:
    Network     -   neural network with initialized geometry.   Network is
                    not changed during cross-validation -  it is used only
                    as a representative of its architecture.
    XY          -   training set.
    SSize       -   training set size
    Decay       -   weight  decay, same as in MLPTrainLBFGS
    Restarts    -   number of restarts, &gt;0.
                    restarts are counted for each partition separately, so
                    total number of restarts will be Restarts*FoldsCount.
    WStep       -   stopping criterion, same as in MLPTrainLBFGS
    MaxIts      -   stopping criterion, same as in MLPTrainLBFGS
    FoldsCount  -   number of folds in k-fold cross-validation,
                    2&lt;=FoldsCount&lt;=SSize.
                    recommended value: 10.

OUTPUT PARAMETERS:
    Info        -   return code, same as in MLPTrainLBFGS
    Rep         -   report, same as in MLPTrainLM/MLPTrainLBFGS
    CVRep       -   generalization error estimates

  -- ALGLIB --
     Copyright 09.12.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpkfoldcvlbfgs(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>double</font> wstep,
    <font color=navy>int</font> maxits,
    <font color=navy>int</font> foldscount,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep,
    <font color=navy>out</font> mlpcvreport cvrep)

</div></pre>
<a name='sub_mlpkfoldcvlm'></a><h3 class=pageheader><code>mlpkfoldcvlm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cross-validation estimate of generalization error.

Base algorithm - Levenberg-Marquardt.

INPUT PARAMETERS:
    Network     -   neural network with initialized geometry.   Network is
                    not changed during cross-validation -  it is used only
                    as a representative of its architecture.
    XY          -   training set.
    SSize       -   training set size
    Decay       -   weight  decay, same as in MLPTrainLBFGS
    Restarts    -   number of restarts, &gt;0.
                    restarts are counted for each partition separately, so
                    total number of restarts will be Restarts*FoldsCount.
    FoldsCount  -   number of folds in k-fold cross-validation,
                    2&lt;=FoldsCount&lt;=SSize.
                    recommended value: 10.

OUTPUT PARAMETERS:
    Info        -   return code, same as in MLPTrainLBFGS
    Rep         -   report, same as in MLPTrainLM/MLPTrainLBFGS
    CVRep       -   generalization error estimates

  -- ALGLIB --
     Copyright 09.12.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpkfoldcvlm(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>int</font> foldscount,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep,
    <font color=navy>out</font> mlpcvreport cvrep)

</div></pre>
<a name='sub_mlpsetalgobatch'></a><h3 class=pageheader><code>mlpsetalgobatch</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets training algorithm: batch training using L-BFGS will be
used.

This algorithm:
* the most robust for small-scale problems, but may be too slow for  large
  scale ones.
* perfoms full pass through the dataset before performing step
* uses conditions specified by MLPSetCond() for stopping
* is default one used by trainer object

INPUT PARAMETERS:
    S           -   trainer object

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetalgobatch(mlptrainer s)

</div></pre>
<a name='sub_mlpsetcond'></a><h3 class=pageheader><code>mlpsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping criteria for the optimizer.

INPUT PARAMETERS:
    S           -   trainer object
    WStep       -   stopping criterion. Algorithm stops if  step  size  is
                    less than WStep. Recommended value - 0.01.  Zero  step
                    size means stopping after MaxIts iterations.
                    WStep&gt;=0.
    MaxIts      -   stopping   criterion.  Algorithm  stops  after  MaxIts
                    epochs (full passes over entire dataset).  Zero MaxIts
                    means stopping when step is sufficiently small.
                    MaxIts&gt;=0.

NOTE: by default, WStep=0.005 and MaxIts=0 are used. These values are also
      used when MLPSetCond() is called with WStep=0 and MaxIts=0.

NOTE: these stopping criteria are used for all kinds of neural training  -
      from &quot;conventional&quot; networks to early stopping ensembles. When  used
      for &quot;conventional&quot; networks, they are  used  as  the  only  stopping
      criteria. When combined with early stopping, they used as ADDITIONAL
      stopping criteria which can terminate early stopping algorithm.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetcond(
    mlptrainer s,
    <font color=navy>double</font> wstep,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_mlpsetdataset'></a><h3 class=pageheader><code>mlpsetdataset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets &quot;current dataset&quot; of the trainer object to  one  passed
by user.

INPUT PARAMETERS:
    S           -   trainer object
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed.
    NPoints     -   points count, &gt;=0.

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
datasetformat is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetdataset(
    mlptrainer s,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nn_regr' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nn_regr_n' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_nn_cls2' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_nn_cls3' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_nn_trainerobject' class=nav>[5]</a>&nbsp;&nbsp;<a href='#example_nn_crossvalidation' class=nav>[6]</a>&nbsp;&nbsp;<a href='#example_nn_ensembles_es' class=nav>[7]</a>&nbsp;&nbsp;<a href='#example_nn_parallel' class=nav>[8]</a>&nbsp;&nbsp;</p>
<a name='sub_mlpsetdecay'></a><h3 class=pageheader><code>mlpsetdecay</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets weight decay coefficient which is used for training.

INPUT PARAMETERS:
    S           -   trainer object
    Decay       -   weight  decay  coefficient,  &gt;=0.  Weight  decay  term
                    'Decay*||Weights||^2' is added to error  function.  If
                    you don't know what Decay to choose, use 1.0E-3.
                    Weight decay can be set to zero,  in this case network
                    is trained without weight decay.

NOTE: by default network uses some small nonzero value for weight decay.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetdecay(mlptrainer s, <font color=navy>double</font> decay)

</div></pre>
<a name='sub_mlpsetsparsedataset'></a><h3 class=pageheader><code>mlpsetsparsedataset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets &quot;current dataset&quot; of the trainer object to  one  passed
by user (sparse matrix is used to store dataset).

INPUT PARAMETERS:
    S           -   trainer object
    XY          -   training  set,  see  below  for  information  on   the
                    training set format. This function checks  correctness
                    of  the  dataset  (no  NANs/INFs,  class  numbers  are
                    correct) and throws exception when  incorrect  dataset
                    is passed. Any  sparse  storage  format  can be  used:
                    Hash-table, CRS...
    NPoints     -   points count, &gt;=0

DATASET FORMAT:

This  function  uses  two  different  dataset formats - one for regression
networks, another one for classification networks.

For regression networks with NIn inputs and NOut outputs following dataset
format is used:
* dataset is given by NPoints*(NIn+NOut) matrix
* each row corresponds to one example
* first NIn columns are inputs, next NOut columns are outputs

For classification networks with NIn inputs and NClasses clases  following
datasetformat is used:
* dataset is given by NPoints*(NIn+1) matrix
* each row corresponds to one example
* first NIn columns are inputs, last column stores class number (from 0 to
  NClasses-1).

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpsetsparsedataset(
    mlptrainer s,
    sparsematrix xy,
    <font color=navy>int</font> npoints)

</div></pre>
<a name='sub_mlpstarttraining'></a><h3 class=pageheader><code>mlpstarttraining</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IMPORTANT: this is an &quot;expert&quot; version of the MLPTrain() function.  We  do
           not recommend you to use it unless you are pretty sure that you
           need ability to monitor training progress.

This function performs step-by-step training of the neural  network.  Here
&quot;step-by-step&quot; means that training  starts  with  MLPStartTraining() call,
and then user subsequently calls MLPContinueTraining() to perform one more
iteration of the training.

After call to this function trainer object remembers network and  is ready
to  train  it.  However,  no  training  is  performed  until first call to
MLPContinueTraining() function. Subsequent calls  to MLPContinueTraining()
will advance training progress one iteration further.

EXAMPLE:
    &gt;
    &gt; ...initialize network and trainer object....
    &gt;
    &gt; MLPStartTraining(Trainer, Network, True)
    &gt; while MLPContinueTraining(Trainer, Network) do
    &gt;     ...visualize training progress...
    &gt;

INPUT PARAMETERS:
    S           -   trainer object
    Network     -   neural network. It must have same number of inputs and
                    output/classes as was specified during creation of the
                    trainer object.
    RandomStart -   randomize network before training or not:
                    * True  means  that  network  is  randomized  and  its
                      initial state (one which was passed to  the  trainer
                      object) is lost.
                    * False  means  that  training  is  started  from  the
                      current state of the network

OUTPUT PARAMETERS:
    Network     -   neural network which is ready to training (weights are
                    initialized, preprocessor is initialized using current
                    training set)

NOTE: this method uses sum-of-squares error function for training.

NOTE: it is expected that trainer object settings are NOT  changed  during
      step-by-step training, i.e. no  one  changes  stopping  criteria  or
      training set during training. It is possible and there is no defense
      against  such  actions,  but  algorithm  behavior  in  such cases is
      undefined and can be unpredictable.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlpstarttraining(
    mlptrainer s,
    multilayerperceptron network,
    <font color=navy>bool</font> randomstart)

</div></pre>
<a name='sub_mlptrainensemblees'></a><h3 class=pageheader><code>mlptrainensemblees</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function trains neural network ensemble passed to this function using
current dataset and early stopping training algorithm. Each early stopping
round performs NRestarts  random  restarts  (thus,  EnsembleSize*NRestarts
training rounds is performed in total).

FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support (C++ computational core)
  !
  ! Second improvement gives constant  speedup (2-3X).  First  improvement
  ! gives  close-to-linear  speedup  on   multicore   systems.   Following
  ! operations can be executed in parallel:
  ! * EnsembleSize  training  sessions  performed  for  each  of  ensemble
  !   members (always parallelized)
  ! * NRestarts  training  sessions  performed  within  each  of  training
  !   sessions (if NRestarts&gt;1)
  ! * gradient calculation over large dataset (if dataset is large enough)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.

INPUT PARAMETERS:
    S           -   trainer object;
    Ensemble    -   neural network ensemble. It must have same  number  of
                    inputs and outputs/classes  as  was  specified  during
                    creation of the trainer object.
    NRestarts   -   number of restarts, &gt;=0:
                    * NRestarts&gt;0 means that specified  number  of  random
                      restarts are performed during each ES round;
                    * NRestarts=0 is silently replaced by 1.

OUTPUT PARAMETERS:
    Ensemble    -   trained ensemble;
    Rep         -   it contains all type of errors.

NOTE: this training method uses BOTH early stopping and weight decay!  So,
      you should select weight decay before starting training just as  you
      select it before training &quot;conventional&quot; networks.

NOTE: when no dataset was specified with MLPSetDataset/SetSparseDataset(),
      or  single-point  dataset  was  passed,  ensemble  is filled by zero
      values.

NOTE: this method uses sum-of-squares error function for training.

  -- ALGLIB --
     Copyright 22.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlptrainensemblees(
    mlptrainer s,
    mlpensemble ensemble,
    <font color=navy>int</font> nrestarts,
    <font color=navy>out</font> mlpreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlptrainensemblees(
    mlptrainer s,
    mlpensemble ensemble,
    <font color=navy>int</font> nrestarts,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nn_ensembles_es' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nn_parallel' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mlptraines'></a><h3 class=pageheader><code>mlptraines</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Neural network training using early stopping (base algorithm - L-BFGS with
regularization).

INPUT PARAMETERS:
    Network     -   neural network with initialized geometry
    TrnXY       -   training set
    TrnSize     -   training set size, TrnSize&gt;0
    ValXY       -   validation set
    ValSize     -   validation set size, ValSize&gt;0
    Decay       -   weight decay constant, &gt;=0.001
                    Decay term 'Decay*||Weights||^2' is added to error
                    function.
                    If you don't know what Decay to choose, use 0.001.
    Restarts    -   number of restarts, either:
                    * strictly positive number - algorithm make specified
                      number of restarts from random position.
                    * -1, in which case algorithm makes exactly one run
                      from the initial state of the network (no randomization).
                    If you don't know what Restarts to choose, choose one
                    one the following:
                    * -1 (deterministic start)
                    * +1 (one random restart)
                    * +5 (moderate amount of random restarts)

OUTPUT PARAMETERS:
    Network     -   trained neural network.
    Info        -   return code:
                    * -2, if there is a point with class number
                          outside of [0..NOut-1].
                    * -1, if wrong parameters specified
                          (NPoints&lt;0, Restarts&lt;1, ...).
                    *  2, task has been solved, stopping  criterion  met -
                          sufficiently small step size.  Not expected  (we
                          use  EARLY  stopping)  but  possible  and not an
                          error.
                    *  6, task has been solved, stopping  criterion  met -
                          increasing of validation set error.
    Rep         -   training report

NOTE:

Algorithm stops if validation set error increases for  a  long  enough  or
step size is small enought  (there  are  task  where  validation  set  may
decrease for eternity). In any case solution returned corresponds  to  the
minimum of validation set error.

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlptraines(
    multilayerperceptron network,
    <font color=navy>double</font>[,] trnxy,
    <font color=navy>int</font> trnsize,
    <font color=navy>double</font>[,] valxy,
    <font color=navy>int</font> valsize,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<a name='sub_mlptrainlbfgs'></a><h3 class=pageheader><code>mlptrainlbfgs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Neural  network  training  using  L-BFGS  algorithm  with  regularization.
Subroutine  trains  neural  network  with  restarts from random positions.
Algorithm  is  well  suited  for  problems  of  any dimensionality (memory
requirements and step complexity are linear by weights number).

INPUT PARAMETERS:
    Network     -   neural network with initialized geometry
    XY          -   training set
    NPoints     -   training set size
    Decay       -   weight decay constant, &gt;=0.001
                    Decay term 'Decay*||Weights||^2' is added to error
                    function.
                    If you don't know what Decay to choose, use 0.001.
    Restarts    -   number of restarts from random position, &gt;0.
                    If you don't know what Restarts to choose, use 2.
    WStep       -   stopping criterion. Algorithm stops if  step  size  is
                    less than WStep. Recommended value - 0.01.  Zero  step
                    size means stopping after MaxIts iterations.
    MaxIts      -   stopping   criterion.  Algorithm  stops  after  MaxIts
                    iterations (NOT gradient  calculations).  Zero  MaxIts
                    means stopping when step is sufficiently small.

OUTPUT PARAMETERS:
    Network     -   trained neural network.
    Info        -   return code:
                    * -8, if both WStep=0 and MaxIts=0
                    * -2, if there is a point with class number
                          outside of [0..NOut-1].
                    * -1, if wrong parameters specified
                          (NPoints&lt;0, Restarts&lt;1).
                    *  2, if task has been solved.
    Rep         -   training report

  -- ALGLIB --
     Copyright 09.12.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlptrainlbfgs(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>double</font> wstep,
    <font color=navy>int</font> maxits,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<a name='sub_mlptrainlm'></a><h3 class=pageheader><code>mlptrainlm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Neural network training  using  modified  Levenberg-Marquardt  with  exact
Hessian calculation and regularization. Subroutine trains  neural  network
with restarts from random positions. Algorithm is well  suited  for  small
and medium scale problems (hundreds of weights).

INPUT PARAMETERS:
    Network     -   neural network with initialized geometry
    XY          -   training set
    NPoints     -   training set size
    Decay       -   weight decay constant, &gt;=0.001
                    Decay term 'Decay*||Weights||^2' is added to error
                    function.
                    If you don't know what Decay to choose, use 0.001.
    Restarts    -   number of restarts from random position, &gt;0.
                    If you don't know what Restarts to choose, use 2.

OUTPUT PARAMETERS:
    Network     -   trained neural network.
    Info        -   return code:
                    * -9, if internal matrix inverse subroutine failed
                    * -2, if there is a point with class number
                          outside of [0..NOut-1].
                    * -1, if wrong parameters specified
                          (NPoints&lt;0, Restarts&lt;1).
                    *  2, if task has been solved.
    Rep         -   training report

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlptrainlm(
    multilayerperceptron network,
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> npoints,
    <font color=navy>double</font> decay,
    <font color=navy>int</font> restarts,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<a name='sub_mlptrainnetwork'></a><h3 class=pageheader><code>mlptrainnetwork</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function trains neural network passed to this function, using current
dataset (one which was passed to MLPSetDataset() or MLPSetSparseDataset())
and current training settings. Training  from  NRestarts  random  starting
positions is performed, best network is chosen.

Training is performed using current training algorithm.

FOR USERS OF COMMERCIAL EDITION:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function:
  ! * multicore support (C++ and C# computational cores)
  ! * SSE support (C++ computational core)
  !
  ! Second improvement gives constant  speedup (2-3X).  First  improvement
  ! gives  close-to-linear  speedup  on   multicore   systems.   Following
  ! operations can be executed in parallel:
  ! * NRestarts training sessions performed within each of
  !   cross-validation rounds (if NRestarts&gt;1)
  ! * gradient calculation over large dataset (if dataset is large enough)
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! In order to use SSE features you have to:
  ! * use commercial version of ALGLIB on Intel processors
  ! * use C++ computational core
  !
  ! This note is given for users of commercial edition; if  you  use  GPL
  ! edition, you still will be able to call smp-version of this function,
  ! but all computations will be done serially.
  !
  ! We recommend you to carefully read ALGLIB Reference  Manual,  section
  ! called 'SMP support', before using parallel version of this function.

INPUT PARAMETERS:
    S           -   trainer object
    Network     -   neural network. It must have same number of inputs and
                    output/classes as was specified during creation of the
                    trainer object.
    NRestarts   -   number of restarts, &gt;=0:
                    * NRestarts&gt;0 means that specified  number  of  random
                      restarts are performed, best network is chosen after
                      training
                    * NRestarts=0 means that current state of the  network
                      is used for training.

OUTPUT PARAMETERS:
    Network     -   trained network

NOTE: when no dataset was specified with MLPSetDataset/SetSparseDataset(),
      network  is  filled  by zero  values.  Same  behavior  for functions
      MLPStartTraining and MLPContinueTraining.

NOTE: this method uses sum-of-squares error function for training.

  -- ALGLIB --
     Copyright 23.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.mlptrainnetwork(
    mlptrainer s,
    multilayerperceptron network,
    <font color=navy>int</font> nrestarts,
    <font color=navy>out</font> mlpreport rep)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_mlptrainnetwork(
    mlptrainer s,
    multilayerperceptron network,
    <font color=navy>int</font> nrestarts,
    <font color=navy>out</font> mlpreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nn_regr' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nn_regr_n' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_nn_cls2' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_nn_cls3' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_nn_trainerobject' class=nav>[5]</a>&nbsp;&nbsp;<a href='#example_nn_parallel' class=nav>[6]</a>&nbsp;&nbsp;</p>
<a name='example_nn_cls2'></a><h3 class=pageheader>nn_cls2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Suppose that we want to classify numbers as positive (class 0) and negative</font>
    <font color=green>// (class 1). We have training set which includes several strictly positive</font>
    <font color=green>// or negative numbers - and zero.</font>
    <font color=green>//</font>
    <font color=green>// The problem is that we are not sure how to classify zero, so from time to</font>
    <font color=green>// time we mark it as positive or negative (with equal probability). Other</font>
    <font color=green>// numbers are marked in pure deterministic setting. How will neural network</font>
    <font color=green>// cope with such classification task?</font>
    <font color=green>//</font>
    <font color=green>// NOTE: we use network with excessive amount of neurons, which guarantees</font>
    <font color=green>//       almost exact reproduction of the training set. Generalization ability</font>
    <font color=green>//       of such network is rather low, but we are not concerned with such</font>
    <font color=green>//       questions in this basic demo.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.multilayerperceptron network;
    alglib.mlpreport rep;
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0,0};

    <font color=green>//</font>
    <font color=green>// Training set. One row corresponds to one record [A =&gt; class(A)].</font>
    <font color=green>//</font>
    <font color=green>// Classes are denoted by numbers from 0 to 1, where 0 corresponds to positive</font>
    <font color=green>// numbers and 1 to negative numbers.</font>
    <font color=green>//</font>
    <font color=green>// [ +1  0]</font>
    <font color=green>// [ +2  0]</font>
    <font color=green>// [ -1  1]</font>
    <font color=green>// [ -2  1]</font>
    <font color=green>// [  0  0]   !! sometimes we classify 0 as positive, sometimes as negative</font>
    <font color=green>// [  0  1]   !!</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{+1,0},{+2,0},{-1,1},{-2,1},{0,0},{0,1}};

    <font color=green>//</font>
    <font color=green>//</font>
    <font color=green>// When we solve classification problems, everything is slightly different from</font>
    <font color=green>// the regression ones:</font>
    <font color=green>//</font>
    <font color=green>// 1. Network is created. Because we solve classification problem, we use</font>
    <font color=green>//    mlpcreatec1() function instead of mlpcreate1(). This function creates</font>
    <font color=green>//    classifier network with SOFTMAX-normalized outputs. This network returns</font>
    <font color=green>//    vector of class membership probabilities which are normalized to be</font>
    <font color=green>//    non-negative and sum to 1.0</font>
    <font color=green>//</font>
    <font color=green>// 2. We use mlpcreatetrainercls() function instead of mlpcreatetrainer() to</font>
    <font color=green>//    create trainer object. Trainer object process dataset and neural network</font>
    <font color=green>//    slightly differently to account <font color=navy>for</font> specifics of the classification</font>
    <font color=green>//    problems.</font>
    <font color=green>//</font>
    <font color=green>// 3. Dataset is attached to trainer object. Note that dataset format is slightly</font>
    <font color=green>//    different from one used <font color=navy>for</font> regression.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainercls(1, 2, <font color=navy>out</font> trn);
    alglib.mlpcreatec1(1, 5, 2, <font color=navy>out</font> network);
    alglib.mlpsetdataset(trn, xy, 6);

    <font color=green>//</font>
    <font color=green>// Network is trained with 5 restarts from random positions</font>
    <font color=green>//</font>
    alglib.mlptrainnetwork(trn, network, 5, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Test our neural network on strictly positive and strictly negative numbers.</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT! Classifier network returns class membership probabilities instead</font>
    <font color=green>// of class indexes. Network returns two values (probabilities) instead of one</font>
    <font color=green>// (class index).</font>
    <font color=green>//</font>
    <font color=green>// Thus, <font color=navy>for</font> +1 we expect to get [P0,P1] = [1,0], where P0 is probability that</font>
    <font color=green>// number is positive (belongs to class 0), and P1 is probability that number</font>
    <font color=green>// is negative (belongs to class 1).</font>
    <font color=green>//</font>
    <font color=green>// For -1 we expect to get [P0,P1] = [0,1]</font>
    <font color=green>//</font>
    <font color=green>// Following properties are guaranteed by network architecture:</font>
    <font color=green>// * P0&gt;=0, P1&gt;=0   non-negativity</font>
    <font color=green>// * P0+P1=1        normalization</font>
    <font color=green>//</font>
    x = new <font color=navy>double</font>[]{1};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [1.000,0.000]</font>
    x = new <font color=navy>double</font>[]{-1};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [0.000,1.000]</font>

    <font color=green>//</font>
    <font color=green>// But what our network will <font color=navy>return</font> <font color=navy>for</font> 0, which is between classes 0 and 1?</font>
    <font color=green>//</font>
    <font color=green>// In our dataset it has two different marks assigned (class 0 AND class 1).</font>
    <font color=green>// So network will <font color=navy>return</font> something average between class 0 and class 1:</font>
    <font color=green>//     0 =&gt; [0.5, 0.5]</font>
    <font color=green>//</font>
    x = new <font color=navy>double</font>[]{0};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [0.500,0.500]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_cls3'></a><h3 class=pageheader>nn_cls3 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Suppose that we want to classify numbers as positive (class 0) and negative</font>
    <font color=green>// (class 1). We also have one more class <font color=navy>for</font> zero (class 2).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: we use network with excessive amount of neurons, which guarantees</font>
    <font color=green>//       almost exact reproduction of the training set. Generalization ability</font>
    <font color=green>//       of such network is rather low, but we are not concerned with such</font>
    <font color=green>//       questions in this basic demo.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.multilayerperceptron network;
    alglib.mlpreport rep;
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0,0,0};

    <font color=green>//</font>
    <font color=green>// Training set. One row corresponds to one record [A =&gt; class(A)].</font>
    <font color=green>//</font>
    <font color=green>// Classes are denoted by numbers from 0 to 2, where 0 corresponds to positive</font>
    <font color=green>// numbers, 1 to negative numbers, 2 to zero</font>
    <font color=green>//</font>
    <font color=green>// [ +1  0]</font>
    <font color=green>// [ +2  0]</font>
    <font color=green>// [ -1  1]</font>
    <font color=green>// [ -2  1]</font>
    <font color=green>// [  0  2]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{+1,0},{+2,0},{-1,1},{-2,1},{0,2}};

    <font color=green>//</font>
    <font color=green>//</font>
    <font color=green>// When we solve classification problems, everything is slightly different from</font>
    <font color=green>// the regression ones:</font>
    <font color=green>//</font>
    <font color=green>// 1. Network is created. Because we solve classification problem, we use</font>
    <font color=green>//    mlpcreatec1() function instead of mlpcreate1(). This function creates</font>
    <font color=green>//    classifier network with SOFTMAX-normalized outputs. This network returns</font>
    <font color=green>//    vector of class membership probabilities which are normalized to be</font>
    <font color=green>//    non-negative and sum to 1.0</font>
    <font color=green>//</font>
    <font color=green>// 2. We use mlpcreatetrainercls() function instead of mlpcreatetrainer() to</font>
    <font color=green>//    create trainer object. Trainer object process dataset and neural network</font>
    <font color=green>//    slightly differently to account <font color=navy>for</font> specifics of the classification</font>
    <font color=green>//    problems.</font>
    <font color=green>//</font>
    <font color=green>// 3. Dataset is attached to trainer object. Note that dataset format is slightly</font>
    <font color=green>//    different from one used <font color=navy>for</font> regression.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainercls(1, 3, <font color=navy>out</font> trn);
    alglib.mlpcreatec1(1, 5, 3, <font color=navy>out</font> network);
    alglib.mlpsetdataset(trn, xy, 5);

    <font color=green>//</font>
    <font color=green>// Network is trained with 5 restarts from random positions</font>
    <font color=green>//</font>
    alglib.mlptrainnetwork(trn, network, 5, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Test our neural network on strictly positive and strictly negative numbers.</font>
    <font color=green>//</font>
    <font color=green>// IMPORTANT! Classifier network returns class membership probabilities instead</font>
    <font color=green>// of class indexes. Network returns three values (probabilities) instead of one</font>
    <font color=green>// (class index).</font>
    <font color=green>//</font>
    <font color=green>// Thus, <font color=navy>for</font> +1 we expect to get [P0,P1,P2] = [1,0,0],</font>
    <font color=green>// <font color=navy>for</font> -1 we expect to get [P0,P1,P2] = [0,1,0],</font>
    <font color=green>// and <font color=navy>for</font> 0 we will get [P0,P1,P2] = [0,0,1].</font>
    <font color=green>//</font>
    <font color=green>// Following properties are guaranteed by network architecture:</font>
    <font color=green>// * P0&gt;=0, P1&gt;=0, P2&gt;=0    non-negativity</font>
    <font color=green>// * P0+P1+P2=1             normalization</font>
    <font color=green>//</font>
    x = new <font color=navy>double</font>[]{1};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [1.000,0.000,0.000]</font>
    x = new <font color=navy>double</font>[]{-1};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [0.000,1.000,0.000]</font>
    x = new <font color=navy>double</font>[]{0};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [0.000,0.000,1.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_crossvalidation'></a><h3 class=pageheader>nn_crossvalidation example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example shows how to perform cross-validation with ALGLIB</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.multilayerperceptron network;
    alglib.mlpreport rep;

    <font color=green>//</font>
    <font color=green>// Training set: f(x)=1/(x^2+1)</font>
    <font color=green>// One row corresponds to one record [x,f(x)]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{-2.0,0.2},{-1.6,0.3},{-1.3,0.4},{-1,0.5},{-0.6,0.7},{-0.3,0.9},{0,1},{2.0,0.2},{1.6,0.3},{1.3,0.4},{1,0.5},{0.6,0.7},{0.3,0.9}};

    <font color=green>//</font>
    <font color=green>// Trainer object is created.</font>
    <font color=green>// Dataset is attached to trainer object.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: it is not good idea to perform cross-validation on sample</font>
    <font color=green>//       as small as ours (13 examples). It is done <font color=navy>for</font> demonstration</font>
    <font color=green>//       purposes only. Generalization error estimates won't be</font>
    <font color=green>//       precise enough <font color=navy>for</font> practical purposes.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainer(1, 1, <font color=navy>out</font> trn);
    alglib.mlpsetdataset(trn, xy, 13);

    <font color=green>//</font>
    <font color=green>// The key property of the cross-validation is that it estimates</font>
    <font color=green>// generalization properties of neural ARCHITECTURE. It does NOT</font>
    <font color=green>// estimates generalization error of some specific network which</font>
    <font color=green>// is passed to the k-fold CV routine.</font>
    <font color=green>//</font>
    <font color=green>// In our example we create 1x4x1 neural network and pass it to</font>
    <font color=green>// CV routine without training it. Original state of the network</font>
    <font color=green>// is not used <font color=navy>for</font> cross-validation - each round is restarted from</font>
    <font color=green>// random initial state. Only geometry of network matters.</font>
    <font color=green>//</font>
    <font color=green>// We perform 5 restarts from different random positions <font color=navy>for</font> each</font>
    <font color=green>// of the 10 cross-validation rounds.</font>
    <font color=green>//</font>
    alglib.mlpcreate1(1, 4, 1, <font color=navy>out</font> network);
    alglib.mlpkfoldcv(trn, network, 5, 10, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Cross-validation routine stores estimates of the generalization</font>
    <font color=green>// error to MLP report structure. You may examine its fields and</font>
    <font color=green>// see estimates of different errors (RMS, CE, Avg).</font>
    <font color=green>//</font>
    <font color=green>// Because cross-validation is non-deterministic, in our manual we</font>
    <font color=green>// can not say what values will be stored to rep after call to</font>
    <font color=green>// mlpkfoldcv(). Every CV round will <font color=navy>return</font> slightly different</font>
    <font color=green>// estimates.</font>
    <font color=green>//</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_ensembles_es'></a><h3 class=pageheader>nn_ensembles_es example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example shows how to train early stopping ensebles.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.mlpensemble ensemble;
    alglib.mlpreport rep;

    <font color=green>//</font>
    <font color=green>// Training set: f(x)=1/(x^2+1)</font>
    <font color=green>// One row corresponds to one record [x,f(x)]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{-2.0,0.2},{-1.6,0.3},{-1.3,0.4},{-1,0.5},{-0.6,0.7},{-0.3,0.9},{0,1},{2.0,0.2},{1.6,0.3},{1.3,0.4},{1,0.5},{0.6,0.7},{0.3,0.9}};

    <font color=green>//</font>
    <font color=green>// Trainer object is created.</font>
    <font color=green>// Dataset is attached to trainer object.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: it is not good idea to use early stopping ensemble on sample</font>
    <font color=green>//       as small as ours (13 examples). It is done <font color=navy>for</font> demonstration</font>
    <font color=green>//       purposes only. Ensemble training algorithm won't find good</font>
    <font color=green>//       solution on such small sample.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainer(1, 1, <font color=navy>out</font> trn);
    alglib.mlpsetdataset(trn, xy, 13);

    <font color=green>//</font>
    <font color=green>// Ensemble is created and trained. Each of 50 network is trained</font>
    <font color=green>// with 5 restarts.</font>
    <font color=green>//</font>
    alglib.mlpecreate1(1, 4, 1, 50, <font color=navy>out</font> ensemble);
    alglib.mlptrainensemblees(trn, ensemble, 5, <font color=navy>out</font> rep);
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_parallel'></a><h3 class=pageheader>nn_parallel example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example shows how to use parallel functionality of ALGLIB.</font>
    <font color=green>// We generate simple 1-dimensional regression problem and show how</font>
    <font color=green>// to use parallel training, parallel cross-validation, parallel</font>
    <font color=green>// training of neural ensembles.</font>
    <font color=green>//</font>
    <font color=green>// We assume that you already know how to use ALGLIB in serial mode</font>
    <font color=green>// and concentrate on its parallel capabilities.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: it is not good idea to use parallel features on sample as small</font>
    <font color=green>//       as ours (13 examples). It is done only <font color=navy>for</font> demonstration purposes.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.multilayerperceptron network;
    alglib.mlpensemble ensemble;
    alglib.mlpreport rep;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{-2.0,0.2},{-1.6,0.3},{-1.3,0.4},{-1,0.5},{-0.6,0.7},{-0.3,0.9},{0,1},{2.0,0.2},{1.6,0.3},{1.3,0.4},{1,0.5},{0.6,0.7},{0.3,0.9}};
    alglib.mlpcreatetrainer(1, 1, <font color=navy>out</font> trn);
    alglib.mlpsetdataset(trn, xy, 13);
    alglib.mlpcreate1(1, 4, 1, <font color=navy>out</font> network);
    alglib.mlpecreate1(1, 4, 1, 50, <font color=navy>out</font> ensemble);

    <font color=green>//</font>
    <font color=green>// Below we demonstrate how to perform:</font>
    <font color=green>// * parallel training of individual networks</font>
    <font color=green>// * parallel cross-validation</font>
    <font color=green>// * parallel training of neural ensembles</font>
    <font color=green>//</font>
    <font color=green>// In order to use multithreading, you have to:</font>
    <font color=green>// 1) Install SMP edition of ALGLIB.</font>
    <font color=green>// 2) This step is specific <font color=navy>for</font> C++ users: you should activate OS-specific</font>
    <font color=green>//    capabilities of ALGLIB by defining AE_OS=AE_POSIX (<font color=navy>for</font> *nix systems)</font>
    <font color=green>//    or AE_OS=AE_WINDOWS (<font color=navy>for</font> Windows systems).</font>
    <font color=green>//    C# users <font color=navy>do</font> not have to perform this step because C# programs are</font>
    <font color=green>//    portable across different systems without OS-specific tuning.</font>
    <font color=green>// 3) Allow ALGLIB to know about number of worker threads to use:</font>
    <font color=green>//    a) autodetection (C++, C#):</font>
    <font color=green>//          ALGLIB will automatically determine number of CPU cores and</font>
    <font color=green>//          (by default) will use all cores except <font color=navy>for</font> one. Say, on 4-core</font>
    <font color=green>//          system it will use three cores - unless you manually told it</font>
    <font color=green>//          to use more or less. It will keep your system responsive during</font>
    <font color=green>//          lengthy computations.</font>
    <font color=green>//          Such behavior may be changed with setnworkers() call:</font>
    <font color=green>//          * alglib::setnworkers(0)  = use all cores</font>
    <font color=green>//          * alglib::setnworkers(-1) = leave one core unused</font>
    <font color=green>//          * alglib::setnworkers(-2) = leave two cores unused</font>
    <font color=green>//          * alglib::setnworkers(+2) = use 2 cores (even <font color=navy>if</font> you have more)</font>
    <font color=green>//    b) manual specification (C++, C#):</font>
    <font color=green>//          You may want to specify maximum number of worker threads during</font>
    <font color=green>//          compile time by means of preprocessor definition AE_NWORKERS.</font>
    <font color=green>//          For C++ it will be <font color=blue><b>&quot;AE_NWORKERS=X&quot;</b></font> where X can be any positive number.</font>
    <font color=green>//          For C# it is <font color=blue><b>&quot;AE_NWORKERSX&quot;</b></font>, where X should be replaced by number of</font>
    <font color=green>//          workers (AE_NWORKERS2, AE_NWORKERS3, AE_NWORKERS4, ...).</font>
    <font color=green>//          You can add this definition to compiler command line or change</font>
    <font color=green>//          corresponding project settings in your IDE.</font>
    <font color=green>//</font>
    <font color=green>// After you installed and configured SMP edition of ALGLIB, you may choose</font>
    <font color=green>// between serial and multithreaded versions of SMP-capable functions:</font>
    <font color=green>// * serial version works as usual, in the context of the calling thread</font>
    <font color=green>// * multithreaded version (with <font color=blue><b>&quot;smp_&quot;</b></font> prefix) creates (or wakes up) worker</font>
    <font color=green>//   threads, inserts task in the worker queue, and waits <font color=navy>for</font> completion of</font>
    <font color=green>//   the task. All processing is done in context of worker thread(s).</font>
    <font color=green>//</font>
    <font color=green>// NOTE: because starting/stopping worker threads costs thousands of CPU cycles,</font>
    <font color=green>//       you should not use multithreading <font color=navy>for</font> lightweight computational problems.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: some old POSIX-compatible operating systems <font color=navy>do</font> not support</font>
    <font color=green>//       sysconf(_SC_NPROCESSORS_ONLN) system call which is required in order</font>
    <font color=green>//       to automatically determine number of active cores. On these systems</font>
    <font color=green>//       you should specify number of cores manually at compile time.</font>
    <font color=green>//       Without it ALGLIB will run in single-threaded mode.</font>
    <font color=green>//</font>

    <font color=green>//</font>
    <font color=green>// First, we perform parallel training of individual network with 5</font>
    <font color=green>// restarts from random positions. These 5 rounds of  training  are</font>
    <font color=green>// executed in parallel manner,  with  best  network  chosen  after</font>
    <font color=green>// training.</font>
    <font color=green>//</font>
    <font color=green>// ALGLIB can use additional way to speed up computations -  divide</font>
    <font color=green>// dataset   into   smaller   subsets   and   process these subsets</font>
    <font color=green>// simultaneously. It allows us  to  efficiently  parallelize  even</font>
    <font color=green>// single training round. This operation is performed automatically</font>
    <font color=green>// <font color=navy>for</font> large datasets, but our toy dataset is too small.</font>
    <font color=green>//</font>
    alglib.smp_mlptrainnetwork(trn, network, 5, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Then, we perform parallel 10-fold cross-validation, with 5 random</font>
    <font color=green>// restarts per each CV round. I.e., 5*10=50  networks  are trained</font>
    <font color=green>// in total. All these operations can be parallelized.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: again, ALGLIB can parallelize  calculation   of   gradient</font>
    <font color=green>//       over entire dataset - but our dataset is too small.</font>
    <font color=green>//</font>
    alglib.smp_mlpkfoldcv(trn, network, 5, 10, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// Finally, we train early stopping ensemble of 50 neural networks,</font>
    <font color=green>// each  of them is trained with 5 random restarts. I.e.,  5*50=250</font>
    <font color=green>// networks aretrained in total.</font>
    <font color=green>//</font>
    alglib.smp_mlptrainensemblees(trn, ensemble, 5, <font color=navy>out</font> rep);
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_regr'></a><h3 class=pageheader>nn_regr example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// The very simple example on neural network: network is trained to reproduce</font>
    <font color=green>// small 2x2 multiplication table.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: we use network with excessive amount of neurons, which guarantees</font>
    <font color=green>//       almost exact reproduction of the training set. Generalization ability</font>
    <font color=green>//       of such network is rather low, but we are not concerned with such</font>
    <font color=green>//       questions in this basic demo.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.multilayerperceptron network;
    alglib.mlpreport rep;

    <font color=green>//</font>
    <font color=green>// Training set:</font>
    <font color=green>// * one row corresponds to one record A*B=C in the multiplication table</font>
    <font color=green>// * first two columns store A and B, last column stores C</font>
    <font color=green>//</font>
    <font color=green>// [1 * 1 = 1]</font>
    <font color=green>// [1 * 2 = 2]</font>
    <font color=green>// [2 * 1 = 2]</font>
    <font color=green>// [2 * 2 = 4]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,1,1},{1,2,2},{2,1,2},{2,2,4}};

    <font color=green>//</font>
    <font color=green>// Network is created.</font>
    <font color=green>// Trainer object is created.</font>
    <font color=green>// Dataset is attached to trainer object.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainer(2, 1, <font color=navy>out</font> trn);
    alglib.mlpcreate1(2, 5, 1, <font color=navy>out</font> network);
    alglib.mlpsetdataset(trn, xy, 4);

    <font color=green>//</font>
    <font color=green>// Network is trained with 5 restarts from random positions</font>
    <font color=green>//</font>
    alglib.mlptrainnetwork(trn, network, 5, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// 2*2=?</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{2,2};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [4.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_regr_n'></a><h3 class=pageheader>nn_regr_n example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Network with 2 inputs and 2 outputs is trained to reproduce vector function:</font>
    <font color=green>//     (x0,x1) =&gt; (x0+x1, x0*x1)</font>
    <font color=green>//</font>
    <font color=green>// Informally speaking, we want neural network to simultaneously calculate</font>
    <font color=green>// both sum of two numbers and their product.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: we use network with excessive amount of neurons, which guarantees</font>
    <font color=green>//       almost exact reproduction of the training set. Generalization ability</font>
    <font color=green>//       of such network is rather low, but we are not concerned with such</font>
    <font color=green>//       questions in this basic demo.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;
    alglib.multilayerperceptron network;
    alglib.mlpreport rep;

    <font color=green>//</font>
    <font color=green>// Training set. One row corresponds to one record [A,B,A+B,A*B].</font>
    <font color=green>//</font>
    <font color=green>// [ 1   1  1+1  1*1 ]</font>
    <font color=green>// [ 1   2  1+2  1*2 ]</font>
    <font color=green>// [ 2   1  2+1  2*1 ]</font>
    <font color=green>// [ 2   2  2+2  2*2 ]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,1,2,1},{1,2,3,2},{2,1,3,2},{2,2,4,4}};

    <font color=green>//</font>
    <font color=green>// Network is created.</font>
    <font color=green>// Trainer object is created.</font>
    <font color=green>// Dataset is attached to trainer object.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainer(2, 2, <font color=navy>out</font> trn);
    alglib.mlpcreate1(2, 5, 2, <font color=navy>out</font> network);
    alglib.mlpsetdataset(trn, xy, 4);

    <font color=green>//</font>
    <font color=green>// Network is trained with 5 restarts from random positions</font>
    <font color=green>//</font>
    alglib.mlptrainnetwork(trn, network, 5, <font color=navy>out</font> rep);

    <font color=green>//</font>
    <font color=green>// 2+1=?</font>
    <font color=green>// 2*1=?</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{2,1};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0,0};
    alglib.mlpprocess(network, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,1)); <font color=green>// EXPECTED: [3.000,2.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nn_trainerobject'></a><h3 class=pageheader>nn_trainerobject example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Trainer object is used to train network. It stores dataset, training settings,</font>
    <font color=green>// and other information which is NOT part of neural network. You should use</font>
    <font color=green>// trainer object as follows:</font>
    <font color=green>// (1) you create trainer object and specify task type (classification/regression)</font>
    <font color=green>//     and number of inputs/outputs</font>
    <font color=green>// (2) you add dataset to the trainer object</font>
    <font color=green>// (3) you may change training settings (stopping criteria or weight decay)</font>
    <font color=green>// (4) finally, you may train one or more networks</font>
    <font color=green>//</font>
    <font color=green>// You may interleave stages 2...4 and repeat them many times. Trainer object</font>
    <font color=green>// remembers its internal state and can be used several times after its creation</font>
    <font color=green>// and initialization.</font>
    <font color=green>//</font>
    alglib.mlptrainer trn;

    <font color=green>//</font>
    <font color=green>// Stage 1: object creation.</font>
    <font color=green>//</font>
    <font color=green>// We have to specify number of inputs and outputs. Trainer object can be used</font>
    <font color=green>// only <font color=navy>for</font> problems with same number of inputs/outputs as was specified during</font>
    <font color=green>// its creation.</font>
    <font color=green>//</font>
    <font color=green>// In case you want to train SOFTMAX-normalized network which solves classification</font>
    <font color=green>// problems,  you  must  use  another  function  to  create  trainer  object:</font>
    <font color=green>// mlpcreatetrainercls().</font>
    <font color=green>//</font>
    <font color=green>// Below we create trainer object which can be used to train regression networks</font>
    <font color=green>// with 2 inputs and 1 output.</font>
    <font color=green>//</font>
    alglib.mlpcreatetrainer(2, 1, <font color=navy>out</font> trn);

    <font color=green>//</font>
    <font color=green>// Stage 2: specification of the training set</font>
    <font color=green>//</font>
    <font color=green>// By default trainer object stores empty dataset. So to solve your non-empty problem</font>
    <font color=green>// you have to set dataset by passing to trainer dense or sparse matrix.</font>
    <font color=green>//</font>
    <font color=green>// One row of the matrix corresponds to one record A*B=C in the multiplication table.</font>
    <font color=green>// First two columns store A and B, last column stores C</font>
    <font color=green>//</font>
    <font color=green>//     [1 * 1 = 1]   [ 1 1 1 ]</font>
    <font color=green>//     [1 * 2 = 2]   [ 1 2 2 ]</font>
    <font color=green>//     [2 * 1 = 2] = [ 2 1 2 ]</font>
    <font color=green>//     [2 * 2 = 4]   [ 2 2 4 ]</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{1,1,1},{1,2,2},{2,1,2},{2,2,4}};
    alglib.mlpsetdataset(trn, xy, 4);

    <font color=green>//</font>
    <font color=green>// Stage 3: modification of the training parameters.</font>
    <font color=green>//</font>
    <font color=green>// You may modify parameters like weights decay or stopping criteria:</font>
    <font color=green>// * we set moderate weight decay</font>
    <font color=green>// * we choose iterations limit as stopping condition (another condition - step size -</font>
    <font color=green>//   is zero, which means than this condition is not active)</font>
    <font color=green>//</font>
    <font color=navy>double</font> wstep = 0.000;
    <font color=navy>int</font> maxits = 100;
    alglib.mlpsetdecay(trn, 0.01);
    alglib.mlpsetcond(trn, wstep, maxits);

    <font color=green>//</font>
    <font color=green>// Stage 4: training.</font>
    <font color=green>//</font>
    <font color=green>// We will train several networks with different architecture using same trainer object.</font>
    <font color=green>// We may change training parameters or even dataset, so different networks are trained</font>
    <font color=green>// differently. But in this simple example we will train all networks with same settings.</font>
    <font color=green>//</font>
    <font color=green>// We create and train three networks:</font>
    <font color=green>// * network 1 has 2x1 architecture     (2 inputs, no hidden neurons, 1 output)</font>
    <font color=green>// * network 2 has 2x5x1 architecture   (2 inputs, 5 hidden neurons, 1 output)</font>
    <font color=green>// * network 3 has 2x5x5x1 architecture (2 inputs, two hidden layers, 1 output)</font>
    <font color=green>//</font>
    <font color=green>// NOTE: these networks solve regression problems. For classification problems you</font>
    <font color=green>//       should use mlpcreatec0/c1/c2 to create neural networks which have SOFTMAX-</font>
    <font color=green>//       normalized outputs.</font>
    <font color=green>//</font>
    alglib.multilayerperceptron net1;
    alglib.multilayerperceptron net2;
    alglib.multilayerperceptron net3;
    alglib.mlpreport rep;

    alglib.mlpcreate0(2, 1, <font color=navy>out</font> net1);
    alglib.mlpcreate1(2, 5, 1, <font color=navy>out</font> net2);
    alglib.mlpcreate2(2, 5, 5, 1, <font color=navy>out</font> net3);

    alglib.mlptrainnetwork(trn, net1, 5, <font color=navy>out</font> rep);
    alglib.mlptrainnetwork(trn, net2, 5, <font color=navy>out</font> rep);
    alglib.mlptrainnetwork(trn, net3, 5, <font color=navy>out</font> rep);
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_nearestneighbor></a><h2 class=pageheader><code>nearestneighbor</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_kdtree' class=toc>kdtree</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_kdtreebuild' class=toc>kdtreebuild</a><br>
<a href='#sub_kdtreebuildtagged' class=toc>kdtreebuildtagged</a><br>
<a href='#sub_kdtreequeryaknn' class=toc>kdtreequeryaknn</a><br>
<a href='#sub_kdtreequeryknn' class=toc>kdtreequeryknn</a><br>
<a href='#sub_kdtreequeryresultsdistances' class=toc>kdtreequeryresultsdistances</a><br>
<a href='#sub_kdtreequeryresultsdistancesi' class=toc>kdtreequeryresultsdistancesi</a><br>
<a href='#sub_kdtreequeryresultstags' class=toc>kdtreequeryresultstags</a><br>
<a href='#sub_kdtreequeryresultstagsi' class=toc>kdtreequeryresultstagsi</a><br>
<a href='#sub_kdtreequeryresultsx' class=toc>kdtreequeryresultsx</a><br>
<a href='#sub_kdtreequeryresultsxi' class=toc>kdtreequeryresultsxi</a><br>
<a href='#sub_kdtreequeryresultsxy' class=toc>kdtreequeryresultsxy</a><br>
<a href='#sub_kdtreequeryresultsxyi' class=toc>kdtreequeryresultsxyi</a><br>
<a href='#sub_kdtreequeryrnn' class=toc>kdtreequeryrnn</a><br>
<a href='#sub_kdtreeserialize' class=toc>kdtreeserialize</a><br>
<a href='#sub_kdtreeunserialize' class=toc>kdtreeunserialize</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_nneighbor_d_1' class=toc>nneighbor_d_1</a></td><td width=15>&nbsp;</td><td>Nearest neighbor search, KNN queries</td></tr>
<tr align=left valign=top><td><a href='#example_nneighbor_d_2' class=toc>nneighbor_d_2</a></td><td width=15>&nbsp;</td><td>Serialization of KD-trees</td></tr>
</table></div>
<a name='struct_kdtree'></a><h3 class=pageheader><code>kdtree</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class kdtree
{
}

</div></pre>
<a name='sub_kdtreebuild'></a><h3 class=pageheader><code>kdtreebuild</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
KD-tree creation

This subroutine creates KD-tree from set of X-values and optional Y-values

INPUT PARAMETERS
    XY      -   dataset, array[0..N-1,0..NX+NY-1].
                one row corresponds to one point.
                first NX columns contain X-values, next NY (NY may be zero)
                columns may contain associated Y-values
    N       -   number of points, N&gt;=0.
    NX      -   space dimension, NX&gt;=1.
    NY      -   number of optional Y-values, NY&gt;=0.
    NormType-   norm type:
                * 0 denotes infinity-norm
                * 1 denotes 1-norm
                * 2 denotes 2-norm (Euclidean norm)

OUTPUT PARAMETERS
    KDT     -   KD-tree


NOTES

1. KD-tree  creation  have O(N*logN) complexity and O(N*(2*NX+NY))  memory
   requirements.
2. Although KD-trees may be used with any combination of N  and  NX,  they
   are more efficient than brute-force search only when N &gt;&gt; 4^NX. So they
   are most useful in low-dimensional tasks (NX=2, NX=3). NX=1  is another
   inefficient case, because  simple  binary  search  (without  additional
   structures) is much more efficient in such tasks than KD-trees.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreebuild(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> nx,
    <font color=navy>int</font> ny,
    <font color=navy>int</font> normtype,
    <font color=navy>out</font> kdtree kdt)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreebuild(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nx,
    <font color=navy>int</font> ny,
    <font color=navy>int</font> normtype,
    <font color=navy>out</font> kdtree kdt)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_nneighbor_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreebuildtagged'></a><h3 class=pageheader><code>kdtreebuildtagged</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
KD-tree creation

This  subroutine  creates  KD-tree  from set of X-values, integer tags and
optional Y-values

INPUT PARAMETERS
    XY      -   dataset, array[0..N-1,0..NX+NY-1].
                one row corresponds to one point.
                first NX columns contain X-values, next NY (NY may be zero)
                columns may contain associated Y-values
    Tags    -   tags, array[0..N-1], contains integer tags associated
                with points.
    N       -   number of points, N&gt;=0
    NX      -   space dimension, NX&gt;=1.
    NY      -   number of optional Y-values, NY&gt;=0.
    NormType-   norm type:
                * 0 denotes infinity-norm
                * 1 denotes 1-norm
                * 2 denotes 2-norm (Euclidean norm)

OUTPUT PARAMETERS
    KDT     -   KD-tree

NOTES

1. KD-tree  creation  have O(N*logN) complexity and O(N*(2*NX+NY))  memory
   requirements.
2. Although KD-trees may be used with any combination of N  and  NX,  they
   are more efficient than brute-force search only when N &gt;&gt; 4^NX. So they
   are most useful in low-dimensional tasks (NX=2, NX=3). NX=1  is another
   inefficient case, because  simple  binary  search  (without  additional
   structures) is much more efficient in such tasks than KD-trees.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreebuildtagged(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font>[] tags,
    <font color=navy>int</font> nx,
    <font color=navy>int</font> ny,
    <font color=navy>int</font> normtype,
    <font color=navy>out</font> kdtree kdt)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreebuildtagged(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font>[] tags,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nx,
    <font color=navy>int</font> ny,
    <font color=navy>int</font> normtype,
    <font color=navy>out</font> kdtree kdt)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryaknn'></a><h3 class=pageheader><code>kdtreequeryaknn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
K-NN query: approximate K nearest neighbors

INPUT PARAMETERS
    KDT         -   KD-tree
    X           -   point, array[0..NX-1].
    K           -   number of neighbors to return, K&gt;=1
    SelfMatch   -   whether self-matches are allowed:
                    * if True, nearest neighbor may be the point itself
                      (if it exists in original dataset)
                    * if False, then only points with non-zero distance
                      are returned
                    * if not given, considered True
    Eps         -   approximation factor, Eps&gt;=0. eps-approximate  nearest
                    neighbor  is  a  neighbor  whose distance from X is at
                    most (1+eps) times distance of true nearest neighbor.

RESULT
    number of actual neighbors found (either K or N, if K&gt;N).

NOTES
    significant performance gain may be achieved only when Eps  is  is  on
    the order of magnitude of 1 or larger.

This  subroutine  performs  query  and  stores  its result in the internal
structures of the KD-tree. You can use  following  subroutines  to  obtain
these results:
* KDTreeQueryResultsX() to get X-values
* KDTreeQueryResultsXY() to get X- and Y-values
* KDTreeQueryResultsTags() to get tag values
* KDTreeQueryResultsDistances() to get distances

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.kdtreequeryaknn(
    kdtree kdt,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> k,
    <font color=navy>double</font> eps)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.kdtreequeryaknn(
    kdtree kdt,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> k,
    <font color=navy>bool</font> selfmatch,
    <font color=navy>double</font> eps)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryknn'></a><h3 class=pageheader><code>kdtreequeryknn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
K-NN query: K nearest neighbors

INPUT PARAMETERS
    KDT         -   KD-tree
    X           -   point, array[0..NX-1].
    K           -   number of neighbors to return, K&gt;=1
    SelfMatch   -   whether self-matches are allowed:
                    * if True, nearest neighbor may be the point itself
                      (if it exists in original dataset)
                    * if False, then only points with non-zero distance
                      are returned
                    * if not given, considered True

RESULT
    number of actual neighbors found (either K or N, if K&gt;N).

This  subroutine  performs  query  and  stores  its result in the internal
structures of the KD-tree. You can use  following  subroutines  to  obtain
these results:
* KDTreeQueryResultsX() to get X-values
* KDTreeQueryResultsXY() to get X- and Y-values
* KDTreeQueryResultsTags() to get tag values
* KDTreeQueryResultsDistances() to get distances

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.kdtreequeryknn(kdtree kdt, <font color=navy>double</font>[] x, <font color=navy>int</font> k)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.kdtreequeryknn(
    kdtree kdt,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> k,
    <font color=navy>bool</font> selfmatch)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsdistances'></a><h3 class=pageheader><code>kdtreequeryresultsdistances</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Distances from last query

INPUT PARAMETERS
    KDT     -   KD-tree
    R       -   possibly pre-allocated buffer. If X is too small to store
                result, it is resized. If size(X) is enough to store
                result, it is left unchanged.

OUTPUT PARAMETERS
    R       -   filled with distances (in corresponding norm)

NOTES
1. points are ordered by distance from the query point (first = closest)
2. if  XY is larger than required to store result, only leading part  will
   be overwritten; trailing part will be left unchanged. So  if  on  input
   XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
   XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
   you want function  to  resize  array  according  to  result  size,  use
   function with same name and suffix 'I'.

SEE ALSO
* KDTreeQueryResultsX()             X-values
* KDTreeQueryResultsXY()            X- and Y-values
* KDTreeQueryResultsTags()          tag values

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultsdistances(
    kdtree kdt,
    <font color=navy>ref</font> <font color=navy>double</font>[] r)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsdistancesi'></a><h3 class=pageheader><code>kdtreequeryresultsdistancesi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Distances from last query; 'interactive' variant for languages like Python
which  support  constructs   like  &quot;R = KDTreeQueryResultsDistancesI(KDT)&quot;
and interactive mode of interpreter.

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultsdistancesi(
    kdtree kdt,
    <font color=navy>out</font> <font color=navy>double</font>[] r)

</div></pre>
<a name='sub_kdtreequeryresultstags'></a><h3 class=pageheader><code>kdtreequeryresultstags</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Tags from last query

INPUT PARAMETERS
    KDT     -   KD-tree
    Tags    -   possibly pre-allocated buffer. If X is too small to store
                result, it is resized. If size(X) is enough to store
                result, it is left unchanged.

OUTPUT PARAMETERS
    Tags    -   filled with tags associated with points,
                or, when no tags were supplied, with zeros

NOTES
1. points are ordered by distance from the query point (first = closest)
2. if  XY is larger than required to store result, only leading part  will
   be overwritten; trailing part will be left unchanged. So  if  on  input
   XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
   XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
   you want function  to  resize  array  according  to  result  size,  use
   function with same name and suffix 'I'.

SEE ALSO
* KDTreeQueryResultsX()             X-values
* KDTreeQueryResultsXY()            X- and Y-values
* KDTreeQueryResultsDistances()     distances

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultstags(
    kdtree kdt,
    <font color=navy>ref</font> <font color=navy>int</font>[] tags)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultstagsi'></a><h3 class=pageheader><code>kdtreequeryresultstagsi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Tags  from  last  query;  'interactive' variant for languages like  Python
which  support  constructs  like &quot;Tags = KDTreeQueryResultsTagsI(KDT)&quot; and
interactive mode of interpreter.

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultstagsi(
    kdtree kdt,
    <font color=navy>out</font> <font color=navy>int</font>[] tags)

</div></pre>
<a name='sub_kdtreequeryresultsx'></a><h3 class=pageheader><code>kdtreequeryresultsx</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
X-values from last query

INPUT PARAMETERS
    KDT     -   KD-tree
    X       -   possibly pre-allocated buffer. If X is too small to store
                result, it is resized. If size(X) is enough to store
                result, it is left unchanged.

OUTPUT PARAMETERS
    X       -   rows are filled with X-values

NOTES
1. points are ordered by distance from the query point (first = closest)
2. if  XY is larger than required to store result, only leading part  will
   be overwritten; trailing part will be left unchanged. So  if  on  input
   XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
   XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
   you want function  to  resize  array  according  to  result  size,  use
   function with same name and suffix 'I'.

SEE ALSO
* KDTreeQueryResultsXY()            X- and Y-values
* KDTreeQueryResultsTags()          tag values
* KDTreeQueryResultsDistances()     distances

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultsx(kdtree kdt, <font color=navy>ref</font> <font color=navy>double</font>[,] x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsxi'></a><h3 class=pageheader><code>kdtreequeryresultsxi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
X-values from last query; 'interactive' variant for languages like  Python
which   support    constructs   like  &quot;X = KDTreeQueryResultsXI(KDT)&quot;  and
interactive mode of interpreter.

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultsxi(
    kdtree kdt,
    <font color=navy>out</font> <font color=navy>double</font>[,] x)

</div></pre>
<a name='sub_kdtreequeryresultsxy'></a><h3 class=pageheader><code>kdtreequeryresultsxy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
X- and Y-values from last query

INPUT PARAMETERS
    KDT     -   KD-tree
    XY      -   possibly pre-allocated buffer. If XY is too small to store
                result, it is resized. If size(XY) is enough to store
                result, it is left unchanged.

OUTPUT PARAMETERS
    XY      -   rows are filled with points: first NX columns with
                X-values, next NY columns - with Y-values.

NOTES
1. points are ordered by distance from the query point (first = closest)
2. if  XY is larger than required to store result, only leading part  will
   be overwritten; trailing part will be left unchanged. So  if  on  input
   XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
   XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
   you want function  to  resize  array  according  to  result  size,  use
   function with same name and suffix 'I'.

SEE ALSO
* KDTreeQueryResultsX()             X-values
* KDTreeQueryResultsTags()          tag values
* KDTreeQueryResultsDistances()     distances

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultsxy(
    kdtree kdt,
    <font color=navy>ref</font> <font color=navy>double</font>[,] xy)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsxyi'></a><h3 class=pageheader><code>kdtreequeryresultsxyi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
XY-values from last query; 'interactive' variant for languages like Python
which   support    constructs   like &quot;XY = KDTreeQueryResultsXYI(KDT)&quot; and
interactive mode of interpreter.

This function allocates new array on each call,  so  it  is  significantly
slower than its 'non-interactive' counterpart, but it is  more  convenient
when you call it from command line.

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.kdtreequeryresultsxyi(
    kdtree kdt,
    <font color=navy>out</font> <font color=navy>double</font>[,] xy)

</div></pre>
<a name='sub_kdtreequeryrnn'></a><h3 class=pageheader><code>kdtreequeryrnn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
R-NN query: all points within R-sphere centered at X

INPUT PARAMETERS
    KDT         -   KD-tree
    X           -   point, array[0..NX-1].
    R           -   radius of sphere (in corresponding norm), R&gt;0
    SelfMatch   -   whether self-matches are allowed:
                    * if True, nearest neighbor may be the point itself
                      (if it exists in original dataset)
                    * if False, then only points with non-zero distance
                      are returned
                    * if not given, considered True

RESULT
    number of neighbors found, &gt;=0

This  subroutine  performs  query  and  stores  its result in the internal
structures of the KD-tree. You can use  following  subroutines  to  obtain
actual results:
* KDTreeQueryResultsX() to get X-values
* KDTreeQueryResultsXY() to get X- and Y-values
* KDTreeQueryResultsTags() to get tag values
* KDTreeQueryResultsDistances() to get distances

  -- ALGLIB --
     Copyright 28.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.kdtreequeryrnn(kdtree kdt, <font color=navy>double</font>[] x, <font color=navy>double</font> r)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.kdtreequeryrnn(
    kdtree kdt,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> r,
    <font color=navy>bool</font> selfmatch)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreeserialize'></a><h3 class=pageheader><code>kdtreeserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function serializes data structure to string.

Important properties of s_out:
* it contains alphanumeric characters, dots, underscores, minus signs
* these symbols are grouped into words, which are separated by spaces
  and Windows-style (CR+LF) newlines
* although  serializer  uses  spaces and CR+LF as separators, you can 
  replace any separator character by arbitrary combination of spaces,
  tabs, Windows or Unix newlines. It allows flexible reformatting  of
  the  string  in  case you want to include it into text or XML file. 
  But you should not insert separators into the middle of the &quot;words&quot;
  nor you should change case of letters.
* s_out can be freely moved between 32-bit and 64-bit systems, little
  and big endian machines, and so on. You can serialize structure  on
  32-bit machine and unserialize it on 64-bit one (or vice versa), or
  serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
  serialize  it  in  C++ version of ALGLIB and unserialize in C# one, 
  and vice versa.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> kdtreeserialize(kdtree obj, <font color=navy>out</font> string s_out)

</div></pre>
<a name='sub_kdtreeunserialize'></a><h3 class=pageheader><code>kdtreeunserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function unserializes data structure from string.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> kdtreeunserialize(string s_in, <font color=navy>out</font> kdtree obj)

</div></pre>
<a name='example_nneighbor_d_1'></a><h3 class=pageheader>nneighbor_d_1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{0,0},{0,1},{1,0},{1,1}};
    <font color=navy>int</font> nx = 2;
    <font color=navy>int</font> ny = 0;
    <font color=navy>int</font> normtype = 2;
    alglib.kdtree kdt;
    <font color=navy>double</font>[] x;
    <font color=navy>double</font>[,] r = new <font color=navy>double</font>[0,0];
    <font color=navy>int</font> k;
    alglib.kdtreebuild(a, nx, ny, normtype, <font color=navy>out</font> kdt);
    x = new <font color=navy>double</font>[]{-1,0};
    k = alglib.kdtreequeryknn(kdt, x, 1);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, k); <font color=green>// EXPECTED: 1</font>
    alglib.kdtreequeryresultsx(kdt, <font color=navy>ref</font> r);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(r,1)); <font color=green>// EXPECTED: [[0,0]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_nneighbor_d_2'></a><h3 class=pageheader>nneighbor_d_2 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[,] a = new <font color=navy>double</font>[,]{{0,0},{0,1},{1,0},{1,1}};
    <font color=navy>int</font> nx = 2;
    <font color=navy>int</font> ny = 0;
    <font color=navy>int</font> normtype = 2;
    alglib.kdtree kdt0;
    alglib.kdtree kdt1;
    string s;
    <font color=navy>double</font>[] x;
    <font color=navy>double</font>[,] r0 = new <font color=navy>double</font>[0,0];
    <font color=navy>double</font>[,] r1 = new <font color=navy>double</font>[0,0];

    <font color=green>//</font>
    <font color=green>// Build tree and serialize it</font>
    <font color=green>//</font>
    alglib.kdtreebuild(a, nx, ny, normtype, <font color=navy>out</font> kdt0);
    alglib.kdtreeserialize(kdt0, <font color=navy>out</font> s);
    alglib.kdtreeunserialize(s, <font color=navy>out</font> kdt1);

    <font color=green>//</font>
    <font color=green>// Compare results from KNN queries</font>
    <font color=green>//</font>
    x = new <font color=navy>double</font>[]{-1,0};
    alglib.kdtreequeryknn(kdt0, x, 1);
    alglib.kdtreequeryresultsx(kdt0, <font color=navy>ref</font> r0);
    alglib.kdtreequeryknn(kdt1, x, 1);
    alglib.kdtreequeryresultsx(kdt1, <font color=navy>ref</font> r1);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(r0,1)); <font color=green>// EXPECTED: [[0,0]]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(r1,1)); <font color=green>// EXPECTED: [[0,0]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_nleq></a><h2 class=pageheader><code>nleq</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_nleqreport' class=toc>nleqreport</a><br>
<a href='#struct_nleqstate' class=toc>nleqstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_nleqcreatelm' class=toc>nleqcreatelm</a><br>
<a href='#sub_nleqrestartfrom' class=toc>nleqrestartfrom</a><br>
<a href='#sub_nleqresults' class=toc>nleqresults</a><br>
<a href='#sub_nleqresultsbuf' class=toc>nleqresultsbuf</a><br>
<a href='#sub_nleqsetcond' class=toc>nleqsetcond</a><br>
<a href='#sub_nleqsetstpmax' class=toc>nleqsetstpmax</a><br>
<a href='#sub_nleqsetxrep' class=toc>nleqsetxrep</a><br>
<a href='#sub_nleqsolve' class=toc>nleqsolve</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_nleqreport'></a><h3 class=pageheader><code>nleqreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class nleqreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nfunc;
    <font color=navy>public</font> <font color=navy>int</font>                  njac;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_nleqstate'></a><h3 class=pageheader><code>nleqstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class nleqstate
{
}

</div></pre>
<a name='sub_nleqcreatelm'></a><h3 class=pageheader><code>nleqcreatelm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
                LEVENBERG-MARQUARDT-LIKE NONLINEAR SOLVER

DESCRIPTION:
This algorithm solves system of nonlinear equations
    F[0](x[0], ..., x[n-1])   = 0
    F[1](x[0], ..., x[n-1])   = 0
    ...
    F[M-1](x[0], ..., x[n-1]) = 0
with M/N do not necessarily coincide.  Algorithm  converges  quadratically
under following conditions:
    * the solution set XS is nonempty
    * for some xs in XS there exist such neighbourhood N(xs) that:
      * vector function F(x) and its Jacobian J(x) are continuously
        differentiable on N
      * ||F(x)|| provides local error bound on N, i.e. there  exists  such
        c1, that ||F(x)||&gt;c1*distance(x,XS)
Note that these conditions are much more weaker than usual non-singularity
conditions. For example, algorithm will converge for any  affine  function
F (whether its Jacobian singular or not).


REQUIREMENTS:
Algorithm will request following information during its operation:
* function vector F[] and Jacobian matrix at given point X
* value of merit function f(x)=F[0]^2(x)+...+F[M-1]^2(x) at given point X


USAGE:
1. User initializes algorithm state with NLEQCreateLM() call
2. User tunes solver parameters with  NLEQSetCond(),  NLEQSetStpMax()  and
   other functions
3. User  calls  NLEQSolve()  function  which  takes  algorithm  state  and
   pointers (delegates, etc.) to callback functions which calculate  merit
   function value and Jacobian.
4. User calls NLEQResults() to get solution
5. Optionally, user may call NLEQRestartFrom() to  solve  another  problem
   with same parameters (N/M) but another starting  point  and/or  another
   function vector. NLEQRestartFrom() allows to reuse already  initialized
   structure.


INPUT PARAMETERS:
    N       -   space dimension, N&gt;1:
                * if provided, only leading N elements of X are used
                * if not provided, determined automatically from size of X
    M       -   system size
    X       -   starting point


OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state


NOTES:
1. you may tune stopping conditions with NLEQSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use NLEQSetStpMax() function to bound algorithm's steps.
3. this  algorithm  is  a  slightly  modified implementation of the method
   described  in  'Levenberg-Marquardt  method  for constrained  nonlinear
   equations with strong local convergence properties' by Christian Kanzow
   Nobuo Yamashita and Masao Fukushima and further  developed  in  'On the
   convergence of a New Levenberg-Marquardt Method'  by  Jin-yan  Fan  and
   Ya-Xiang Yuan.


  -- ALGLIB --
     Copyright 20.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqcreatelm(
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> nleqstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqcreatelm(
    <font color=navy>int</font> n,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] x,
    <font color=navy>out</font> nleqstate state)

</div></pre>
<a name='sub_nleqrestartfrom'></a><h3 class=pageheader><code>nleqrestartfrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine  restarts  CG  algorithm from new point. All optimization
parameters are left unchanged.

This  function  allows  to  solve multiple  optimization  problems  (which
must have same number of dimensions) without object reallocation penalty.

INPUT PARAMETERS:
    State   -   structure used for reverse communication previously
                allocated with MinCGCreate call.
    X       -   new starting point.
    BndL    -   new lower bounds
    BndU    -   new upper bounds

  -- ALGLIB --
     Copyright 30.07.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqrestartfrom(nleqstate state, <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_nleqresults'></a><h3 class=pageheader><code>nleqresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
NLEQ solver results

INPUT PARAMETERS:
    State   -   algorithm state.

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -4    ERROR:  algorithm   has   converged   to   the
                            stationary point Xf which is local minimum  of
                            f=F[0]^2+...+F[m-1]^2, but is not solution  of
                            nonlinear system.
                    *  1    sqrt(f)&lt;=EpsF.
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
                * Rep.IterationsCount contains iterations count
                * NFEV countains number of function calculations
                * ActiveConstraints contains number of active constraints

  -- ALGLIB --
     Copyright 20.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqresults(
    nleqstate state,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> nleqreport rep)

</div></pre>
<a name='sub_nleqresultsbuf'></a><h3 class=pageheader><code>nleqresultsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
NLEQ solver results

Buffered implementation of NLEQResults(), which uses pre-allocated  buffer
to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
intended to be used in the inner cycles of performance critical algorithms
where array reallocation penalty is too large to be ignored.

  -- ALGLIB --
     Copyright 20.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqresultsbuf(
    nleqstate state,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    nleqreport rep)

</div></pre>
<a name='sub_nleqsetcond'></a><h3 class=pageheader><code>nleqsetcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for the nonlinear solver

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    EpsF    -   &gt;=0
                The subroutine finishes  its work if on k+1-th iteration
                the condition ||F||&lt;=EpsF is satisfied
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsF=0 and MaxIts=0 simultaneously will lead to  automatic
stopping criterion selection (small EpsF).

NOTES:

  -- ALGLIB --
     Copyright 20.08.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqsetcond(
    nleqstate state,
    <font color=navy>double</font> epsf,
    <font color=navy>int</font> maxits)

</div></pre>
<a name='sub_nleqsetstpmax'></a><h3 class=pageheader><code>nleqsetstpmax</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when target function  contains  exp()  or  other  fast
growing functions, and algorithm makes  too  large  steps  which  lead  to
overflow. This function allows us to reject steps that are too large  (and
therefore expose us to the possible overflow) without actually calculating
function value at the x+stp*d.

  -- ALGLIB --
     Copyright 20.08.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqsetstpmax(nleqstate state, <font color=navy>double</font> stpmax)

</div></pre>
<a name='sub_nleqsetxrep'></a><h3 class=pageheader><code>nleqsetxrep</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state
    NeedXRep-   whether iteration reports are needed or not

If NeedXRep is True, algorithm will call rep() callback function if  it is
provided to NLEQSolve().

  -- ALGLIB --
     Copyright 20.08.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.nleqsetxrep(nleqstate state, <font color=navy>bool</font> needxrep)

</div></pre>
<a name='sub_nleqsolve'></a><h3 class=pageheader><code>nleqsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This family of functions is used to launcn iterations of nonlinear solver

These functions accept following parameters:
    state   -   algorithm state
    func    -   callback which calculates function (or merit function)
                value func at given point x
    jac     -   callback which calculates function vector fi[]
                and Jacobian jac at given point x
    rep     -   optional callback which is called after each iteration
                can be NULL
    ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
                can be NULL


  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> nleqsolve(nleqstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj)

</div></pre>
<a name=unit_normaldistr></a><h2 class=pageheader><code>normaldistr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_errorfunction' class=toc>errorfunction</a><br>
<a href='#sub_errorfunctionc' class=toc>errorfunctionc</a><br>
<a href='#sub_inverf' class=toc>inverf</a><br>
<a href='#sub_invnormaldistribution' class=toc>invnormaldistribution</a><br>
<a href='#sub_normaldistribution' class=toc>normaldistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_errorfunction'></a><h3 class=pageheader><code>errorfunction</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Error function

The integral is

                          x
                           -
                2         | |          2
  erf(x)  =  --------     |    exp( - t  ) dt.
             sqrt(pi)   | |
                         -
                          0

For 0 &lt;= |x| &lt; 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
erf(x) = 1 - erfc(x).


ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0,1         30000       3.7e-16     1.0e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.errorfunction(<font color=navy>double</font> x)

</div></pre>
<a name='sub_errorfunctionc'></a><h3 class=pageheader><code>errorfunctionc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complementary error function

 1 - erf(x) =

                          inf.
                            -
                 2         | |          2
  erfc(x)  =  --------     |    exp( - t  ) dt
              sqrt(pi)   | |
                          -
                           x


For small x, erfc(x) = 1 - erf(x); otherwise rational
approximations are computed.


ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE      0,26.6417   30000       5.7e-14     1.5e-14

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.errorfunctionc(<font color=navy>double</font> x)

</div></pre>
<a name='sub_inverf'></a><h3 class=pageheader><code>inverf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse of the error function

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.inverf(<font color=navy>double</font> e)

</div></pre>
<a name='sub_invnormaldistribution'></a><h3 class=pageheader><code>invnormaldistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse of Normal distribution function

Returns the argument, x, for which the area under the
Gaussian probability density function (integrated from
minus infinity to x) is equal to y.


For small arguments 0 &lt; y &lt; exp(-2), the program computes
z = sqrt( -2.0 * log(y) );  then the approximation is
x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
There are two rational functions P/Q, one for 0 &lt; y &lt; exp(-32)
and the other for y up to exp(-2).  For larger arguments,
w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).

ACCURACY:

                     Relative error:
arithmetic   domain        # trials      peak         rms
   IEEE     0.125, 1        20000       7.2e-16     1.3e-16
   IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invnormaldistribution(<font color=navy>double</font> y0)

</div></pre>
<a name='sub_normaldistribution'></a><h3 class=pageheader><code>normaldistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Normal distribution function

Returns the area under the Gaussian probability density
function, integrated from minus infinity to x:

                           x
                            -
                  1        | |          2
   ndtr(x)  = ---------    |    exp( - t /2 ) dt
              sqrt(2pi)  | |
                          -
                         -inf.

            =  ( 1 + erf(z) ) / 2
            =  erfc(z) / 2

where z = x/sqrt(2). Computation is via the functions
erf and erfc.


ACCURACY:

                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE     -13,0        30000       3.4e-14     6.7e-15

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.normaldistribution(<font color=navy>double</font> x)

</div></pre>
<a name=unit_normestimator></a><h2 class=pageheader><code>normestimator</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_normestimatorstate' class=toc>normestimatorstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_normestimatorcreate' class=toc>normestimatorcreate</a><br>
<a href='#sub_normestimatorestimatesparse' class=toc>normestimatorestimatesparse</a><br>
<a href='#sub_normestimatorresults' class=toc>normestimatorresults</a><br>
<a href='#sub_normestimatorsetseed' class=toc>normestimatorsetseed</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_normestimatorstate'></a><h3 class=pageheader><code>normestimatorstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This object stores state of the iterative norm estimation algorithm.

You should use ALGLIB functions to work with this object.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class normestimatorstate
{
}

</div></pre>
<a name='sub_normestimatorcreate'></a><h3 class=pageheader><code>normestimatorcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This procedure initializes matrix norm estimator.

USAGE:
1. User initializes algorithm state with NormEstimatorCreate() call
2. User calls NormEstimatorEstimateSparse() (or NormEstimatorIteration())
3. User calls NormEstimatorResults() to get solution.

INPUT PARAMETERS:
    M       -   number of rows in the matrix being estimated, M&gt;0
    N       -   number of columns in the matrix being estimated, N&gt;0
    NStart  -   number of random starting vectors
                recommended value - at least 5.
    NIts    -   number of iterations to do with best starting vector
                recommended value - at least 5.

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state


NOTE: this algorithm is effectively deterministic, i.e. it always  returns
same result when repeatedly called for the same matrix. In fact, algorithm
uses randomized starting vectors, but internal  random  numbers  generator
always generates same sequence of the random values (it is a  feature, not
bug).

Algorithm can be made non-deterministic with NormEstimatorSetSeed(0) call.

  -- ALGLIB --
     Copyright 06.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.normestimatorcreate(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> nstart,
    <font color=navy>int</font> nits,
    <font color=navy>out</font> normestimatorstate state)

</div></pre>
<a name='sub_normestimatorestimatesparse'></a><h3 class=pageheader><code>normestimatorestimatesparse</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function estimates norm of the sparse M*N matrix A.

INPUT PARAMETERS:
    State       -   norm estimator state, must be initialized with a  call
                    to NormEstimatorCreate()
    A           -   sparse M*N matrix, must be converted to CRS format
                    prior to calling this function.

After this function  is  over  you can call NormEstimatorResults() to get
estimate of the norm(A).

  -- ALGLIB --
     Copyright 06.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.normestimatorestimatesparse(
    normestimatorstate state,
    sparsematrix a)

</div></pre>
<a name='sub_normestimatorresults'></a><h3 class=pageheader><code>normestimatorresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Matrix norm estimation results

INPUT PARAMETERS:
    State   -   algorithm state

OUTPUT PARAMETERS:
    Nrm     -   estimate of the matrix norm, Nrm&gt;=0

  -- ALGLIB --
     Copyright 06.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.normestimatorresults(
    normestimatorstate state,
    <font color=navy>out</font> <font color=navy>double</font> nrm)

</div></pre>
<a name='sub_normestimatorsetseed'></a><h3 class=pageheader><code>normestimatorsetseed</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function changes seed value used by algorithm. In some cases we  need
deterministic processing, i.e. subsequent calls must return equal results,
in other cases we need non-deterministic algorithm which returns different
results for the same matrix on every pass.

Setting zero seed will lead to non-deterministic algorithm, while non-zero
value will make our algorithm deterministic.

INPUT PARAMETERS:
    State       -   norm estimator state, must be initialized with a  call
                    to NormEstimatorCreate()
    SeedVal     -   seed value, &gt;=0. Zero value = non-deterministic algo.

  -- ALGLIB --
     Copyright 06.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.normestimatorsetseed(
    normestimatorstate state,
    <font color=navy>int</font> seedval)

</div></pre>
<a name=unit_odesolver></a><h2 class=pageheader><code>odesolver</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_odesolverreport' class=toc>odesolverreport</a><br>
<a href='#struct_odesolverstate' class=toc>odesolverstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_odesolverresults' class=toc>odesolverresults</a><br>
<a href='#sub_odesolverrkck' class=toc>odesolverrkck</a><br>
<a href='#sub_odesolversolve' class=toc>odesolversolve</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_odesolver_d1' class=toc>odesolver_d1</a></td><td width=15>&nbsp;</td><td>Solving y'=-y with ODE solver</td></tr>
</table></div>
<a name='struct_odesolverreport'></a><h3 class=pageheader><code>odesolverreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class odesolverreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  nfev;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='struct_odesolverstate'></a><h3 class=pageheader><code>odesolverstate</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class odesolverstate
{
}

</div></pre>
<a name='sub_odesolverresults'></a><h3 class=pageheader><code>odesolverresults</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
ODE solver results

Called after OdeSolverIteration returned False.

INPUT PARAMETERS:
    State   -   algorithm state (used by OdeSolverIteration).

OUTPUT PARAMETERS:
    M       -   number of tabulated values, M&gt;=1
    XTbl    -   array[0..M-1], values of X
    YTbl    -   array[0..M-1,0..N-1], values of Y in X[i]
    Rep     -   solver report:
                * Rep.TerminationType completetion code:
                    * -2    X is not ordered  by  ascending/descending  or
                            there are non-distinct X[],  i.e.  X[i]=X[i+1]
                    * -1    incorrect parameters were specified
                    *  1    task has been solved
                * Rep.NFEV contains number of function calculations

  -- ALGLIB --
     Copyright 01.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.odesolverresults(
    odesolverstate state,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font>[] xtbl,
    <font color=navy>out</font> <font color=navy>double</font>[,] ytbl,
    <font color=navy>out</font> odesolverreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_odesolver_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_odesolverrkck'></a><h3 class=pageheader><code>odesolverrkck</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cash-Karp adaptive ODE solver.

This subroutine solves ODE  Y'=f(Y,x)  with  initial  conditions  Y(xs)=Ys
(here Y may be single variable or vector of N variables).

INPUT PARAMETERS:
    Y       -   initial conditions, array[0..N-1].
                contains values of Y[] at X[0]
    N       -   system size
    X       -   points at which Y should be tabulated, array[0..M-1]
                integrations starts at X[0], ends at X[M-1],  intermediate
                values at X[i] are returned too.
                SHOULD BE ORDERED BY ASCENDING OR BY DESCENDING!
    M       -   number of intermediate points + first point + last point:
                * M&gt;2 means that you need both Y(X[M-1]) and M-2 values at
                  intermediate points
                * M=2 means that you want just to integrate from  X[0]  to
                  X[1] and don't interested in intermediate values.
                * M=1 means that you don't want to integrate :)
                  it is degenerate case, but it will be handled correctly.
                * M&lt;1 means error
    Eps     -   tolerance (absolute/relative error on each  step  will  be
                less than Eps). When passing:
                * Eps&gt;0, it means desired ABSOLUTE error
                * Eps&lt;0, it means desired RELATIVE error.  Relative errors
                  are calculated with respect to maximum values of  Y seen
                  so far. Be careful to use this criterion  when  starting
                  from Y[] that are close to zero.
    H       -   initial  step  lenth,  it  will  be adjusted automatically
                after the first  step.  If  H=0,  step  will  be  selected
                automatically  (usualy  it  will  be  equal  to  0.001  of
                min(x[i]-x[j])).

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state between  subsequent
                calls of OdeSolverIteration. Used for reverse communication.
                This structure should be passed  to the OdeSolverIteration
                subroutine.

SEE ALSO
    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.


  -- ALGLIB --
     Copyright 01.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.odesolverrkck(
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] x,
    <font color=navy>double</font> eps,
    <font color=navy>double</font> h,
    <font color=navy>out</font> odesolverstate state)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.odesolverrkck(
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> m,
    <font color=navy>double</font> eps,
    <font color=navy>double</font> h,
    <font color=navy>out</font> odesolverstate state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_odesolver_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_odesolversolve'></a><h3 class=pageheader><code>odesolversolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function is used to launcn iterations of ODE solver

It accepts following parameters:
    diff    -   callback which calculates dy/dx for given y and x
    ptr     -   optional pointer which is passed to diff; can be NULL


  -- ALGLIB --
     Copyright 01.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> odesolversolve(odesolverstate state, ndimensional_ode_rp diff, object obj)
{
    if( diff==null )
        throw new alglibexception(&quot;ALGLIB: error in 'odesolversolve()' (diff is null)&quot;);
    while( alglib.odesolveriteration(state) )
    {
        if( state.needdy )
        {
            diff(state.innerobj.y, state.innerobj.x, state.innerobj.dy, obj);
            continue;
        }
        throw new alglibexception(&quot;ALGLIB: unexpected error in 'odesolversolve'&quot;);
    }
}
</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_odesolver_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_odesolver_d1'></a><h3 class=pageheader>odesolver_d1 example</h3>
<pre class=source>
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> ode_function_1_diff(<font color=navy>double</font>[] y, <font color=navy>double</font> x, <font color=navy>double</font>[] dy, object obj)
{
    <font color=green>// this callback calculates f(y[],x)=-y[0]</font>
    dy[0] = -y[0];
}
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{1};
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,1,2,3};
    <font color=navy>double</font> eps = 0.00001;
    <font color=navy>double</font> h = 0;
    alglib.odesolverstate s;
    <font color=navy>int</font> m;
    <font color=navy>double</font>[] xtbl;
    <font color=navy>double</font>[,] ytbl;
    alglib.odesolverreport rep;
    alglib.odesolverrkck(y, x, eps, h, <font color=navy>out</font> s);
    alglib.odesolversolve(s, ode_function_1_diff, null);
    alglib.odesolverresults(s, <font color=navy>out</font> m, <font color=navy>out</font> xtbl, <font color=navy>out</font> ytbl, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, m); <font color=green>// EXPECTED: 4</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(xtbl,2)); <font color=green>// EXPECTED: [0, 1, 2, 3]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(ytbl,2)); <font color=green>// EXPECTED: [[1], [0.367], [0.135], [0.050]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_ortfac></a><h2 class=pageheader><code>ortfac</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlq' class=toc>cmatrixlq</a><br>
<a href='#sub_cmatrixlqunpackl' class=toc>cmatrixlqunpackl</a><br>
<a href='#sub_cmatrixlqunpackq' class=toc>cmatrixlqunpackq</a><br>
<a href='#sub_cmatrixqr' class=toc>cmatrixqr</a><br>
<a href='#sub_cmatrixqrunpackq' class=toc>cmatrixqrunpackq</a><br>
<a href='#sub_cmatrixqrunpackr' class=toc>cmatrixqrunpackr</a><br>
<a href='#sub_hmatrixtd' class=toc>hmatrixtd</a><br>
<a href='#sub_hmatrixtdunpackq' class=toc>hmatrixtdunpackq</a><br>
<a href='#sub_rmatrixbd' class=toc>rmatrixbd</a><br>
<a href='#sub_rmatrixbdmultiplybyp' class=toc>rmatrixbdmultiplybyp</a><br>
<a href='#sub_rmatrixbdmultiplybyq' class=toc>rmatrixbdmultiplybyq</a><br>
<a href='#sub_rmatrixbdunpackdiagonals' class=toc>rmatrixbdunpackdiagonals</a><br>
<a href='#sub_rmatrixbdunpackpt' class=toc>rmatrixbdunpackpt</a><br>
<a href='#sub_rmatrixbdunpackq' class=toc>rmatrixbdunpackq</a><br>
<a href='#sub_rmatrixhessenberg' class=toc>rmatrixhessenberg</a><br>
<a href='#sub_rmatrixhessenbergunpackh' class=toc>rmatrixhessenbergunpackh</a><br>
<a href='#sub_rmatrixhessenbergunpackq' class=toc>rmatrixhessenbergunpackq</a><br>
<a href='#sub_rmatrixlq' class=toc>rmatrixlq</a><br>
<a href='#sub_rmatrixlqunpackl' class=toc>rmatrixlqunpackl</a><br>
<a href='#sub_rmatrixlqunpackq' class=toc>rmatrixlqunpackq</a><br>
<a href='#sub_rmatrixqr' class=toc>rmatrixqr</a><br>
<a href='#sub_rmatrixqrunpackq' class=toc>rmatrixqrunpackq</a><br>
<a href='#sub_rmatrixqrunpackr' class=toc>rmatrixqrunpackr</a><br>
<a href='#sub_smatrixtd' class=toc>smatrixtd</a><br>
<a href='#sub_smatrixtdunpackq' class=toc>smatrixtdunpackq</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixlq'></a><h3 class=pageheader><code>cmatrixlq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LQ decomposition of a rectangular complex matrix of size MxN

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices Q and L in compact form
    Tau -   array of scalar factors which are used to form matrix Q. Array
            whose indexes range within [0.. Min(M,N)-1]

Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlq(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] tau)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixlq(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] tau)

</div></pre>
<a name='sub_cmatrixlqunpackl'></a><h3 class=pageheader><code>cmatrixlqunpackl</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix L from the LQ decomposition of a matrix A

Input parameters:
    A       -   matrices Q and L in compact form.
                Output of CMatrixLQ subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    L       -   matrix L, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlqunpackl(
    complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[,] l)

</div></pre>
<a name='sub_cmatrixlqunpackq'></a><h3 class=pageheader><code>cmatrixlqunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A           -   matrices Q and R in compact form.
                    Output of CMatrixLQ subroutine .
    M           -   number of rows in matrix A. M&gt;=0.
    N           -   number of columns in matrix A. N&gt;=0.
    Tau         -   scalar factors which are used to form Q.
                    Output of CMatrixLQ subroutine .
    QRows       -   required number of rows in matrix Q. N&gt;=QColumns&gt;=0.

Output parameters:
    Q           -   first QRows rows of matrix Q.
                    Array whose index ranges within [0..QRows-1, 0..N-1].
                    If QRows=0, array isn't changed.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlqunpackq(
    complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[] tau,
    <font color=navy>int</font> qrows,
    <font color=navy>out</font> complex[,] q)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixlqunpackq(
    complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[] tau,
    <font color=navy>int</font> qrows,
    <font color=navy>out</font> complex[,] q)

</div></pre>
<a name='sub_cmatrixqr'></a><h3 class=pageheader><code>cmatrixqr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
QR decomposition of a rectangular complex matrix of size MxN

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices Q and R in compact form
    Tau -   array of scalar factors which are used to form matrix Q. Array
            whose indexes range within [0.. Min(M,N)-1]

Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixqr(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] tau)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixqr(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] tau)

</div></pre>
<a name='sub_cmatrixqrunpackq'></a><h3 class=pageheader><code>cmatrixqrunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from QR decomposition of a complex matrix A.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A           -   matrices Q and R in compact form.
                    Output of CMatrixQR subroutine .
    M           -   number of rows in matrix A. M&gt;=0.
    N           -   number of columns in matrix A. N&gt;=0.
    Tau         -   scalar factors which are used to form Q.
                    Output of CMatrixQR subroutine .
    QColumns    -   required number of columns in matrix Q. M&gt;=QColumns&gt;=0.

Output parameters:
    Q           -   first QColumns columns of matrix Q.
                    Array whose index ranges within [0..M-1, 0..QColumns-1].
                    If QColumns=0, array isn't changed.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixqrunpackq(
    complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[] tau,
    <font color=navy>int</font> qcolumns,
    <font color=navy>out</font> complex[,] q)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixqrunpackq(
    complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    complex[] tau,
    <font color=navy>int</font> qcolumns,
    <font color=navy>out</font> complex[,] q)

</div></pre>
<a name='sub_cmatrixqrunpackr'></a><h3 class=pageheader><code>cmatrixqrunpackr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix R from the QR decomposition of a matrix A

Input parameters:
    A       -   matrices Q and R in compact form.
                Output of CMatrixQR subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    R       -   matrix R, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixqrunpackr(
    complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[,] r)

</div></pre>
<a name='sub_hmatrixtd'></a><h3 class=pageheader><code>hmatrixtd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
triangular part to a real  tridiagonal  matrix  using  unitary  similarity
transformation: Q'*A*Q = T.


COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix to be transformed
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format. If IsUpper = True, then matrix A is  given
                by its upper triangle, and the lower triangle is not  used
                and not modified by the algorithm, and vice versa
                if IsUpper = False.

Output parameters:
    A       -   matrices T and Q in  compact form (see lower)
    Tau     -   array of factors which are forming matrices H(i)
                array with elements [0..N-2].
    D       -   main diagonal of real symmetric matrix T.
                array with elements [0..N-1].
    E       -   secondary diagonal of real symmetric matrix T.
                array with elements [0..N-2].


  If IsUpper=True, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(n-2) . . . H(2) H(0).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a complex scalar, and v is a complex vector with
  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
  A(0:i-1,i+1), and tau in TAU(i).

  If IsUpper=False, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(0) H(2) . . . H(n-2).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a complex scalar, and v is a complex vector with
  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
  and tau in TAU(i).

  The contents of A on exit are illustrated by the following examples
  with n = 5:

  if UPLO = 'U':                       if UPLO = 'L':

    (  d   e   v1  v2  v3 )              (  d                  )
    (      d   e   v2  v3 )              (  e   d              )
    (          d   e   v3 )              (  v0  e   d          )
    (              d   e  )              (  v0  v1  e   d      )
    (                  d  )              (  v0  v1  v2  e   d  )

where d and e denote diagonal and off-diagonal elements of T, and vi
denotes an element of the vector defining H(i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1992
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hmatrixtd(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> complex[] tau,
    <font color=navy>out</font> <font color=navy>double</font>[] d,
    <font color=navy>out</font> <font color=navy>double</font>[] e)

</div></pre>
<a name='sub_hmatrixtdunpackq'></a><h3 class=pageheader><code>hmatrixtdunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
form.


COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   the result of a HMatrixTD subroutine
    N       -   size of matrix A.
    IsUpper -   storage format (a parameter of HMatrixTD subroutine)
    Tau     -   the result of a HMatrixTD subroutine

Output parameters:
    Q       -   transformation matrix.
                array with elements [0..N-1, 0..N-1].

  -- ALGLIB --
     Copyright 2005-2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hmatrixtdunpackq(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    complex[] tau,
    <font color=navy>out</font> complex[,] q)

</div></pre>
<a name='sub_rmatrixbd'></a><h3 class=pageheader><code>rmatrixbd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a rectangular matrix to  bidiagonal form

The algorithm reduces the rectangular matrix A to  bidiagonal form by
orthogonal transformations P and Q: A = Q*B*(P^T).

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Multithreaded acceleration is NOT supported for this function  because
  ! bidiagonal decompostion is inherently sequential in nature.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   source matrix. array[0..M-1, 0..N-1]
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.

Output parameters:
    A       -   matrices Q, B, P in compact form (see below).
    TauQ    -   scalar factors which are used to form matrix Q.
    TauP    -   scalar factors which are used to form matrix P.

The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
reflections which form MxM matrix Q and NxN matrix P, respectively.

If M&gt;=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).

If M&lt;N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
is stored in A(i,i+1:n-1).

EXAMPLE:

m=6, n=5 (m &gt; n):               m=5, n=6 (m &lt; n):

(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
(  v1  v2  v3  v4  v5 )

Here vi and ui are vectors which form H(i) and G(i), and d and e -
are the diagonal and off-diagonal elements of matrix B.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994.
     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
     pseudocode, 2007-2010.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixbd(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] tauq,
    <font color=navy>out</font> <font color=navy>double</font>[] taup)

</div></pre>
<a name='sub_rmatrixbdmultiplybyp'></a><h3 class=pageheader><code>rmatrixbdmultiplybyp</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication by matrix P which reduces matrix A to  bidiagonal form.

The algorithm allows pre- or post-multiply by P or P'.

Input parameters:
    QP          -   matrices Q and P in compact form.
                    Output of RMatrixBD subroutine.
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    TAUP        -   scalar factors which are used to form P.
                    Output of RMatrixBD subroutine.
    Z           -   multiplied matrix.
                    Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
                    ZRows=N, otherwise ZRows can be arbitrary.
    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
                    ZColumns=N, otherwise ZColumns can be arbitrary.
    FromTheRight -  pre- or post-multiply.
    DoTranspose -   multiply by P or P'.

Output parameters:
    Z - product of Z and P.
                Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
                If ZRows=0 or ZColumns=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixbdmultiplybyp(
    <font color=navy>double</font>[,] qp,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] taup,
    <font color=navy>ref</font> <font color=navy>double</font>[,] z,
    <font color=navy>int</font> zrows,
    <font color=navy>int</font> zcolumns,
    <font color=navy>bool</font> fromtheright,
    <font color=navy>bool</font> dotranspose)

</div></pre>
<a name='sub_rmatrixbdmultiplybyq'></a><h3 class=pageheader><code>rmatrixbdmultiplybyq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication by matrix Q which reduces matrix A to  bidiagonal form.

The algorithm allows pre- or post-multiply by Q or Q'.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    QP          -   matrices Q and P in compact form.
                    Output of ToBidiagonal subroutine.
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    TAUQ        -   scalar factors which are used to form Q.
                    Output of ToBidiagonal subroutine.
    Z           -   multiplied matrix.
                    array[0..ZRows-1,0..ZColumns-1]
    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
                    ZRows=M, otherwise ZRows can be arbitrary.
    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
                    ZColumns=M, otherwise ZColumns can be arbitrary.
    FromTheRight -  pre- or post-multiply.
    DoTranspose -   multiply by Q or Q'.

Output parameters:
    Z           -   product of Z and Q.
                    Array[0..ZRows-1,0..ZColumns-1]
                    If ZRows=0 or ZColumns=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixbdmultiplybyq(
    <font color=navy>double</font>[,] qp,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tauq,
    <font color=navy>ref</font> <font color=navy>double</font>[,] z,
    <font color=navy>int</font> zrows,
    <font color=navy>int</font> zcolumns,
    <font color=navy>bool</font> fromtheright,
    <font color=navy>bool</font> dotranspose)

</div></pre>
<a name='sub_rmatrixbdunpackdiagonals'></a><h3 class=pageheader><code>rmatrixbdunpackdiagonals</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of the main and secondary diagonals of bidiagonal decomposition
of matrix A.

Input parameters:
    B   -   output of RMatrixBD subroutine.
    M   -   number of rows in matrix B.
    N   -   number of columns in matrix B.

Output parameters:
    IsUpper -   True, if the matrix is upper bidiagonal.
                otherwise IsUpper is False.
    D       -   the main diagonal.
                Array whose index ranges within [0..Min(M,N)-1].
    E       -   the secondary diagonal (upper or lower, depending on
                the value of IsUpper).
                Array index ranges within [0..Min(M,N)-1], the last
                element is not used.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixbdunpackdiagonals(
    <font color=navy>double</font>[,] b,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>double</font>[] d,
    <font color=navy>out</font> <font color=navy>double</font>[] e)

</div></pre>
<a name='sub_rmatrixbdunpackpt'></a><h3 class=pageheader><code>rmatrixbdunpackpt</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix P which reduces matrix A to bidiagonal form.
The subroutine returns transposed matrix P.

Input parameters:
    QP      -   matrices Q and P in compact form.
                Output of ToBidiagonal subroutine.
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.
    TAUP    -   scalar factors which are used to form P.
                Output of ToBidiagonal subroutine.
    PTRows  -   required number of rows of matrix P^T. N &gt;= PTRows &gt;= 0.

Output parameters:
    PT      -   first PTRows columns of matrix P^T
                Array[0..PTRows-1, 0..N-1]
                If PTRows=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixbdunpackpt(
    <font color=navy>double</font>[,] qp,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] taup,
    <font color=navy>int</font> ptrows,
    <font color=navy>out</font> <font color=navy>double</font>[,] pt)

</div></pre>
<a name='sub_rmatrixbdunpackq'></a><h3 class=pageheader><code>rmatrixbdunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces a matrix to bidiagonal form.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    QP          -   matrices Q and P in compact form.
                    Output of ToBidiagonal subroutine.
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    TAUQ        -   scalar factors which are used to form Q.
                    Output of ToBidiagonal subroutine.
    QColumns    -   required number of columns in matrix Q.
                    M&gt;=QColumns&gt;=0.

Output parameters:
    Q           -   first QColumns columns of matrix Q.
                    Array[0..M-1, 0..QColumns-1]
                    If QColumns=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixbdunpackq(
    <font color=navy>double</font>[,] qp,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tauq,
    <font color=navy>int</font> qcolumns,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)

</div></pre>
<a name='sub_rmatrixhessenberg'></a><h3 class=pageheader><code>rmatrixhessenberg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
where Q is an orthogonal matrix, H - Hessenberg matrix.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix A with elements [0..N-1, 0..N-1]
    N       -   size of matrix A.

Output parameters:
    A       -   matrices Q and P in  compact form (see below).
    Tau     -   array of scalar factors which are used to form matrix Q.
                Array whose index ranges within [0..N-2]

Matrix H is located on the main diagonal, on the lower secondary  diagonal
and above the main diagonal of matrix A. The elements which are used to
form matrix Q are situated in array Tau and below the lower secondary
diagonal of matrix A as follows:

Matrix Q is represented as a product of elementary reflections

Q = H(0)*H(2)*...*H(n-2),

where each H(i) is given by

H(i) = 1 - tau * v * (v^T)

where tau is a scalar stored in Tau[I]; v - is a real vector,
so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1992
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixhessenberg(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] tau)

</div></pre>
<a name='sub_rmatrixhessenbergunpackh'></a><h3 class=pageheader><code>rmatrixhessenbergunpackh</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)

Input parameters:
    A   -   output of RMatrixHessenberg subroutine.
    N   -   size of matrix A.

Output parameters:
    H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixhessenbergunpackh(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[,] h)

</div></pre>
<a name='sub_rmatrixhessenbergunpackq'></a><h3 class=pageheader><code>rmatrixhessenbergunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces matrix A to upper Hessenberg form

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A   -   output of RMatrixHessenberg subroutine.
    N   -   size of matrix A.
    Tau -   scalar factors which are used to form Q.
            Output of RMatrixHessenberg subroutine.

Output parameters:
    Q   -   matrix Q.
            Array whose indexes range within [0..N-1, 0..N-1].

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixhessenbergunpackq(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tau,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)

</div></pre>
<a name='sub_rmatrixlq'></a><h3 class=pageheader><code>rmatrixlq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LQ decomposition of a rectangular matrix of size MxN

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices L and Q in compact form (see below)
    Tau -   array of scalar factors which are used to form
            matrix Q. Array whose index ranges within [0..Min(M,N)-1].

Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.

The elements of matrix L are located on and below  the  main  diagonal  of
matrix A. The elements which are located in Tau array and above  the  main
diagonal of matrix A are used to form matrix Q as follows:

Matrix Q is represented as a product of elementary reflections

Q = H(k-1)*H(k-2)*...*H(1)*H(0),

where k = min(m,n), and each H(i) is of the form

H(i) = 1 - tau * v * (v^T)

where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlq(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] tau)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixlq(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] tau)

</div></pre>
<a name='sub_rmatrixlqunpackl'></a><h3 class=pageheader><code>rmatrixlqunpackl</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix L from the LQ decomposition of a matrix A

Input parameters:
    A       -   matrices Q and L in compact form.
                Output of RMatrixLQ subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    L       -   matrix L, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlqunpackl(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[,] l)

</div></pre>
<a name='sub_rmatrixlqunpackq'></a><h3 class=pageheader><code>rmatrixlqunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from the LQ decomposition of a matrix A

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrices L and Q in compact form.
                Output of RMatrixLQ subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.
    Tau     -   scalar factors which are used to form Q.
                Output of the RMatrixLQ subroutine.
    QRows   -   required number of rows in matrix Q. N&gt;=QRows&gt;=0.

Output parameters:
    Q       -   first QRows rows of matrix Q. Array whose indexes range
                within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
                unchanged.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlqunpackq(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tau,
    <font color=navy>int</font> qrows,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixlqunpackq(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tau,
    <font color=navy>int</font> qrows,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)

</div></pre>
<a name='sub_rmatrixqr'></a><h3 class=pageheader><code>rmatrixqr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
QR decomposition of a rectangular matrix of size MxN

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices Q and R in compact form (see below).
    Tau -   array of scalar factors which are used to form
            matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].

Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.

The elements of matrix R are located on and above the main diagonal of
matrix A. The elements which are located in Tau array and below the main
diagonal of matrix A are used to form matrix Q as follows:

Matrix Q is represented as a product of elementary reflections

Q = H(0)*H(2)*...*H(k-1),

where k = min(m,n), and each H(i) is in the form

H(i) = 1 - tau * v * (v^T)

where tau is a scalar stored in Tau[I]; v - real vector,
so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixqr(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] tau)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixqr(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] tau)

</div></pre>
<a name='sub_rmatrixqrunpackq'></a><h3 class=pageheader><code>rmatrixqrunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from the QR decomposition of a matrix A

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that QP decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=512,   achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrices Q and R in compact form.
                Output of RMatrixQR subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.
    Tau     -   scalar factors which are used to form Q.
                Output of the RMatrixQR subroutine.
    QColumns -  required number of columns of matrix Q. M&gt;=QColumns&gt;=0.

Output parameters:
    Q       -   first QColumns columns of matrix Q.
                Array whose indexes range within [0..M-1, 0..QColumns-1].
                If QColumns=0, the array remains unchanged.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixqrunpackq(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tau,
    <font color=navy>int</font> qcolumns,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixqrunpackq(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] tau,
    <font color=navy>int</font> qcolumns,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)

</div></pre>
<a name='sub_rmatrixqrunpackr'></a><h3 class=pageheader><code>rmatrixqrunpackr</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix R from the QR decomposition of a matrix A

Input parameters:
    A       -   matrices Q and R in compact form.
                Output of RMatrixQR subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    R       -   matrix R, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixqrunpackr(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[,] r)

</div></pre>
<a name='sub_smatrixtd'></a><h3 class=pageheader><code>smatrixtd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a symmetric matrix which is given by its higher or lower
triangular part to a tridiagonal matrix using orthogonal similarity
transformation: Q'*A*Q=T.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   matrix to be transformed
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format. If IsUpper = True, then matrix A is given
                by its upper triangle, and the lower triangle is not used
                and not modified by the algorithm, and vice versa
                if IsUpper = False.

Output parameters:
    A       -   matrices T and Q in  compact form (see lower)
    Tau     -   array of factors which are forming matrices H(i)
                array with elements [0..N-2].
    D       -   main diagonal of symmetric matrix T.
                array with elements [0..N-1].
    E       -   secondary diagonal of symmetric matrix T.
                array with elements [0..N-2].


  If IsUpper=True, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(n-2) . . . H(2) H(0).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a real scalar, and v is a real vector with
  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
  A(0:i-1,i+1), and tau in TAU(i).

  If IsUpper=False, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(0) H(2) . . . H(n-2).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a real scalar, and v is a real vector with
  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
  and tau in TAU(i).

  The contents of A on exit are illustrated by the following examples
  with n = 5:

  if UPLO = 'U':                       if UPLO = 'L':

    (  d   e   v1  v2  v3 )              (  d                  )
    (      d   e   v2  v3 )              (  e   d              )
    (          d   e   v3 )              (  v0  e   d          )
    (              d   e  )              (  v0  v1  e   d      )
    (                  d  )              (  v0  v1  v2  e   d  )

  where d and e denote diagonal and off-diagonal elements of T, and vi
  denotes an element of the vector defining H(i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1992
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smatrixtd(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>out</font> <font color=navy>double</font>[] tau,
    <font color=navy>out</font> <font color=navy>double</font>[] d,
    <font color=navy>out</font> <font color=navy>double</font>[] e)

</div></pre>
<a name='sub_smatrixtdunpackq'></a><h3 class=pageheader><code>smatrixtdunpackq</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
form.


COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

Input parameters:
    A       -   the result of a SMatrixTD subroutine
    N       -   size of matrix A.
    IsUpper -   storage format (a parameter of SMatrixTD subroutine)
    Tau     -   the result of a SMatrixTD subroutine

Output parameters:
    Q       -   transformation matrix.
                array with elements [0..N-1, 0..N-1].

  -- ALGLIB --
     Copyright 2005-2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smatrixtdunpackq(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] tau,
    <font color=navy>out</font> <font color=navy>double</font>[,] q)

</div></pre>
<a name=unit_parametric></a><h2 class=pageheader><code>parametric</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_pspline2interpolant' class=toc>pspline2interpolant</a><br>
<a href='#struct_pspline3interpolant' class=toc>pspline3interpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_parametricrdpfixed' class=toc>parametricrdpfixed</a><br>
<a href='#sub_pspline2arclength' class=toc>pspline2arclength</a><br>
<a href='#sub_pspline2build' class=toc>pspline2build</a><br>
<a href='#sub_pspline2buildperiodic' class=toc>pspline2buildperiodic</a><br>
<a href='#sub_pspline2calc' class=toc>pspline2calc</a><br>
<a href='#sub_pspline2diff' class=toc>pspline2diff</a><br>
<a href='#sub_pspline2diff2' class=toc>pspline2diff2</a><br>
<a href='#sub_pspline2parametervalues' class=toc>pspline2parametervalues</a><br>
<a href='#sub_pspline2tangent' class=toc>pspline2tangent</a><br>
<a href='#sub_pspline3arclength' class=toc>pspline3arclength</a><br>
<a href='#sub_pspline3build' class=toc>pspline3build</a><br>
<a href='#sub_pspline3buildperiodic' class=toc>pspline3buildperiodic</a><br>
<a href='#sub_pspline3calc' class=toc>pspline3calc</a><br>
<a href='#sub_pspline3diff' class=toc>pspline3diff</a><br>
<a href='#sub_pspline3diff2' class=toc>pspline3diff2</a><br>
<a href='#sub_pspline3parametervalues' class=toc>pspline3parametervalues</a><br>
<a href='#sub_pspline3tangent' class=toc>pspline3tangent</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_parametric_rdp' class=toc>parametric_rdp</a></td><td width=15>&nbsp;</td><td>Parametric Ramer-Douglas-Peucker approximation</td></tr>
</table></div>
<a name='struct_pspline2interpolant'></a><h3 class=pageheader><code>pspline2interpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Parametric spline inteprolant: 2-dimensional curve.

You should not try to access its members directly - use PSpline2XXXXXXXX()
functions instead.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class pspline2interpolant
{
}

</div></pre>
<a name='struct_pspline3interpolant'></a><h3 class=pageheader><code>pspline3interpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Parametric spline inteprolant: 3-dimensional curve.

You should not try to access its members directly - use PSpline3XXXXXXXX()
functions instead.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class pspline3interpolant
{
}

</div></pre>
<a name='sub_parametricrdpfixed'></a><h3 class=pageheader><code>parametricrdpfixed</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
Peucker algorithm. This  function  performs PARAMETRIC fit, i.e. it can be
used to fit curves like circles.

On  input  it  accepts dataset which describes parametric multidimensional
curve X(t), with X being vector, and t taking values in [0,N), where N  is
a number of points in dataset. As result, it returns reduced  dataset  X2,
which can be used to build  parametric  curve  X2(t),  which  approximates
X(t) with desired precision (or has specified number of sections).


INPUT PARAMETERS:
    X       -   array of multidimensional points:
                * at least N elements, leading N elements are used if more
                  than N elements were specified
                * order of points is IMPORTANT because  it  is  parametric
                  fit
                * each row of array is one point which has D coordinates
    N       -   number of elements in X
    D       -   number of dimensions (elements per row of X)
    StopM   -   stopping condition - desired number of sections:
                * at most M sections are generated by this function
                * less than M sections can be generated if we have N&lt;M
                  (or some X are non-distinct).
                * zero StopM means that algorithm does not stop after
                  achieving some pre-specified section count
    StopEps -   stopping condition - desired precision:
                * algorithm stops after error in each section is at most Eps
                * zero Eps means that algorithm does not stop after
                  achieving some pre-specified precision

OUTPUT PARAMETERS:
    X2      -   array of corner points for piecewise approximation,
                has length NSections+1 or zero (for NSections=0).
    Idx2    -   array of indexes (parameter values):
                * has length NSections+1 or zero (for NSections=0).
                * each element of Idx2 corresponds to same-numbered
                  element of X2
                * each element of Idx2 is index of  corresponding  element
                  of X2 at original array X, i.e. I-th  row  of  X2  is
                  Idx2[I]-th row of X.
                * elements of Idx2 can be treated as parameter values
                  which should be used when building new parametric curve
                * Idx2[0]=0, Idx2[NSections]=N-1
    NSections-  number of sections found by algorithm, NSections&lt;=M,
                NSections can be zero for degenerate datasets
                (N&lt;=1 or all X[] are non-distinct).

NOTE: algorithm stops after:
      a) dividing curve into StopM sections
      b) achieving required precision StopEps
      c) dividing curve into N-1 sections
      If both StopM and StopEps are non-zero, algorithm is stopped by  the
      FIRST criterion which is satisfied. In case both StopM  and  StopEps
      are zero, algorithm stops because of (c).

  -- ALGLIB --
     Copyright 02.10.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.parametricrdpfixed(
    <font color=navy>double</font>[,] x,
    <font color=navy>int</font> n,
    <font color=navy>int</font> d,
    <font color=navy>int</font> stopm,
    <font color=navy>double</font> stopeps,
    <font color=navy>out</font> <font color=navy>double</font>[,] x2,
    <font color=navy>out</font> <font color=navy>int</font>[] idx2,
    <font color=navy>out</font> <font color=navy>int</font> nsections)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_parametric_rdp' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pspline2arclength'></a><h3 class=pageheader><code>pspline2arclength</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  arc length, i.e. length of  curve  between  t=a
and t=b.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    A,B -   parameter values corresponding to arc ends:
            * B&gt;A will result in positive length returned
            * B&lt;A will result in negative length returned

RESULT:
    length of arc starting at T=A and ending at T=B.


  -- ALGLIB PROJECT --
     Copyright 30.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.pspline2arclength(
    pspline2interpolant p,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b)

</div></pre>
<a name='sub_pspline2build'></a><h3 class=pageheader><code>pspline2build</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  builds  non-periodic 2-dimensional parametric spline  which
starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).

INPUT PARAMETERS:
    XY  -   points, array[0..N-1,0..1].
            XY[I,0:1] corresponds to the Ith point.
            Order of points is important!
    N   -   points count, N&gt;=5 for Akima splines, N&gt;=2 for other types  of
            splines.
    ST  -   spline type:
            * 0     Akima spline
            * 1     parabolically terminated Catmull-Rom spline (Tension=0)
            * 2     parabolically terminated cubic spline
    PT  -   parameterization type:
            * 0     uniform
            * 1     chord length
            * 2     centripetal

OUTPUT PARAMETERS:
    P   -   parametric spline interpolant


NOTES:
* this function  assumes  that  there all consequent points  are distinct.
  I.e. (x0,y0)&lt;&gt;(x1,y1),  (x1,y1)&lt;&gt;(x2,y2),  (x2,y2)&lt;&gt;(x3,y3)  and  so on.
  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
  =(x2,y2).

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2build(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> st,
    <font color=navy>int</font> pt,
    <font color=navy>out</font> pspline2interpolant p)

</div></pre>
<a name='sub_pspline2buildperiodic'></a><h3 class=pageheader><code>pspline2buildperiodic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  builds  periodic  2-dimensional  parametric  spline  which
starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
back to (X[0],Y[0]).

INPUT PARAMETERS:
    XY  -   points, array[0..N-1,0..1].
            XY[I,0:1] corresponds to the Ith point.
            XY[N-1,0:1] must be different from XY[0,0:1].
            Order of points is important!
    N   -   points count, N&gt;=3 for other types of splines.
    ST  -   spline type:
            * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
            * 2     cubic spline with cyclic boundary conditions
    PT  -   parameterization type:
            * 0     uniform
            * 1     chord length
            * 2     centripetal

OUTPUT PARAMETERS:
    P   -   parametric spline interpolant


NOTES:
* this function  assumes  that there all consequent points  are  distinct.
  I.e. (x0,y0)&lt;&gt;(x1,y1), (x1,y1)&lt;&gt;(x2,y2),  (x2,y2)&lt;&gt;(x3,y3)  and  so  on.
  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
  =(x2,y2).
* last point of sequence is NOT equal to the first  point.  You  shouldn't
  make curve &quot;explicitly periodic&quot; by making them equal.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2buildperiodic(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> st,
    <font color=navy>int</font> pt,
    <font color=navy>out</font> pspline2interpolant p)

</div></pre>
<a name='sub_pspline2calc'></a><h3 class=pageheader><code>pspline2calc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  the value of the parametric spline for a  given
value of parameter T

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-position
    Y   -   Y-position


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2calc(
    pspline2interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> y)

</div></pre>
<a name='sub_pspline2diff'></a><h3 class=pageheader><code>pspline2diff</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates derivative, i.e. it returns (dX/dT,dY/dT).

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   X-derivative
    Y   -   Y-value
    DY  -   Y-derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2diff(
    pspline2interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> dx,
    <font color=navy>out</font> <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> dy)

</div></pre>
<a name='sub_pspline2diff2'></a><h3 class=pageheader><code>pspline2diff2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates first and second derivative with respect to T.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   derivative
    D2X -   second derivative
    Y   -   Y-value
    DY  -   derivative
    D2Y -   second derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2diff2(
    pspline2interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> dx,
    <font color=navy>out</font> <font color=navy>double</font> d2x,
    <font color=navy>out</font> <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> dy,
    <font color=navy>out</font> <font color=navy>double</font> d2y)

</div></pre>
<a name='sub_pspline2parametervalues'></a><h3 class=pageheader><code>pspline2parametervalues</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns vector of parameter values correspoding to points.

I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
have
    (X[0],Y[0]) = PSpline2Calc(P,U[0]),
    (X[1],Y[1]) = PSpline2Calc(P,U[1]),
    (X[2],Y[2]) = PSpline2Calc(P,U[2]),
    ...

INPUT PARAMETERS:
    P   -   parametric spline interpolant

OUTPUT PARAMETERS:
    N   -   array size
    T   -   array[0..N-1]


NOTES:
* for non-periodic splines U[0]=0, U[0]&lt;U[1]&lt;...&lt;U[N-1], U[N-1]=1
* for periodic splines     U[0]=0, U[0]&lt;U[1]&lt;...&lt;U[N-1], U[N-1]&lt;1

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2parametervalues(
    pspline2interpolant p,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] t)

</div></pre>
<a name='sub_pspline2tangent'></a><h3 class=pageheader><code>pspline2tangent</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  tangent vector for a given value of parameter T

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X    -   X-component of tangent vector (normalized)
    Y    -   Y-component of tangent vector (normalized)

NOTE:
    X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline2tangent(
    pspline2interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> y)

</div></pre>
<a name='sub_pspline3arclength'></a><h3 class=pageheader><code>pspline3arclength</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  arc length, i.e. length of  curve  between  t=a
and t=b.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    A,B -   parameter values corresponding to arc ends:
            * B&gt;A will result in positive length returned
            * B&lt;A will result in negative length returned

RESULT:
    length of arc starting at T=A and ending at T=B.


  -- ALGLIB PROJECT --
     Copyright 30.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.pspline3arclength(
    pspline3interpolant p,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b)

</div></pre>
<a name='sub_pspline3build'></a><h3 class=pageheader><code>pspline3build</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  builds  non-periodic 3-dimensional parametric spline  which
starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).

Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
description here.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3build(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> st,
    <font color=navy>int</font> pt,
    <font color=navy>out</font> pspline3interpolant p)

</div></pre>
<a name='sub_pspline3buildperiodic'></a><h3 class=pageheader><code>pspline3buildperiodic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  builds  periodic  3-dimensional  parametric  spline  which
starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
and then back to (X[0],Y[0],Z[0]).

Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
description here.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3buildperiodic(
    <font color=navy>double</font>[,] xy,
    <font color=navy>int</font> n,
    <font color=navy>int</font> st,
    <font color=navy>int</font> pt,
    <font color=navy>out</font> pspline3interpolant p)

</div></pre>
<a name='sub_pspline3calc'></a><h3 class=pageheader><code>pspline3calc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  the value of the parametric spline for a  given
value of parameter T.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-position
    Y   -   Y-position
    Z   -   Z-position


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3calc(
    pspline3interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> z)

</div></pre>
<a name='sub_pspline3diff'></a><h3 class=pageheader><code>pspline3diff</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   X-derivative
    Y   -   Y-value
    DY  -   Y-derivative
    Z   -   Z-value
    DZ  -   Z-derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3diff(
    pspline3interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> dx,
    <font color=navy>out</font> <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> dy,
    <font color=navy>out</font> <font color=navy>double</font> z,
    <font color=navy>out</font> <font color=navy>double</font> dz)

</div></pre>
<a name='sub_pspline3diff2'></a><h3 class=pageheader><code>pspline3diff2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates first and second derivative with respect to T.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   derivative
    D2X -   second derivative
    Y   -   Y-value
    DY  -   derivative
    D2Y -   second derivative
    Z   -   Z-value
    DZ  -   derivative
    D2Z -   second derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3diff2(
    pspline3interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> dx,
    <font color=navy>out</font> <font color=navy>double</font> d2x,
    <font color=navy>out</font> <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> dy,
    <font color=navy>out</font> <font color=navy>double</font> d2y,
    <font color=navy>out</font> <font color=navy>double</font> z,
    <font color=navy>out</font> <font color=navy>double</font> dz,
    <font color=navy>out</font> <font color=navy>double</font> d2z)

</div></pre>
<a name='sub_pspline3parametervalues'></a><h3 class=pageheader><code>pspline3parametervalues</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns vector of parameter values correspoding to points.

Same as PSpline2ParameterValues(), but for 3D.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3parametervalues(
    pspline3interpolant p,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] t)

</div></pre>
<a name='sub_pspline3tangent'></a><h3 class=pageheader><code>pspline3tangent</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  tangent vector for a given value of parameter T

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X    -   X-component of tangent vector (normalized)
    Y    -   Y-component of tangent vector (normalized)
    Z    -   Z-component of tangent vector (normalized)

NOTE:
    X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pspline3tangent(
    pspline3interpolant p,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> z)

</div></pre>
<a name='example_parametric_rdp'></a><h3 class=pageheader>parametric_rdp example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use RDP algorithm to approximate parametric 2D curve given by</font>
    <font color=green>// locations in t=0,1,2,3 (see below), which form piecewise linear</font>
    <font color=green>// trajectory through D-dimensional space (2-dimensional in our example).</font>
    <font color=green>// </font>
    <font color=green>//     |</font>
    <font color=green>//     |</font>
    <font color=green>//     -     *     *     X2................X3</font>
    <font color=green>//     |                .</font>
    <font color=green>//     |               .</font>
    <font color=green>//     -     *     *  .  *     *     *     *</font>
    <font color=green>//     |             .</font>
    <font color=green>//     |            .</font>
    <font color=green>//     -     *     X1    *     *     *     *</font>
    <font color=green>//     |      .....</font>
    <font color=green>//     |  ....</font>
    <font color=green>//     X0----|-----|-----|-----|-----|-----|---</font>
    <font color=green>//</font>
    <font color=navy>int</font> npoints = 4;
    <font color=navy>int</font> ndimensions = 2;
    <font color=navy>double</font>[,] x = new <font color=navy>double</font>[,]{{0,0},{2,1},{3,3},{6,3}};

    <font color=green>//</font>
    <font color=green>// Approximation of parametric curve is performed by another parametric curve</font>
    <font color=green>// with lesser amount of points. It allows to work with <font color=blue><b>&quot;compressed&quot;</b></font></font>
    <font color=green>// representation, which needs smaller amount of memory. Say, in our example</font>
    <font color=green>// (we allow points with error smaller than 0.8) approximation will have</font>
    <font color=green>// just two sequential sections connecting X0 with X2, and X2 with X3.</font>
    <font color=green>// </font>
    <font color=green>//     |</font>
    <font color=green>//     |</font>
    <font color=green>//     -     *     *     X2................X3</font>
    <font color=green>//     |               . </font>
    <font color=green>//     |             .  </font>
    <font color=green>//     -     *     .     *     *     *     *</font>
    <font color=green>//     |         .    </font>
    <font color=green>//     |       .     </font>
    <font color=green>//     -     .     X1    *     *     *     *</font>
    <font color=green>//     |   .       </font>
    <font color=green>//     | .    </font>
    <font color=green>//     X0----|-----|-----|-----|-----|-----|---</font>
    <font color=green>//</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] y;
    <font color=navy>int</font>[] idxy;
    <font color=navy>int</font> nsections;
    <font color=navy>int</font> limitcnt = 0;
    <font color=navy>double</font> limiteps = 0.8;
    alglib.parametricrdpfixed(x, npoints, ndimensions, limitcnt, limiteps, <font color=navy>out</font> y, <font color=navy>out</font> idxy, <font color=navy>out</font> nsections);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, nsections); <font color=green>// EXPECTED: 2</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(idxy)); <font color=green>// EXPECTED: [0,2,3]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_pca></a><h2 class=pageheader><code>pca</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_pcabuildbasis' class=toc>pcabuildbasis</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_pcabuildbasis'></a><h3 class=pageheader><code>pcabuildbasis</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Principal components analysis

Subroutine  builds  orthogonal  basis  where  first  axis  corresponds  to
direction with maximum variance, second axis maximizes variance in subspace
orthogonal to first axis and so on.

It should be noted that, unlike LDA, PCA does not use class labels.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison. Best results are achieved  for  high-dimensional  problems
  ! (NVars is at least 256).
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    X           -   dataset, array[0..NPoints-1,0..NVars-1].
                    matrix contains ONLY INDEPENDENT VARIABLES.
    NPoints     -   dataset size, NPoints&gt;=0
    NVars       -   number of independent variables, NVars&gt;=1

OUTPUT PARAMETERS:
    Info        -   return code:
                    * -4, if SVD subroutine haven't converged
                    * -1, if wrong parameters has been passed (NPoints&lt;0,
                          NVars&lt;1)
                    *  1, if task is solved
    S2          -   array[0..NVars-1]. variance values corresponding
                    to basis vectors.
    V           -   array[0..NVars-1,0..NVars-1]
                    matrix, whose columns store basis vectors.

  -- ALGLIB --
     Copyright 25.08.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.pcabuildbasis(
    <font color=navy>double</font>[,] x,
    <font color=navy>int</font> npoints,
    <font color=navy>int</font> nvars,
    <font color=navy>out</font> <font color=navy>int</font> info,
    <font color=navy>out</font> <font color=navy>double</font>[] s2,
    <font color=navy>out</font> <font color=navy>double</font>[,] v)

</div></pre>
<a name=unit_poissondistr></a><h2 class=pageheader><code>poissondistr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_invpoissondistribution' class=toc>invpoissondistribution</a><br>
<a href='#sub_poissoncdistribution' class=toc>poissoncdistribution</a><br>
<a href='#sub_poissondistribution' class=toc>poissondistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_invpoissondistribution'></a><h3 class=pageheader><code>invpoissondistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse Poisson distribution

Finds the Poisson variable x such that the integral
from 0 to x of the Poisson density is equal to the
given probability y.

This is accomplished using the inverse gamma integral
function and the relation

   m = igami( k+1, y ).

ACCURACY:

See inverse incomplete gamma function

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invpoissondistribution(<font color=navy>int</font> k, <font color=navy>double</font> y)

</div></pre>
<a name='sub_poissoncdistribution'></a><h3 class=pageheader><code>poissoncdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complemented Poisson distribution

Returns the sum of the terms k+1 to infinity of the Poisson
distribution:

 inf.       j
  --   -m  m
  &gt;   e    --
  --       j!
 j=k+1

The terms are not summed directly; instead the incomplete
gamma integral is employed, according to the formula

y = pdtrc( k, m ) = igam( k+1, m ).

The arguments must both be positive.

ACCURACY:

See incomplete gamma function

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.poissoncdistribution(<font color=navy>int</font> k, <font color=navy>double</font> m)

</div></pre>
<a name='sub_poissondistribution'></a><h3 class=pageheader><code>poissondistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Poisson distribution

Returns the sum of the first k+1 terms of the Poisson
distribution:

  k         j
  --   -m  m
  &gt;   e    --
  --       j!
 j=0

The terms are not summed directly; instead the incomplete
gamma integral is employed, according to the relation

y = pdtr( k, m ) = igamc( k+1, m ).

The arguments must both be positive.
ACCURACY:

See incomplete gamma function

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.poissondistribution(<font color=navy>int</font> k, <font color=navy>double</font> m)

</div></pre>
<a name=unit_polint></a><h2 class=pageheader><code>polint</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_polynomialbar2cheb' class=toc>polynomialbar2cheb</a><br>
<a href='#sub_polynomialbar2pow' class=toc>polynomialbar2pow</a><br>
<a href='#sub_polynomialbuild' class=toc>polynomialbuild</a><br>
<a href='#sub_polynomialbuildcheb1' class=toc>polynomialbuildcheb1</a><br>
<a href='#sub_polynomialbuildcheb2' class=toc>polynomialbuildcheb2</a><br>
<a href='#sub_polynomialbuildeqdist' class=toc>polynomialbuildeqdist</a><br>
<a href='#sub_polynomialcalccheb1' class=toc>polynomialcalccheb1</a><br>
<a href='#sub_polynomialcalccheb2' class=toc>polynomialcalccheb2</a><br>
<a href='#sub_polynomialcalceqdist' class=toc>polynomialcalceqdist</a><br>
<a href='#sub_polynomialcheb2bar' class=toc>polynomialcheb2bar</a><br>
<a href='#sub_polynomialpow2bar' class=toc>polynomialpow2bar</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_polint_d_calcdiff' class=toc>polint_d_calcdiff</a></td><td width=15>&nbsp;</td><td>Interpolation and differentiation using barycentric representation</td></tr>
<tr align=left valign=top><td><a href='#example_polint_d_conv' class=toc>polint_d_conv</a></td><td width=15>&nbsp;</td><td>Conversion between power basis and barycentric representation</td></tr>
<tr align=left valign=top><td><a href='#example_polint_d_spec' class=toc>polint_d_spec</a></td><td width=15>&nbsp;</td><td>Polynomial interpolation on special grids (equidistant, Chebyshev I/II)</td></tr>
</table></div>
<a name='sub_polynomialbar2cheb'></a><h3 class=pageheader><code>polynomialbar2cheb</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conversion from barycentric representation to Chebyshev basis.
This function has O(N^2) complexity.

INPUT PARAMETERS:
    P   -   polynomial in barycentric form
    A,B -   base interval for Chebyshev polynomials (see below)
            A&lt;&gt;B

OUTPUT PARAMETERS
    T   -   coefficients of Chebyshev representation;
            P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
            where Ti - I-th Chebyshev polynomial.

NOTES:
    barycentric interpolant passed as P may be either polynomial  obtained
    from  polynomial  interpolation/ fitting or rational function which is
    NOT polynomial. We can't distinguish between these two cases, and this
    algorithm just tries to work assuming that P IS a polynomial.  If not,
    algorithm will return results, but they won't have any meaning.

  -- ALGLIB --
     Copyright 30.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbar2cheb(
    barycentricinterpolant p,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> <font color=navy>double</font>[] t)

</div></pre>
<a name='sub_polynomialbar2pow'></a><h3 class=pageheader><code>polynomialbar2pow</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conversion from barycentric representation to power basis.
This function has O(N^2) complexity.

INPUT PARAMETERS:
    P   -   polynomial in barycentric form
    C   -   offset (see below); 0.0 is used as default value.
    S   -   scale (see below);  1.0 is used as default value. S&lt;&gt;0.

OUTPUT PARAMETERS
    A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
    N   -   number of coefficients (polynomial degree plus 1)

NOTES:
1.  this function accepts offset and scale, which can be  set  to  improve
    numerical properties of polynomial. For example, if P was obtained  as
    result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
    represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
    is exactly what you need.

    However, if your interpolation model was built on [999,1001], you will
    see significant growth of numerical errors when using {1, x, x^2, x^3}
    as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
    will be better option. Such representation can be  obtained  by  using
    1000.0 as offset C and 1.0 as scale S.

2.  power basis is ill-conditioned and tricks described above can't  solve
    this problem completely. This function  will  return  coefficients  in
    any  case,  but  for  N&gt;8  they  will  become unreliable. However, N's
    less than 5 are pretty safe.

3.  barycentric interpolant passed as P may be either polynomial  obtained
    from  polynomial  interpolation/ fitting or rational function which is
    NOT polynomial. We can't distinguish between these two cases, and this
    algorithm just tries to work assuming that P IS a polynomial.  If not,
    algorithm will return results, but they won't have any meaning.

  -- ALGLIB --
     Copyright 30.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbar2pow(
    barycentricinterpolant p,
    <font color=navy>out</font> <font color=navy>double</font>[] a)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbar2pow(
    barycentricinterpolant p,
    <font color=navy>double</font> c,
    <font color=navy>double</font> s,
    <font color=navy>out</font> <font color=navy>double</font>[] a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_conv' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuild'></a><h3 class=pageheader><code>polynomialbuild</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant: generation of the model on the general grid.
This function has O(N^2) complexity.

INPUT PARAMETERS:
    X   -   abscissas, array[0..N-1]
    Y   -   function values, array[0..N-1]
    N   -   number of points, N&gt;=1

OUTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuild(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> barycentricinterpolant p)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuild(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> barycentricinterpolant p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_calcdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildcheb1'></a><h3 class=pageheader><code>polynomialbuildcheb1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant on Chebyshev grid (first kind).
This function has O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    Y   -   function values at the nodes, array[0..N-1],
            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
    N   -   number of points, N&gt;=1
            for N=1 a constant model is constructed.

OUTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 03.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuildcheb1(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> barycentricinterpolant p)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuildcheb1(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> barycentricinterpolant p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildcheb2'></a><h3 class=pageheader><code>polynomialbuildcheb2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant on Chebyshev grid (second kind).
This function has O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    Y   -   function values at the nodes, array[0..N-1],
            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
    N   -   number of points, N&gt;=1
            for N=1 a constant model is constructed.

OUTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 03.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuildcheb2(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> barycentricinterpolant p)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuildcheb2(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> barycentricinterpolant p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildeqdist'></a><h3 class=pageheader><code>polynomialbuildeqdist</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant: generation of the model on equidistant grid.
This function has O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    Y   -   function values at the nodes, array[0..N-1]
    N   -   number of points, N&gt;=1
            for N=1 a constant model is constructed.

OUTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 03.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuildeqdist(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> barycentricinterpolant p)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialbuildeqdist(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> barycentricinterpolant p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalccheb1'></a><h3 class=pageheader><code>polynomialcalccheb1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fast polynomial interpolation function on Chebyshev points (first kind)
with O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    F   -   function values, array[0..N-1]
    N   -   number of points on Chebyshev grid (first kind),
            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
            for N=1 a constant model is constructed.
    T   -   position where P(x) is calculated

RESULT
    value of the Lagrange interpolant at T

IMPORTANT
    this function provides fast interface which is not overflow-safe
    nor it is very precise.
    the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
    subroutines unless you are pretty sure that your data will not result
    in overflow.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.polynomialcalccheb1(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] f,
    <font color=navy>double</font> t)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.polynomialcalccheb1(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] f,
    <font color=navy>int</font> n,
    <font color=navy>double</font> t)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalccheb2'></a><h3 class=pageheader><code>polynomialcalccheb2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fast polynomial interpolation function on Chebyshev points (second kind)
with O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    F   -   function values, array[0..N-1]
    N   -   number of points on Chebyshev grid (second kind),
            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
            for N=1 a constant model is constructed.
    T   -   position where P(x) is calculated

RESULT
    value of the Lagrange interpolant at T

IMPORTANT
    this function provides fast interface which is not overflow-safe
    nor it is very precise.
    the best option is to use PolIntBuildCheb2()/BarycentricCalc()
    subroutines unless you are pretty sure that your data will not result
    in overflow.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.polynomialcalccheb2(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] f,
    <font color=navy>double</font> t)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.polynomialcalccheb2(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] f,
    <font color=navy>int</font> n,
    <font color=navy>double</font> t)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalceqdist'></a><h3 class=pageheader><code>polynomialcalceqdist</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fast equidistant polynomial interpolation function with O(N) complexity

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    F   -   function values, array[0..N-1]
    N   -   number of points on equidistant grid, N&gt;=1
            for N=1 a constant model is constructed.
    T   -   position where P(x) is calculated

RESULT
    value of the Lagrange interpolant at T

IMPORTANT
    this function provides fast interface which is not overflow-safe
    nor it is very precise.
    the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
    subroutines unless you are pretty sure that your data will not result
    in overflow.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.polynomialcalceqdist(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] f,
    <font color=navy>double</font> t)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.polynomialcalceqdist(
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>double</font>[] f,
    <font color=navy>int</font> n,
    <font color=navy>double</font> t)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcheb2bar'></a><h3 class=pageheader><code>polynomialcheb2bar</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conversion from Chebyshev basis to barycentric representation.
This function has O(N^2) complexity.

INPUT PARAMETERS:
    T   -   coefficients of Chebyshev representation;
            P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
            where Ti - I-th Chebyshev polynomial.
    N   -   number of coefficients:
            * if given, only leading N elements of T are used
            * if not given, automatically determined from size of T
    A,B -   base interval for Chebyshev polynomials (see above)
            A&lt;B

OUTPUT PARAMETERS
    P   -   polynomial in barycentric form

  -- ALGLIB --
     Copyright 30.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialcheb2bar(
    <font color=navy>double</font>[] t,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> barycentricinterpolant p)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialcheb2bar(
    <font color=navy>double</font>[] t,
    <font color=navy>int</font> n,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b,
    <font color=navy>out</font> barycentricinterpolant p)

</div></pre>
<a name='sub_polynomialpow2bar'></a><h3 class=pageheader><code>polynomialpow2bar</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conversion from power basis to barycentric representation.
This function has O(N^2) complexity.

INPUT PARAMETERS:
    A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
    N   -   number of coefficients (polynomial degree plus 1)
            * if given, only leading N elements of A are used
            * if not given, automatically determined from size of A
    C   -   offset (see below); 0.0 is used as default value.
    S   -   scale (see below);  1.0 is used as default value. S&lt;&gt;0.

OUTPUT PARAMETERS
    P   -   polynomial in barycentric form


NOTES:
1.  this function accepts offset and scale, which can be  set  to  improve
    numerical properties of polynomial. For example, if you interpolate on
    [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
    x^3 and so on. In most cases you it is exactly what you need.

    However, if your interpolation model was built on [999,1001], you will
    see significant growth of numerical errors when using {1, x, x^2, x^3}
    as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
    (x-1000)^3 will be better option (you have to specify 1000.0 as offset
    C and 1.0 as scale S).

2.  power basis is ill-conditioned and tricks described above can't  solve
    this problem completely. This function  will  return barycentric model
    in any case, but for N&gt;8 accuracy well degrade. However, N's less than
    5 are pretty safe.

  -- ALGLIB --
     Copyright 30.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialpow2bar(
    <font color=navy>double</font>[] a,
    <font color=navy>out</font> barycentricinterpolant p)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialpow2bar(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font> n,
    <font color=navy>double</font> c,
    <font color=navy>double</font> s,
    <font color=navy>out</font> barycentricinterpolant p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_conv' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_polint_d_calcdiff'></a><h3 class=pageheader>polint_d_calcdiff example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Here we demonstrate polynomial interpolation and differentiation</font>
    <font color=green>// of y=x^2-x sampled at [0,1,2]. Barycentric representation of polynomial is used.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,1,2};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0,0,2};
    <font color=navy>double</font> t = -1;
    <font color=navy>double</font> v;
    <font color=navy>double</font> dv;
    <font color=navy>double</font> d2v;
    alglib.barycentricinterpolant p;

    <font color=green>// barycentric model is created</font>
    alglib.polynomialbuild(x, y, <font color=navy>out</font> p);

    <font color=green>// barycentric interpolation is demonstrated</font>
    v = alglib.barycentriccalc(p, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0</font>

    <font color=green>// barycentric differentation is demonstrated</font>
    alglib.barycentricdiff1(p, t, <font color=navy>out</font> v, <font color=navy>out</font> dv);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, dv); <font color=green>// EXPECTED: -3.0</font>

    <font color=green>// second derivatives with barycentric representation</font>
    alglib.barycentricdiff1(p, t, <font color=navy>out</font> v, <font color=navy>out</font> dv);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, dv); <font color=green>// EXPECTED: -3.0</font>
    alglib.barycentricdiff2(p, t, <font color=navy>out</font> v, <font color=navy>out</font> dv, <font color=navy>out</font> d2v);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, dv); <font color=green>// EXPECTED: -3.0</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, d2v); <font color=green>// EXPECTED: 2.0</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_polint_d_conv'></a><h3 class=pageheader>polint_d_conv example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Here we demonstrate conversion of y=x^2-x</font>
    <font color=green>// between power basis and barycentric representation.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] a = new <font color=navy>double</font>[]{0,-1,+1};
    <font color=navy>double</font> t = 2;
    <font color=navy>double</font>[] a2;
    <font color=navy>double</font> v;
    alglib.barycentricinterpolant p;

    <font color=green>//</font>
    <font color=green>// a=[0,-1,+1] is decomposition of y=x^2-x in the power basis:</font>
    <font color=green>//</font>
    <font color=green>//     y = 0 - 1*x + 1*x^2</font>
    <font color=green>//</font>
    <font color=green>// We convert it to the barycentric form.</font>
    <font color=green>//</font>
    alglib.polynomialpow2bar(a, <font color=navy>out</font> p);

    <font color=green>// now we have barycentric interpolation; we can use it <font color=navy>for</font> interpolation</font>
    v = alglib.barycentriccalc(p, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0</font>

    <font color=green>// we can also convert back from barycentric representation to power basis</font>
    alglib.polynomialbar2pow(p, <font color=navy>out</font> a2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a2,2)); <font color=green>// EXPECTED: [0,-1,+1]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_polint_d_spec'></a><h3 class=pageheader>polint_d_spec example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Temporaries:</font>
    <font color=green>// * values of y=x^2-x sampled at three special grids:</font>
    <font color=green>//   * equdistant grid spanning [0,2],     x[i] = 2*i/(N-1), i=0..N-1</font>
    <font color=green>//   * Chebyshev-I grid spanning [-1,+1],  x[i] = 1 + Cos(PI*(2*i+1)/(2*n)), i=0..N-1</font>
    <font color=green>//   * Chebyshev-II grid spanning [-1,+1], x[i] = 1 + Cos(PI*i/(n-1)), i=0..N-1</font>
    <font color=green>// * barycentric interpolants <font color=navy>for</font> these three grids</font>
    <font color=green>// * vectors to store coefficients of quadratic representation</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] y_eqdist = new <font color=navy>double</font>[]{0,0,2};
    <font color=navy>double</font>[] y_cheb1 = new <font color=navy>double</font>[]{-0.116025,0.000000,1.616025};
    <font color=navy>double</font>[] y_cheb2 = new <font color=navy>double</font>[]{0,0,2};
    alglib.barycentricinterpolant p_eqdist;
    alglib.barycentricinterpolant p_cheb1;
    alglib.barycentricinterpolant p_cheb2;
    <font color=navy>double</font>[] a_eqdist;
    <font color=navy>double</font>[] a_cheb1;
    <font color=navy>double</font>[] a_cheb2;

    <font color=green>//</font>
    <font color=green>// First, we demonstrate construction of barycentric interpolants on</font>
    <font color=green>// special grids. We unpack power representation to ensure that</font>
    <font color=green>// interpolant was built correctly.</font>
    <font color=green>//</font>
    <font color=green>// In all three cases we should get same quadratic function.</font>
    <font color=green>//</font>
    alglib.polynomialbuildeqdist(0.0, 2.0, y_eqdist, <font color=navy>out</font> p_eqdist);
    alglib.polynomialbar2pow(p_eqdist, <font color=navy>out</font> a_eqdist);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a_eqdist,4)); <font color=green>// EXPECTED: [0,-1,+1]</font>

    alglib.polynomialbuildcheb1(-1, +1, y_cheb1, <font color=navy>out</font> p_cheb1);
    alglib.polynomialbar2pow(p_cheb1, <font color=navy>out</font> a_cheb1);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a_cheb1,4)); <font color=green>// EXPECTED: [0,-1,+1]</font>

    alglib.polynomialbuildcheb2(-1, +1, y_cheb2, <font color=navy>out</font> p_cheb2);
    alglib.polynomialbar2pow(p_cheb2, <font color=navy>out</font> a_cheb2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(a_cheb2,4)); <font color=green>// EXPECTED: [0,-1,+1]</font>

    <font color=green>//</font>
    <font color=green>// Now we demonstrate polynomial interpolation without construction </font>
    <font color=green>// of the barycentricinterpolant structure.</font>
    <font color=green>//</font>
    <font color=green>// We calculate interpolant value at x=-2.</font>
    <font color=green>// In all three cases we should get same f=6</font>
    <font color=green>//</font>
    <font color=navy>double</font> t = -2;
    <font color=navy>double</font> v;
    v = alglib.polynomialcalceqdist(0.0, 2.0, y_eqdist, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 6.0</font>

    v = alglib.polynomialcalccheb1(-1, +1, y_cheb1, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 6.0</font>

    v = alglib.polynomialcalccheb2(-1, +1, y_cheb2, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 6.0</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_polynomialsolver></a><h2 class=pageheader><code>polynomialsolver</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_polynomialsolverreport' class=toc>polynomialsolverreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_polynomialsolve' class=toc>polynomialsolve</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_polynomialsolverreport'></a><h3 class=pageheader><code>polynomialsolverreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class polynomialsolverreport
{
    <font color=navy>public</font> <font color=navy>double</font>               maxerr;
}

</div></pre>
<a name='sub_polynomialsolve'></a><h3 class=pageheader><code>polynomialsolve</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Polynomial root finding.

This function returns all roots of the polynomial
    P(x) = a0 + a1*x + a2*x^2 + ... + an*x^n
Both real and complex roots are returned (see below).

INPUT PARAMETERS:
    A       -   array[N+1], polynomial coefficients:
                * A[0] is constant term
                * A[N] is a coefficient of X^N
    N       -   polynomial degree

OUTPUT PARAMETERS:
    X       -   array of complex roots:
                * for isolated real root, X[I] is strictly real: IMAGE(X[I])=0
                * complex roots are always returned in pairs - roots occupy
                  positions I and I+1, with:
                  * X[I+1]=Conj(X[I])
                  * IMAGE(X[I]) &gt; 0
                  * IMAGE(X[I+1]) = -IMAGE(X[I]) &lt; 0
                * multiple real roots may have non-zero imaginary part due
                  to roundoff errors. There is no reliable way to distinguish
                  real root of multiplicity 2 from two  complex  roots  in
                  the presence of roundoff errors.
    Rep     -   report, additional information, following fields are set:
                * Rep.MaxErr - max( |P(xi)| )  for  i=0..N-1.  This  field
                  allows to quickly estimate &quot;quality&quot; of the roots  being
                  returned.

NOTE:   this function uses companion matrix method to find roots. In  case
        internal EVD  solver  fails  do  find  eigenvalues,  exception  is
        generated.

NOTE:   roots are not &quot;polished&quot; and  no  matrix  balancing  is  performed
        for them.

  -- ALGLIB --
     Copyright 24.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.polynomialsolve(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[] x,
    <font color=navy>out</font> polynomialsolverreport rep)

</div></pre>
<a name=unit_psif></a><h2 class=pageheader><code>psif</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_psi' class=toc>psi</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_psi'></a><h3 class=pageheader><code>psi</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Psi (digamma) function

             d      -
  psi(x)  =  -- ln | (x)
             dx

is the logarithmic derivative of the gamma function.
For integer x,
                  n-1
                   -
psi(n) = -EUL  +   &gt;  1/k.
                   -
                  k=1

This formula is used for 0 &lt; n &lt;= 10.  If x is negative, it
is transformed to a positive argument by the reflection
formula  psi(1-x) = psi(x) + pi cot(pi x).
For general positive x, the argument is made greater than 10
using the recurrence  psi(x+1) = psi(x) + 1/x.
Then the following asymptotic expansion is applied:

                          inf.   B
                           -      2k
psi(x) = log(x) - 1/2x -   &gt;   -------
                           -        2k
                          k=1   2k x

where the B2k are Bernoulli numbers.

ACCURACY:
   Relative error (except absolute when |psi| &lt; 1):
arithmetic   domain     # trials      peak         rms
   IEEE      0,30        30000       1.3e-15     1.4e-16
   IEEE      -30,0       40000       1.5e-15     2.2e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1992, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.psi(<font color=navy>double</font> x)

</div></pre>
<a name=unit_ratint></a><h2 class=pageheader><code>ratint</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_barycentricinterpolant' class=toc>barycentricinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_barycentricbuildfloaterhormann' class=toc>barycentricbuildfloaterhormann</a><br>
<a href='#sub_barycentricbuildxyw' class=toc>barycentricbuildxyw</a><br>
<a href='#sub_barycentriccalc' class=toc>barycentriccalc</a><br>
<a href='#sub_barycentricdiff1' class=toc>barycentricdiff1</a><br>
<a href='#sub_barycentricdiff2' class=toc>barycentricdiff2</a><br>
<a href='#sub_barycentriclintransx' class=toc>barycentriclintransx</a><br>
<a href='#sub_barycentriclintransy' class=toc>barycentriclintransy</a><br>
<a href='#sub_barycentricunpack' class=toc>barycentricunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_barycentricinterpolant'></a><h3 class=pageheader><code>barycentricinterpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Barycentric interpolant.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class barycentricinterpolant
{
}

</div></pre>
<a name='sub_barycentricbuildfloaterhormann'></a><h3 class=pageheader><code>barycentricbuildfloaterhormann</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational interpolant without poles

The subroutine constructs the rational interpolating function without real
poles  (see  'Barycentric rational interpolation with no  poles  and  high
rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
information on this subject).

Input parameters:
    X   -   interpolation nodes, array[0..N-1].
    Y   -   function values, array[0..N-1].
    N   -   number of nodes, N&gt;0.
    D   -   order of the interpolation scheme, 0 &lt;= D &lt;= N-1.
            D&lt;0 will cause an error.
            D&gt;=N it will be replaced with D=N-1.
            if you don't know what D to choose, use small value about 3-5.

Output parameters:
    B   -   barycentric interpolant.

Note:
    this algorithm always succeeds and calculates the weights  with  close
    to machine precision.

  -- ALGLIB PROJECT --
     Copyright 17.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricbuildfloaterhormann(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> d,
    <font color=navy>out</font> barycentricinterpolant b)

</div></pre>
<a name='sub_barycentricbuildxyw'></a><h3 class=pageheader><code>barycentricbuildxyw</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational interpolant from X/Y/W arrays

F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

INPUT PARAMETERS:
    X   -   interpolation nodes, array[0..N-1]
    F   -   function values, array[0..N-1]
    W   -   barycentric weights, array[0..N-1]
    N   -   nodes count, N&gt;0

OUTPUT PARAMETERS:
    B   -   barycentric interpolant built from (X, Y, W)

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricbuildxyw(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] w,
    <font color=navy>int</font> n,
    <font color=navy>out</font> barycentricinterpolant b)

</div></pre>
<a name='sub_barycentriccalc'></a><h3 class=pageheader><code>barycentriccalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational interpolation using barycentric formula

F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

Input parameters:
    B   -   barycentric interpolant built with one of model building
            subroutines.
    T   -   interpolation point

Result:
    barycentric interpolant F(t)

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.barycentriccalc(
    barycentricinterpolant b,
    <font color=navy>double</font> t)

</div></pre>
<a name='sub_barycentricdiff1'></a><h3 class=pageheader><code>barycentricdiff1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Differentiation of barycentric interpolant: first derivative.

Algorithm used in this subroutine is very robust and should not fail until
provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
or greater will overflow).

INPUT PARAMETERS:
    B   -   barycentric interpolant built with one of model building
            subroutines.
    T   -   interpolation point

OUTPUT PARAMETERS:
    F   -   barycentric interpolant at T
    DF  -   first derivative

NOTE


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricdiff1(
    barycentricinterpolant b,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> f,
    <font color=navy>out</font> <font color=navy>double</font> df)

</div></pre>
<a name='sub_barycentricdiff2'></a><h3 class=pageheader><code>barycentricdiff2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Differentiation of barycentric interpolant: first/second derivatives.

INPUT PARAMETERS:
    B   -   barycentric interpolant built with one of model building
            subroutines.
    T   -   interpolation point

OUTPUT PARAMETERS:
    F   -   barycentric interpolant at T
    DF  -   first derivative
    D2F -   second derivative

NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
BarycentricDiff1() subroutine in such cases.


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricdiff2(
    barycentricinterpolant b,
    <font color=navy>double</font> t,
    <font color=navy>out</font> <font color=navy>double</font> f,
    <font color=navy>out</font> <font color=navy>double</font> df,
    <font color=navy>out</font> <font color=navy>double</font> d2f)

</div></pre>
<a name='sub_barycentriclintransx'></a><h3 class=pageheader><code>barycentriclintransx</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the argument.

INPUT PARAMETERS:
    B       -   rational interpolant in barycentric form
    CA, CB  -   transformation coefficients: x = CA*t + CB

OUTPUT PARAMETERS:
    B       -   transformed interpolant with X replaced by T

  -- ALGLIB PROJECT --
     Copyright 19.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentriclintransx(
    barycentricinterpolant b,
    <font color=navy>double</font> ca,
    <font color=navy>double</font> cb)

</div></pre>
<a name='sub_barycentriclintransy'></a><h3 class=pageheader><code>barycentriclintransy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine   performs   linear  transformation  of  the  barycentric
interpolant.

INPUT PARAMETERS:
    B       -   rational interpolant in barycentric form
    CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB

OUTPUT PARAMETERS:
    B       -   transformed interpolant

  -- ALGLIB PROJECT --
     Copyright 19.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentriclintransy(
    barycentricinterpolant b,
    <font color=navy>double</font> ca,
    <font color=navy>double</font> cb)

</div></pre>
<a name='sub_barycentricunpack'></a><h3 class=pageheader><code>barycentricunpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Extracts X/Y/W arrays from rational interpolant

INPUT PARAMETERS:
    B   -   barycentric interpolant

OUTPUT PARAMETERS:
    N   -   nodes count, N&gt;0
    X   -   interpolation nodes, array[0..N-1]
    F   -   function values, array[0..N-1]
    W   -   barycentric weights, array[0..N-1]

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.barycentricunpack(
    barycentricinterpolant b,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[] x,
    <font color=navy>out</font> <font color=navy>double</font>[] y,
    <font color=navy>out</font> <font color=navy>double</font>[] w)

</div></pre>
<a name=unit_rbf></a><h2 class=pageheader><code>rbf</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_rbfmodel' class=toc>rbfmodel</a><br>
<a href='#struct_rbfreport' class=toc>rbfreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rbfbuildmodel' class=toc>rbfbuildmodel</a><br>
<a href='#sub_rbfcalc' class=toc>rbfcalc</a><br>
<a href='#sub_rbfcalc2' class=toc>rbfcalc2</a><br>
<a href='#sub_rbfcalc3' class=toc>rbfcalc3</a><br>
<a href='#sub_rbfcalcbuf' class=toc>rbfcalcbuf</a><br>
<a href='#sub_rbfcreate' class=toc>rbfcreate</a><br>
<a href='#sub_rbfgridcalc2' class=toc>rbfgridcalc2</a><br>
<a href='#sub_rbfserialize' class=toc>rbfserialize</a><br>
<a href='#sub_rbfsetalgomultilayer' class=toc>rbfsetalgomultilayer</a><br>
<a href='#sub_rbfsetalgoqnn' class=toc>rbfsetalgoqnn</a><br>
<a href='#sub_rbfsetconstterm' class=toc>rbfsetconstterm</a><br>
<a href='#sub_rbfsetlinterm' class=toc>rbfsetlinterm</a><br>
<a href='#sub_rbfsetpoints' class=toc>rbfsetpoints</a><br>
<a href='#sub_rbfsetzeroterm' class=toc>rbfsetzeroterm</a><br>
<a href='#sub_rbfunpack' class=toc>rbfunpack</a><br>
<a href='#sub_rbfunserialize' class=toc>rbfunserialize</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_rbf_d_ml_ls' class=toc>rbf_d_ml_ls</a></td><td width=15>&nbsp;</td><td>Least squares problem solved with RBF-ML algorithm</td></tr>
<tr align=left valign=top><td><a href='#example_rbf_d_ml_simple' class=toc>rbf_d_ml_simple</a></td><td width=15>&nbsp;</td><td>Simple model built with RBF-ML algorithm</td></tr>
<tr align=left valign=top><td><a href='#example_rbf_d_polterm' class=toc>rbf_d_polterm</a></td><td width=15>&nbsp;</td><td>RBF models - working with polynomial term</td></tr>
<tr align=left valign=top><td><a href='#example_rbf_d_qnn' class=toc>rbf_d_qnn</a></td><td width=15>&nbsp;</td><td>Simple model built with RBF-QNN algorithm</td></tr>
<tr align=left valign=top><td><a href='#example_rbf_d_serialize' class=toc>rbf_d_serialize</a></td><td width=15>&nbsp;</td><td>Serialization/unserialization</td></tr>
<tr align=left valign=top><td><a href='#example_rbf_d_vector' class=toc>rbf_d_vector</a></td><td width=15>&nbsp;</td><td>Working with vector functions</td></tr>
</table></div>
<a name='struct_rbfmodel'></a><h3 class=pageheader><code>rbfmodel</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RBF model.

Never try to directly work with fields of this object - always use  ALGLIB
functions to use this object.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class rbfmodel
{
}

</div></pre>
<a name='struct_rbfreport'></a><h3 class=pageheader><code>rbfreport</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
RBF solution report:
* TerminationType   -   termination type, positive values - success,
                        non-positive - failure.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class rbfreport
{
    <font color=navy>public</font> <font color=navy>int</font>                  arows;
    <font color=navy>public</font> <font color=navy>int</font>                  acols;
    <font color=navy>public</font> <font color=navy>int</font>                  annz;
    <font color=navy>public</font> <font color=navy>int</font>                  iterationscount;
    <font color=navy>public</font> <font color=navy>int</font>                  nmv;
    <font color=navy>public</font> <font color=navy>int</font>                  terminationtype;
}

</div></pre>
<a name='sub_rbfbuildmodel'></a><h3 class=pageheader><code>rbfbuildmodel</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This   function  builds  RBF  model  and  returns  report  (contains  some
information which can be used for evaluation of the algorithm properties).

Call to this function modifies RBF model by calculating its centers/radii/
weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel
contain zero coefficients, but after call to this function  we  will  have
coefficients which were calculated in order to fit our dataset.

After you called this function you can call RBFCalc(),  RBFGridCalc()  and
other model calculation functions.

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call
    Rep     -   report:
                * Rep.TerminationType:
                  * -5 - non-distinct basis function centers were detected,
                         interpolation aborted
                  * -4 - nonconvergence of the internal SVD solver
                  *  1 - successful termination
                Fields are used for debugging purposes:
                * Rep.IterationsCount - iterations count of the LSQR solver
                * Rep.NMV - number of matrix-vector products
                * Rep.ARows - rows count for the system matrix
                * Rep.ACols - columns count for the system matrix
                * Rep.ANNZ - number of significantly non-zero elements
                  (elements above some algorithm-determined threshold)

NOTE:  failure  to  build  model will leave current state of the structure
unchanged.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfbuildmodel(rbfmodel s, <font color=navy>out</font> rbfreport rep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_qnn' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_rbf_d_vector' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_simple' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_ls' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfcalc'></a><h3 class=pageheader><code>rbfcalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates values of the RBF model at the given point.

This is general function which can be used for arbitrary NX (dimension  of
the space of arguments) and NY (dimension of the function itself). However
when  you  have  NY=1  you  may  find more convenient to use RBFCalc2() or
RBFCalc3().

This function returns 0.0 when model is not initialized.

INPUT PARAMETERS:
    S       -   RBF model
    X       -   coordinates, array[NX].
                X may have more than NX elements, in this case only
                leading NX will be used.

OUTPUT PARAMETERS:
    Y       -   function value, array[NY]. Y is out-parameter and
                reallocated after call to this function. In case you  want
                to reuse previously allocated Y, you may use RBFCalcBuf(),
                which reallocates Y only when it is too small.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfcalc(rbfmodel s, <font color=navy>double</font>[] x, <font color=navy>out</font> <font color=navy>double</font>[] y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_vector' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfcalc2'></a><h3 class=pageheader><code>rbfcalc2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates values of the RBF model in the given point.

This function should be used when we have NY=1 (scalar function) and  NX=2
(2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
you have general situation (NX-dimensional space, NY-dimensional function)
you should use general, less efficient implementation RBFCalc().

If  you  want  to  calculate  function  values  many times, consider using
RBFGridCalc2(), which is far more efficient than many subsequent calls  to
RBFCalc2().

This function returns 0.0 when:
* model is not initialized
* NX&lt;&gt;2
 *NY&lt;&gt;1

INPUT PARAMETERS:
    S       -   RBF model
    X0      -   first coordinate, finite number
    X1      -   second coordinate, finite number

RESULT:
    value of the model or 0.0 (as defined above)

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rbfcalc2(rbfmodel s, <font color=navy>double</font> x0, <font color=navy>double</font> x1)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_qnn' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_simple' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_ls' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfcalc3'></a><h3 class=pageheader><code>rbfcalc3</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates values of the RBF model in the given point.

This function should be used when we have NY=1 (scalar function) and  NX=3
(3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
you have general situation (NX-dimensional space, NY-dimensional function)
you should use general, less efficient implementation RBFCalc().

This function returns 0.0 when:
* model is not initialized
* NX&lt;&gt;3
 *NY&lt;&gt;1

INPUT PARAMETERS:
    S       -   RBF model
    X0      -   first coordinate, finite number
    X1      -   second coordinate, finite number
    X2      -   third coordinate, finite number

RESULT:
    value of the model or 0.0 (as defined above)

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rbfcalc3(
    rbfmodel s,
    <font color=navy>double</font> x0,
    <font color=navy>double</font> x1,
    <font color=navy>double</font> x2)

</div></pre>
<a name='sub_rbfcalcbuf'></a><h3 class=pageheader><code>rbfcalcbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates values of the RBF model at the given point.

Same as RBFCalc(), but does not reallocate Y when in is large enough to
store function values.

INPUT PARAMETERS:
    S       -   RBF model
    X       -   coordinates, array[NX].
                X may have more than NX elements, in this case only
                leading NX will be used.
    Y       -   possibly preallocated array

OUTPUT PARAMETERS:
    Y       -   function value, array[NY]. Y is not reallocated when it
                is larger than NY.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfcalcbuf(
    rbfmodel s,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_rbfcreate'></a><h3 class=pageheader><code>rbfcreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY&gt;1)
function in a NX-dimensional space (NX=2 or NX=3).

Newly created model is empty. It can be used for interpolation right after
creation, but it just returns zeros. You have to add points to the  model,
tune interpolation settings, and then  call  model  construction  function
RBFBuildModel() which will update model according to your specification.

USAGE:
1. User creates model with RBFCreate()
2. User adds dataset with RBFSetPoints() (points do NOT have to  be  on  a
   regular grid)
3. (OPTIONAL) User chooses polynomial term by calling:
   * RBFLinTerm() to set linear term
   * RBFConstTerm() to set constant term
   * RBFZeroTerm() to set zero term
   By default, linear term is used.
4. User chooses specific RBF algorithm to use: either QNN (RBFSetAlgoQNN)
   or ML (RBFSetAlgoMultiLayer).
5. User calls RBFBuildModel() function which rebuilds model  according  to
   the specification
6. User may call RBFCalc() to calculate model value at the specified point,
   RBFGridCalc() to  calculate   model  values at the points of the regular
   grid. User may extract model coefficients with RBFUnpack() call.

INPUT PARAMETERS:
    NX      -   dimension of the space, NX=2 or NX=3
    NY      -   function dimension, NY&gt;=1

OUTPUT PARAMETERS:
    S       -   RBF model (initially equals to zero)

NOTE 1: memory requirements. RBF models require amount of memory  which is
        proportional  to  the  number  of data points. Memory is allocated
        during model construction, but most of this memory is freed  after
        model coefficients are calculated.

        Some approximate estimates for N centers with default settings are
        given below:
        * about 250*N*(sizeof(double)+2*sizeof(int)) bytes  of  memory  is
          needed during model construction stage.
        * about 15*N*sizeof(double) bytes is needed after model is built.
        For example, for N=100000 we may need 0.6 GB of memory  to  build
        model, but just about 0.012 GB to store it.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfcreate(<font color=navy>int</font> nx, <font color=navy>int</font> ny, <font color=navy>out</font> rbfmodel s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_qnn' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_rbf_d_vector' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_rbf_d_serialize' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_simple' class=nav>[5]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_ls' class=nav>[6]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfgridcalc2'></a><h3 class=pageheader><code>rbfgridcalc2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates values of the RBF model at the regular grid.

Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])

This function returns 0.0 when:
* model is not initialized
* NX&lt;&gt;2
 *NY&lt;&gt;1

INPUT PARAMETERS:
    S       -   RBF model
    X0      -   array of grid nodes, first coordinates, array[N0]
    N0      -   grid size (number of nodes) in the first dimension
    X1      -   array of grid nodes, second coordinates, array[N1]
    N1      -   grid size (number of nodes) in the second dimension

OUTPUT PARAMETERS:
    Y       -   function values, array[N0,N1]. Y is out-variable and
                is reallocated by this function.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfgridcalc2(
    rbfmodel s,
    <font color=navy>double</font>[] x0,
    <font color=navy>int</font> n0,
    <font color=navy>double</font>[] x1,
    <font color=navy>int</font> n1,
    <font color=navy>out</font> <font color=navy>double</font>[,] y)

</div></pre>
<a name='sub_rbfserialize'></a><h3 class=pageheader><code>rbfserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function serializes data structure to string.

Important properties of s_out:
* it contains alphanumeric characters, dots, underscores, minus signs
* these symbols are grouped into words, which are separated by spaces
  and Windows-style (CR+LF) newlines
* although  serializer  uses  spaces and CR+LF as separators, you can 
  replace any separator character by arbitrary combination of spaces,
  tabs, Windows or Unix newlines. It allows flexible reformatting  of
  the  string  in  case you want to include it into text or XML file. 
  But you should not insert separators into the middle of the &quot;words&quot;
  nor you should change case of letters.
* s_out can be freely moved between 32-bit and 64-bit systems, little
  and big endian machines, and so on. You can serialize structure  on
  32-bit machine and unserialize it on 64-bit one (or vice versa), or
  serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
  serialize  it  in  C++ version of ALGLIB and unserialize in C# one, 
  and vice versa.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> rbfserialize(rbfmodel obj, <font color=navy>out</font> string s_out)

</div></pre>
<a name='sub_rbfsetalgomultilayer'></a><h3 class=pageheader><code>rbfsetalgomultilayer</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  sets  RBF interpolation algorithm. ALGLIB supports several
RBF algorithms with different properties.

This  algorithm is called RBF-ML. It builds  multilayer  RBF  model,  i.e.
model with subsequently decreasing  radii,  which  allows  us  to  combine
smoothness (due to  large radii of  the first layers) with  exactness (due
to small radii of the last layers) and fast convergence.

Internally RBF-ML uses many different  means  of acceleration, from sparse
matrices  to  KD-trees,  which  results in algorithm whose working time is
roughly proportional to N*log(N)*Density*RBase^2*NLayers,  where  N  is  a
number of points, Density is an average density if points per unit of  the
interpolation space, RBase is an initial radius, NLayers is  a  number  of
layers.

RBF-ML is good for following kinds of interpolation problems:
1. &quot;exact&quot; problems (perfect fit) with well separated points
2. least squares problems with arbitrary distribution of points (algorithm
   gives  perfect  fit  where it is possible, and resorts to least squares
   fit in the hard areas).
3. noisy problems where  we  want  to  apply  some  controlled  amount  of
   smoothing.

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call
    RBase   -   RBase parameter, RBase&gt;0
    NLayers -   NLayers parameter, NLayers&gt;0, recommended value  to  start
                with - about 5.
    LambdaV -   regularization value, can be useful when  solving  problem
                in the least squares sense.  Optimal  lambda  is  problem-
                dependent and require trial and error. In our  experience,
                good lambda can be as large as 0.1, and you can use  0.001
                as initial guess.
                Default  value  - 0.01, which is used when LambdaV is  not
                given.  You  can  specify  zero  value,  but  it  is   not
                recommended to do so.

TUNING ALGORITHM

In order to use this algorithm you have to choose three parameters:
* initial radius RBase
* number of layers in the model NLayers
* regularization coefficient LambdaV

Initial radius is easy to choose - you can pick any number  several  times
larger  than  the  average  distance between points. Algorithm won't break
down if you choose radius which is too large (model construction time will
increase, but model will be built correctly).

Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
by  the  last  layer)  will  be  smaller than the typical distance between
points.  In  case  model  error  is  too large, you can increase number of
layers.  Having  more  layers  will make model construction and evaluation
proportionally slower, but it will allow you to have model which precisely
fits your data. From the other side, if you want to  suppress  noise,  you
can DECREASE number of layers to make your model less flexible.

Regularization coefficient LambdaV controls smoothness of  the  individual
models built for each layer. We recommend you to use default value in case
you don't want to tune this parameter,  because  having  non-zero  LambdaV
accelerates and stabilizes internal iterative algorithm. In case you  want
to suppress noise you can use  LambdaV  as  additional  parameter  (larger
value = more smoothness) to tune.

TYPICAL ERRORS

1. Using  initial  radius  which is too large. Memory requirements  of the
   RBF-ML are roughly proportional to N*Density*RBase^2 (where Density  is
   an average density of points per unit of the interpolation  space).  In
   the extreme case of the very large RBase we will need O(N^2)  units  of
   memory - and many layers in order to decrease radius to some reasonably
   small value.

2. Using too small number of layers - RBF models with large radius are not
   flexible enough to reproduce small variations in the  target  function.
   You  need  many  layers  with  different radii, from large to small, in
   order to have good model.

3. Using  initial  radius  which  is  too  small.  You will get model with
   &quot;holes&quot; in the areas which are too far away from interpolation centers.
   However, algorithm will work correctly (and quickly) in this case.

4. Using too many layers - you will get too large and too slow model. This
   model  will  perfectly  reproduce  your function, but maybe you will be
   able to achieve similar results with less layers (and less memory).

  -- ALGLIB --
     Copyright 02.03.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetalgomultilayer(
    rbfmodel s,
    <font color=navy>double</font> rbase,
    <font color=navy>int</font> nlayers)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetalgomultilayer(
    rbfmodel s,
    <font color=navy>double</font> rbase,
    <font color=navy>int</font> nlayers,
    <font color=navy>double</font> lambdav)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_ml_simple' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_ls' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfsetalgoqnn'></a><h3 class=pageheader><code>rbfsetalgoqnn</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  sets  RBF interpolation algorithm. ALGLIB supports several
RBF algorithms with different properties.

This algorithm is called RBF-QNN and  it  is  good  for  point  sets  with
following properties:
a) all points are distinct
b) all points are well separated.
c) points  distribution  is  approximately  uniform.  There is no &quot;contour
   lines&quot;, clusters of points, or other small-scale structures.

Algorithm description:
1) interpolation centers are allocated to data points
2) interpolation radii are calculated as distances to the  nearest centers
   times Q coefficient (where Q is a value from [0.75,1.50]).
3) after  performing (2) radii are transformed in order to avoid situation
   when single outlier has very large radius and  influences  many  points
   across all dataset. Transformation has following form:
       new_r[i] = min(r[i],Z*median(r[]))
   where r[i] is I-th radius, median()  is a median  radius across  entire
   dataset, Z is user-specified value which controls amount  of  deviation
   from median radius.

When (a) is violated,  we  will  be unable to build RBF model. When (b) or
(c) are violated, model will be built, but interpolation quality  will  be
low. See http://www.alglib.net/interpolation/ for more information on this
subject.

This algorithm is used by default.

Additional Q parameter controls smoothness properties of the RBF basis:
* Q&lt;0.75 will give perfectly conditioned basis,  but  terrible  smoothness
  properties (RBF interpolant will have sharp peaks around function values)
* Q around 1.0 gives good balance between smoothness and condition number
* Q&gt;1.5 will lead to badly conditioned systems and slow convergence of the
  underlying linear solver (although smoothness will be very good)
* Q&gt;2.0 will effectively make optimizer useless because it won't  converge
  within reasonable amount of iterations. It is possible to set such large
  Q, but it is advised not to do so.

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call
    Q       -   Q parameter, Q&gt;0, recommended value - 1.0
    Z       -   Z parameter, Z&gt;0, recommended value - 5.0

NOTE: this   function  has   some   serialization-related  subtleties.  We
      recommend you to study serialization examples from ALGLIB  Reference
      Manual if you want to perform serialization of your models.


  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetalgoqnn(rbfmodel s)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetalgoqnn(rbfmodel s, <font color=navy>double</font> q, <font color=navy>double</font> z)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_qnn' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_rbf_d_vector' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfsetconstterm'></a><h3 class=pageheader><code>rbfsetconstterm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets constant term (model is a sum of radial basis functions
plus constant).  This  function  won't  have  effect  until  next  call to
RBFBuildModel().

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call

NOTE: this   function  has   some   serialization-related  subtleties.  We
      recommend you to study serialization examples from ALGLIB  Reference
      Manual if you want to perform serialization of your models.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetconstterm(rbfmodel s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfsetlinterm'></a><h3 class=pageheader><code>rbfsetlinterm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets linear term (model is a sum of radial  basis  functions
plus linear polynomial). This function won't have effect until  next  call
to RBFBuildModel().

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call

NOTE: this   function  has   some   serialization-related  subtleties.  We
      recommend you to study serialization examples from ALGLIB  Reference
      Manual if you want to perform serialization of your models.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetlinterm(rbfmodel s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfsetpoints'></a><h3 class=pageheader><code>rbfsetpoints</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function adds dataset.

This function overrides results of the previous calls, i.e. multiple calls
of this function will result in only the last set being added.

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call.
    XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
                in the dataset. First NX elements  are  coordinates,  next
                NY elements are function values. Array may  be larger than
                specific,  in  this  case  only leading [N,NX+NY] elements
                will be used.
    N       -   number of points in the dataset

After you've added dataset and (optionally) tuned algorithm  settings  you
should call RBFBuildModel() in order to build a model for you.

NOTE: this   function  has   some   serialization-related  subtleties.  We
      recommend you to study serialization examples from ALGLIB  Reference
      Manual if you want to perform serialization of your models.


  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetpoints(rbfmodel s, <font color=navy>double</font>[,] xy)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetpoints(rbfmodel s, <font color=navy>double</font>[,] xy, <font color=navy>int</font> n)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_qnn' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_rbf_d_vector' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_simple' class=nav>[4]</a>&nbsp;&nbsp;<a href='#example_rbf_d_ml_ls' class=nav>[5]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfsetzeroterm'></a><h3 class=pageheader><code>rbfsetzeroterm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  sets  zero  term (model is a sum of radial basis functions
without polynomial term). This function won't have effect until next  call
to RBFBuildModel().

INPUT PARAMETERS:
    S       -   RBF model, initialized by RBFCreate() call

NOTE: this   function  has   some   serialization-related  subtleties.  We
      recommend you to study serialization examples from ALGLIB  Reference
      Manual if you want to perform serialization of your models.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfsetzeroterm(rbfmodel s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfunpack'></a><h3 class=pageheader><code>rbfunpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function &quot;unpacks&quot; RBF model by extracting its coefficients.

INPUT PARAMETERS:
    S       -   RBF model

OUTPUT PARAMETERS:
    NX      -   dimensionality of argument
    NY      -   dimensionality of the target function
    XWR     -   model information, array[NC,NX+NY+1].
                One row of the array corresponds to one basis function:
                * first NX columns  - coordinates of the center
                * next NY columns   - weights, one per dimension of the
                                      function being modelled
                * last column       - radius, same for all dimensions of
                                      the function being modelled
    NC      -   number of the centers
    V       -   polynomial  term , array[NY,NX+1]. One row per one
                dimension of the function being modelled. First NX
                elements are linear coefficients, V[NX] is equal to the
                constant part.

  -- ALGLIB --
     Copyright 13.12.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rbfunpack(
    rbfmodel s,
    <font color=navy>out</font> <font color=navy>int</font> nx,
    <font color=navy>out</font> <font color=navy>int</font> ny,
    <font color=navy>out</font> <font color=navy>double</font>[,] xwr,
    <font color=navy>out</font> <font color=navy>int</font> nc,
    <font color=navy>out</font> <font color=navy>double</font>[,] v)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rbf_d_polterm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rbfunserialize'></a><h3 class=pageheader><code>rbfunserialize</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function unserializes data structure from string.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> rbfunserialize(string s_in, <font color=navy>out</font> rbfmodel obj)

</div></pre>
<a name='example_rbf_d_ml_ls'></a><h3 class=pageheader>rbf_d_ml_ls example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example shows how to solve least squares problems with RBF-ML algorithm.</font>
    <font color=green>// Below we assume that you already know basic concepts shown in the RBF_D_QNN and</font>
    <font color=green>// RBF_D_ML_SIMPLE examples.</font>
    <font color=green>//</font>
    alglib.rbfmodel model;
    alglib.rbfreport rep;
    <font color=navy>double</font> v;

    <font color=green>//</font>
    <font color=green>// We have 2-dimensional space and very simple fitting problem - all points</font>
    <font color=green>// except <font color=navy>for</font> two are well separated and located at straight line. Two</font>
    <font color=green>// <font color=blue><b>&quot;exceptional&quot;</b></font> points are very close, with distance between them as small</font>
    <font color=green>// as 0.01. RBF-QNN algorithm will have many difficulties with such distribution</font>
    <font color=green>// of points:</font>
    <font color=green>//     X        Y</font>
    <font color=green>//     -2       1</font>
    <font color=green>//     -1       0</font>
    <font color=green>//     -0.005   1</font>
    <font color=green>//     +0.005   2</font>
    <font color=green>//     +1      -1</font>
    <font color=green>//     +2       1</font>
    <font color=green>// How will RBF-ML handle such problem?</font>
    <font color=green>//</font>
    alglib.rbfcreate(2, 1, <font color=navy>out</font> model);
    <font color=navy>double</font>[,] xy0 = new <font color=navy>double</font>[,]{{-2,0,1},{-1,0,0},{-0.005,0,1},{+0.005,0,2},{+1,0,-1},{+2,0,1}};
    alglib.rbfsetpoints(model, xy0);

    <font color=green>// First, we try to use R=5.0 with single layer (NLayers=1) and moderate amount</font>
    <font color=green>// of regularization. Well, we already expected that results will be bad:</font>
    <font color=green>//     Model(x=-2,y=0)=0.8407    (instead of 1.0)</font>
    <font color=green>//     Model(x=0.005,y=0)=0.6584 (instead of 2.0)</font>
    <font color=green>// We need more layers to show better results.</font>
    alglib.rbfsetalgomultilayer(model, 5.0, 1, 1.0e-3);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    v = alglib.rbfcalc2(model, -2.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.8407981659</font>
    v = alglib.rbfcalc2(model, 0.005, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.6584267649</font>

    <font color=green>// With 4 layers we got better result at x=-2 (point which is well separated</font>
    <font color=green>// from its neighbors). Model is now many times closer to the original data</font>
    <font color=green>//     Model(x=-2,y=0)=0.9992    (instead of 1.0)</font>
    <font color=green>//     Model(x=0.005,y=0)=1.5534 (instead of 2.0)</font>
    <font color=green>// We may see that at x=0.005 result is a bit closer to 2.0, but does not</font>
    <font color=green>// reproduce function value precisely because of close neighbor located at</font>
    <font color=green>// at x=-0.005. Let's add two layers...</font>
    alglib.rbfsetalgomultilayer(model, 5.0, 4, 1.0e-3);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    v = alglib.rbfcalc2(model, -2.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.9992673278</font>
    v = alglib.rbfcalc2(model, 0.005, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.5534666012</font>

    <font color=green>// With 6 layers we got almost perfect fit:</font>
    <font color=green>//     Model(x=-2,y=0)=1.000    (perfect fit)</font>
    <font color=green>//     Model(x=0.005,y=0)=1.996 (instead of 2.0)</font>
    <font color=green>// Of course, we can reduce error at x=0.005 down to zero by adding more</font>
    <font color=green>// layers. But <font color=navy>do</font> we really need it?</font>
    alglib.rbfsetalgomultilayer(model, 5.0, 6, 1.0e-3);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    v = alglib.rbfcalc2(model, -2.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000000000</font>
    v = alglib.rbfcalc2(model, 0.005, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.9965775952</font>

    <font color=green>// Do we really need zero error? We have f(+0.005)=2 and f(-0.005)=1.</font>
    <font color=green>// Two points are very close, and in real life situations it often means</font>
    <font color=green>// that difference in function values can be explained by noise in the</font>
    <font color=green>// data. Thus, true value of the underlying function should be close to</font>
    <font color=green>// 1.5 (halfway between 1.0 and 2.0).</font>
    <font color=green>//</font>
    <font color=green>// How can we get such result with RBF-ML? Well, we can:</font>
    <font color=green>// a) reduce number of layers (make model less flexible)</font>
    <font color=green>// b) increase regularization coefficient (another way of reducing flexibility)</font>
    <font color=green>//</font>
    <font color=green>// Having NLayers=5 and LambdaV=0.1 gives us good least squares fit to the data:</font>
    <font color=green>//     Model(x=-2,y=0)=1.000</font>
    <font color=green>//     Model(x=-0.005,y=0)=1.504</font>
    <font color=green>//     Model(x=+0.005,y=0)=1.496</font>
    alglib.rbfsetalgomultilayer(model, 5.0, 5, 1.0e-1);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    v = alglib.rbfcalc2(model, -2.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000001620</font>
    v = alglib.rbfcalc2(model, -0.005, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.5042954378</font>
    v = alglib.rbfcalc2(model, 0.005, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.4957042013</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_rbf_d_ml_simple'></a><h3 class=pageheader>rbf_d_ml_simple example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example shows how to build models with RBF-ML algorithm. Below</font>
    <font color=green>// we assume that you already know basic concepts shown in the example</font>
    <font color=green>// on RBF-QNN algorithm.</font>
    <font color=green>//</font>
    <font color=green>// RBF-ML is a multilayer RBF algorithm, which fits a sequence of models</font>
    <font color=green>// with decreasing radii. Each model is fitted with fixed number of</font>
    <font color=green>// iterations of linear solver. First layers give only inexact approximation</font>
    <font color=green>// of the target function, because RBF problems with large radii are</font>
    <font color=green>// ill-conditioned. However, as we add more and more layers with smaller</font>
    <font color=green>// and smaller radii, we get better conditioned systems - and more precise models.</font>
    <font color=green>//</font>
    alglib.rbfmodel model;
    alglib.rbfreport rep;
    <font color=navy>double</font> v;

    <font color=green>//</font>
    <font color=green>// We have 2-dimensional space and very simple interpolation problem - all</font>
    <font color=green>// points are distinct and located at straight line. We want to solve it</font>
    <font color=green>// with RBF-ML algorithm. This problem is very simple, and RBF-QNN will</font>
    <font color=green>// solve it too, but we want to evaluate RBF-ML and to start from the simple</font>
    <font color=green>// problem.</font>
    <font color=green>//     X        Y</font>
    <font color=green>//     -2       1</font>
    <font color=green>//     -1       0</font>
    <font color=green>//      0       1</font>
    <font color=green>//     +1      -1</font>
    <font color=green>//     +2       1</font>
    <font color=green>//</font>
    alglib.rbfcreate(2, 1, <font color=navy>out</font> model);
    <font color=navy>double</font>[,] xy0 = new <font color=navy>double</font>[,]{{-2,0,1},{-1,0,0},{0,0,1},{+1,0,-1},{+2,0,1}};
    alglib.rbfsetpoints(model, xy0);

    <font color=green>// First, we try to use R=5.0 with single layer (NLayers=1) and moderate amount</font>
    <font color=green>// of regularization.... but results are disappointing: Model(x=0,y=0)=-0.02,</font>
    <font color=green>// and we need 1.0 at (x,y)=(0,0). Why?</font>
    <font color=green>//</font>
    <font color=green>// Because first layer gives very smooth and imprecise approximation of the</font>
    <font color=green>// function. Average distance between points is 1.0, and R=5.0 is too large</font>
    <font color=green>// to give us flexible model. It can give smoothness, but can't give precision.</font>
    <font color=green>// So we need more layers with smaller radii.</font>
    alglib.rbfsetalgomultilayer(model, 5.0, 1, 1.0e-3);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>
    v = alglib.rbfcalc2(model, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: -0.021690</font>

    <font color=green>// Now we know that single layer is not enough. We still want to start with</font>
    <font color=green>// R=5.0 because it has good smoothness properties, but we will add more layers,</font>
    <font color=green>// each with R[i+1]=R[i]/2. We think that 4 layers is enough, because last layer</font>
    <font color=green>// will have R = 5.0/2^3 = 5/8 ~ 0.63, which is smaller than the average distance</font>
    <font color=green>// between points. And it works!</font>
    alglib.rbfsetalgomultilayer(model, 5.0, 4, 1.0e-3);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>
    v = alglib.rbfcalc2(model, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.000000</font>

    <font color=green>// BTW, <font color=navy>if</font> you look at v, you will see that it is equal to 0.9999999997, not to 1.</font>
    <font color=green>// This small error can be fixed by adding one more layer.</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_rbf_d_polterm'></a><h3 class=pageheader>rbf_d_polterm example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example show how to work with polynomial term</font>
    <font color=green>// </font>
    <font color=green>// Suppose that we have set of 2-dimensional points with associated</font>
    <font color=green>// scalar function values, and we want to build a RBF model using</font>
    <font color=green>// our data.</font>
    <font color=green>//</font>
    <font color=navy>double</font> v;
    alglib.rbfmodel model;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{-1,0,2},{+1,0,3}};
    alglib.rbfreport rep;

    alglib.rbfcreate(2, 1, <font color=navy>out</font> model);
    alglib.rbfsetpoints(model, xy);
    alglib.rbfsetalgoqnn(model);

    <font color=green>//</font>
    <font color=green>// By default, RBF model uses linear term. It means that model</font>
    <font color=green>// looks like</font>
    <font color=green>//     f(x,y) = SUM(RBF[i]) + a*x + b*y + c</font>
    <font color=green>// where RBF[i] is I-th radial basis function and a*x+by+c is a</font>
    <font color=green>// linear term. Having linear terms in a model gives us:</font>
    <font color=green>// (1) improved extrapolation properties</font>
    <font color=green>// (2) linearity of the model when data can be perfectly fitted</font>
    <font color=green>//     by the linear function</font>
    <font color=green>// (3) linear asymptotic behavior</font>
    <font color=green>//</font>
    <font color=green>// Our simple dataset can be modelled by the linear function</font>
    <font color=green>//     f(x,y) = 0.5*x + 2.5</font>
    <font color=green>// and rbfbuildmodel() with default settings should preserve this</font>
    <font color=green>// linearity.</font>
    <font color=green>//</font>
    <font color=navy>int</font> nx;
    <font color=navy>int</font> ny;
    <font color=navy>int</font> nc;
    <font color=navy>double</font>[,] xwr;
    <font color=navy>double</font>[,] c;
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>
    alglib.rbfunpack(model, <font color=navy>out</font> nx, <font color=navy>out</font> ny, <font color=navy>out</font> xwr, <font color=navy>out</font> nc, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,2)); <font color=green>// EXPECTED: [[0.500,0.000,2.500]]</font>

    <font color=green>// asymptotic behavior of our function is linear</font>
    v = alglib.rbfcalc2(model, 1000.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F1&quot;</b></font>, v); <font color=green>// EXPECTED: 502.50</font>

    <font color=green>//</font>
    <font color=green>// Instead of linear term we can use constant term. In this case</font>
    <font color=green>// we will get model which has form</font>
    <font color=green>//     f(x,y) = SUM(RBF[i]) + c</font>
    <font color=green>// where RBF[i] is I-th radial basis function and c is a constant,</font>
    <font color=green>// which is equal to the average function value on the dataset.</font>
    <font color=green>//</font>
    <font color=green>// Because we've already attached dataset to the model the only</font>
    <font color=green>// thing we have to <font color=navy>do</font> is to call rbfsetconstterm() and then</font>
    <font color=green>// rebuild model with rbfbuildmodel().</font>
    <font color=green>//</font>
    alglib.rbfsetconstterm(model);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>
    alglib.rbfunpack(model, <font color=navy>out</font> nx, <font color=navy>out</font> ny, <font color=navy>out</font> xwr, <font color=navy>out</font> nc, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,2)); <font color=green>// EXPECTED: [[0.000,0.000,2.500]]</font>

    <font color=green>// asymptotic behavior of our function is constant</font>
    v = alglib.rbfcalc2(model, 1000.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.500</font>

    <font color=green>//</font>
    <font color=green>// Finally, we can use zero term. Just plain RBF without polynomial</font>
    <font color=green>// part:</font>
    <font color=green>//     f(x,y) = SUM(RBF[i])</font>
    <font color=green>// where RBF[i] is I-th radial basis function.</font>
    <font color=green>//</font>
    alglib.rbfsetzeroterm(model);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>
    alglib.rbfunpack(model, <font color=navy>out</font> nx, <font color=navy>out</font> ny, <font color=navy>out</font> xwr, <font color=navy>out</font> nc, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,2)); <font color=green>// EXPECTED: [[0.000,0.000,0.000]]</font>

    <font color=green>// asymptotic behavior of our function is just zero constant</font>
    v = alglib.rbfcalc2(model, 1000.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.000</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_rbf_d_qnn'></a><h3 class=pageheader>rbf_d_qnn example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example illustrates basic concepts of the RBF models: creation, modification,</font>
    <font color=green>// evaluation.</font>
    <font color=green>// </font>
    <font color=green>// Suppose that we have set of 2-dimensional points with associated</font>
    <font color=green>// scalar function values, and we want to build a RBF model using</font>
    <font color=green>// our data.</font>
    <font color=green>// </font>
    <font color=green>// NOTE: we can work with 3D models too :)</font>
    <font color=green>// </font>
    <font color=green>// Typical sequence of steps is given below:</font>
    <font color=green>// 1. we create RBF model object</font>
    <font color=green>// 2. we attach our dataset to the RBF model and tune algorithm settings</font>
    <font color=green>// 3. we rebuild RBF model using QNN algorithm on new data</font>
    <font color=green>// 4. we use RBF model (evaluate, serialize, etc.)</font>
    <font color=green>//</font>
    <font color=navy>double</font> v;

    <font color=green>//</font>
    <font color=green>// Step 1: RBF model creation.</font>
    <font color=green>//</font>
    <font color=green>// We have to specify dimensionality of the space (2 or 3) and</font>
    <font color=green>// dimensionality of the function (scalar or vector).</font>
    <font color=green>//</font>
    alglib.rbfmodel model;
    alglib.rbfcreate(2, 1, <font color=navy>out</font> model);

    <font color=green>// New model is empty - it can be evaluated,</font>
    <font color=green>// but we just get zero value at any point.</font>
    v = alglib.rbfcalc2(model, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.000</font>

    <font color=green>//</font>
    <font color=green>// Step 2: we add dataset.</font>
    <font color=green>//</font>
    <font color=green>// XY arrays containt two points - x0=(-1,0) and x1=(+1,0) -</font>
    <font color=green>// and two function values f(x0)=2, f(x1)=3.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{-1,0,2},{+1,0,3}};
    alglib.rbfsetpoints(model, xy);

    <font color=green>// We added points, but model was not rebuild yet.</font>
    <font color=green>// If we call rbfcalc2(), we still will get 0.0 as result.</font>
    v = alglib.rbfcalc2(model, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.000</font>

    <font color=green>//</font>
    <font color=green>// Step 3: rebuild model</font>
    <font color=green>//</font>
    <font color=green>// After we've configured model, we should rebuild it -</font>
    <font color=green>// it will change coefficients stored internally in the</font>
    <font color=green>// rbfmodel structure.</font>
    <font color=green>//</font>
    <font color=green>// By default, RBF uses QNN algorithm, which works well with</font>
    <font color=green>// relatively uniform datasets (all points are well separated,</font>
    <font color=green>// average distance is approximately same <font color=navy>for</font> all points).</font>
    <font color=green>// This default algorithm is perfectly suited <font color=navy>for</font> our simple</font>
    <font color=green>// made up data.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: we recommend you to take a look at example of RBF-ML,</font>
    <font color=green>// multilayer RBF algorithm, which sometimes is a better</font>
    <font color=green>// option than QNN.</font>
    <font color=green>//</font>
    alglib.rbfreport rep;
    alglib.rbfsetalgoqnn(model);
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>

    <font color=green>//</font>
    <font color=green>// Step 4: model was built</font>
    <font color=green>//</font>
    <font color=green>// After call of rbfbuildmodel(), rbfcalc2() will <font color=navy>return</font></font>
    <font color=green>// value of the new model.</font>
    <font color=green>//</font>
    v = alglib.rbfcalc2(model, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.500</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_rbf_d_serialize'></a><h3 class=pageheader>rbf_d_serialize example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example show how to serialize and unserialize RBF model</font>
    <font color=green>// </font>
    <font color=green>// Suppose that we have set of 2-dimensional points with associated</font>
    <font color=green>// scalar function values, and we want to build a RBF model using</font>
    <font color=green>// our data. Then we want to serialize it to string and to unserialize</font>
    <font color=green>// from string, loading to another instance of RBF model.</font>
    <font color=green>//</font>
    <font color=green>// Here we assume that you already know how to create RBF models.</font>
    <font color=green>//</font>
    string s;
    <font color=navy>double</font> v;
    alglib.rbfmodel model0;
    alglib.rbfmodel model1;
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{-1,0,2},{+1,0,3}};
    alglib.rbfreport rep;

    <font color=green>// model initialization</font>
    alglib.rbfcreate(2, 1, <font color=navy>out</font> model0);
    alglib.rbfsetpoints(model0, xy);
    alglib.rbfsetalgoqnn(model0);
    alglib.rbfbuildmodel(model0, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>

    <font color=green>//</font>
    <font color=green>// Serialization - it looks easy,</font>
    <font color=green>// but you should carefully read next section.</font>
    <font color=green>//</font>
    alglib.rbfserialize(model0, <font color=navy>out</font> s);
    alglib.rbfunserialize(s, <font color=navy>out</font> model1);

    <font color=green>// both models <font color=navy>return</font> same value</font>
    v = alglib.rbfcalc2(model0, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.500</font>
    v = alglib.rbfcalc2(model1, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.500</font>

    <font color=green>//</font>
    <font color=green>// Previous section shows that model state is saved/restored during</font>
    <font color=green>// serialization. However, some properties are NOT serialized.</font>
    <font color=green>//</font>
    <font color=green>// Serialization saves/restores RBF model, but it does NOT saves/restores</font>
    <font color=green>// settings which were used to build current model. In particular, dataset</font>
    <font color=green>// which were used to build model, is not preserved.</font>
    <font color=green>//</font>
    <font color=green>// What does it mean in <font color=navy>for</font> us?</font>
    <font color=green>//</font>
    <font color=green>// Do you remember this sequence: rbfcreate-rbfsetpoints-rbfbuildmodel?</font>
    <font color=green>// First step creates model, second step adds dataset and tunes model</font>
    <font color=green>// settings, third step builds model using current dataset and model</font>
    <font color=green>// construction settings.</font>
    <font color=green>//</font>
    <font color=green>// If you call rbfbuildmodel() without calling rbfsetpoints() first, you</font>
    <font color=green>// will get empty (zero) RBF model. In our example, model0 contains</font>
    <font color=green>// dataset which was added by rbfsetpoints() call. However, model1 does</font>
    <font color=green>// NOT contain dataset - because dataset is NOT serialized.</font>
    <font color=green>//</font>
    <font color=green>// This, <font color=navy>if</font> we call rbfbuildmodel(model0,rep), we will get same model,</font>
    <font color=green>// which returns 2.5 at (x,y)=(0,0). However, after same call model1 will</font>
    <font color=green>// <font color=navy>return</font> zero - because it contains RBF model (coefficients), but does NOT</font>
    <font color=green>// contain dataset which was used to build this model.</font>
    <font color=green>//</font>
    <font color=green>// Basically, it means that:</font>
    <font color=green>// * serialization of the RBF model preserves anything related to the model</font>
    <font color=green>//   EVALUATION</font>
    <font color=green>// * but it does NOT creates perfect copy of the original object.</font>
    <font color=green>//</font>
    alglib.rbfbuildmodel(model0, <font color=navy>out</font> rep);
    v = alglib.rbfcalc2(model0, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.500</font>

    alglib.rbfbuildmodel(model1, <font color=navy>out</font> rep);
    v = alglib.rbfcalc2(model1, 0.0, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.000</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_rbf_d_vector'></a><h3 class=pageheader>rbf_d_vector example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Suppose that we have set of 2-dimensional points with associated VECTOR</font>
    <font color=green>// function values, and we want to build a RBF model using our data.</font>
    <font color=green>// </font>
    <font color=green>// Typical sequence of steps is given below:</font>
    <font color=green>// 1. we create RBF model object</font>
    <font color=green>// 2. we attach our dataset to the RBF model and tune algorithm settings</font>
    <font color=green>// 3. we rebuild RBF model using new data</font>
    <font color=green>// 4. we use RBF model (evaluate, serialize, etc.)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x;
    <font color=navy>double</font>[] y;

    <font color=green>//</font>
    <font color=green>// Step 1: RBF model creation.</font>
    <font color=green>//</font>
    <font color=green>// We have to specify dimensionality of the space (equal to 2) and</font>
    <font color=green>// dimensionality of the function (2-dimensional vector function).</font>
    <font color=green>//</font>
    alglib.rbfmodel model;
    alglib.rbfcreate(2, 2, <font color=navy>out</font> model);

    <font color=green>// New model is empty - it can be evaluated,</font>
    <font color=green>// but we just get zero value at any point.</font>
    x = new <font color=navy>double</font>[]{+1,+1};
    alglib.rbfcalc(model, x, <font color=navy>out</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,2)); <font color=green>// EXPECTED: [0.000,0.000]</font>

    <font color=green>//</font>
    <font color=green>// Step 2: we add dataset.</font>
    <font color=green>//</font>
    <font color=green>// XY arrays containt four points:</font>
    <font color=green>// * (x0,y0) = (+1,+1), f(x0,y0)=(0,-1)</font>
    <font color=green>// * (x1,y1) = (+1,-1), f(x1,y1)=(-1,0)</font>
    <font color=green>// * (x2,y2) = (-1,-1), f(x2,y2)=(0,+1)</font>
    <font color=green>// * (x3,y3) = (-1,+1), f(x3,y3)=(+1,0)</font>
    <font color=green>//</font>
    <font color=green>// By default, RBF uses QNN algorithm, which works well with</font>
    <font color=green>// relatively uniform datasets (all points are well separated,</font>
    <font color=green>// average distance is approximately same <font color=navy>for</font> all points).</font>
    <font color=green>//</font>
    <font color=green>// This default algorithm is perfectly suited <font color=navy>for</font> our simple</font>
    <font color=green>// made up data.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[,] xy = new <font color=navy>double</font>[,]{{+1,+1,0,-1},{+1,-1,-1,0},{-1,-1,0,+1},{-1,+1,+1,0}};
    alglib.rbfsetpoints(model, xy);

    <font color=green>// We added points, but model was not rebuild yet.</font>
    <font color=green>// If we call rbfcalc(), we still will get 0.0 as result.</font>
    alglib.rbfcalc(model, x, <font color=navy>out</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,2)); <font color=green>// EXPECTED: [0.000,0.000]</font>

    <font color=green>//</font>
    <font color=green>// Step 3: rebuild model</font>
    <font color=green>//</font>
    <font color=green>// After we've configured model, we should rebuild it -</font>
    <font color=green>// it will change coefficients stored internally in the</font>
    <font color=green>// rbfmodel structure.</font>
    <font color=green>//</font>
    alglib.rbfreport rep;
    alglib.rbfbuildmodel(model, <font color=navy>out</font> rep);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, rep.terminationtype); <font color=green>// EXPECTED: 1</font>

    <font color=green>//</font>
    <font color=green>// Step 4: model was built</font>
    <font color=green>//</font>
    <font color=green>// After call of rbfbuildmodel(), rbfcalc() will <font color=navy>return</font></font>
    <font color=green>// value of the new model.</font>
    <font color=green>//</font>
    alglib.rbfcalc(model, x, <font color=navy>out</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,2)); <font color=green>// EXPECTED: [0.000,-1.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_rcond></a><h2 class=pageheader><code>rcond</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlurcond1' class=toc>cmatrixlurcond1</a><br>
<a href='#sub_cmatrixlurcondinf' class=toc>cmatrixlurcondinf</a><br>
<a href='#sub_cmatrixrcond1' class=toc>cmatrixrcond1</a><br>
<a href='#sub_cmatrixrcondinf' class=toc>cmatrixrcondinf</a><br>
<a href='#sub_cmatrixtrrcond1' class=toc>cmatrixtrrcond1</a><br>
<a href='#sub_cmatrixtrrcondinf' class=toc>cmatrixtrrcondinf</a><br>
<a href='#sub_hpdmatrixcholeskyrcond' class=toc>hpdmatrixcholeskyrcond</a><br>
<a href='#sub_hpdmatrixrcond' class=toc>hpdmatrixrcond</a><br>
<a href='#sub_rmatrixlurcond1' class=toc>rmatrixlurcond1</a><br>
<a href='#sub_rmatrixlurcondinf' class=toc>rmatrixlurcondinf</a><br>
<a href='#sub_rmatrixrcond1' class=toc>rmatrixrcond1</a><br>
<a href='#sub_rmatrixrcondinf' class=toc>rmatrixrcondinf</a><br>
<a href='#sub_rmatrixtrrcond1' class=toc>rmatrixtrrcond1</a><br>
<a href='#sub_rmatrixtrrcondinf' class=toc>rmatrixtrrcondinf</a><br>
<a href='#sub_spdmatrixcholeskyrcond' class=toc>spdmatrixcholeskyrcond</a><br>
<a href='#sub_spdmatrixrcond' class=toc>spdmatrixrcond</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixlurcond1'></a><h3 class=pageheader><code>cmatrixlurcond1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA         -   LU decomposition of a matrix in compact form. Output of
                    the CMatrixLU subroutine.
    N           -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cmatrixlurcond1(complex[,] lua, <font color=navy>int</font> n)

</div></pre>
<a name='sub_cmatrixlurcondinf'></a><h3 class=pageheader><code>cmatrixlurcondinf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition
(infinity norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA     -   LU decomposition of a matrix in compact form. Output of
                the CMatrixLU subroutine.
    N       -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cmatrixlurcondinf(complex[,] lua, <font color=navy>int</font> n)

</div></pre>
<a name='sub_cmatrixrcond1'></a><h3 class=pageheader><code>cmatrixrcond1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cmatrixrcond1(complex[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_cmatrixrcondinf'></a><h3 class=pageheader><code>cmatrixrcondinf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cmatrixrcondinf(complex[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_cmatrixtrrcond1'></a><h3 class=pageheader><code>cmatrixtrrcond1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A       -   matrix. Array[0..N-1, 0..N-1].
    N       -   size of A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cmatrixtrrcond1(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit)

</div></pre>
<a name='sub_cmatrixtrrcondinf'></a><h3 class=pageheader><code>cmatrixtrrcondinf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.cmatrixtrrcondinf(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit)

</div></pre>
<a name='sub_hpdmatrixcholeskyrcond'></a><h3 class=pageheader><code>hpdmatrixcholeskyrcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a Hermitian positive definite matrix given by
Cholesky decomposition.

The algorithm calculates a lower bound of the condition number. In this
case, the algorithm does not return a lower bound of the condition number,
but an inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    CD  - Cholesky decomposition of matrix A,
          output of SMatrixCholesky subroutine.
    N   - size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hpdmatrixcholeskyrcond(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_hpdmatrixrcond'></a><h3 class=pageheader><code>hpdmatrixrcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a Hermitian positive definite matrix.

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm of condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    A       -   Hermitian positive definite matrix which is given by its
                upper or lower triangle depending on the value of
                IsUpper. Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.

Result:
    1/LowerBound(cond(A)), if matrix A is positive definite,
   -1, if matrix A is not positive definite, and its condition number
    could not be found by this algorithm.

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.hpdmatrixrcond(
    complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_rmatrixlurcond1'></a><h3 class=pageheader><code>rmatrixlurcond1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA         -   LU decomposition of a matrix in compact form. Output of
                    the RMatrixLU subroutine.
    N           -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixlurcond1(<font color=navy>double</font>[,] lua, <font color=navy>int</font> n)

</div></pre>
<a name='sub_rmatrixlurcondinf'></a><h3 class=pageheader><code>rmatrixlurcondinf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition
(infinity norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA     -   LU decomposition of a matrix in compact form. Output of
                the RMatrixLU subroutine.
    N       -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixlurcondinf(<font color=navy>double</font>[,] lua, <font color=navy>int</font> n)

</div></pre>
<a name='sub_rmatrixrcond1'></a><h3 class=pageheader><code>rmatrixrcond1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixrcond1(<font color=navy>double</font>[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_rmatrixrcondinf'></a><h3 class=pageheader><code>rmatrixrcondinf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixrcondinf(<font color=navy>double</font>[,] a, <font color=navy>int</font> n)

</div></pre>
<a name='sub_rmatrixtrrcond1'></a><h3 class=pageheader><code>rmatrixtrrcond1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A       -   matrix. Array[0..N-1, 0..N-1].
    N       -   size of A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixtrrcond1(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit)

</div></pre>
<a name='sub_rmatrixtrrcondinf'></a><h3 class=pageheader><code>rmatrixtrrcondinf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.rmatrixtrrcondinf(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit)

</div></pre>
<a name='sub_spdmatrixcholeskyrcond'></a><h3 class=pageheader><code>spdmatrixcholeskyrcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a symmetric positive definite matrix given by
Cholesky decomposition.

The algorithm calculates a lower bound of the condition number. In this
case, the algorithm does not return a lower bound of the condition number,
but an inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    CD  - Cholesky decomposition of matrix A,
          output of SMatrixCholesky subroutine.
    N   - size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spdmatrixcholeskyrcond(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_spdmatrixrcond'></a><h3 class=pageheader><code>spdmatrixrcond</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a symmetric positive definite matrix.

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm of condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    A       -   symmetric positive definite matrix which is given by its
                upper or lower triangle depending on the value of
                IsUpper. Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.

Result:
    1/LowerBound(cond(A)), if matrix A is positive definite,
   -1, if matrix A is not positive definite, and its condition number
    could not be found by this algorithm.

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spdmatrixrcond(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name=unit_schur></a><h2 class=pageheader><code>schur</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixschur' class=toc>rmatrixschur</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixschur'></a><h3 class=pageheader><code>rmatrixschur</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine performing the Schur decomposition of a general matrix by using
the QR algorithm with multiple shifts.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Multithreaded acceleration is NOT supported for this function.
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

The source matrix A is represented as S'*A*S = T, where S is an orthogonal
matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
sizes 1x1 and 2x2 on the main diagonal).

Input parameters:
    A   -   matrix to be decomposed.
            Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of A, N&gt;=0.


Output parameters:
    A   -   contains matrix T.
            Array whose indexes range within [0..N-1, 0..N-1].
    S   -   contains Schur vectors.
            Array whose indexes range within [0..N-1, 0..N-1].

Note 1:
    The block structure of matrix T can be easily recognized: since all
    the elements below the blocks are zeros, the elements a[i+1,i] which
    are equal to 0 show the block border.

Note 2:
    The algorithm performance depends on the value of the internal parameter
    NS of the InternalSchurDecomposition subroutine which defines the number
    of shifts in the QR algorithm (similarly to the block width in block-matrix
    algorithms in linear algebra). If you require maximum performance on
    your machine, it is recommended to adjust this parameter manually.

Result:
    True,
        if the algorithm has converged and parameters A and S contain the result.
    False,
        if the algorithm has not converged.

Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.rmatrixschur(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[,] s)

</div></pre>
<a name=unit_sparse></a><h2 class=pageheader><code>sparse</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_sparsebuffers' class=toc>sparsebuffers</a><br>
<a href='#struct_sparsematrix' class=toc>sparsematrix</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_sparseadd' class=toc>sparseadd</a><br>
<a href='#sub_sparseconvertto' class=toc>sparseconvertto</a><br>
<a href='#sub_sparseconverttocrs' class=toc>sparseconverttocrs</a><br>
<a href='#sub_sparseconverttohash' class=toc>sparseconverttohash</a><br>
<a href='#sub_sparseconverttosks' class=toc>sparseconverttosks</a><br>
<a href='#sub_sparsecopy' class=toc>sparsecopy</a><br>
<a href='#sub_sparsecopybuf' class=toc>sparsecopybuf</a><br>
<a href='#sub_sparsecopytobuf' class=toc>sparsecopytobuf</a><br>
<a href='#sub_sparsecopytocrs' class=toc>sparsecopytocrs</a><br>
<a href='#sub_sparsecopytocrsbuf' class=toc>sparsecopytocrsbuf</a><br>
<a href='#sub_sparsecopytohash' class=toc>sparsecopytohash</a><br>
<a href='#sub_sparsecopytohashbuf' class=toc>sparsecopytohashbuf</a><br>
<a href='#sub_sparsecopytosks' class=toc>sparsecopytosks</a><br>
<a href='#sub_sparsecopytosksbuf' class=toc>sparsecopytosksbuf</a><br>
<a href='#sub_sparsecreate' class=toc>sparsecreate</a><br>
<a href='#sub_sparsecreatebuf' class=toc>sparsecreatebuf</a><br>
<a href='#sub_sparsecreatecrs' class=toc>sparsecreatecrs</a><br>
<a href='#sub_sparsecreatecrsbuf' class=toc>sparsecreatecrsbuf</a><br>
<a href='#sub_sparsecreatesks' class=toc>sparsecreatesks</a><br>
<a href='#sub_sparsecreatesksbuf' class=toc>sparsecreatesksbuf</a><br>
<a href='#sub_sparseenumerate' class=toc>sparseenumerate</a><br>
<a href='#sub_sparsefree' class=toc>sparsefree</a><br>
<a href='#sub_sparseget' class=toc>sparseget</a><br>
<a href='#sub_sparsegetcompressedrow' class=toc>sparsegetcompressedrow</a><br>
<a href='#sub_sparsegetdiagonal' class=toc>sparsegetdiagonal</a><br>
<a href='#sub_sparsegetlowercount' class=toc>sparsegetlowercount</a><br>
<a href='#sub_sparsegetmatrixtype' class=toc>sparsegetmatrixtype</a><br>
<a href='#sub_sparsegetncols' class=toc>sparsegetncols</a><br>
<a href='#sub_sparsegetnrows' class=toc>sparsegetnrows</a><br>
<a href='#sub_sparsegetrow' class=toc>sparsegetrow</a><br>
<a href='#sub_sparsegetuppercount' class=toc>sparsegetuppercount</a><br>
<a href='#sub_sparseiscrs' class=toc>sparseiscrs</a><br>
<a href='#sub_sparseishash' class=toc>sparseishash</a><br>
<a href='#sub_sparseissks' class=toc>sparseissks</a><br>
<a href='#sub_sparsemm' class=toc>sparsemm</a><br>
<a href='#sub_sparsemm2' class=toc>sparsemm2</a><br>
<a href='#sub_sparsemtm' class=toc>sparsemtm</a><br>
<a href='#sub_sparsemtv' class=toc>sparsemtv</a><br>
<a href='#sub_sparsemv' class=toc>sparsemv</a><br>
<a href='#sub_sparsemv2' class=toc>sparsemv2</a><br>
<a href='#sub_sparseresizematrix' class=toc>sparseresizematrix</a><br>
<a href='#sub_sparserewriteexisting' class=toc>sparserewriteexisting</a><br>
<a href='#sub_sparseset' class=toc>sparseset</a><br>
<a href='#sub_sparsesmm' class=toc>sparsesmm</a><br>
<a href='#sub_sparsesmv' class=toc>sparsesmv</a><br>
<a href='#sub_sparseswap' class=toc>sparseswap</a><br>
<a href='#sub_sparsetransposesks' class=toc>sparsetransposesks</a><br>
<a href='#sub_sparsetrmv' class=toc>sparsetrmv</a><br>
<a href='#sub_sparsetrsv' class=toc>sparsetrsv</a><br>
<a href='#sub_sparsevsmv' class=toc>sparsevsmv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_sparse_d_1' class=toc>sparse_d_1</a></td><td width=15>&nbsp;</td><td>Basic operations with sparse matrices</td></tr>
<tr align=left valign=top><td><a href='#example_sparse_d_crs' class=toc>sparse_d_crs</a></td><td width=15>&nbsp;</td><td>Advanced topic: creation in the CRS format.</td></tr>
</table></div>
<a name='struct_sparsebuffers'></a><h3 class=pageheader><code>sparsebuffers</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Temporary buffers for sparse matrix operations.

You should pass an instance of this structure to factorization  functions.
It allows to reuse memory during repeated sparse  factorizations.  You  do
not have to call some initialization function - simply passing an instance
to factorization function is enough.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class sparsebuffers
{
}

</div></pre>
<a name='struct_sparsematrix'></a><h3 class=pageheader><code>sparsematrix</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Sparse matrix structure.

You should use ALGLIB functions to work with sparse matrix. Never  try  to
access its fields directly!

NOTES ON THE SPARSE STORAGE FORMATS

Sparse matrices can be stored using several formats:
* Hash-Table representation
* Compressed Row Storage (CRS)
* Skyline matrix storage (SKS)

Each of the formats has benefits and drawbacks:
* Hash-table is good for dynamic operations (insertion of new elements),
  but does not support linear algebra operations
* CRS is good for operations like matrix-vector or matrix-matrix products,
  but its initialization is less convenient - you have to tell row   sizes
  at the initialization, and you have to fill  matrix  only  row  by  row,
  from left to right.
* SKS is a special format which is used to store triangular  factors  from
  Cholesky factorization. It does not support  dynamic  modification,  and
  support for linear algebra operations is very limited.

Tables below outline information about these two formats:

    OPERATIONS WITH MATRIX      HASH        CRS         SKS
    creation                    +           +           +
    SparseGet                   +           +           +
    SparseRewriteExisting       +           +           +
    SparseSet                   +
    SparseAdd                   +
    SparseGetRow                            +           +
    SparseGetCompressedRow                  +           +
    sparse-dense linear algebra             +           +
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class sparsematrix
{
}

</div></pre>
<a name='sub_sparseadd'></a><h3 class=pageheader><code>sparseadd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function adds value to S[i,j] - element of the sparse matrix. Matrix
must be in a Hash-Table mode.

In case S[i,j] already exists in the table, V i added to  its  value.  In
case  S[i,j]  is  non-existent,  it  is  inserted  in  the  table.  Table
automatically grows when necessary.

INPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table representation.
                    Exception will be thrown for CRS matrix.
    I           -   row index of the element to modify, 0&lt;=I&lt;M
    J           -   column index of the element to modify, 0&lt;=J&lt;N
    V           -   value to add, must be finite number

OUTPUT PARAMETERS
    S           -   modified matrix

NOTE 1:  when  S[i,j]  is exactly zero after modification, it is  deleted
from the table.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseadd(
    sparsematrix s,
    <font color=navy>int</font> i,
    <font color=navy>int</font> j,
    <font color=navy>double</font> v)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_sparseconvertto'></a><h3 class=pageheader><code>sparseconvertto</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  in-place  conversion  to  desired sparse storage
format.

INPUT PARAMETERS
    S0      -   sparse matrix in any format.
    Fmt     -   desired storage format  of  the  output,  as  returned  by
                SparseGetMatrixType() function:
                * 0 for hash-based storage
                * 1 for CRS
                * 2 for SKS

OUTPUT PARAMETERS
    S0          -   sparse matrix in requested format.

NOTE: in-place conversion wastes a lot of memory which is  used  to  store
      temporaries.  If  you  perform  a  lot  of  repeated conversions, we
      recommend to use out-of-place buffered  conversion  functions,  like
      SparseCopyToBuf(), which can reuse already allocated memory.

  -- ALGLIB PROJECT --
     Copyright 16.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseconvertto(sparsematrix s0, <font color=navy>int</font> fmt)

</div></pre>
<a name='sub_sparseconverttocrs'></a><h3 class=pageheader><code>sparseconverttocrs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function converts matrix to CRS format.

Some  algorithms  (linear  algebra ones, for example) require matrices in
CRS format. This function allows to perform in-place conversion.

INPUT PARAMETERS
    S           -   sparse M*N matrix in any format

OUTPUT PARAMETERS
    S           -   matrix in CRS format

NOTE: this   function  has  no  effect  when  called with matrix which is
      already in CRS mode.

NOTE: this function allocates temporary memory to store a   copy  of  the
      matrix. If you perform a lot of repeated conversions, we  recommend
      you  to  use  SparseCopyToCRSBuf()  function,   which   can   reuse
      previously allocated memory.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseconverttocrs(sparsematrix s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_sparseconverttohash'></a><h3 class=pageheader><code>sparseconverttohash</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function performs in-place conversion to Hash table storage.

INPUT PARAMETERS
    S           -   sparse matrix in CRS format.

OUTPUT PARAMETERS
    S           -   sparse matrix in Hash table format.

NOTE: this  function  has   no  effect  when  called with matrix which  is
      already in Hash table mode.

NOTE: in-place conversion involves allocation of temporary arrays. If  you
      perform a lot of repeated in- place  conversions,  it  may  lead  to
      memory fragmentation. Consider using out-of-place SparseCopyToHashBuf()
      function in this case.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseconverttohash(sparsematrix s)

</div></pre>
<a name='sub_sparseconverttosks'></a><h3 class=pageheader><code>sparseconverttosks</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function performs in-place conversion to SKS format.

INPUT PARAMETERS
    S           -   sparse matrix in any format.

OUTPUT PARAMETERS
    S           -   sparse matrix in SKS format.

NOTE: this  function  has   no  effect  when  called with matrix which  is
      already in SKS mode.

NOTE: in-place conversion involves allocation of temporary arrays. If  you
      perform a lot of repeated in- place  conversions,  it  may  lead  to
      memory fragmentation. Consider using out-of-place SparseCopyToSKSBuf()
      function in this case.

  -- ALGLIB PROJECT --
     Copyright 15.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseconverttosks(sparsematrix s)

</div></pre>
<a name='sub_sparsecopy'></a><h3 class=pageheader><code>sparsecopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function copies S0 to S1.
This function completely deallocates memory owned by S1 before creating a
copy of S0. If you want to reuse memory, use SparseCopyBuf.

NOTE:  this  function  does  not verify its arguments, it just copies all
fields of the structure.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopy(sparsematrix s0, <font color=navy>out</font> sparsematrix s1)

</div></pre>
<a name='sub_sparsecopybuf'></a><h3 class=pageheader><code>sparsecopybuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function copies S0 to S1.
Memory already allocated in S1 is reused as much as possible.

NOTE:  this  function  does  not verify its arguments, it just copies all
fields of the structure.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopybuf(sparsematrix s0, sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytobuf'></a><h3 class=pageheader><code>sparsecopytobuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs out-of-place conversion to desired sparse storage
format. S0 is copied to S1 and converted on-the-fly. Memory  allocated  in
S1 is reused to maximum extent possible.

INPUT PARAMETERS
    S0      -   sparse matrix in any format.
    Fmt     -   desired storage format  of  the  output,  as  returned  by
                SparseGetMatrixType() function:
                * 0 for hash-based storage
                * 1 for CRS
                * 2 for SKS

OUTPUT PARAMETERS
    S1          -   sparse matrix in requested format.

  -- ALGLIB PROJECT --
     Copyright 16.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytobuf(
    sparsematrix s0,
    <font color=navy>int</font> fmt,
    sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytocrs'></a><h3 class=pageheader><code>sparsecopytocrs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
copied to S1 and converted on-the-fly.

INPUT PARAMETERS
    S0          -   sparse matrix in any format.

OUTPUT PARAMETERS
    S1          -   sparse matrix in CRS format.

NOTE: if S0 is stored as CRS, it is just copied without conversion.

NOTE: this function de-allocates memory occupied by S1 before starting CRS
      conversion. If you perform a lot of repeated CRS conversions, it may
      lead to memory fragmentation. In this case we recommend you  to  use
      SparseCopyToCRSBuf() function which re-uses memory in S1 as much  as
      possible.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytocrs(
    sparsematrix s0,
    <font color=navy>out</font> sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytocrsbuf'></a><h3 class=pageheader><code>sparsecopytocrsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  out-of-place  conversion  to  CRS format.  S0 is
copied to S1 and converted on-the-fly. Memory allocated in S1 is reused to
maximum extent possible.

INPUT PARAMETERS
    S0          -   sparse matrix in any format.
    S1          -   matrix which may contain some pre-allocated memory, or
                    can be just uninitialized structure.

OUTPUT PARAMETERS
    S1          -   sparse matrix in CRS format.

NOTE: if S0 is stored as CRS, it is just copied without conversion.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytocrsbuf(
    sparsematrix s0,
    sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytohash'></a><h3 class=pageheader><code>sparsecopytohash</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  out-of-place  conversion  to  Hash table storage
format. S0 is copied to S1 and converted on-the-fly.

INPUT PARAMETERS
    S0          -   sparse matrix in any format.

OUTPUT PARAMETERS
    S1          -   sparse matrix in Hash table format.

NOTE: if S0 is stored as Hash-table, it is just copied without conversion.

NOTE: this function de-allocates memory  occupied  by  S1 before  starting
      conversion. If you perform a  lot  of  repeated  conversions, it may
      lead to memory fragmentation. In this case we recommend you  to  use
      SparseCopyToHashBuf() function which re-uses memory in S1 as much as
      possible.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytohash(
    sparsematrix s0,
    <font color=navy>out</font> sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytohashbuf'></a><h3 class=pageheader><code>sparsecopytohashbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  out-of-place  conversion  to  Hash table storage
format. S0 is copied to S1 and converted on-the-fly. Memory  allocated  in
S1 is reused to maximum extent possible.

INPUT PARAMETERS
    S0          -   sparse matrix in any format.

OUTPUT PARAMETERS
    S1          -   sparse matrix in Hash table format.

NOTE: if S0 is stored as Hash-table, it is just copied without conversion.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytohashbuf(
    sparsematrix s0,
    sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytosks'></a><h3 class=pageheader><code>sparsecopytosks</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  out-of-place  conversion  to SKS storage format.
S0 is copied to S1 and converted on-the-fly.

INPUT PARAMETERS
    S0          -   sparse matrix in any format.

OUTPUT PARAMETERS
    S1          -   sparse matrix in SKS format.

NOTE: if S0 is stored as SKS, it is just copied without conversion.

NOTE: this function de-allocates memory  occupied  by  S1 before  starting
      conversion. If you perform a  lot  of  repeated  conversions, it may
      lead to memory fragmentation. In this case we recommend you  to  use
      SparseCopyToSKSBuf() function which re-uses memory in S1 as much  as
      possible.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytosks(
    sparsematrix s0,
    <font color=navy>out</font> sparsematrix s1)

</div></pre>
<a name='sub_sparsecopytosksbuf'></a><h3 class=pageheader><code>sparsecopytosksbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  performs  out-of-place  conversion  to SKS format.  S0  is
copied to S1 and converted on-the-fly. Memory  allocated  in S1 is  reused
to maximum extent possible.

INPUT PARAMETERS
    S0          -   sparse matrix in any format.

OUTPUT PARAMETERS
    S1          -   sparse matrix in SKS format.

NOTE: if S0 is stored as SKS, it is just copied without conversion.

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecopytosksbuf(
    sparsematrix s0,
    sparsematrix s1)

</div></pre>
<a name='sub_sparsecreate'></a><h3 class=pageheader><code>sparsecreate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function creates sparse matrix in a Hash-Table format.

This function creates Hast-Table matrix, which can be  converted  to  CRS
format after its initialization is over. Typical  usage  scenario  for  a
sparse matrix is:
1. creation in a Hash-Table format
2. insertion of the matrix elements
3. conversion to the CRS representation
4. matrix is passed to some linear algebra algorithm

Some  information  about  different matrix formats can be found below, in
the &quot;NOTES&quot; section.

INPUT PARAMETERS
    M           -   number of rows in a matrix, M&gt;=1
    N           -   number of columns in a matrix, N&gt;=1
    K           -   K&gt;=0, expected number of non-zero elements in a matrix.
                    K can be inexact approximation, can be less than actual
                    number  of  elements  (table will grow when needed) or
                    even zero).
                    It is important to understand that although hash-table
                    may grow automatically, it is better to  provide  good
                    estimate of data size.

OUTPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table representation.
                    All elements of the matrix are zero.

NOTE 1

Hash-tables use memory inefficiently, and they have to keep  some  amount
of the &quot;spare memory&quot; in order to have good performance. Hash  table  for
matrix with K non-zero elements will  need  C*K*(8+2*sizeof(int))  bytes,
where C is a small constant, about 1.5-2 in magnitude.

CRS storage, from the other side, is  more  memory-efficient,  and  needs
just K*(8+sizeof(int))+M*sizeof(int) bytes, where M is a number  of  rows
in a matrix.

When you convert from the Hash-Table to CRS  representation, all unneeded
memory will be freed.

NOTE 2

Comments of SparseMatrix structure outline  information  about  different
sparse storage formats. We recommend you to read them before starting  to
use ALGLIB sparse matrices.

NOTE 3

This function completely  overwrites S with new sparse matrix. Previously
allocated storage is NOT reused. If you  want  to reuse already allocated
memory, call SparseCreateBuf function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreate(<font color=navy>int</font> m, <font color=navy>int</font> n, <font color=navy>out</font> sparsematrix s)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreate(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    <font color=navy>out</font> sparsematrix s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_sparsecreatebuf'></a><h3 class=pageheader><code>sparsecreatebuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This version of SparseCreate function creates sparse matrix in Hash-Table
format, reusing previously allocated storage as much  as  possible.  Read
comments for SparseCreate() for more information.

INPUT PARAMETERS
    M           -   number of rows in a matrix, M&gt;=1
    N           -   number of columns in a matrix, N&gt;=1
    K           -   K&gt;=0, expected number of non-zero elements in a matrix.
                    K can be inexact approximation, can be less than actual
                    number  of  elements  (table will grow when needed) or
                    even zero).
                    It is important to understand that although hash-table
                    may grow automatically, it is better to  provide  good
                    estimate of data size.
    S           -   SparseMatrix structure which MAY contain some  already
                    allocated storage.

OUTPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table representation.
                    All elements of the matrix are zero.
                    Previously allocated storage is reused, if  its  size
                    is compatible with expected number of non-zeros K.

  -- ALGLIB PROJECT --
     Copyright 14.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreatebuf(<font color=navy>int</font> m, <font color=navy>int</font> n, sparsematrix s)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreatebuf(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> k,
    sparsematrix s)

</div></pre>
<a name='sub_sparsecreatecrs'></a><h3 class=pageheader><code>sparsecreatecrs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function creates sparse matrix in a CRS format (expert function for
situations when you are running out of memory).

This function creates CRS matrix. Typical usage scenario for a CRS matrix
is:
1. creation (you have to tell number of non-zero elements at each row  at
   this moment)
2. insertion of the matrix elements (row by row, from left to right)
3. matrix is passed to some linear algebra algorithm

This function is a memory-efficient alternative to SparseCreate(), but it
is more complex because it requires you to know in advance how large your
matrix is. Some  information about  different matrix formats can be found
in comments on SparseMatrix structure.  We recommend  you  to  read  them
before starting to use ALGLIB sparse matrices..

INPUT PARAMETERS
    M           -   number of rows in a matrix, M&gt;=1
    N           -   number of columns in a matrix, N&gt;=1
    NER         -   number of elements at each row, array[M], NER[I]&gt;=0

OUTPUT PARAMETERS
    S           -   sparse M*N matrix in CRS representation.
                    You have to fill ALL non-zero elements by calling
                    SparseSet() BEFORE you try to use this matrix.

NOTE: this function completely  overwrites  S  with  new  sparse  matrix.
      Previously allocated storage is NOT reused. If you  want  to  reuse
      already allocated memory, call SparseCreateCRSBuf function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreatecrs(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font>[] ner,
    <font color=navy>out</font> sparsematrix s)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_crs' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_sparsecreatecrsbuf'></a><h3 class=pageheader><code>sparsecreatecrsbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function creates sparse matrix in a CRS format (expert function  for
situations when you are running out  of  memory).  This  version  of  CRS
matrix creation function may reuse memory already allocated in S.

This function creates CRS matrix. Typical usage scenario for a CRS matrix
is:
1. creation (you have to tell number of non-zero elements at each row  at
   this moment)
2. insertion of the matrix elements (row by row, from left to right)
3. matrix is passed to some linear algebra algorithm

This function is a memory-efficient alternative to SparseCreate(), but it
is more complex because it requires you to know in advance how large your
matrix is. Some  information about  different matrix formats can be found
in comments on SparseMatrix structure.  We recommend  you  to  read  them
before starting to use ALGLIB sparse matrices..

INPUT PARAMETERS
    M           -   number of rows in a matrix, M&gt;=1
    N           -   number of columns in a matrix, N&gt;=1
    NER         -   number of elements at each row, array[M], NER[I]&gt;=0
    S           -   sparse matrix structure with possibly preallocated
                    memory.

OUTPUT PARAMETERS
    S           -   sparse M*N matrix in CRS representation.
                    You have to fill ALL non-zero elements by calling
                    SparseSet() BEFORE you try to use this matrix.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreatecrsbuf(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font>[] ner,
    sparsematrix s)

</div></pre>
<a name='sub_sparsecreatesks'></a><h3 class=pageheader><code>sparsecreatesks</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function creates sparse matrix in  a  SKS  format  (skyline  storage
format). In most cases you do not need this function - CRS format  better
suits most use cases.

INPUT PARAMETERS
    M, N        -   number of rows(M) and columns (N) in a matrix:
                    * M=N (as for now, ALGLIB supports only square SKS)
                    * N&gt;=1
                    * M&gt;=1
    D           -   &quot;bottom&quot; bandwidths, array[M], D[I]&gt;=0.
                    I-th element stores number of non-zeros at I-th  row,
                    below the diagonal (diagonal itself is not  included)
    U           -   &quot;top&quot; bandwidths, array[N], U[I]&gt;=0.
                    I-th element stores number of non-zeros  at I-th row,
                    above the diagonal (diagonal itself  is not included)

OUTPUT PARAMETERS
    S           -   sparse M*N matrix in SKS representation.
                    All elements are filled by zeros.
                    You may use SparseRewriteExisting() to  change  their
                    values.

NOTE: this function completely  overwrites  S  with  new  sparse  matrix.
      Previously allocated storage is NOT reused. If you  want  to  reuse
      already allocated memory, call SparseCreateSKSBuf function.

  -- ALGLIB PROJECT --
     Copyright 13.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreatesks(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font>[] d,
    <font color=navy>int</font>[] u,
    <font color=navy>out</font> sparsematrix s)

</div></pre>
<a name='sub_sparsecreatesksbuf'></a><h3 class=pageheader><code>sparsecreatesksbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is &quot;buffered&quot;  version  of  SparseCreateSKS()  which  reuses  memory
previously allocated in S (of course, memory is reallocated if needed).

This function creates sparse matrix in  a  SKS  format  (skyline  storage
format). In most cases you do not need this function - CRS format  better
suits most use cases.

INPUT PARAMETERS
    M, N        -   number of rows(M) and columns (N) in a matrix:
                    * M=N (as for now, ALGLIB supports only square SKS)
                    * N&gt;=1
                    * M&gt;=1
    D           -   &quot;bottom&quot; bandwidths, array[M], 0&lt;=D[I]&lt;=I.
                    I-th element stores number of non-zeros at I-th row,
                    below the diagonal (diagonal itself is not included)
    U           -   &quot;top&quot; bandwidths, array[N], 0&lt;=U[I]&lt;=I.
                    I-th element stores number of non-zeros at I-th row,
                    above the diagonal (diagonal itself is not included)

OUTPUT PARAMETERS
    S           -   sparse M*N matrix in SKS representation.
                    All elements are filled by zeros.
                    You may use SparseSet()/SparseAdd() to change their
                    values.

  -- ALGLIB PROJECT --
     Copyright 13.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsecreatesksbuf(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font>[] d,
    <font color=navy>int</font>[] u,
    sparsematrix s)

</div></pre>
<a name='sub_sparseenumerate'></a><h3 class=pageheader><code>sparseenumerate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  is  used  to enumerate all elements of the sparse matrix.
Before  first  call  user  initializes  T0 and T1 counters by zero. These
counters are used to remember current position in a  matrix;  after  each
call they are updated by the function.

Subsequent calls to this function return non-zero elements of the  sparse
matrix, one by one. If you enumerate CRS matrix, matrix is traversed from
left to right, from top to bottom. In case you enumerate matrix stored as
Hash table, elements are returned in random order.

EXAMPLE
    &gt; T0=0
    &gt; T1=0
    &gt; while SparseEnumerate(S,T0,T1,I,J,V) do
    &gt;     ....do something with I,J,V

INPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table or CRS representation.
    T0          -   internal counter
    T1          -   internal counter

OUTPUT PARAMETERS
    T0          -   new value of the internal counter
    T1          -   new value of the internal counter
    I           -   row index of non-zero element, 0&lt;=I&lt;M.
    J           -   column index of non-zero element, 0&lt;=J&lt;N
    V           -   value of the T-th element

RESULT
    True in case of success (next non-zero element was retrieved)
    False in case all non-zero elements were enumerated

NOTE: you may call SparseRewriteExisting() during enumeration, but it  is
      THE  ONLY  matrix  modification  function  you  can  call!!!  Other
      matrix modification functions should not be called during enumeration!

  -- ALGLIB PROJECT --
     Copyright 14.03.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.sparseenumerate(
    sparsematrix s,
    <font color=navy>ref</font> <font color=navy>int</font> t0,
    <font color=navy>ref</font> <font color=navy>int</font> t1,
    <font color=navy>out</font> <font color=navy>int</font> i,
    <font color=navy>out</font> <font color=navy>int</font> j,
    <font color=navy>out</font> <font color=navy>double</font> v)

</div></pre>
<a name='sub_sparsefree'></a><h3 class=pageheader><code>sparsefree</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The function frees all memory occupied by  sparse  matrix.  Sparse  matrix
structure becomes unusable after this call.

OUTPUT PARAMETERS
    S   -   sparse matrix to delete

  -- ALGLIB PROJECT --
     Copyright 24.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsefree(<font color=navy>out</font> sparsematrix s)

</div></pre>
<a name='sub_sparseget'></a><h3 class=pageheader><code>sparseget</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns S[i,j] - element of the sparse matrix.  Matrix  can
be in any mode (Hash-Table, CRS, SKS), but this function is less efficient
for CRS matrices. Hash-Table and SKS matrices can find  element  in  O(1)
time, while  CRS  matrices need O(log(RS)) time, where RS is an number of
non-zero elements in a row.

INPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table representation.
                    Exception will be thrown for CRS matrix.
    I           -   row index of the element to modify, 0&lt;=I&lt;M
    J           -   column index of the element to modify, 0&lt;=J&lt;N

RESULT
    value of S[I,J] or zero (in case no element with such index is found)

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.sparseget(sparsematrix s, <font color=navy>int</font> i, <font color=navy>int</font> j)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_sparse_d_crs' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_sparsegetcompressedrow'></a><h3 class=pageheader><code>sparsegetcompressedrow</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns I-th row of the sparse matrix IN COMPRESSED FORMAT -
only non-zero elements are returned (with their indexes). Matrix  must  be
stored in CRS or SKS format.

INPUT PARAMETERS:
    S           -   sparse M*N matrix in CRS format
    I           -   row index, 0&lt;=I&lt;M
    ColIdx      -   output buffer for column indexes, can be preallocated.
                    In case buffer size is too small to store I-th row, it
                    is automatically reallocated.
    Vals        -   output buffer for values, can be preallocated. In case
                    buffer size is too small to  store  I-th  row,  it  is
                    automatically reallocated.

OUTPUT PARAMETERS:
    ColIdx      -   column   indexes   of  non-zero  elements,  sorted  by
                    ascending. Symbolically non-zero elements are  counted
                    (i.e. if you allocated place for element, but  it  has
                    zero numerical value - it is counted).
    Vals        -   values. Vals[K] stores value of  matrix  element  with
                    indexes (I,ColIdx[K]). Symbolically non-zero  elements
                    are counted (i.e. if you allocated place for  element,
                    but it has zero numerical value - it is counted).
    NZCnt       -   number of symbolically non-zero elements per row.

NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non  CRS/SKS)
      is passed, this function throws exception.

NOTE: this function may allocate additional, unnecessary place for  ColIdx
      and Vals arrays. It is dictated by  performance  reasons  -  on  SKS
      matrices it is faster  to  allocate  space  at  the  beginning  with
      some &quot;extra&quot;-space, than performing two passes over matrix  -  first
      time to calculate exact space required for data, second  time  -  to
      store data itself.

  -- ALGLIB PROJECT --
     Copyright 10.12.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsegetcompressedrow(
    sparsematrix s,
    <font color=navy>int</font> i,
    <font color=navy>ref</font> <font color=navy>int</font>[] colidx,
    <font color=navy>ref</font> <font color=navy>double</font>[] vals,
    <font color=navy>out</font> <font color=navy>int</font> nzcnt)

</div></pre>
<a name='sub_sparsegetdiagonal'></a><h3 class=pageheader><code>sparsegetdiagonal</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns I-th diagonal element of the sparse matrix.

Matrix can be in any mode (Hash-Table or CRS storage), but this  function
is most efficient for CRS matrices - it requires less than 50 CPU  cycles
to extract diagonal element. For Hash-Table matrices we still  have  O(1)
query time, but function is many times slower.

INPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table representation.
                    Exception will be thrown for CRS matrix.
    I           -   index of the element to modify, 0&lt;=I&lt;min(M,N)

RESULT
    value of S[I,I] or zero (in case no element with such index is found)

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.sparsegetdiagonal(sparsematrix s, <font color=navy>int</font> i)

</div></pre>
<a name='sub_sparsegetlowercount'></a><h3 class=pageheader><code>sparsegetlowercount</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The function returns number of strictly lower triangular non-zero elements
in  the  matrix.  It  counts  SYMBOLICALLY non-zero elements, i.e. entries
in the sparse matrix data structure. If some element  has  zero  numerical
value, it is still counted.

This function has different cost for different types of matrices:
* for hash-based matrices it involves complete pass over entire hash-table
  with O(NNZ) cost, where NNZ is number of non-zero elements
* for CRS and SKS matrix types cost of counting is O(N) (N - matrix size).

RESULT: number of non-zero elements strictly below main diagonal

  -- ALGLIB PROJECT --
     Copyright 12.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.sparsegetlowercount(sparsematrix s)

</div></pre>
<a name='sub_sparsegetmatrixtype'></a><h3 class=pageheader><code>sparsegetmatrixtype</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns type of the matrix storage format.

INPUT PARAMETERS:
    S           -   sparse matrix.

RESULT:
    sparse storage format used by matrix:
        0   -   Hash-table
        1   -   CRS (compressed row storage)
        2   -   SKS (skyline)

NOTE: future  versions  of  ALGLIB  may  include additional sparse storage
      formats.


  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.sparsegetmatrixtype(sparsematrix s)

</div></pre>
<a name='sub_sparsegetncols'></a><h3 class=pageheader><code>sparsegetncols</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The function returns number of columns of a sparse matrix.

RESULT: number of columns of a sparse matrix.

  -- ALGLIB PROJECT --
     Copyright 23.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.sparsegetncols(sparsematrix s)

</div></pre>
<a name='sub_sparsegetnrows'></a><h3 class=pageheader><code>sparsegetnrows</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The function returns number of rows of a sparse matrix.

RESULT: number of rows of a sparse matrix.

  -- ALGLIB PROJECT --
     Copyright 23.08.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.sparsegetnrows(sparsematrix s)

</div></pre>
<a name='sub_sparsegetrow'></a><h3 class=pageheader><code>sparsegetrow</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns I-th row of the sparse matrix. Matrix must be stored
in CRS or SKS format.

INPUT PARAMETERS:
    S           -   sparse M*N matrix in CRS format
    I           -   row index, 0&lt;=I&lt;M
    IRow        -   output buffer, can be  preallocated.  In  case  buffer
                    size  is  too  small  to  store  I-th   row,   it   is
                    automatically reallocated.

OUTPUT PARAMETERS:
    IRow        -   array[M], I-th row.

NOTE: this function has O(N) running time, where N is a  column  count. It
      allocates and fills N-element  array,  even  although  most  of  its
      elemets are zero.

NOTE: If you have O(non-zeros-per-row) time and memory  requirements,  use
      SparseGetCompressedRow() function. It  returns  data  in  compressed
      format.

NOTE: when  incorrect  I  (outside  of  [0,M-1]) or  matrix (non  CRS/SKS)
      is passed, this function throws exception.

  -- ALGLIB PROJECT --
     Copyright 10.12.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsegetrow(
    sparsematrix s,
    <font color=navy>int</font> i,
    <font color=navy>ref</font> <font color=navy>double</font>[] irow)

</div></pre>
<a name='sub_sparsegetuppercount'></a><h3 class=pageheader><code>sparsegetuppercount</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
The function returns number of strictly upper triangular non-zero elements
in  the  matrix.  It  counts  SYMBOLICALLY non-zero elements, i.e. entries
in the sparse matrix data structure. If some element  has  zero  numerical
value, it is still counted.

This function has different cost for different types of matrices:
* for hash-based matrices it involves complete pass over entire hash-table
  with O(NNZ) cost, where NNZ is number of non-zero elements
* for CRS and SKS matrix types cost of counting is O(N) (N - matrix size).

RESULT: number of non-zero elements strictly above main diagonal

  -- ALGLIB PROJECT --
     Copyright 12.02.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.sparsegetuppercount(sparsematrix s)

</div></pre>
<a name='sub_sparseiscrs'></a><h3 class=pageheader><code>sparseiscrs</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function checks matrix storage format and returns True when matrix is
stored using CRS representation.

INPUT PARAMETERS:
    S   -   sparse matrix.

RESULT:
    True if matrix type is CRS
    False if matrix type is not CRS

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.sparseiscrs(sparsematrix s)

</div></pre>
<a name='sub_sparseishash'></a><h3 class=pageheader><code>sparseishash</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function checks matrix storage format and returns True when matrix is
stored using Hash table representation.

INPUT PARAMETERS:
    S   -   sparse matrix.

RESULT:
    True if matrix type is Hash table
    False if matrix type is not Hash table

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.sparseishash(sparsematrix s)

</div></pre>
<a name='sub_sparseissks'></a><h3 class=pageheader><code>sparseissks</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function checks matrix storage format and returns True when matrix is
stored using SKS representation.

INPUT PARAMETERS:
    S   -   sparse matrix.

RESULT:
    True if matrix type is SKS
    False if matrix type is not SKS

  -- ALGLIB PROJECT --
     Copyright 20.07.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.sparseissks(sparsematrix s)

</div></pre>
<a name='sub_sparsemm'></a><h3 class=pageheader><code>sparsemm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-matrix product  S*A.  Matrix  S  must  be
stored in CRS or SKS format (exception will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*N matrix in CRS or SKS format.
    A           -   array[N][K], input dense matrix. For  performance reasons
                    we make only quick checks - we check that array size
                    is at least N, but we do not check for NAN's or INF's.
    K           -   number of columns of matrix (A).
    B           -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    B           -   array[M][K], S*A

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsemm(
    sparsematrix s,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> k,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b)

</div></pre>
<a name='sub_sparsemm2'></a><h3 class=pageheader><code>sparsemm2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function simultaneously calculates two matrix-matrix products:
    S*A and S^T*A.
S  must  be  square (non-rectangular) matrix stored in CRS or  SKS  format
(exception will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse N*N matrix in CRS or SKS format.
    A           -   array[N][K], input dense matrix. For performance reasons
                    we make only quick checks - we check that array size  is
                    at least N, but we do not check for NAN's or INF's.
    K           -   number of columns of matrix (A).
    B0          -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.
    B1          -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    B0          -   array[N][K], S*A
    B1          -   array[N][K], S^T*A

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsemm2(
    sparsematrix s,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> k,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b0,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b1)

</div></pre>
<a name='sub_sparsemtm'></a><h3 class=pageheader><code>sparsemtm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-matrix product  S^T*A. Matrix S  must  be
stored in CRS or SKS format (exception will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*N matrix in CRS or SKS format.
    A           -   array[M][K], input dense matrix. For performance reasons
                    we make only quick checks - we check that array size  is
                    at least M, but we do not check for NAN's or INF's.
    K           -   number of columns of matrix (A).
    B           -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    B           -   array[N][K], S^T*A

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsemtm(
    sparsematrix s,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> k,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b)

</div></pre>
<a name='sub_sparsemtv'></a><h3 class=pageheader><code>sparsemtv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-vector product  S^T*x. Matrix S  must  be
stored in CRS or SKS format (exception will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*N matrix in CRS or SKS format.
    X           -   array[M], input vector. For  performance  reasons  we
                    make only quick checks - we check that array size  is
                    at least M, but we do not check for NAN's or INF's.
    Y           -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    Y           -   array[N], S^T*x

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsemtv(
    sparsematrix s,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_sparsemv'></a><h3 class=pageheader><code>sparsemv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-vector product  S*x.  Matrix  S  must  be
stored in CRS or SKS format (exception will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*N matrix in CRS or SKS format.
    X           -   array[N], input vector. For  performance  reasons  we
                    make only quick checks - we check that array size  is
                    at least N, but we do not check for NAN's or INF's.
    Y           -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    Y           -   array[M], S*x

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsemv(
    sparsematrix s,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_sparse_d_crs' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_sparsemv2'></a><h3 class=pageheader><code>sparsemv2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function simultaneously calculates two matrix-vector products:
    S*x and S^T*x.
S must be square (non-rectangular) matrix stored in  CRS  or  SKS  format
(exception will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse N*N matrix in CRS or SKS format.
    X           -   array[N], input vector. For  performance  reasons  we
                    make only quick checks - we check that array size  is
                    at least N, but we do not check for NAN's or INF's.
    Y0          -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.
    Y1          -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    Y0          -   array[N], S*x
    Y1          -   array[N], S^T*x

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsemv2(
    sparsematrix s,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y0,
    <font color=navy>ref</font> <font color=navy>double</font>[] y1)

</div></pre>
<a name='sub_sparseresizematrix'></a><h3 class=pageheader><code>sparseresizematrix</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This procedure resizes Hash-Table matrix. It can be called when you  have
deleted too many elements from the matrix, and you want to  free unneeded
memory.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseresizematrix(sparsematrix s)

</div></pre>
<a name='sub_sparserewriteexisting'></a><h3 class=pageheader><code>sparserewriteexisting</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function rewrites existing (non-zero) element. It  returns  True   if
element  exists  or  False,  when  it  is  called for non-existing  (zero)
element.

This function works with any kind of the matrix.

The purpose of this function is to provide convenient thread-safe  way  to
modify  sparse  matrix.  Such  modification  (already  existing element is
rewritten) is guaranteed to be thread-safe without any synchronization, as
long as different threads modify different elements.

INPUT PARAMETERS
    S           -   sparse M*N matrix in any kind of representation
                    (Hash, SKS, CRS).
    I           -   row index of non-zero element to modify, 0&lt;=I&lt;M
    J           -   column index of non-zero element to modify, 0&lt;=J&lt;N
    V           -   value to rewrite, must be finite number

OUTPUT PARAMETERS
    S           -   modified matrix
RESULT
    True in case when element exists
    False in case when element doesn't exist or it is zero

  -- ALGLIB PROJECT --
     Copyright 14.03.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.sparserewriteexisting(
    sparsematrix s,
    <font color=navy>int</font> i,
    <font color=navy>int</font> j,
    <font color=navy>double</font> v)

</div></pre>
<a name='sub_sparseset'></a><h3 class=pageheader><code>sparseset</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function modifies S[i,j] - element of the sparse matrix.

For Hash-based storage format:
* this function can be called at any moment - during matrix initialization
  or later
* new value can be zero or non-zero.  In case new value of S[i,j] is zero,
  this element is deleted from the table.
* this  function  has  no  effect when called with zero V for non-existent
  element.

For CRS-bases storage format:
* this function can be called ONLY DURING MATRIX INITIALIZATION
* new value MUST be non-zero. Exception will be thrown for zero V.
* elements must be initialized in correct order -  from top row to bottom,
  within row - from left to right.

For SKS storage: NOT SUPPORTED! Use SparseRewriteExisting() to  work  with
SKS matrices.

INPUT PARAMETERS
    S           -   sparse M*N matrix in Hash-Table or CRS representation.
    I           -   row index of the element to modify, 0&lt;=I&lt;M
    J           -   column index of the element to modify, 0&lt;=J&lt;N
    V           -   value to set, must be finite number, can be zero

OUTPUT PARAMETERS
    S           -   modified matrix

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseset(
    sparsematrix s,
    <font color=navy>int</font> i,
    <font color=navy>int</font> j,
    <font color=navy>double</font> v)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_sparse_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_sparse_d_crs' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_sparsesmm'></a><h3 class=pageheader><code>sparsesmm</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-matrix product  S*A, when S  is  symmetric
matrix. Matrix S must be stored in CRS or SKS format  (exception  will  be
thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*M matrix in CRS or SKS format.
    IsUpper     -   whether upper or lower triangle of S is given:
                    * if upper triangle is given,  only   S[i,j] for j&gt;=i
                      are used, and lower triangle is ignored (it can  be
                      empty - these elements are not referenced at all).
                    * if lower triangle is given,  only   S[i,j] for j&lt;=i
                      are used, and upper triangle is ignored.
    A           -   array[N][K], input dense matrix. For performance reasons
                    we make only quick checks - we check that array size is
                    at least N, but we do not check for NAN's or INF's.
    K           -   number of columns of matrix (A).
    B           -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    B           -   array[M][K], S*A

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsesmm(
    sparsematrix s,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> k,
    <font color=navy>ref</font> <font color=navy>double</font>[,] b)

</div></pre>
<a name='sub_sparsesmv'></a><h3 class=pageheader><code>sparsesmv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-vector product  S*x, when S is  symmetric
matrix. Matrix S  must be stored in CRS or SKS format  (exception will be
thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*M matrix in CRS or SKS format.
    IsUpper     -   whether upper or lower triangle of S is given:
                    * if upper triangle is given,  only   S[i,j] for j&gt;=i
                      are used, and lower triangle is ignored (it can  be
                      empty - these elements are not referenced at all).
                    * if lower triangle is given,  only   S[i,j] for j&lt;=i
                      are used, and upper triangle is ignored.
    X           -   array[N], input vector. For  performance  reasons  we
                    make only quick checks - we check that array size  is
                    at least N, but we do not check for NAN's or INF's.
    Y           -   output buffer, possibly preallocated. In case  buffer
                    size is too small to store  result,  this  buffer  is
                    automatically resized.

OUTPUT PARAMETERS
    Y           -   array[M], S*x

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 14.10.2011 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsesmv(
    sparsematrix s,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_sparseswap'></a><h3 class=pageheader><code>sparseswap</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function efficiently swaps contents of S0 and S1.

  -- ALGLIB PROJECT --
     Copyright 16.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparseswap(sparsematrix s0, sparsematrix s1)

</div></pre>
<a name='sub_sparsetransposesks'></a><h3 class=pageheader><code>sparsetransposesks</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function performs efficient in-place  transpose  of  SKS  matrix.  No
additional memory is allocated during transposition.

This function supports only skyline storage format (SKS).

INPUT PARAMETERS
    S       -   sparse matrix in SKS format.

OUTPUT PARAMETERS
    S           -   sparse matrix, transposed.

  -- ALGLIB PROJECT --
     Copyright 16.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsetransposesks(sparsematrix s)

</div></pre>
<a name='sub_sparsetrmv'></a><h3 class=pageheader><code>sparsetrmv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates matrix-vector product op(S)*x, when x is  vector,
S is symmetric triangular matrix, op(S) is transposition or no  operation.
Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown
otherwise).

INPUT PARAMETERS
    S           -   sparse square matrix in CRS or SKS format.
    IsUpper     -   whether upper or lower triangle of S is used:
                    * if upper triangle is given,  only   S[i,j] for  j&gt;=i
                      are used, and lower triangle is  ignored (it can  be
                      empty - these elements are not referenced at all).
                    * if lower triangle is given,  only   S[i,j] for  j&lt;=i
                      are used, and upper triangle is ignored.
    IsUnit      -   unit or non-unit diagonal:
                    * if True, diagonal elements of triangular matrix  are
                      considered equal to 1.0. Actual elements  stored  in
                      S are not referenced at all.
                    * if False, diagonal stored in S is used
    OpType      -   operation type:
                    * if 0, S*x is calculated
                    * if 1, (S^T)*x is calculated (transposition)
    X           -   array[N] which stores input  vector.  For  performance
                    reasons we make only quick  checks  -  we  check  that
                    array  size  is  at  least  N, but we do not check for
                    NAN's or INF's.
    Y           -   possibly  preallocated  input   buffer.  Automatically
                    resized if its size is too small.

OUTPUT PARAMETERS
    Y           -   array[N], op(S)*x

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 20.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsetrmv(
    sparsematrix s,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> <font color=navy>double</font>[] x,
    <font color=navy>ref</font> <font color=navy>double</font>[] y)

</div></pre>
<a name='sub_sparsetrsv'></a><h3 class=pageheader><code>sparsetrsv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves linear system op(S)*y=x  where  x  is  vector,  S  is
symmetric  triangular  matrix,  op(S)  is  transposition  or no operation.
Matrix S must be stored in CRS or SKS format  (exception  will  be  thrown
otherwise).

INPUT PARAMETERS
    S           -   sparse square matrix in CRS or SKS format.
    IsUpper     -   whether upper or lower triangle of S is used:
                    * if upper triangle is given,  only   S[i,j] for  j&gt;=i
                      are used, and lower triangle is  ignored (it can  be
                      empty - these elements are not referenced at all).
                    * if lower triangle is given,  only   S[i,j] for  j&lt;=i
                      are used, and upper triangle is ignored.
    IsUnit      -   unit or non-unit diagonal:
                    * if True, diagonal elements of triangular matrix  are
                      considered equal to 1.0. Actual elements  stored  in
                      S are not referenced at all.
                    * if False, diagonal stored in S is used. It  is  your
                      responsibility  to  make  sure  that   diagonal   is
                      non-zero.
    OpType      -   operation type:
                    * if 0, S*x is calculated
                    * if 1, (S^T)*x is calculated (transposition)
    X           -   array[N] which stores input  vector.  For  performance
                    reasons we make only quick  checks  -  we  check  that
                    array  size  is  at  least  N, but we do not check for
                    NAN's or INF's.

OUTPUT PARAMETERS
    X           -   array[N], inv(op(S))*x

NOTE: this function throws exception when called for  non-CRS/SKS  matrix.
      You must convert your matrix  with  SparseConvertToCRS/SKS()  before
      using this function.

NOTE: no assertion or tests are done during algorithm  operation.   It  is
      your responsibility to provide invertible matrix to algorithm.

  -- ALGLIB PROJECT --
     Copyright 20.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sparsetrsv(
    sparsematrix s,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font> isunit,
    <font color=navy>int</font> optype,
    <font color=navy>ref</font> <font color=navy>double</font>[] x)

</div></pre>
<a name='sub_sparsevsmv'></a><h3 class=pageheader><code>sparsevsmv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates vector-matrix-vector product x'*S*x, where  S is
symmetric matrix. Matrix S must be stored in CRS or SKS format (exception
will be thrown otherwise).

INPUT PARAMETERS
    S           -   sparse M*M matrix in CRS or SKS format.
    IsUpper     -   whether upper or lower triangle of S is given:
                    * if upper triangle is given,  only   S[i,j] for j&gt;=i
                      are used, and lower triangle is ignored (it can  be
                      empty - these elements are not referenced at all).
                    * if lower triangle is given,  only   S[i,j] for j&lt;=i
                      are used, and upper triangle is ignored.
    X           -   array[N], input vector. For  performance  reasons  we
                    make only quick checks - we check that array size  is
                    at least N, but we do not check for NAN's or INF's.

RESULT
    x'*S*x

NOTE: this function throws exception when called for non-CRS/SKS  matrix.
You must convert your matrix with SparseConvertToCRS/SKS()  before  using
this function.

  -- ALGLIB PROJECT --
     Copyright 27.01.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.sparsevsmv(
    sparsematrix s,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] x)

</div></pre>
<a name='example_sparse_d_1'></a><h3 class=pageheader>sparse_d_1 example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates creation/initialization of the sparse matrix</font>
    <font color=green>// and matrix-vector multiplication.</font>
    <font color=green>//</font>
    <font color=green>// First, we have to create matrix and initialize it. Matrix is initially created</font>
    <font color=green>// in the Hash-Table format, which allows convenient initialization. We can modify</font>
    <font color=green>// Hash-Table matrix with sparseset() and sparseadd() functions.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: Unlike CRS format, Hash-Table representation allows you to initialize</font>
    <font color=green>// elements in the arbitrary order. You may see that we initialize a[0][0] first,</font>
    <font color=green>// then move to the second row, and then move back to the first row.</font>
    <font color=green>//</font>
    alglib.sparsematrix s;
    alglib.sparsecreate(2, 2, <font color=navy>out</font> s);
    alglib.sparseset(s, 0, 0, 2.0);
    alglib.sparseset(s, 1, 1, 1.0);
    alglib.sparseset(s, 0, 1, 1.0);

    alglib.sparseadd(s, 1, 1, 4.0);

    <font color=green>//</font>
    <font color=green>// Now S is equal to</font>
    <font color=green>//   [ 2 1 ]</font>
    <font color=green>//   [   5 ]</font>
    <font color=green>// Lets check it by reading matrix contents with sparseget().</font>
    <font color=green>// You may see that with sparseget() you may read both non-zero</font>
    <font color=green>// and zero elements.</font>
    <font color=green>//</font>
    <font color=navy>double</font> v;
    v = alglib.sparseget(s, 0, 0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0000</font>
    v = alglib.sparseget(s, 0, 1);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000</font>
    v = alglib.sparseget(s, 1, 0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.0000</font>
    v = alglib.sparseget(s, 1, 1);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 5.0000</font>

    <font color=green>//</font>
    <font color=green>// After successful creation we can use our matrix <font color=navy>for</font> linear operations.</font>
    <font color=green>//</font>
    <font color=green>// However, there is one more thing we MUST <font color=navy>do</font> before using S in linear</font>
    <font color=green>// operations: we have to convert it from HashTable representation (used <font color=navy>for</font></font>
    <font color=green>// initialization and dynamic operations) to CRS format with sparseconverttocrs()</font>
    <font color=green>// call. If you omit this call, ALGLIB will generate exception on the first</font>
    <font color=green>// attempt to use S in linear operations. </font>
    <font color=green>//</font>
    alglib.sparseconverttocrs(s);

    <font color=green>//</font>
    <font color=green>// Now S is in the CRS format and we are ready to <font color=navy>do</font> linear operations.</font>
    <font color=green>// Lets calculate A*x <font color=navy>for</font> some x.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1,-1};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[0];
    alglib.sparsemv(s, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,2)); <font color=green>// EXPECTED: [1.000,-5.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_sparse_d_crs'></a><h3 class=pageheader>sparse_d_crs example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// This example demonstrates creation/initialization of the sparse matrix in the</font>
    <font color=green>// CRS format.</font>
    <font color=green>//</font>
    <font color=green>// Hash-Table format used by default is very convenient (it allows easy</font>
    <font color=green>// insertion of elements, automatic memory reallocation), but has</font>
    <font color=green>// significant memory and performance overhead. Insertion of one element </font>
    <font color=green>// costs hundreds of CPU cycles, and memory consumption is several times</font>
    <font color=green>// higher than that of CRS.</font>
    <font color=green>//</font>
    <font color=green>// When you work with really large matrices and when you can tell in </font>
    <font color=green>// advance how many elements EXACTLY you need, it can be beneficial to </font>
    <font color=green>// create matrix in the CRS format from the very beginning.</font>
    <font color=green>//</font>
    <font color=green>// If you want to create matrix in the CRS format, you should:</font>
    <font color=green>// * use sparsecreatecrs() function</font>
    <font color=green>// * know row sizes in advance (number of non-zero entries in the each row)</font>
    <font color=green>// * initialize matrix with sparseset() - another function, sparseadd(), is not allowed</font>
    <font color=green>// * initialize elements from left to right, from top to bottom, each</font>
    <font color=green>//   element is initialized only once.</font>
    <font color=green>//</font>
    alglib.sparsematrix s;
    <font color=navy>int</font>[] row_sizes = new <font color=navy>int</font>[]{2,2,2,1};
    alglib.sparsecreatecrs(4, 4, row_sizes, <font color=navy>out</font> s);
    alglib.sparseset(s, 0, 0, 2.0);
    alglib.sparseset(s, 0, 1, 1.0);
    alglib.sparseset(s, 1, 1, 4.0);
    alglib.sparseset(s, 1, 2, 2.0);
    alglib.sparseset(s, 2, 2, 3.0);
    alglib.sparseset(s, 2, 3, 1.0);
    alglib.sparseset(s, 3, 3, 9.0);

    <font color=green>//</font>
    <font color=green>// Now S is equal to</font>
    <font color=green>//   [ 2 1     ]</font>
    <font color=green>//   [   4 2   ]</font>
    <font color=green>//   [     3 1 ]</font>
    <font color=green>//   [       9 ]</font>
    <font color=green>//</font>
    <font color=green>// We should point that we have initialized S elements from left to right,</font>
    <font color=green>// from top to bottom. CRS representation does NOT allow you to <font color=navy>do</font> so in</font>
    <font color=green>// the different order. Try to change order of the sparseset() calls above,</font>
    <font color=green>// and you will see that your program generates exception.</font>
    <font color=green>//</font>
    <font color=green>// We can check it by reading matrix contents with sparseget().</font>
    <font color=green>// However, you should remember that sparseget() is inefficient on</font>
    <font color=green>// CRS matrices (it may have to pass through all elements of the row </font>
    <font color=green>// until it finds element you need).</font>
    <font color=green>//</font>
    <font color=navy>double</font> v;
    v = alglib.sparseget(s, 0, 0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 2.0000</font>
    v = alglib.sparseget(s, 2, 3);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000</font>

    <font color=green>// you may see that you can read zero elements (which are not stored) with sparseget()</font>
    v = alglib.sparseget(s, 3, 2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F2&quot;</b></font>, v); <font color=green>// EXPECTED: 0.0000</font>

    <font color=green>//</font>
    <font color=green>// After successful creation we can use our matrix <font color=navy>for</font> linear operations.</font>
    <font color=green>// Lets calculate A*x <font color=navy>for</font> some x.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{1,-1,1,-1};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[0];
    alglib.sparsemv(s, x, <font color=navy>ref</font> y);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y,2)); <font color=green>// EXPECTED: [1.000,-2.000,2.000,-9]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_spdgevd></a><h2 class=pageheader><code>spdgevd</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_smatrixgevd' class=toc>smatrixgevd</a><br>
<a href='#sub_smatrixgevdreduce' class=toc>smatrixgevdreduce</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_smatrixgevd'></a><h3 class=pageheader><code>smatrixgevd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Algorithm for solving the following generalized symmetric positive-definite
eigenproblem:
    A*x = lambda*B*x (1) or
    A*B*x = lambda*x (2) or
    B*A*x = lambda*x (3).
where A is a symmetric matrix, B - symmetric positive-definite matrix.
The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
problem.

Input parameters:
    A           -   symmetric matrix which is given by its upper or lower
                    triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    N           -   size of matrices A and B.
    IsUpperA    -   storage format of matrix A.
    B           -   symmetric positive-definite matrix which is given by
                    its upper or lower triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    IsUpperB    -   storage format of matrix B.
    ZNeeded     -   if ZNeeded is equal to:
                     * 0, the eigenvectors are not returned;
                     * 1, the eigenvectors are returned.
    ProblemType -   if ProblemType is equal to:
                     * 1, the following problem is solved: A*x = lambda*B*x;
                     * 2, the following problem is solved: A*B*x = lambda*x;
                     * 3, the following problem is solved: B*A*x = lambda*x.

Output parameters:
    D           -   eigenvalues in ascending order.
                    Array whose index ranges within [0..N-1].
    Z           -   if ZNeeded is equal to:
                     * 0, Z hasnt changed;
                     * 1, Z contains eigenvectors.
                    Array whose indexes range within [0..N-1, 0..N-1].
                    The eigenvectors are stored in matrix columns. It should
                    be noted that the eigenvectors in such problems do not
                    form an orthogonal system.

Result:
    True, if the problem was solved successfully.
    False, if the error occurred during the Cholesky decomposition of matrix
    B (the matrix isnt positive-definite) or during the work of the iterative
    algorithm for solving the symmetric eigenproblem.

See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.

  -- ALGLIB --
     Copyright 1.28.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixgevd(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isuppera,
    <font color=navy>double</font>[,] b,
    <font color=navy>bool</font> isupperb,
    <font color=navy>int</font> zneeded,
    <font color=navy>int</font> problemtype,
    <font color=navy>out</font> <font color=navy>double</font>[] d,
    <font color=navy>out</font> <font color=navy>double</font>[,] z)

</div></pre>
<a name='sub_smatrixgevdreduce'></a><h3 class=pageheader><code>smatrixgevdreduce</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Algorithm for reduction of the following generalized symmetric positive-
definite eigenvalue problem:
    A*x = lambda*B*x (1) or
    A*B*x = lambda*x (2) or
    B*A*x = lambda*x (3)
to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
the given problems are the same, and the eigenvectors of the given problem
could be obtained by multiplying the obtained eigenvectors by the
transformation matrix x = R*y).

Here A is a symmetric matrix, B - symmetric positive-definite matrix.

Input parameters:
    A           -   symmetric matrix which is given by its upper or lower
                    triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    N           -   size of matrices A and B.
    IsUpperA    -   storage format of matrix A.
    B           -   symmetric positive-definite matrix which is given by
                    its upper or lower triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    IsUpperB    -   storage format of matrix B.
    ProblemType -   if ProblemType is equal to:
                     * 1, the following problem is solved: A*x = lambda*B*x;
                     * 2, the following problem is solved: A*B*x = lambda*x;
                     * 3, the following problem is solved: B*A*x = lambda*x.

Output parameters:
    A           -   symmetric matrix which is given by its upper or lower
                    triangle depending on IsUpperA. Contains matrix C.
                    Array whose indexes range within [0..N-1, 0..N-1].
    R           -   upper triangular or low triangular transformation matrix
                    which is used to obtain the eigenvectors of a given problem
                    as the product of eigenvectors of C (from the right) and
                    matrix R (from the left). If the matrix is upper
                    triangular, the elements below the main diagonal
                    are equal to 0 (and vice versa). Thus, we can perform
                    the multiplication without taking into account the
                    internal structure (which is an easier though less
                    effective way).
                    Array whose indexes range within [0..N-1, 0..N-1].
    IsUpperR    -   type of matrix R (upper or lower triangular).

Result:
    True, if the problem was reduced successfully.
    False, if the error occurred during the Cholesky decomposition of
        matrix B (the matrix is not positive-definite).

  -- ALGLIB --
     Copyright 1.28.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smatrixgevdreduce(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isuppera,
    <font color=navy>double</font>[,] b,
    <font color=navy>bool</font> isupperb,
    <font color=navy>int</font> problemtype,
    <font color=navy>out</font> <font color=navy>double</font>[,] r,
    <font color=navy>out</font> <font color=navy>bool</font> isupperr)

</div></pre>
<a name=unit_spline1d></a><h2 class=pageheader><code>spline1d</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_spline1dinterpolant' class=toc>spline1dinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_spline1dbuildakima' class=toc>spline1dbuildakima</a><br>
<a href='#sub_spline1dbuildcatmullrom' class=toc>spline1dbuildcatmullrom</a><br>
<a href='#sub_spline1dbuildcubic' class=toc>spline1dbuildcubic</a><br>
<a href='#sub_spline1dbuildhermite' class=toc>spline1dbuildhermite</a><br>
<a href='#sub_spline1dbuildlinear' class=toc>spline1dbuildlinear</a><br>
<a href='#sub_spline1dbuildmonotone' class=toc>spline1dbuildmonotone</a><br>
<a href='#sub_spline1dcalc' class=toc>spline1dcalc</a><br>
<a href='#sub_spline1dconvcubic' class=toc>spline1dconvcubic</a><br>
<a href='#sub_spline1dconvdiff2cubic' class=toc>spline1dconvdiff2cubic</a><br>
<a href='#sub_spline1dconvdiffcubic' class=toc>spline1dconvdiffcubic</a><br>
<a href='#sub_spline1ddiff' class=toc>spline1ddiff</a><br>
<a href='#sub_spline1dgriddiff2cubic' class=toc>spline1dgriddiff2cubic</a><br>
<a href='#sub_spline1dgriddiffcubic' class=toc>spline1dgriddiffcubic</a><br>
<a href='#sub_spline1dintegrate' class=toc>spline1dintegrate</a><br>
<a href='#sub_spline1dlintransx' class=toc>spline1dlintransx</a><br>
<a href='#sub_spline1dlintransy' class=toc>spline1dlintransy</a><br>
<a href='#sub_spline1dunpack' class=toc>spline1dunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_spline1d_d_convdiff' class=toc>spline1d_d_convdiff</a></td><td width=15>&nbsp;</td><td>Resampling using cubic splines</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_cubic' class=toc>spline1d_d_cubic</a></td><td width=15>&nbsp;</td><td>Cubic spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_griddiff' class=toc>spline1d_d_griddiff</a></td><td width=15>&nbsp;</td><td>Differentiation on the grid using cubic splines</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_linear' class=toc>spline1d_d_linear</a></td><td width=15>&nbsp;</td><td>Piecewise linear spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_monotone' class=toc>spline1d_d_monotone</a></td><td width=15>&nbsp;</td><td>Monotone interpolation</td></tr>
</table></div>
<a name='struct_spline1dinterpolant'></a><h3 class=pageheader><code>spline1dinterpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional spline interpolant
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class spline1dinterpolant
{
}

</div></pre>
<a name='sub_spline1dbuildakima'></a><h3 class=pageheader><code>spline1dbuildakima</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds Akima spline interpolant

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1]
    Y           -   function values, array[0..N-1]
    N           -   points count (optional):
                    * N&gt;=2
                    * if given, only first N points are used to build spline
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))

OUTPUT PARAMETERS:
    C           -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

  -- ALGLIB PROJECT --
     Copyright 24.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildakima(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> spline1dinterpolant c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildakima(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> spline1dinterpolant c)

</div></pre>
<a name='sub_spline1dbuildcatmullrom'></a><h3 class=pageheader><code>spline1dbuildcatmullrom</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds Catmull-Rom spline interpolant.

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1].
    Y           -   function values, array[0..N-1].

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points are used to build spline
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundType   -   boundary condition type:
                    * -1 for periodic boundary condition
                    *  0 for parabolically terminated spline (default)
    Tension     -   tension parameter:
                    * tension=0   corresponds to classic Catmull-Rom spline (default)
                    * 0&lt;tension&lt;1 corresponds to more general form - cardinal spline

OUTPUT PARAMETERS:
    C           -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildcatmullrom(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> spline1dinterpolant c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildcatmullrom(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundtype,
    <font color=navy>double</font> tension,
    <font color=navy>out</font> spline1dinterpolant c)

</div></pre>
<a name='sub_spline1dbuildcubic'></a><h3 class=pageheader><code>spline1dbuildcubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds cubic spline interpolant.

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1].
    Y           -   function values, array[0..N-1].

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points are used to build spline
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)

OUTPUT PARAMETERS:
    C           -   spline interpolant

ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition
    *  by default, BoundType=0 is used

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> spline1dinterpolant c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundltype,
    <font color=navy>double</font> boundl,
    <font color=navy>int</font> boundrtype,
    <font color=navy>double</font> boundr,
    <font color=navy>out</font> spline1dinterpolant c)

</div></pre>
<a name='sub_spline1dbuildhermite'></a><h3 class=pageheader><code>spline1dbuildhermite</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds Hermite spline interpolant.

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1]
    Y           -   function values, array[0..N-1]
    D           -   derivatives, array[0..N-1]
    N           -   points count (optional):
                    * N&gt;=2
                    * if given, only first N points are used to build spline
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))

OUTPUT PARAMETERS:
    C           -   spline interpolant.


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildhermite(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] d,
    <font color=navy>out</font> spline1dinterpolant c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildhermite(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] d,
    <font color=navy>int</font> n,
    <font color=navy>out</font> spline1dinterpolant c)

</div></pre>
<a name='sub_spline1dbuildlinear'></a><h3 class=pageheader><code>spline1dbuildlinear</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds linear spline interpolant

INPUT PARAMETERS:
    X   -   spline nodes, array[0..N-1]
    Y   -   function values, array[0..N-1]
    N   -   points count (optional):
            * N&gt;=2
            * if given, only first N points are used to build spline
            * if not given, automatically detected from X/Y sizes
              (len(X) must be equal to len(Y))

OUTPUT PARAMETERS:
    C   -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

  -- ALGLIB PROJECT --
     Copyright 24.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildlinear(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> spline1dinterpolant c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildlinear(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> spline1dinterpolant c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_linear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline1d_d_cubic' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dbuildmonotone'></a><h3 class=pageheader><code>spline1dbuildmonotone</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function builds monotone cubic Hermite interpolant. This interpolant
is monotonic in [x(0),x(n-1)] and is constant outside of this interval.

In  case  y[]  form  non-monotonic  sequence,  interpolant  is  piecewise
monotonic.  Say, for x=(0,1,2,3,4)  and  y=(0,1,2,1,0)  interpolant  will
monotonically grow at [0..2] and monotonically decrease at [2..4].

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1]. Subroutine automatically
                    sorts points, so caller may pass unsorted array.
    Y           -   function values, array[0..N-1]
    N           -   the number of points(N&gt;=2).

OUTPUT PARAMETERS:
    C           -   spline interpolant.

 -- ALGLIB PROJECT --
     Copyright 21.06.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildmonotone(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> spline1dinterpolant c)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dbuildmonotone(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>out</font> spline1dinterpolant c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_monotone' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dcalc'></a><h3 class=pageheader><code>spline1dcalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the spline at the given point X.

INPUT PARAMETERS:
    C   -   spline interpolant
    X   -   point

Result:
    S(x)

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spline1dcalc(spline1dinterpolant c, <font color=navy>double</font> x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_linear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline1d_d_cubic' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_spline1d_d_monotone' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dconvcubic'></a><h3 class=pageheader><code>spline1dconvcubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves following problem: given table y[] of function values
at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
function values y2[] (calculated at x2[]).

This function yields same result as Spline1DBuildCubic() call followed  by
sequence of Spline1DDiff() calls, but it can be several times faster  when
called for ordered X[] and X2[].

INPUT PARAMETERS:
    X           -   old spline nodes
    Y           -   function values
    X2           -  new spline nodes

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points from X/Y are used
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)
    N2          -   new points count:
                    * N2&gt;=2
                    * if given, only first N2 points from X2 are used
                    * if not given, automatically detected from X2 size

OUTPUT PARAMETERS:
    F2          -   function values at X2[]

ORDER OF POINTS

Subroutine automatically sorts points, so caller  may pass unsorted array.
Function  values  are correctly reordered on  return, so F2[I]  is  always
equal to S(X2[I]) independently of points order.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition
    *  by default, BoundType=0 is used

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 03.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dconvcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] x2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dconvcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundltype,
    <font color=navy>double</font> boundl,
    <font color=navy>int</font> boundrtype,
    <font color=navy>double</font> boundr,
    <font color=navy>double</font>[] x2,
    <font color=navy>int</font> n2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_convdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dconvdiff2cubic'></a><h3 class=pageheader><code>spline1dconvdiff2cubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves following problem: given table y[] of function values
at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
(calculated at x2[]).

This function yields same result as Spline1DBuildCubic() call followed  by
sequence of Spline1DDiff() calls, but it can be several times faster  when
called for ordered X[] and X2[].

INPUT PARAMETERS:
    X           -   old spline nodes
    Y           -   function values
    X2           -  new spline nodes

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points from X/Y are used
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)
    N2          -   new points count:
                    * N2&gt;=2
                    * if given, only first N2 points from X2 are used
                    * if not given, automatically detected from X2 size

OUTPUT PARAMETERS:
    F2          -   function values at X2[]
    D2          -   first derivatives at X2[]
    DD2         -   second derivatives at X2[]

ORDER OF POINTS

Subroutine automatically sorts points, so caller  may pass unsorted array.
Function  values  are correctly reordered on  return, so F2[I]  is  always
equal to S(X2[I]) independently of points order.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition
    *  by default, BoundType=0 is used

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 03.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dconvdiff2cubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] x2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2,
    <font color=navy>out</font> <font color=navy>double</font>[] d2,
    <font color=navy>out</font> <font color=navy>double</font>[] dd2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dconvdiff2cubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundltype,
    <font color=navy>double</font> boundl,
    <font color=navy>int</font> boundrtype,
    <font color=navy>double</font> boundr,
    <font color=navy>double</font>[] x2,
    <font color=navy>int</font> n2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2,
    <font color=navy>out</font> <font color=navy>double</font>[] d2,
    <font color=navy>out</font> <font color=navy>double</font>[] dd2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_convdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dconvdiffcubic'></a><h3 class=pageheader><code>spline1dconvdiffcubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves following problem: given table y[] of function values
at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
function values y2[] and derivatives d2[] (calculated at x2[]).

This function yields same result as Spline1DBuildCubic() call followed  by
sequence of Spline1DDiff() calls, but it can be several times faster  when
called for ordered X[] and X2[].

INPUT PARAMETERS:
    X           -   old spline nodes
    Y           -   function values
    X2           -  new spline nodes

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points from X/Y are used
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)
    N2          -   new points count:
                    * N2&gt;=2
                    * if given, only first N2 points from X2 are used
                    * if not given, automatically detected from X2 size

OUTPUT PARAMETERS:
    F2          -   function values at X2[]
    D2          -   first derivatives at X2[]

ORDER OF POINTS

Subroutine automatically sorts points, so caller  may pass unsorted array.
Function  values  are correctly reordered on  return, so F2[I]  is  always
equal to S(X2[I]) independently of points order.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition
    *  by default, BoundType=0 is used

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 03.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dconvdiffcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[] x2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2,
    <font color=navy>out</font> <font color=navy>double</font>[] d2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dconvdiffcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundltype,
    <font color=navy>double</font> boundl,
    <font color=navy>int</font> boundrtype,
    <font color=navy>double</font> boundr,
    <font color=navy>double</font>[] x2,
    <font color=navy>int</font> n2,
    <font color=navy>out</font> <font color=navy>double</font>[] y2,
    <font color=navy>out</font> <font color=navy>double</font>[] d2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_convdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1ddiff'></a><h3 class=pageheader><code>spline1ddiff</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine differentiates the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    X   -   point

Result:
    S   -   S(x)
    DS  -   S'(x)
    D2S -   S''(x)

  -- ALGLIB PROJECT --
     Copyright 24.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1ddiff(
    spline1dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> s,
    <font color=navy>out</font> <font color=navy>double</font> ds,
    <font color=navy>out</font> <font color=navy>double</font> d2s)

</div></pre>
<a name='sub_spline1dgriddiff2cubic'></a><h3 class=pageheader><code>spline1dgriddiff2cubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves following problem: given table y[] of function values
at  nodes  x[],  it  calculates  and  returns  tables  of first and second
function derivatives d1[] and d2[] (calculated at the same nodes x[]).

This function yields same result as Spline1DBuildCubic() call followed  by
sequence of Spline1DDiff() calls, but it can be several times faster  when
called for ordered X[] and X2[].

INPUT PARAMETERS:
    X           -   spline nodes
    Y           -   function values

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points are used
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)

OUTPUT PARAMETERS:
    D1          -   S' values at X[]
    D2          -   S'' values at X[]

ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.
Derivative values are correctly reordered on return, so  D[I]  is  always
equal to S'(X[I]) independently of points order.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition
    *  by default, BoundType=0 is used

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 03.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dgriddiff2cubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> <font color=navy>double</font>[] d1,
    <font color=navy>out</font> <font color=navy>double</font>[] d2)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dgriddiff2cubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundltype,
    <font color=navy>double</font> boundl,
    <font color=navy>int</font> boundrtype,
    <font color=navy>double</font> boundr,
    <font color=navy>out</font> <font color=navy>double</font>[] d1,
    <font color=navy>out</font> <font color=navy>double</font>[] d2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_griddiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dgriddiffcubic'></a><h3 class=pageheader><code>spline1dgriddiffcubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function solves following problem: given table y[] of function values
at nodes x[], it calculates and returns table of function derivatives  d[]
(calculated at the same nodes x[]).

This function yields same result as Spline1DBuildCubic() call followed  by
sequence of Spline1DDiff() calls, but it can be several times faster  when
called for ordered X[] and X2[].

INPUT PARAMETERS:
    X           -   spline nodes
    Y           -   function values

OPTIONAL PARAMETERS:
    N           -   points count:
                    * N&gt;=2
                    * if given, only first N points are used
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)

OUTPUT PARAMETERS:
    D           -   derivative values at X[]

ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.
Derivative values are correctly reordered on return, so  D[I]  is  always
equal to S'(X[I]) independently of points order.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition
    *  by default, BoundType=0 is used

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them  to  be  equal by
copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
Y[last_point]. However it is recommended to pass consistent values of Y[],
i.e. to make Y[first_point]=Y[last_point].

  -- ALGLIB PROJECT --
     Copyright 03.09.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dgriddiffcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>out</font> <font color=navy>double</font>[] d)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dgriddiffcubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> n,
    <font color=navy>int</font> boundltype,
    <font color=navy>double</font> boundl,
    <font color=navy>int</font> boundrtype,
    <font color=navy>double</font> boundr,
    <font color=navy>out</font> <font color=navy>double</font>[] d)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_griddiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dintegrate'></a><h3 class=pageheader><code>spline1dintegrate</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine integrates the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    X   -   right bound of the integration interval [a, x],
            here 'a' denotes min(x[])
Result:
    integral(S(t)dt,a,x)

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spline1dintegrate(
    spline1dinterpolant c,
    <font color=navy>double</font> x)

</div></pre>
<a name='sub_spline1dlintransx'></a><h3 class=pageheader><code>spline1dlintransx</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline argument.

INPUT PARAMETERS:
    C   -   spline interpolant.
    A, B-   transformation coefficients: x = A*t + B
Result:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dlintransx(
    spline1dinterpolant c,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b)

</div></pre>
<a name='sub_spline1dlintransy'></a><h3 class=pageheader><code>spline1dlintransy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    A, B-   transformation coefficients: S2(x) = A*S(x) + B
Result:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dlintransy(
    spline1dinterpolant c,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b)

</div></pre>
<a name='sub_spline1dunpack'></a><h3 class=pageheader><code>spline1dunpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine unpacks the spline into the coefficients table.

INPUT PARAMETERS:
    C   -   spline interpolant.
    X   -   point

OUTPUT PARAMETERS:
    Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
            For I = 0...N-2:
                Tbl[I,0] = X[i]
                Tbl[I,1] = X[i+1]
                Tbl[I,2] = C0
                Tbl[I,3] = C1
                Tbl[I,4] = C2
                Tbl[I,5] = C3
            On [x[i], x[i+1]] spline is equals to:
                S(x) = C0 + C1*t + C2*t^2 + C3*t^3
                t = x-x[i]

NOTE:
    You  can rebuild spline with  Spline1DBuildHermite()  function,  which
    accepts as inputs function values and derivatives at nodes, which  are
    easy to calculate when you have coefficients.

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline1dunpack(
    spline1dinterpolant c,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[,] tbl)

</div></pre>
<a name='example_spline1d_d_convdiff'></a><h3 class=pageheader>spline1d_d_convdiff example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use cubic spline to <font color=navy>do</font> resampling, i.e. having</font>
    <font color=green>// values of f(x)=x^2 sampled at 5 equidistant nodes on [-1,+1]</font>
    <font color=green>// we calculate values/derivatives of cubic spline on </font>
    <font color=green>// another grid (equidistant with 9 nodes on [-1,+1])</font>
    <font color=green>// WITHOUT CONSTRUCTION OF SPLINE OBJECT.</font>
    <font color=green>//</font>
    <font color=green>// There are efficient functions spline1dconvcubic(),</font>
    <font color=green>// spline1dconvdiffcubic() and spline1dconvdiff2cubic() </font>
    <font color=green>// <font color=navy>for</font> such calculations.</font>
    <font color=green>//</font>
    <font color=green>// We use default boundary conditions (&quot;parabolically terminated</font>
    <font color=green>// spline&quot;) because cubic spline built with such boundary conditions </font>
    <font color=green>// will exactly reproduce any quadratic f(x).</font>
    <font color=green>//</font>
    <font color=green>// Actually, we could use natural conditions, but we feel that </font>
    <font color=green>// spline which exactly reproduces f() will show us more </font>
    <font color=green>// understandable results.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x_old = new <font color=navy>double</font>[]{-1.0,-0.5,0.0,+0.5,+1.0};
    <font color=navy>double</font>[] y_old = new <font color=navy>double</font>[]{+1.0,0.25,0.0,0.25,+1.0};
    <font color=navy>double</font>[] x_new = new <font color=navy>double</font>[]{-1.00,-0.75,-0.50,-0.25,0.00,+0.25,+0.50,+0.75,+1.00};
    <font color=navy>double</font>[] y_new;
    <font color=navy>double</font>[] d1_new;
    <font color=navy>double</font>[] d2_new;

    <font color=green>//</font>
    <font color=green>// First, conversion without differentiation.</font>
    <font color=green>//</font>
    <font color=green>//</font>
    alglib.spline1dconvcubic(x_old, y_old, x_new, <font color=navy>out</font> y_new);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y_new,3)); <font color=green>// EXPECTED: [1.0000, 0.5625, 0.2500, 0.0625, 0.0000, 0.0625, 0.2500, 0.5625, 1.0000]</font>

    <font color=green>//</font>
    <font color=green>// Then, conversion with differentiation (first derivatives only)</font>
    <font color=green>//</font>
    <font color=green>//</font>
    alglib.spline1dconvdiffcubic(x_old, y_old, x_new, <font color=navy>out</font> y_new, <font color=navy>out</font> d1_new);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y_new,3)); <font color=green>// EXPECTED: [1.0000, 0.5625, 0.2500, 0.0625, 0.0000, 0.0625, 0.2500, 0.5625, 1.0000]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(d1_new,3)); <font color=green>// EXPECTED: [-2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0]</font>

    <font color=green>//</font>
    <font color=green>// Finally, conversion with first and second derivatives</font>
    <font color=green>//</font>
    <font color=green>//</font>
    alglib.spline1dconvdiff2cubic(x_old, y_old, x_new, <font color=navy>out</font> y_new, <font color=navy>out</font> d1_new, <font color=navy>out</font> d2_new);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(y_new,3)); <font color=green>// EXPECTED: [1.0000, 0.5625, 0.2500, 0.0625, 0.0000, 0.0625, 0.2500, 0.5625, 1.0000]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(d1_new,3)); <font color=green>// EXPECTED: [-2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(d2_new,3)); <font color=green>// EXPECTED: [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline1d_d_cubic'></a><h3 class=pageheader>spline1d_d_cubic example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use cubic spline to interpolate f(x)=x^2 sampled </font>
    <font color=green>// at 5 equidistant nodes on [-1,+1].</font>
    <font color=green>//</font>
    <font color=green>// First, we use default boundary conditions (&quot;parabolically terminated</font>
    <font color=green>// spline&quot;) because cubic spline built with such boundary conditions </font>
    <font color=green>// will exactly reproduce any quadratic f(x).</font>
    <font color=green>//</font>
    <font color=green>// Then we try to use natural boundary conditions</font>
    <font color=green>//     d2S(-1)/dx^2 = 0.0</font>
    <font color=green>//     d2S(+1)/dx^2 = 0.0</font>
    <font color=green>// and see that such spline interpolated f(x) with small error.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{-1.0,-0.5,0.0,+0.5,+1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{+1.0,0.25,0.0,0.25,+1.0};
    <font color=navy>double</font> t = 0.25;
    <font color=navy>double</font> v;
    alglib.spline1dinterpolant s;
    <font color=navy>int</font> natural_bound_type = 2;
    <font color=green>//</font>
    <font color=green>// Test exact boundary conditions: build S(x), calculare S(0.25)</font>
    <font color=green>// (almost same as original function)</font>
    <font color=green>//</font>
    alglib.spline1dbuildcubic(x, y, <font color=navy>out</font> s);
    v = alglib.spline1dcalc(s, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 0.0625</font>

    <font color=green>//</font>
    <font color=green>// Test natural boundary conditions: build S(x), calculare S(0.25)</font>
    <font color=green>// (small interpolation error)</font>
    <font color=green>//</font>
    alglib.spline1dbuildcubic(x, y, 5, natural_bound_type, 0.0, natural_bound_type, 0.0, <font color=navy>out</font> s);
    v = alglib.spline1dcalc(s, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F3&quot;</b></font>, v); <font color=green>// EXPECTED: 0.0580</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline1d_d_griddiff'></a><h3 class=pageheader>spline1d_d_griddiff example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use cubic spline to <font color=navy>do</font> grid differentiation, i.e. having</font>
    <font color=green>// values of f(x)=x^2 sampled at 5 equidistant nodes on [-1,+1]</font>
    <font color=green>// we calculate derivatives of cubic spline at nodes WITHOUT</font>
    <font color=green>// CONSTRUCTION OF SPLINE OBJECT.</font>
    <font color=green>//</font>
    <font color=green>// There are efficient functions spline1dgriddiffcubic() and</font>
    <font color=green>// spline1dgriddiff2cubic() <font color=navy>for</font> such calculations.</font>
    <font color=green>//</font>
    <font color=green>// We use default boundary conditions (&quot;parabolically terminated</font>
    <font color=green>// spline&quot;) because cubic spline built with such boundary conditions </font>
    <font color=green>// will exactly reproduce any quadratic f(x).</font>
    <font color=green>//</font>
    <font color=green>// Actually, we could use natural conditions, but we feel that </font>
    <font color=green>// spline which exactly reproduces f() will show us more </font>
    <font color=green>// understandable results.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{-1.0,-0.5,0.0,+0.5,+1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{+1.0,0.25,0.0,0.25,+1.0};
    <font color=navy>double</font>[] d1;
    <font color=navy>double</font>[] d2;

    <font color=green>//</font>
    <font color=green>// We calculate first derivatives: they must be equal to 2*x</font>
    <font color=green>//</font>
    alglib.spline1dgriddiffcubic(x, y, <font color=navy>out</font> d1);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(d1,3)); <font color=green>// EXPECTED: [-2.0, -1.0, 0.0, +1.0, +2.0]</font>

    <font color=green>//</font>
    <font color=green>// Now test griddiff2, which returns first AND second derivatives.</font>
    <font color=green>// First derivative is 2*x, second is equal to 2.0</font>
    <font color=green>//</font>
    alglib.spline1dgriddiff2cubic(x, y, <font color=navy>out</font> d1, <font color=navy>out</font> d2);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(d1,3)); <font color=green>// EXPECTED: [-2.0, -1.0, 0.0, +1.0, +2.0]</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(d2,3)); <font color=green>// EXPECTED: [ 2.0,  2.0, 2.0,  2.0,  2.0]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline1d_d_linear'></a><h3 class=pageheader>spline1d_d_linear example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use piecewise linear spline to interpolate f(x)=x^2 sampled </font>
    <font color=green>// at 5 equidistant nodes on [-1,+1].</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{-1.0,-0.5,0.0,+0.5,+1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{+1.0,0.25,0.0,0.25,+1.0};
    <font color=navy>double</font> t = 0.25;
    <font color=navy>double</font> v;
    alglib.spline1dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline1dbuildlinear(x, y, <font color=navy>out</font> s);

    <font color=green>// calculate S(0.25) - it is quite different from 0.25^2=0.0625</font>
    v = alglib.spline1dcalc(s, t);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 0.125</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline1d_d_monotone'></a><h3 class=pageheader>spline1d_d_monotone example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// Spline built witn spline1dbuildcubic() can be non-monotone even when</font>
    <font color=green>// Y-values form monotone sequence. Say, <font color=navy>for</font> x=[0,1,2] and y=[0,1,1]</font>
    <font color=green>// cubic spline will monotonically grow until x=1.5 and then start</font>
    <font color=green>// decreasing.</font>
    <font color=green>//</font>
    <font color=green>// That's why ALGLIB provides special spline construction function</font>
    <font color=green>// which builds spline which preserves monotonicity of the original</font>
    <font color=green>// dataset.</font>
    <font color=green>//</font>
    <font color=green>// NOTE: in case original dataset is non-monotonic, ALGLIB splits it</font>
    <font color=green>// into monotone subsequences and builds piecewise monotonic spline.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0,1,2};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0,1,1};
    alglib.spline1dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline1dbuildmonotone(x, y, <font color=navy>out</font> s);

    <font color=green>// calculate S at x = [-0.5, 0.0, 0.5, 1.0, 1.5, 2.0]</font>
    <font color=green>// you may see that spline is really monotonic</font>
    <font color=navy>double</font> v;
    v = alglib.spline1dcalc(s, -0.5);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 0.0000</font>
    v = alglib.spline1dcalc(s, 0.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 0.0000</font>
    v = alglib.spline1dcalc(s, +0.5);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 0.5000</font>
    v = alglib.spline1dcalc(s, 1.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000</font>
    v = alglib.spline1dcalc(s, 1.5);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000</font>
    v = alglib.spline1dcalc(s, 2.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0000</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_spline2d></a><h2 class=pageheader><code>spline2d</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_spline2dinterpolant' class=toc>spline2dinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_spline2dbuildbicubic' class=toc>spline2dbuildbicubic</a><br>
<a href='#sub_spline2dbuildbicubicv' class=toc>spline2dbuildbicubicv</a><br>
<a href='#sub_spline2dbuildbilinear' class=toc>spline2dbuildbilinear</a><br>
<a href='#sub_spline2dbuildbilinearv' class=toc>spline2dbuildbilinearv</a><br>
<a href='#sub_spline2dcalc' class=toc>spline2dcalc</a><br>
<a href='#sub_spline2dcalcv' class=toc>spline2dcalcv</a><br>
<a href='#sub_spline2dcalcvbuf' class=toc>spline2dcalcvbuf</a><br>
<a href='#sub_spline2dcopy' class=toc>spline2dcopy</a><br>
<a href='#sub_spline2ddiff' class=toc>spline2ddiff</a><br>
<a href='#sub_spline2dlintransf' class=toc>spline2dlintransf</a><br>
<a href='#sub_spline2dlintransxy' class=toc>spline2dlintransxy</a><br>
<a href='#sub_spline2dresamplebicubic' class=toc>spline2dresamplebicubic</a><br>
<a href='#sub_spline2dresamplebilinear' class=toc>spline2dresamplebilinear</a><br>
<a href='#sub_spline2dunpack' class=toc>spline2dunpack</a><br>
<a href='#sub_spline2dunpackv' class=toc>spline2dunpackv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_spline2d_bicubic' class=toc>spline2d_bicubic</a></td><td width=15>&nbsp;</td><td>Bilinear spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#example_spline2d_bilinear' class=toc>spline2d_bilinear</a></td><td width=15>&nbsp;</td><td>Bilinear spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#example_spline2d_copytrans' class=toc>spline2d_copytrans</a></td><td width=15>&nbsp;</td><td>Copy and transform</td></tr>
<tr align=left valign=top><td><a href='#example_spline2d_unpack' class=toc>spline2d_unpack</a></td><td width=15>&nbsp;</td><td>Unpacking bilinear spline</td></tr>
<tr align=left valign=top><td><a href='#example_spline2d_vector' class=toc>spline2d_vector</a></td><td width=15>&nbsp;</td><td>Copy and transform</td></tr>
</table></div>
<a name='struct_spline2dinterpolant'></a><h3 class=pageheader><code>spline2dinterpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
2-dimensional spline inteprolant
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class spline2dinterpolant
{
}

</div></pre>
<a name='sub_spline2dbuildbicubic'></a><h3 class=pageheader><code>spline2dbuildbicubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine was deprecated in ALGLIB 3.6.0

We recommend you to switch  to  Spline2DBuildBicubicV(),  which  is  more
flexible and accepts its arguments in more convenient order.

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dbuildbicubic(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] f,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> spline2dinterpolant c)

</div></pre>
<a name='sub_spline2dbuildbicubicv'></a><h3 class=pageheader><code>spline2dbuildbicubicv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds bicubic vector-valued spline.

Input parameters:
    X   -   spline abscissas, array[0..N-1]
    Y   -   spline ordinates, array[0..M-1]
    F   -   function values, array[0..M*N*D-1]:
            * first D elements store D values at (X[0],Y[0])
            * next D elements store D values at (X[1],Y[0])
            * general form - D function values at (X[i],Y[j]) are stored
              at F[D*(J*N+I)...D*(J*N+I)+D-1].
    M,N -   grid size, M&gt;=2, N&gt;=2
    D   -   vector dimension, D&gt;=1

Output parameters:
    C   -   spline interpolant

  -- ALGLIB PROJECT --
     Copyright 16.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dbuildbicubicv(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] f,
    <font color=navy>int</font> d,
    <font color=navy>out</font> spline2dinterpolant c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_bicubic' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2dbuildbilinear'></a><h3 class=pageheader><code>spline2dbuildbilinear</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine was deprecated in ALGLIB 3.6.0

We recommend you to switch  to  Spline2DBuildBilinearV(),  which  is  more
flexible and accepts its arguments in more convenient order.

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dbuildbilinear(
    <font color=navy>double</font>[] x,
    <font color=navy>double</font>[] y,
    <font color=navy>double</font>[,] f,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> spline2dinterpolant c)

</div></pre>
<a name='sub_spline2dbuildbilinearv'></a><h3 class=pageheader><code>spline2dbuildbilinearv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds bilinear vector-valued spline.

Input parameters:
    X   -   spline abscissas, array[0..N-1]
    Y   -   spline ordinates, array[0..M-1]
    F   -   function values, array[0..M*N*D-1]:
            * first D elements store D values at (X[0],Y[0])
            * next D elements store D values at (X[1],Y[0])
            * general form - D function values at (X[i],Y[j]) are stored
              at F[D*(J*N+I)...D*(J*N+I)+D-1].
    M,N -   grid size, M&gt;=2, N&gt;=2
    D   -   vector dimension, D&gt;=1

Output parameters:
    C   -   spline interpolant

  -- ALGLIB PROJECT --
     Copyright 16.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dbuildbilinearv(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] f,
    <font color=navy>int</font> d,
    <font color=navy>out</font> spline2dinterpolant c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_bilinear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline2d_vector' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2dcalc'></a><h3 class=pageheader><code>spline2dcalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the bilinear or bicubic spline  at
the given point X.

Input parameters:
    C   -   coefficients table.
            Built by BuildBilinearSpline or BuildBicubicSpline.
    X, Y-   point

Result:
    S(x,y)

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spline2dcalc(
    spline2dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_bilinear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline2d_bicubic' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2dcalcv'></a><h3 class=pageheader><code>spline2dcalcv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates bilinear or bicubic vector-valued spline at the
given point (X,Y).

INPUT PARAMETERS:
    C   -   spline interpolant.
    X, Y-   point

OUTPUT PARAMETERS:
    F   -   array[D] which stores function values.  F is out-parameter and
            it  is  reallocated  after  call to this function. In case you
            want  to    reuse  previously  allocated  F,   you   may   use
            Spline2DCalcVBuf(),  which  reallocates  F only when it is too
            small.

  -- ALGLIB PROJECT --
     Copyright 16.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dcalcv(
    spline2dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font>[] f)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_vector' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2dcalcvbuf'></a><h3 class=pageheader><code>spline2dcalcvbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates bilinear or bicubic vector-valued spline at the
given point (X,Y).

INPUT PARAMETERS:
    C   -   spline interpolant.
    X, Y-   point
    F   -   output buffer, possibly preallocated array. In case array size
            is large enough to store result, it is not reallocated.  Array
            which is too short will be reallocated

OUTPUT PARAMETERS:
    F   -   array[D] (or larger) which stores function values

  -- ALGLIB PROJECT --
     Copyright 16.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dcalcvbuf(
    spline2dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y,
    <font color=navy>ref</font> <font color=navy>double</font>[] f)

</div></pre>
<a name='sub_spline2dcopy'></a><h3 class=pageheader><code>spline2dcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine makes the copy of the spline model.

Input parameters:
    C   -   spline interpolant

Output parameters:
    CC  -   spline copy

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dcopy(
    spline2dinterpolant c,
    <font color=navy>out</font> spline2dinterpolant cc)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_copytrans' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2ddiff'></a><h3 class=pageheader><code>spline2ddiff</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the bilinear or bicubic spline  at
the given point X and its derivatives.

Input parameters:
    C   -   spline interpolant.
    X, Y-   point

Output parameters:
    F   -   S(x,y)
    FX  -   dS(x,y)/dX
    FY  -   dS(x,y)/dY
    FXY -   d2S(x,y)/dXdY

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2ddiff(
    spline2dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y,
    <font color=navy>out</font> <font color=navy>double</font> f,
    <font color=navy>out</font> <font color=navy>double</font> fx,
    <font color=navy>out</font> <font color=navy>double</font> fy,
    <font color=navy>out</font> <font color=navy>double</font> fxy)

</div></pre>
<a name='sub_spline2dlintransf'></a><h3 class=pageheader><code>spline2dlintransf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline.

Input parameters:
    C   -   spline interpolant.
    A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B

Output parameters:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dlintransf(
    spline2dinterpolant c,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_copytrans' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2dlintransxy'></a><h3 class=pageheader><code>spline2dlintransxy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline argument.

Input parameters:
    C       -   spline interpolant
    AX, BX  -   transformation coefficients: x = A*t + B
    AY, BY  -   transformation coefficients: y = A*u + B
Result:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dlintransxy(
    spline2dinterpolant c,
    <font color=navy>double</font> ax,
    <font color=navy>double</font> bx,
    <font color=navy>double</font> ay,
    <font color=navy>double</font> by)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_copytrans' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline2dresamplebicubic'></a><h3 class=pageheader><code>spline2dresamplebicubic</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bicubic spline resampling

Input parameters:
    A           -   function values at the old grid,
                    array[0..OldHeight-1, 0..OldWidth-1]
    OldHeight   -   old grid height, OldHeight&gt;1
    OldWidth    -   old grid width, OldWidth&gt;1
    NewHeight   -   new grid height, NewHeight&gt;1
    NewWidth    -   new grid width, NewWidth&gt;1

Output parameters:
    B           -   function values at the new grid,
                    array[0..NewHeight-1, 0..NewWidth-1]

  -- ALGLIB routine --
     15 May, 2007
     Copyright by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dresamplebicubic(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> oldheight,
    <font color=navy>int</font> oldwidth,
    <font color=navy>out</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> newheight,
    <font color=navy>int</font> newwidth)

</div></pre>
<a name='sub_spline2dresamplebilinear'></a><h3 class=pageheader><code>spline2dresamplebilinear</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bilinear spline resampling

Input parameters:
    A           -   function values at the old grid,
                    array[0..OldHeight-1, 0..OldWidth-1]
    OldHeight   -   old grid height, OldHeight&gt;1
    OldWidth    -   old grid width, OldWidth&gt;1
    NewHeight   -   new grid height, NewHeight&gt;1
    NewWidth    -   new grid width, NewWidth&gt;1

Output parameters:
    B           -   function values at the new grid,
                    array[0..NewHeight-1, 0..NewWidth-1]

  -- ALGLIB routine --
     09.07.2007
     Copyright by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dresamplebilinear(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> oldheight,
    <font color=navy>int</font> oldwidth,
    <font color=navy>out</font> <font color=navy>double</font>[,] b,
    <font color=navy>int</font> newheight,
    <font color=navy>int</font> newwidth)

</div></pre>
<a name='sub_spline2dunpack'></a><h3 class=pageheader><code>spline2dunpack</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine was deprecated in ALGLIB 3.6.0

We recommend you to switch  to  Spline2DUnpackV(),  which is more flexible
and accepts its arguments in more convenient order.

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dunpack(
    spline2dinterpolant c,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>double</font>[,] tbl)

</div></pre>
<a name='sub_spline2dunpackv'></a><h3 class=pageheader><code>spline2dunpackv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine unpacks two-dimensional spline into the coefficients table

Input parameters:
    C   -   spline interpolant.

Result:
    M, N-   grid size (x-axis and y-axis)
    D   -   number of components
    Tbl -   coefficients table, unpacked format,
            D - components: [0..(N-1)*(M-1)*D-1, 0..19].
            For T=0..D-1 (component index), I = 0...N-2 (x index),
            J=0..M-2 (y index):
                K :=  T + I*D + J*D*(N-1)

                K-th row stores decomposition for T-th component of the
                vector-valued function

                Tbl[K,0] = X[i]
                Tbl[K,1] = X[i+1]
                Tbl[K,2] = Y[j]
                Tbl[K,3] = Y[j+1]
                Tbl[K,4] = C00
                Tbl[K,5] = C01
                Tbl[K,6] = C02
                Tbl[K,7] = C03
                Tbl[K,8] = C10
                Tbl[K,9] = C11
                ...
                Tbl[K,19] = C33
            On each grid square spline is equals to:
                S(x) = SUM(c[i,j]*(t^i)*(u^j), i=0..3, j=0..3)
                t = x-x[j]
                u = y-y[i]

  -- ALGLIB PROJECT --
     Copyright 16.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline2dunpackv(
    spline2dinterpolant c,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> d,
    <font color=navy>out</font> <font color=navy>double</font>[,] tbl)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline2d_unpack' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_spline2d_bicubic'></a><h3 class=pageheader>spline2d_bicubic example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use bilinear spline to interpolate f(x,y)=x^2+2*y^2 sampled </font>
    <font color=green>// at (x,y) from [0.0, 0.5, 1.0] X [0.0, 1.0].</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,0.5,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0.00,0.25,1.00,2.00,2.25,3.00};
    <font color=navy>double</font> vx = 0.25;
    <font color=navy>double</font> vy = 0.50;
    <font color=navy>double</font> v;
    <font color=navy>double</font> dx;
    <font color=navy>double</font> dy;
    <font color=navy>double</font> dxy;
    alglib.spline2dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline2dbuildbicubicv(x, 3, y, 2, f, 1, <font color=navy>out</font> s);

    <font color=green>// calculate S(0.25,0.50)</font>
    v = alglib.spline2dcalc(s, vx, vy);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0625</font>

    <font color=green>// calculate derivatives</font>
    alglib.spline2ddiff(s, vx, vy, <font color=navy>out</font> v, <font color=navy>out</font> dx, <font color=navy>out</font> dy, <font color=navy>out</font> dxy);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.0625</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, dx); <font color=green>// EXPECTED: 0.5000</font>
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, dy); <font color=green>// EXPECTED: 2.0000</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline2d_bilinear'></a><h3 class=pageheader>spline2d_bilinear example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use bilinear spline to interpolate f(x,y)=x^2+2*y^2 sampled </font>
    <font color=green>// at (x,y) from [0.0, 0.5, 1.0] X [0.0, 1.0].</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,0.5,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0.00,0.25,1.00,2.00,2.25,3.00};
    <font color=navy>double</font> vx = 0.25;
    <font color=navy>double</font> vy = 0.50;
    <font color=navy>double</font> v;
    alglib.spline2dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline2dbuildbilinearv(x, 3, y, 2, f, 1, <font color=navy>out</font> s);

    <font color=green>// calculate S(0.25,0.50)</font>
    v = alglib.spline2dcalc(s, vx, vy);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.1250</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline2d_copytrans'></a><h3 class=pageheader>spline2d_copytrans example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We build bilinear spline <font color=navy>for</font> f(x,y)=x+2*y <font color=navy>for</font> (x,y) in [0,1].</font>
    <font color=green>// Then we apply several transformations to this spline.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0.00,1.00,2.00,3.00};
    alglib.spline2dinterpolant s;
    alglib.spline2dinterpolant snew;
    <font color=navy>double</font> v;
    alglib.spline2dbuildbilinearv(x, 2, y, 2, f, 1, <font color=navy>out</font> s);

    <font color=green>// copy spline, apply transformation x:=2*xnew, y:=4*ynew</font>
    <font color=green>// evaluate at (xnew,ynew) = (0.25,0.25) - should be same as (x,y)=(0.5,1.0)</font>
    alglib.spline2dcopy(s, <font color=navy>out</font> snew);
    alglib.spline2dlintransxy(snew, 2.0, 0.0, 4.0, 0.0);
    v = alglib.spline2dcalc(snew, 0.25, 0.25);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 2.500</font>

    <font color=green>// copy spline, apply transformation SNew:=2*S+3</font>
    alglib.spline2dcopy(s, <font color=navy>out</font> snew);
    alglib.spline2dlintransf(snew, 2.0, 3.0);
    v = alglib.spline2dcalc(snew, 0.5, 1.0);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 8.000</font>

    <font color=green>//</font>
    <font color=green>// Same example, but <font color=navy>for</font> vector spline (f0,f1) = {x+2*y, 2*x+y}</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] f2 = new <font color=navy>double</font>[]{0.00,0.00,1.00,2.00,2.00,1.00,3.00,3.00};
    <font color=navy>double</font>[] vr;
    alglib.spline2dbuildbilinearv(x, 2, y, 2, f2, 2, <font color=navy>out</font> s);

    <font color=green>// copy spline, apply transformation x:=2*xnew, y:=4*ynew</font>
    alglib.spline2dcopy(s, <font color=navy>out</font> snew);
    alglib.spline2dlintransxy(snew, 2.0, 0.0, 4.0, 0.0);
    alglib.spline2dcalcv(snew, 0.25, 0.25, <font color=navy>out</font> vr);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(vr,4)); <font color=green>// EXPECTED: [2.500,2.000]</font>

    <font color=green>// copy spline, apply transformation SNew:=2*S+3</font>
    alglib.spline2dcopy(s, <font color=navy>out</font> snew);
    alglib.spline2dlintransf(snew, 2.0, 3.0);
    alglib.spline2dcalcv(snew, 0.5, 1.0, <font color=navy>out</font> vr);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(vr,4)); <font color=green>// EXPECTED: [8.000,7.000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline2d_unpack'></a><h3 class=pageheader>spline2d_unpack example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We build bilinear spline <font color=navy>for</font> f(x,y)=x+2*y+3*xy <font color=navy>for</font> (x,y) in [0,1].</font>
    <font color=green>// Then we demonstrate how to unpack it.</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0.00,1.00,2.00,6.00};
    <font color=navy>double</font>[,] c;
    <font color=navy>int</font> m;
    <font color=navy>int</font> n;
    <font color=navy>int</font> d;
    alglib.spline2dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline2dbuildbilinearv(x, 2, y, 2, f, 1, <font color=navy>out</font> s);

    <font color=green>// unpack and test</font>
    alglib.spline2dunpackv(s, <font color=navy>out</font> m, <font color=navy>out</font> n, <font color=navy>out</font> d, <font color=navy>out</font> c);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(c,4)); <font color=green>// EXPECTED: [[0, 1, 0, 1, 0,2,0,0, 1,3,0,0, 0,0,0,0, 0,0,0,0 ]]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline2d_vector'></a><h3 class=pageheader>spline2d_vector example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We build bilinear vector-valued spline (f0,f1) = {x+2*y, 2*x+y}</font>
    <font color=green>// Spline is built using function values at 2x2 grid: (x,y)=[0,1]*[0,1]</font>
    <font color=green>// Then we perform evaluation at (x,y)=(0.1,0.3)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0.00,0.00,1.00,2.00,2.00,1.00,3.00,3.00};
    alglib.spline2dinterpolant s;
    <font color=navy>double</font>[] vr;
    alglib.spline2dbuildbilinearv(x, 2, y, 2, f, 2, <font color=navy>out</font> s);
    alglib.spline2dcalcv(s, 0.1, 0.3, <font color=navy>out</font> vr);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(vr,4)); <font color=green>// EXPECTED: [0.700,0.500]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_spline3d></a><h2 class=pageheader><code>spline3d</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_spline3dinterpolant' class=toc>spline3dinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_spline3dbuildtrilinearv' class=toc>spline3dbuildtrilinearv</a><br>
<a href='#sub_spline3dcalc' class=toc>spline3dcalc</a><br>
<a href='#sub_spline3dcalcv' class=toc>spline3dcalcv</a><br>
<a href='#sub_spline3dcalcvbuf' class=toc>spline3dcalcvbuf</a><br>
<a href='#sub_spline3dlintransf' class=toc>spline3dlintransf</a><br>
<a href='#sub_spline3dlintransxyz' class=toc>spline3dlintransxyz</a><br>
<a href='#sub_spline3dresampletrilinear' class=toc>spline3dresampletrilinear</a><br>
<a href='#sub_spline3dunpackv' class=toc>spline3dunpackv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_spline3d_trilinear' class=toc>spline3d_trilinear</a></td><td width=15>&nbsp;</td><td>Trilinear spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#example_spline3d_vector' class=toc>spline3d_vector</a></td><td width=15>&nbsp;</td><td>Vector-valued trilinear spline interpolation</td></tr>
</table></div>
<a name='struct_spline3dinterpolant'></a><h3 class=pageheader><code>spline3dinterpolant</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
3-dimensional spline inteprolant
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class spline3dinterpolant
{
}

</div></pre>
<a name='sub_spline3dbuildtrilinearv'></a><h3 class=pageheader><code>spline3dbuildtrilinearv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds trilinear vector-valued spline.

INPUT PARAMETERS:
    X   -   spline abscissas,  array[0..N-1]
    Y   -   spline ordinates,  array[0..M-1]
    Z   -   spline applicates, array[0..L-1]
    F   -   function values, array[0..M*N*L*D-1]:
            * first D elements store D values at (X[0],Y[0],Z[0])
            * next D elements store D values at (X[1],Y[0],Z[0])
            * next D elements store D values at (X[2],Y[0],Z[0])
            * ...
            * next D elements store D values at (X[0],Y[1],Z[0])
            * next D elements store D values at (X[1],Y[1],Z[0])
            * next D elements store D values at (X[2],Y[1],Z[0])
            * ...
            * next D elements store D values at (X[0],Y[0],Z[1])
            * next D elements store D values at (X[1],Y[0],Z[1])
            * next D elements store D values at (X[2],Y[0],Z[1])
            * ...
            * general form - D function values at (X[i],Y[j]) are stored
              at F[D*(N*(M*K+J)+I)...D*(N*(M*K+J)+I)+D-1].
    M,N,
    L   -   grid size, M&gt;=2, N&gt;=2, L&gt;=2
    D   -   vector dimension, D&gt;=1

OUTPUT PARAMETERS:
    C   -   spline interpolant

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dbuildtrilinearv(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>double</font>[] z,
    <font color=navy>int</font> l,
    <font color=navy>double</font>[] f,
    <font color=navy>int</font> d,
    <font color=navy>out</font> spline3dinterpolant c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline3d_trilinear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline3d_vector' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_spline3dcalc'></a><h3 class=pageheader><code>spline3dcalc</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the trilinear or tricubic spline at
the given point (X,Y,Z).

INPUT PARAMETERS:
    C   -   coefficients table.
            Built by BuildBilinearSpline or BuildBicubicSpline.
    X, Y,
    Z   -   point

Result:
    S(x,y,z)

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.spline3dcalc(
    spline3dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y,
    <font color=navy>double</font> z)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline3d_trilinear' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline3dcalcv'></a><h3 class=pageheader><code>spline3dcalcv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates trilinear or tricubic vector-valued spline at the
given point (X,Y,Z).

INPUT PARAMETERS:
    C   -   spline interpolant.
    X, Y,
    Z   -   point

OUTPUT PARAMETERS:
    F   -   array[D] which stores function values.  F is out-parameter and
            it  is  reallocated  after  call to this function. In case you
            want  to    reuse  previously  allocated  F,   you   may   use
            Spline2DCalcVBuf(),  which  reallocates  F only when it is too
            small.

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dcalcv(
    spline3dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y,
    <font color=navy>double</font> z,
    <font color=navy>out</font> <font color=navy>double</font>[] f)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline3d_vector' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline3dcalcvbuf'></a><h3 class=pageheader><code>spline3dcalcvbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates bilinear or bicubic vector-valued spline at the
given point (X,Y,Z).

INPUT PARAMETERS:
    C   -   spline interpolant.
    X, Y,
    Z   -   point
    F   -   output buffer, possibly preallocated array. In case array size
            is large enough to store result, it is not reallocated.  Array
            which is too short will be reallocated

OUTPUT PARAMETERS:
    F   -   array[D] (or larger) which stores function values

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dcalcvbuf(
    spline3dinterpolant c,
    <font color=navy>double</font> x,
    <font color=navy>double</font> y,
    <font color=navy>double</font> z,
    <font color=navy>ref</font> <font color=navy>double</font>[] f)

</div></pre>
<a name='sub_spline3dlintransf'></a><h3 class=pageheader><code>spline3dlintransf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    A, B-   transformation coefficients: S2(x,y) = A*S(x,y,z) + B

OUTPUT PARAMETERS:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dlintransf(
    spline3dinterpolant c,
    <font color=navy>double</font> a,
    <font color=navy>double</font> b)

</div></pre>
<a name='sub_spline3dlintransxyz'></a><h3 class=pageheader><code>spline3dlintransxyz</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline argument.

INPUT PARAMETERS:
    C       -   spline interpolant
    AX, BX  -   transformation coefficients: x = A*u + B
    AY, BY  -   transformation coefficients: y = A*v + B
    AZ, BZ  -   transformation coefficients: z = A*w + B

OUTPUT PARAMETERS:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dlintransxyz(
    spline3dinterpolant c,
    <font color=navy>double</font> ax,
    <font color=navy>double</font> bx,
    <font color=navy>double</font> ay,
    <font color=navy>double</font> by,
    <font color=navy>double</font> az,
    <font color=navy>double</font> bz)

</div></pre>
<a name='sub_spline3dresampletrilinear'></a><h3 class=pageheader><code>spline3dresampletrilinear</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Trilinear spline resampling

INPUT PARAMETERS:
    A           -   array[0..OldXCount*OldYCount*OldZCount-1], function
                    values at the old grid, :
                        A[0]        x=0,y=0,z=0
                        A[1]        x=1,y=0,z=0
                        A[..]       ...
                        A[..]       x=oldxcount-1,y=0,z=0
                        A[..]       x=0,y=1,z=0
                        A[..]       ...
                        ...
    OldZCount   -   old Z-count, OldZCount&gt;1
    OldYCount   -   old Y-count, OldYCount&gt;1
    OldXCount   -   old X-count, OldXCount&gt;1
    NewZCount   -   new Z-count, NewZCount&gt;1
    NewYCount   -   new Y-count, NewYCount&gt;1
    NewXCount   -   new X-count, NewXCount&gt;1

OUTPUT PARAMETERS:
    B           -   array[0..NewXCount*NewYCount*NewZCount-1], function
                    values at the new grid:
                        B[0]        x=0,y=0,z=0
                        B[1]        x=1,y=0,z=0
                        B[..]       ...
                        B[..]       x=newxcount-1,y=0,z=0
                        B[..]       x=0,y=1,z=0
                        B[..]       ...
                        ...

  -- ALGLIB routine --
     26.04.2012
     Copyright by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dresampletrilinear(
    <font color=navy>double</font>[] a,
    <font color=navy>int</font> oldzcount,
    <font color=navy>int</font> oldycount,
    <font color=navy>int</font> oldxcount,
    <font color=navy>int</font> newzcount,
    <font color=navy>int</font> newycount,
    <font color=navy>int</font> newxcount,
    <font color=navy>out</font> <font color=navy>double</font>[] b)

</div></pre>
<a name='sub_spline3dunpackv'></a><h3 class=pageheader><code>spline3dunpackv</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine unpacks tri-dimensional spline into the coefficients table

INPUT PARAMETERS:
    C   -   spline interpolant.

Result:
    N   -   grid size (X)
    M   -   grid size (Y)
    L   -   grid size (Z)
    D   -   number of components
    SType-  spline type. Currently, only one spline type is supported:
            trilinear spline, as indicated by SType=1.
    Tbl -   spline coefficients: [0..(N-1)*(M-1)*(L-1)*D-1, 0..13].
            For T=0..D-1 (component index), I = 0...N-2 (x index),
            J=0..M-2 (y index), K=0..L-2 (z index):
                Q := T + I*D + J*D*(N-1) + K*D*(N-1)*(M-1),

                Q-th row stores decomposition for T-th component of the
                vector-valued function

                Tbl[Q,0] = X[i]
                Tbl[Q,1] = X[i+1]
                Tbl[Q,2] = Y[j]
                Tbl[Q,3] = Y[j+1]
                Tbl[Q,4] = Z[k]
                Tbl[Q,5] = Z[k+1]

                Tbl[Q,6] = C000
                Tbl[Q,7] = C100
                Tbl[Q,8] = C010
                Tbl[Q,9] = C110
                Tbl[Q,10]= C001
                Tbl[Q,11]= C101
                Tbl[Q,12]= C011
                Tbl[Q,13]= C111
            On each grid square spline is equals to:
                S(x) = SUM(c[i,j,k]*(x^i)*(y^j)*(z^k), i=0..1, j=0..1, k=0..1)
                t = x-x[j]
                u = y-y[i]
                v = z-z[k]

            NOTE: format of Tbl is given for SType=1. Future versions of
                  ALGLIB can use different formats for different values of
                  SType.

  -- ALGLIB PROJECT --
     Copyright 26.04.2012 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spline3dunpackv(
    spline3dinterpolant c,
    <font color=navy>out</font> <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>int</font> l,
    <font color=navy>out</font> <font color=navy>int</font> d,
    <font color=navy>out</font> <font color=navy>int</font> stype,
    <font color=navy>out</font> <font color=navy>double</font>[,] tbl)

</div></pre>
<a name='example_spline3d_trilinear'></a><h3 class=pageheader>spline3d_trilinear example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use trilinear spline to interpolate f(x,y,z)=x+xy+z sampled </font>
    <font color=green>// at (x,y,z) from [0.0, 1.0] X [0.0, 1.0] X [0.0, 1.0].</font>
    <font color=green>//</font>
    <font color=green>// We store x, y and z-values at local arrays with same names.</font>
    <font color=green>// Function values are stored in the array F as follows:</font>
    <font color=green>//     f[0]     (x,y,z) = (0,0,0)</font>
    <font color=green>//     f[1]     (x,y,z) = (1,0,0)</font>
    <font color=green>//     f[2]     (x,y,z) = (0,1,0)</font>
    <font color=green>//     f[3]     (x,y,z) = (1,1,0)</font>
    <font color=green>//     f[4]     (x,y,z) = (0,0,1)</font>
    <font color=green>//     f[5]     (x,y,z) = (1,0,1)</font>
    <font color=green>//     f[6]     (x,y,z) = (0,1,1)</font>
    <font color=green>//     f[7]     (x,y,z) = (1,1,1)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] z = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0,1,0,2,1,2,1,3};
    <font color=navy>double</font> vx = 0.50;
    <font color=navy>double</font> vy = 0.50;
    <font color=navy>double</font> vz = 0.50;
    <font color=navy>double</font> v;
    alglib.spline3dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline3dbuildtrilinearv(x, 2, y, 2, z, 2, f, 1, <font color=navy>out</font> s);

    <font color=green>// calculate S(0.5,0.5,0.5)</font>
    v = alglib.spline3dcalc(s, vx, vy, vz);
    System.Console.WriteLine(<font color=blue><b>&quot;{0:F4&quot;</b></font>, v); <font color=green>// EXPECTED: 1.2500</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name='example_spline3d_vector'></a><h3 class=pageheader>spline3d_vector example</h3>
<pre class=source>

<font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> Main(string[] args)
{
    <font color=green>//</font>
    <font color=green>// We use trilinear vector-valued spline to interpolate {f0,f1}={x+xy+z,x+xy+yz+z}</font>
    <font color=green>// sampled at (x,y,z) from [0.0, 1.0] X [0.0, 1.0] X [0.0, 1.0].</font>
    <font color=green>//</font>
    <font color=green>// We store x, y and z-values at local arrays with same names.</font>
    <font color=green>// Function values are stored in the array F as follows:</font>
    <font color=green>//     f[0]     f0, (x,y,z) = (0,0,0)</font>
    <font color=green>//     f[1]     f1, (x,y,z) = (0,0,0)</font>
    <font color=green>//     f[2]     f0, (x,y,z) = (1,0,0)</font>
    <font color=green>//     f[3]     f1, (x,y,z) = (1,0,0)</font>
    <font color=green>//     f[4]     f0, (x,y,z) = (0,1,0)</font>
    <font color=green>//     f[5]     f1, (x,y,z) = (0,1,0)</font>
    <font color=green>//     f[6]     f0, (x,y,z) = (1,1,0)</font>
    <font color=green>//     f[7]     f1, (x,y,z) = (1,1,0)</font>
    <font color=green>//     f[8]     f0, (x,y,z) = (0,0,1)</font>
    <font color=green>//     f[9]     f1, (x,y,z) = (0,0,1)</font>
    <font color=green>//     f[10]    f0, (x,y,z) = (1,0,1)</font>
    <font color=green>//     f[11]    f1, (x,y,z) = (1,0,1)</font>
    <font color=green>//     f[12]    f0, (x,y,z) = (0,1,1)</font>
    <font color=green>//     f[13]    f1, (x,y,z) = (0,1,1)</font>
    <font color=green>//     f[14]    f0, (x,y,z) = (1,1,1)</font>
    <font color=green>//     f[15]    f1, (x,y,z) = (1,1,1)</font>
    <font color=green>//</font>
    <font color=navy>double</font>[] x = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] y = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] z = new <font color=navy>double</font>[]{0.0,1.0};
    <font color=navy>double</font>[] f = new <font color=navy>double</font>[]{0,0,1,1,0,0,2,2,1,1,2,2,1,2,3,4};
    <font color=navy>double</font> vx = 0.50;
    <font color=navy>double</font> vy = 0.50;
    <font color=navy>double</font> vz = 0.50;
    alglib.spline3dinterpolant s;

    <font color=green>// build spline</font>
    alglib.spline3dbuildtrilinearv(x, 2, y, 2, z, 2, f, 2, <font color=navy>out</font> s);

    <font color=green>// calculate S(0.5,0.5,0.5) - we have vector of values instead of single value</font>
    <font color=navy>double</font>[] v;
    alglib.spline3dcalcv(s, vx, vy, vz, <font color=navy>out</font> v);
    System.Console.WriteLine(<font color=blue><b>&quot;{0}&quot;</b></font>, alglib.ap.format(v,4)); <font color=green>// EXPECTED: [1.2500,1.5000]</font>
    System.Console.ReadLine();
    <font color=navy>return</font> 0;
}


</pre><a name=unit_stest></a><h2 class=pageheader><code>stest</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_onesamplesigntest' class=toc>onesamplesigntest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_onesamplesigntest'></a><h3 class=pageheader><code>onesamplesigntest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Sign test

This test checks three hypotheses about the median of  the  given  sample.
The following tests are performed:
    * two-tailed test (null hypothesis - the median is equal to the  given
      value)
    * left-tailed test (null hypothesis - the median is  greater  than  or
      equal to the given value)
    * right-tailed test (null hypothesis - the  median  is  less  than  or
      equal to the given value)

Requirements:
    * the scale of measurement should be ordinal, interval or ratio  (i.e.
      the test could not be applied to nominal variables).

The test is non-parametric and doesn't require distribution X to be normal

Input parameters:
    X       -   sample. Array whose index goes from 0 to N-1.
    N       -   size of the sample.
    Median  -   assumed median value.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

While   calculating   p-values   high-precision   binomial    distribution
approximation is used, so significance levels have about 15 exact digits.

  -- ALGLIB --
     Copyright 08.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.onesamplesigntest(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font> median,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name=unit_studenttdistr></a><h2 class=pageheader><code>studenttdistr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_invstudenttdistribution' class=toc>invstudenttdistribution</a><br>
<a href='#sub_studenttdistribution' class=toc>studenttdistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_invstudenttdistribution'></a><h3 class=pageheader><code>invstudenttdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Functional inverse of Student's t distribution

Given probability p, finds the argument t such that stdtr(k,t)
is equal to p.

ACCURACY:

Tested at random 1 &lt;= k &lt;= 100.  The &quot;domain&quot; refers to p:
                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE    .001,.999     25000       5.7e-15     8.0e-16
   IEEE    10^-6,.001    25000       2.0e-12     2.9e-14

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.invstudenttdistribution(<font color=navy>int</font> k, <font color=navy>double</font> p)

</div></pre>
<a name='sub_studenttdistribution'></a><h3 class=pageheader><code>studenttdistribution</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Student's t distribution

Computes the integral from minus infinity to t of the Student
t distribution with integer k &gt; 0 degrees of freedom:

                                     t
                                     -
                                    | |
             -                      |         2   -(k+1)/2
            | ( (k+1)/2 )           |  (     x   )
      ----------------------        |  ( 1 + --- )        dx
                    -               |  (      k  )
      sqrt( k pi ) | ( k/2 )        |
                                  | |
                                   -
                                  -inf.

Relation to incomplete beta integral:

       1 - stdtr(k,t) = 0.5 * incbet( k/2, 1/2, z )
where
       z = k/(k + t**2).

For t &lt; -2, this is the method of computation.  For higher t,
a direct method is derived from integration by parts.
Since the function is symmetric about t=0, the area under the
right tail of the density is found by calling the function
with -t instead of t.

ACCURACY:

Tested at random 1 &lt;= k &lt;= 25.  The &quot;domain&quot; refers to t.
                     Relative error:
arithmetic   domain     # trials      peak         rms
   IEEE     -100,-2      50000       5.9e-15     1.4e-15
   IEEE     -2,100      500000       2.7e-15     4.9e-17

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.studenttdistribution(<font color=navy>int</font> k, <font color=navy>double</font> t)

</div></pre>
<a name=unit_studentttests></a><h2 class=pageheader><code>studentttests</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_studentttest1' class=toc>studentttest1</a><br>
<a href='#sub_studentttest2' class=toc>studentttest2</a><br>
<a href='#sub_unequalvariancettest' class=toc>unequalvariancettest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_studentttest1'></a><h3 class=pageheader><code>studentttest1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One-sample t-test

This test checks three hypotheses about the mean of the given sample.  The
following tests are performed:
    * two-tailed test (null hypothesis - the mean is equal  to  the  given
      value)
    * left-tailed test (null hypothesis - the  mean  is  greater  than  or
      equal to the given value)
    * right-tailed test (null hypothesis - the mean is less than or  equal
      to the given value).

The test is based on the assumption that  a  given  sample  has  a  normal
distribution and  an  unknown  dispersion.  If  the  distribution  sharply
differs from normal, the test will work incorrectly.

INPUT PARAMETERS:
    X       -   sample. Array whose index goes from 0 to N-1.
    N       -   size of sample, N&gt;=0
    Mean    -   assumed value of the mean.

OUTPUT PARAMETERS:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

NOTE: this function correctly handles degenerate cases:
      * when N=0, all p-values are set to 1.0
      * when variance of X[] is exactly zero, p-values are set
        to 1.0 or 0.0, depending on difference between sample mean and
        value of mean being tested.


  -- ALGLIB --
     Copyright 08.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.studentttest1(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font> mean,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name='sub_studentttest2'></a><h3 class=pageheader><code>studentttest2</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Two-sample pooled test

This test checks three hypotheses about the mean of the given samples. The
following tests are performed:
    * two-tailed test (null hypothesis - the means are equal)
    * left-tailed test (null hypothesis - the mean of the first sample  is
      greater than or equal to the mean of the second sample)
    * right-tailed test (null hypothesis - the mean of the first sample is
      less than or equal to the mean of the second sample).

Test is based on the following assumptions:
    * given samples have normal distributions
    * dispersions are equal
    * samples are independent.

Input parameters:
    X       -   sample 1. Array whose index goes from 0 to N-1.
    N       -   size of sample.
    Y       -   sample 2. Array whose index goes from 0 to M-1.
    M       -   size of sample.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

NOTE: this function correctly handles degenerate cases:
      * when N=0 or M=0, all p-values are set to 1.0
      * when both samples has exactly zero variance, p-values are set
        to 1.0 or 0.0, depending on difference between means.

  -- ALGLIB --
     Copyright 18.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.studentttest2(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name='sub_unequalvariancettest'></a><h3 class=pageheader><code>unequalvariancettest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Two-sample unpooled test

This test checks three hypotheses about the mean of the given samples. The
following tests are performed:
    * two-tailed test (null hypothesis - the means are equal)
    * left-tailed test (null hypothesis - the mean of the first sample  is
      greater than or equal to the mean of the second sample)
    * right-tailed test (null hypothesis - the mean of the first sample is
      less than or equal to the mean of the second sample).

Test is based on the following assumptions:
    * given samples have normal distributions
    * samples are independent.
Equality of variances is NOT required.

Input parameters:
    X - sample 1. Array whose index goes from 0 to N-1.
    N - size of the sample.
    Y - sample 2. Array whose index goes from 0 to M-1.
    M - size of the sample.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

NOTE: this function correctly handles degenerate cases:
      * when N=0 or M=0, all p-values are set to 1.0
      * when both samples has zero variance, p-values are set
        to 1.0 or 0.0, depending on difference between means.
      * when only one sample has zero variance, test reduces to 1-sample
        version.

  -- ALGLIB --
     Copyright 18.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.unequalvariancettest(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name=unit_svd></a><h2 class=pageheader><code>svd</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixsvd' class=toc>rmatrixsvd</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixsvd'></a><h3 class=pageheader><code>rmatrixsvd</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Singular value decomposition of a rectangular matrix.

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes one  important  improvement   of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Generally, commercial ALGLIB is several times faster than  open-source
  ! generic C edition, and many times faster than open-source C# edition.
  !
  ! Multithreaded acceleration is only partially supported (some parts are
  ! optimized, but most - are not).
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

The algorithm calculates the singular value decomposition of a matrix of
size MxN: A = U * S * V^T

The algorithm finds the singular values and, optionally, matrices U and V^T.
The algorithm can find both first min(M,N) columns of matrix U and rows of
matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
and NxN respectively).

Take into account that the subroutine does not return matrix V but V^T.

Input parameters:
    A           -   matrix to be decomposed.
                    Array whose indexes range within [0..M-1, 0..N-1].
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    UNeeded     -   0, 1 or 2. See the description of the parameter U.
    VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
    AdditionalMemory -
                    If the parameter:
                     * equals 0, the algorithm doesnt use additional
                       memory (lower requirements, lower performance).
                     * equals 1, the algorithm uses additional
                       memory of size min(M,N)*min(M,N) of real numbers.
                       It often speeds up the algorithm.
                     * equals 2, the algorithm uses additional
                       memory of size M*min(M,N) of real numbers.
                       It allows to get a maximum performance.
                    The recommended value of the parameter is 2.

Output parameters:
    W           -   contains singular values in descending order.
    U           -   if UNeeded=0, U isn't changed, the left singular vectors
                    are not calculated.
                    if Uneeded=1, U contains left singular vectors (first
                    min(M,N) columns of matrix U). Array whose indexes range
                    within [0..M-1, 0..Min(M,N)-1].
                    if UNeeded=2, U contains matrix U wholly. Array whose
                    indexes range within [0..M-1, 0..M-1].
    VT          -   if VTNeeded=0, VT isnt changed, the right singular vectors
                    are not calculated.
                    if VTNeeded=1, VT contains right singular vectors (first
                    min(M,N) rows of matrix V^T). Array whose indexes range
                    within [0..min(M,N)-1, 0..N-1].
                    if VTNeeded=2, VT contains matrix V^T wholly. Array whose
                    indexes range within [0..N-1, 0..N-1].

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.rmatrixsvd(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> uneeded,
    <font color=navy>int</font> vtneeded,
    <font color=navy>int</font> additionalmemory,
    <font color=navy>out</font> <font color=navy>double</font>[] w,
    <font color=navy>out</font> <font color=navy>double</font>[,] u,
    <font color=navy>out</font> <font color=navy>double</font>[,] vt)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smp_rmatrixsvd(
    <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>int</font> uneeded,
    <font color=navy>int</font> vtneeded,
    <font color=navy>int</font> additionalmemory,
    <font color=navy>out</font> <font color=navy>double</font>[] w,
    <font color=navy>out</font> <font color=navy>double</font>[,] u,
    <font color=navy>out</font> <font color=navy>double</font>[,] vt)

</div></pre>
<a name=unit_trfac></a><h2 class=pageheader><code>trfac</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlu' class=toc>cmatrixlu</a><br>
<a href='#sub_hpdmatrixcholesky' class=toc>hpdmatrixcholesky</a><br>
<a href='#sub_rmatrixlu' class=toc>rmatrixlu</a><br>
<a href='#sub_sparsecholeskyskyline' class=toc>sparsecholeskyskyline</a><br>
<a href='#sub_spdmatrixcholesky' class=toc>spdmatrixcholesky</a><br>
<a href='#sub_spdmatrixcholeskyupdateadd1' class=toc>spdmatrixcholeskyupdateadd1</a><br>
<a href='#sub_spdmatrixcholeskyupdateadd1buf' class=toc>spdmatrixcholeskyupdateadd1buf</a><br>
<a href='#sub_spdmatrixcholeskyupdatefix' class=toc>spdmatrixcholeskyupdatefix</a><br>
<a href='#sub_spdmatrixcholeskyupdatefixbuf' class=toc>spdmatrixcholeskyupdatefixbuf</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixlu'></a><h3 class=pageheader><code>cmatrixlu</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LU decomposition of a general complex matrix with row pivoting

A is represented as A = P*L*U, where:
* L is lower unitriangular matrix
* U is upper triangular matrix
* P = P0*P1*...*PK, K=min(M,N)-1,
  Pi - permutation matrix for I and Pivots[I]

This is cache-oblivous implementation of LU decomposition. It is optimized
for square matrices. As for rectangular matrices:
* best case - M&gt;&gt;N
* worst case - N&gt;&gt;M, small M, large N, matrix does not fit in CPU cache

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   array[0..M-1, 0..N-1].
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.


OUTPUT PARAMETERS:
    A       -   matrices L and U in compact form:
                * L is stored under main diagonal
                * U is stored on and above main diagonal
    Pivots  -   permutation matrix in compact form.
                array[0..Min(M-1,N-1)].

  -- ALGLIB routine --
     10.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.cmatrixlu(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font>[] pivots)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_cmatrixlu(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font>[] pivots)

</div></pre>
<a name='sub_hpdmatrixcholesky'></a><h3 class=pageheader><code>hpdmatrixcholesky</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivious Cholesky decomposition

The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
definite matrix. The result of an algorithm is a representation  of  A  as
A=U'*U  or A=L*L' (here X' detones conj(X^T)).

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   upper or lower triangle of a factorized matrix.
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   if IsUpper=True, then A contains an upper triangle of
                a symmetric matrix, otherwise A contains a lower one.

OUTPUT PARAMETERS:
    A       -   the result of factorization. If IsUpper=True, then
                the upper triangle contains matrix U, so that A = U'*U,
                and the elements below the main diagonal are not modified.
                Similarly, if IsUpper = False.

RESULT:
    If  the  matrix  is  positive-definite,  the  function  returns  True.
    Otherwise, the function returns False. Contents of A is not determined
    in such case.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.hpdmatrixcholesky(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smp_hpdmatrixcholesky(
    <font color=navy>ref</font> complex[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_rmatrixlu'></a><h3 class=pageheader><code>rmatrixlu</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LU decomposition of a general real matrix with row pivoting

A is represented as A = P*L*U, where:
* L is lower unitriangular matrix
* U is upper triangular matrix
* P = P0*P1*...*PK, K=min(M,N)-1,
  Pi - permutation matrix for I and Pivots[I]

This is cache-oblivous implementation of LU decomposition.
It is optimized for square matrices. As for rectangular matrices:
* best case - M&gt;&gt;N
* worst case - N&gt;&gt;M, small M, large N, matrix does not fit in CPU cache

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that LU decomposition  is  harder  to
  ! parallelize than, say, matrix-matrix  product  -  this  algorithm  has
  ! many internal synchronization points which can not be avoided. However
  ! parallelism starts to be profitable starting  from  N=1024,  achieving
  ! near-linear speedup for N=4096 or higher.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   array[0..M-1, 0..N-1].
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.


OUTPUT PARAMETERS:
    A       -   matrices L and U in compact form:
                * L is stored under main diagonal
                * U is stored on and above main diagonal
    Pivots  -   permutation matrix in compact form.
                array[0..Min(M-1,N-1)].

  -- ALGLIB routine --
     10.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.rmatrixlu(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font>[] pivots)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.smp_rmatrixlu(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> <font color=navy>int</font>[] pivots)

</div></pre>
<a name='sub_sparsecholeskyskyline'></a><h3 class=pageheader><code>sparsecholeskyskyline</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Sparse Cholesky decomposition for skyline matrixm using in-place algorithm
without allocating additional storage.

The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
definite sparse matrix. The result of an algorithm is a representation  of
A as A=U^T*U or A=L*L^T

This  function  is  a  more  efficient alternative to general, but  slower
SparseCholeskyX(), because it does not  create  temporary  copies  of  the
target. It performs factorization in-place, which gives  best  performance
on low-profile matrices. Its drawback, however, is that it can not perform
profile-reducing permutation of input matrix.

INPUT PARAMETERS:
    A       -   sparse matrix in skyline storage (SKS) format.
    N       -   size of matrix A (can be smaller than actual size of A)
    IsUpper -   if IsUpper=True, then factorization is performed on  upper
                triangle. Another triangle is ignored (it may contant some
                data, but it is not changed).


OUTPUT PARAMETERS:
    A       -   the result of factorization, stored in SKS. If IsUpper=True,
                then the upper  triangle  contains  matrix  U,  such  that
                A = U^T*U. Lower triangle is not changed.
                Similarly, if IsUpper = False. In this case L is returned,
                and we have A = L*(L^T).
                Note that THIS function does not  perform  permutation  of
                rows to reduce bandwidth.

RESULT:
    If  the  matrix  is  positive-definite,  the  function  returns  True.
    Otherwise, the function returns False. Contents of A is not determined
    in such case.

NOTE: for  performance  reasons  this  function  does NOT check that input
      matrix  includes  only  finite  values. It is your responsibility to
      make sure that there are no infinite or NAN values in the matrix.

  -- ALGLIB routine --
     16.01.2014
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.sparsecholeskyskyline(
    sparsematrix a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_spdmatrixcholesky'></a><h3 class=pageheader><code>spdmatrixcholesky</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivious Cholesky decomposition

The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
definite matrix. The result of an algorithm is a representation  of  A  as
A=U^T*U  or A=L*L^T

COMMERCIAL EDITION OF ALGLIB:

  ! Commercial version of ALGLIB includes two  important  improvements  of
  ! this function, which can be used from C++ and C#:
  ! * Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
  ! * multicore support
  !
  ! Intel MKL gives approximately constant  (with  respect  to  number  of
  ! worker threads) acceleration factor which depends on CPU  being  used,
  ! problem  size  and  &quot;baseline&quot;  ALGLIB  edition  which  is  used   for
  ! comparison.
  !
  ! Say, on SSE2-capable CPU with N=1024, HPC ALGLIB will be:
  ! * about 2-3x faster than ALGLIB for C++ without MKL
  ! * about 7-10x faster than &quot;pure C#&quot; edition of ALGLIB
  ! Difference in performance will be more striking  on  newer  CPU's with
  ! support for newer SIMD instructions. Generally,  MKL  accelerates  any
  ! problem whose size is at least 128, with best  efficiency achieved for
  ! N's larger than 512.
  !
  ! Commercial edition of ALGLIB also supports multithreaded  acceleration
  ! of this function. We should note that Cholesky decomposition is harder
  ! to parallelize than, say, matrix-matrix product - this  algorithm  has
  ! several synchronization points which  can  not  be  avoided.  However,
  ! parallelism starts to be profitable starting from N=500.
  !
  ! In order to use multicore features you have to:
  ! * use commercial version of ALGLIB
  ! * call  this  function  with  &quot;smp_&quot;  prefix,  which  indicates  that
  !   multicore code will be used (for multicore support)
  !
  ! We recommend you to read 'Working with commercial version' section  of
  ! ALGLIB Reference Manual in order to find out how to  use  performance-
  ! related features provided by commercial edition of ALGLIB.

INPUT PARAMETERS:
    A       -   upper or lower triangle of a factorized matrix.
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   if IsUpper=True, then A contains an upper triangle of
                a symmetric matrix, otherwise A contains a lower one.

OUTPUT PARAMETERS:
    A       -   the result of factorization. If IsUpper=True, then
                the upper triangle contains matrix U, so that A = U^T*U,
                and the elements below the main diagonal are not modified.
                Similarly, if IsUpper = False.

RESULT:
    If  the  matrix  is  positive-definite,  the  function  returns  True.
    Otherwise, the function returns False. Contents of A is not determined
    in such case.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.spdmatrixcholesky(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)
<font color=navy>public</font> <font color=navy>static</font> <font color=navy>bool</font> alglib.smp_spdmatrixcholesky(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper)

</div></pre>
<a name='sub_spdmatrixcholeskyupdateadd1'></a><h3 class=pageheader><code>spdmatrixcholeskyupdateadd1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Update of Cholesky decomposition: rank-1 update to original A.  &quot;Buffered&quot;
version which uses preallocated buffer which is saved  between  subsequent
function calls.

This function uses internally allocated buffer which is not saved  between
subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,
we  recommend   you   to   use   &quot;buffered&quot;   version   of  this function:
SPDMatrixCholeskyUpdateAdd1Buf().

INPUT PARAMETERS:
    A       -   upper or lower Cholesky factor.
                array with elements [0..N-1, 0..N-1].
                Exception is thrown if array size is too small.
    N       -   size of matrix A, N&gt;0
    IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
                otherwise A contains a lower one.
    U       -   array[N], rank-1 update to A: A_mod = A + u*u'
                Exception is thrown if array size is too small.
    BufR    -   possibly preallocated  buffer;  automatically  resized  if
                needed. It is recommended to  reuse  this  buffer  if  you
                perform a lot of subsequent decompositions.

OUTPUT PARAMETERS:
    A       -   updated factorization.  If  IsUpper=True,  then  the  upper
                triangle contains matrix U, and the elements below the main
                diagonal are not modified. Similarly, if IsUpper = False.

NOTE: this function always succeeds, so it does not return completion code

NOTE: this function checks sizes of input arrays, but it does  NOT  checks
      for presence of infinities or NAN's.

  -- ALGLIB --
     03.02.2014
     Sergey Bochkanov
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskyupdateadd1(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] u)

</div></pre>
<a name='sub_spdmatrixcholeskyupdateadd1buf'></a><h3 class=pageheader><code>spdmatrixcholeskyupdateadd1buf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Update of Cholesky decomposition: rank-1 update to original A.  &quot;Buffered&quot;
version which uses preallocated buffer which is saved  between  subsequent
function calls.

See comments for SPDMatrixCholeskyUpdateAdd1() for more information.

INPUT PARAMETERS:
    A       -   upper or lower Cholesky factor.
                array with elements [0..N-1, 0..N-1].
                Exception is thrown if array size is too small.
    N       -   size of matrix A, N&gt;0
    IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
                otherwise A contains a lower one.
    U       -   array[N], rank-1 update to A: A_mod = A + u*u'
                Exception is thrown if array size is too small.
    BufR    -   possibly preallocated  buffer;  automatically  resized  if
                needed. It is recommended to  reuse  this  buffer  if  you
                perform a lot of subsequent decompositions.

OUTPUT PARAMETERS:
    A       -   updated factorization.  If  IsUpper=True,  then  the  upper
                triangle contains matrix U, and the elements below the main
                diagonal are not modified. Similarly, if IsUpper = False.

  -- ALGLIB --
     03.02.2014
     Sergey Bochkanov
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskyupdateadd1buf(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>double</font>[] u,
    <font color=navy>ref</font> <font color=navy>double</font>[] bufr)

</div></pre>
<a name='sub_spdmatrixcholeskyupdatefix'></a><h3 class=pageheader><code>spdmatrixcholeskyupdatefix</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Update of Cholesky decomposition: &quot;fixing&quot; some variables.

This function uses internally allocated buffer which is not saved  between
subsequent  calls.  So,  if  you  perform  a lot  of  subsequent  updates,
we  recommend   you   to   use   &quot;buffered&quot;   version   of  this function:
SPDMatrixCholeskyUpdateFixBuf().

&quot;FIXING&quot; EXPLAINED:

    Suppose we have N*N positive definite matrix A. &quot;Fixing&quot; some variable
    means filling corresponding row/column of  A  by  zeros,  and  setting
    diagonal element to 1.

    For example, if we fix 2nd variable in 4*4 matrix A, it becomes Af:

        ( A00  A01  A02  A03 )      ( Af00  0   Af02 Af03 )
        ( A10  A11  A12  A13 )      (  0    1    0    0   )
        ( A20  A21  A22  A23 )  =&gt;  ( Af20  0   Af22 Af23 )
        ( A30  A31  A32  A33 )      ( Af30  0   Af32 Af33 )

    If we have Cholesky decomposition of A, it must be recalculated  after
    variables were  fixed.  However,  it  is  possible  to  use  efficient
    algorithm, which needs O(K*N^2)  time  to  &quot;fix&quot;  K  variables,  given
    Cholesky decomposition of original, &quot;unfixed&quot; A.

INPUT PARAMETERS:
    A       -   upper or lower Cholesky factor.
                array with elements [0..N-1, 0..N-1].
                Exception is thrown if array size is too small.
    N       -   size of matrix A, N&gt;0
    IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
                otherwise A contains a lower one.
    Fix     -   array[N], I-th element is True if I-th  variable  must  be
                fixed. Exception is thrown if array size is too small.
    BufR    -   possibly preallocated  buffer;  automatically  resized  if
                needed. It is recommended to  reuse  this  buffer  if  you
                perform a lot of subsequent decompositions.

OUTPUT PARAMETERS:
    A       -   updated factorization.  If  IsUpper=True,  then  the  upper
                triangle contains matrix U, and the elements below the main
                diagonal are not modified. Similarly, if IsUpper = False.

NOTE: this function always succeeds, so it does not return completion code

NOTE: this function checks sizes of input arrays, but it does  NOT  checks
      for presence of infinities or NAN's.

NOTE: this  function  is  efficient  only  for  moderate amount of updated
      variables - say, 0.1*N or 0.3*N. For larger amount of  variables  it
      will  still  work,  but  you  may  get   better   performance   with
      straightforward Cholesky.

  -- ALGLIB --
     03.02.2014
     Sergey Bochkanov
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskyupdatefix(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font>[] fix)

</div></pre>
<a name='sub_spdmatrixcholeskyupdatefixbuf'></a><h3 class=pageheader><code>spdmatrixcholeskyupdatefixbuf</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Update of Cholesky  decomposition:  &quot;fixing&quot;  some  variables.  &quot;Buffered&quot;
version which uses preallocated buffer which is saved  between  subsequent
function calls.

See comments for SPDMatrixCholeskyUpdateFix() for more information.

INPUT PARAMETERS:
    A       -   upper or lower Cholesky factor.
                array with elements [0..N-1, 0..N-1].
                Exception is thrown if array size is too small.
    N       -   size of matrix A, N&gt;0
    IsUpper -   if IsUpper=True, then A contains  upper  Cholesky  factor;
                otherwise A contains a lower one.
    Fix     -   array[N], I-th element is True if I-th  variable  must  be
                fixed. Exception is thrown if array size is too small.
    BufR    -   possibly preallocated  buffer;  automatically  resized  if
                needed. It is recommended to  reuse  this  buffer  if  you
                perform a lot of subsequent decompositions.

OUTPUT PARAMETERS:
    A       -   updated factorization.  If  IsUpper=True,  then  the  upper
                triangle contains matrix U, and the elements below the main
                diagonal are not modified. Similarly, if IsUpper = False.

  -- ALGLIB --
     03.02.2014
     Sergey Bochkanov
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.spdmatrixcholeskyupdatefixbuf(
    <font color=navy>ref</font> <font color=navy>double</font>[,] a,
    <font color=navy>int</font> n,
    <font color=navy>bool</font> isupper,
    <font color=navy>bool</font>[] fix,
    <font color=navy>ref</font> <font color=navy>double</font>[] bufr)

</div></pre>
<a name=unit_trigintegrals></a><h2 class=pageheader><code>trigintegrals</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hyperbolicsinecosineintegrals' class=toc>hyperbolicsinecosineintegrals</a><br>
<a href='#sub_sinecosineintegrals' class=toc>sinecosineintegrals</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_hyperbolicsinecosineintegrals'></a><h3 class=pageheader><code>hyperbolicsinecosineintegrals</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Hyperbolic sine and cosine integrals

Approximates the integrals

                           x
                           -
                          | |   cosh t - 1
  Chi(x) = eul + ln x +   |    -----------  dt,
                        | |          t
                         -
                         0

              x
              -
             | |  sinh t
  Shi(x) =   |    ------  dt
           | |       t
            -
            0

where eul = 0.57721566490153286061 is Euler's constant.
The integrals are evaluated by power series for x &lt; 8
and by Chebyshev expansions for x between 8 and 88.
For large x, both functions approach exp(x)/2x.
Arguments greater than 88 in magnitude return MAXNUM.


ACCURACY:

Test interval 0 to 88.
                     Relative error:
arithmetic   function  # trials      peak         rms
   IEEE         Shi      30000       6.9e-16     1.6e-16
       Absolute error, except relative when |Chi| &gt; 1:
   IEEE         Chi      30000       8.4e-16     1.4e-16

Cephes Math Library Release 2.8:  June, 2000
Copyright 1984, 1987, 2000 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.hyperbolicsinecosineintegrals(
    <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> shi,
    <font color=navy>out</font> <font color=navy>double</font> chi)

</div></pre>
<a name='sub_sinecosineintegrals'></a><h3 class=pageheader><code>sinecosineintegrals</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Sine and cosine integrals

Evaluates the integrals

                         x
                         -
                        |  cos t - 1
  Ci(x) = eul + ln x +  |  --------- dt,
                        |      t
                       -
                        0
            x
            -
           |  sin t
  Si(x) =  |  ----- dt
           |    t
          -
           0

where eul = 0.57721566490153286061 is Euler's constant.
The integrals are approximated by rational functions.
For x &gt; 8 auxiliary functions f(x) and g(x) are employed
such that

Ci(x) = f(x) sin(x) - g(x) cos(x)
Si(x) = pi/2 - f(x) cos(x) - g(x) sin(x)


ACCURACY:
   Test interval = [0,50].
Absolute error, except relative when &gt; 1:
arithmetic   function   # trials      peak         rms
   IEEE        Si        30000       4.4e-16     7.3e-17
   IEEE        Ci        30000       6.9e-16     5.1e-17

Cephes Math Library Release 2.1:  January, 1989
Copyright 1984, 1987, 1989 by Stephen L. Moshier
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.sinecosineintegrals(
    <font color=navy>double</font> x,
    <font color=navy>out</font> <font color=navy>double</font> si,
    <font color=navy>out</font> <font color=navy>double</font> ci)

</div></pre>
<a name=unit_variancetests></a><h2 class=pageheader><code>variancetests</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_ftest' class=toc>ftest</a><br>
<a href='#sub_onesamplevariancetest' class=toc>onesamplevariancetest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_ftest'></a><h3 class=pageheader><code>ftest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Two-sample F-test

This test checks three hypotheses about dispersions of the given  samples.
The following tests are performed:
    * two-tailed test (null hypothesis - the dispersions are equal)
    * left-tailed test (null hypothesis  -  the  dispersion  of  the first
      sample is greater than or equal to  the  dispersion  of  the  second
      sample).
    * right-tailed test (null hypothesis - the  dispersion  of  the  first
      sample is less than or equal to the dispersion of the second sample)

The test is based on the following assumptions:
    * the given samples have normal distributions
    * the samples are independent.

Input parameters:
    X   -   sample 1. Array whose index goes from 0 to N-1.
    N   -   sample size.
    Y   -   sample 2. Array whose index goes from 0 to M-1.
    M   -   sample size.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

  -- ALGLIB --
     Copyright 19.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.ftest(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[] y,
    <font color=navy>int</font> m,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name='sub_onesamplevariancetest'></a><h3 class=pageheader><code>onesamplevariancetest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One-sample chi-square test

This test checks three hypotheses about the dispersion of the given sample
The following tests are performed:
    * two-tailed test (null hypothesis - the dispersion equals  the  given
      number)
    * left-tailed test (null hypothesis - the dispersion is  greater  than
      or equal to the given number)
    * right-tailed test (null hypothesis  -  dispersion is  less  than  or
      equal to the given number).

Test is based on the following assumptions:
    * the given sample has a normal distribution.

Input parameters:
    X           -   sample 1. Array whose index goes from 0 to N-1.
    N           -   size of the sample.
    Variance    -   dispersion value to compare with.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

  -- ALGLIB --
     Copyright 19.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.onesamplevariancetest(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font> variance,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name=unit_wsr></a><h2 class=pageheader><code>wsr</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_wilcoxonsignedranktest' class=toc>wilcoxonsignedranktest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_wilcoxonsignedranktest'></a><h3 class=pageheader><code>wilcoxonsignedranktest</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Wilcoxon signed-rank test

This test checks three hypotheses about the median  of  the  given sample.
The following tests are performed:
    * two-tailed test (null hypothesis - the median is equal to the  given
      value)
    * left-tailed test (null hypothesis - the median is  greater  than  or
      equal to the given value)
    * right-tailed test (null hypothesis  -  the  median  is  less than or
      equal to the given value)

Requirements:
    * the scale of measurement should be ordinal, interval or  ratio (i.e.
      the test could not be applied to nominal variables).
    * the distribution should be continuous and symmetric relative to  its
      median.
    * number of distinct values in the X array should be greater than 4

The test is non-parametric and doesn't require distribution X to be normal

Input parameters:
    X       -   sample. Array whose index goes from 0 to N-1.
    N       -   size of the sample.
    Median  -   assumed median value.

Output parameters:
    BothTails   -   p-value for two-tailed test.
                    If BothTails is less than the given significance level
                    the null hypothesis is rejected.
    LeftTail    -   p-value for left-tailed test.
                    If LeftTail is less than the given significance level,
                    the null hypothesis is rejected.
    RightTail   -   p-value for right-tailed test.
                    If RightTail is less than the given significance level
                    the null hypothesis is rejected.

To calculate p-values, special approximation is used. This method lets  us
calculate p-values with two decimal places in interval [0.0001, 1].

&quot;Two decimal places&quot; does not sound very impressive, but in  practice  the
relative error of less than 1% is enough to make a decision.

There is no approximation outside the [0.0001, 1] interval. Therefore,  if
the significance level outlies this interval, the test returns 0.0001.

  -- ALGLIB --
     Copyright 08.09.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.wilcoxonsignedranktest(
    <font color=navy>double</font>[] x,
    <font color=navy>int</font> n,
    <font color=navy>double</font> e,
    <font color=navy>out</font> <font color=navy>double</font> bothtails,
    <font color=navy>out</font> <font color=navy>double</font> lefttail,
    <font color=navy>out</font> <font color=navy>double</font> righttail)

</div></pre>
<a name=unit_xdebug></a><h2 class=pageheader><code>xdebug</code> subpackage</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_xdebugrecord1' class=toc>xdebugrecord1</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_xdebugb1appendcopy' class=toc>xdebugb1appendcopy</a><br>
<a href='#sub_xdebugb1count' class=toc>xdebugb1count</a><br>
<a href='#sub_xdebugb1not' class=toc>xdebugb1not</a><br>
<a href='#sub_xdebugb1outeven' class=toc>xdebugb1outeven</a><br>
<a href='#sub_xdebugb2count' class=toc>xdebugb2count</a><br>
<a href='#sub_xdebugb2not' class=toc>xdebugb2not</a><br>
<a href='#sub_xdebugb2outsin' class=toc>xdebugb2outsin</a><br>
<a href='#sub_xdebugb2transpose' class=toc>xdebugb2transpose</a><br>
<a href='#sub_xdebugc1appendcopy' class=toc>xdebugc1appendcopy</a><br>
<a href='#sub_xdebugc1neg' class=toc>xdebugc1neg</a><br>
<a href='#sub_xdebugc1outeven' class=toc>xdebugc1outeven</a><br>
<a href='#sub_xdebugc1sum' class=toc>xdebugc1sum</a><br>
<a href='#sub_xdebugc2neg' class=toc>xdebugc2neg</a><br>
<a href='#sub_xdebugc2outsincos' class=toc>xdebugc2outsincos</a><br>
<a href='#sub_xdebugc2sum' class=toc>xdebugc2sum</a><br>
<a href='#sub_xdebugc2transpose' class=toc>xdebugc2transpose</a><br>
<a href='#sub_xdebugi1appendcopy' class=toc>xdebugi1appendcopy</a><br>
<a href='#sub_xdebugi1neg' class=toc>xdebugi1neg</a><br>
<a href='#sub_xdebugi1outeven' class=toc>xdebugi1outeven</a><br>
<a href='#sub_xdebugi1sum' class=toc>xdebugi1sum</a><br>
<a href='#sub_xdebugi2neg' class=toc>xdebugi2neg</a><br>
<a href='#sub_xdebugi2outsin' class=toc>xdebugi2outsin</a><br>
<a href='#sub_xdebugi2sum' class=toc>xdebugi2sum</a><br>
<a href='#sub_xdebugi2transpose' class=toc>xdebugi2transpose</a><br>
<a href='#sub_xdebuginitrecord1' class=toc>xdebuginitrecord1</a><br>
<a href='#sub_xdebugmaskedbiasedproductsum' class=toc>xdebugmaskedbiasedproductsum</a><br>
<a href='#sub_xdebugr1appendcopy' class=toc>xdebugr1appendcopy</a><br>
<a href='#sub_xdebugr1neg' class=toc>xdebugr1neg</a><br>
<a href='#sub_xdebugr1outeven' class=toc>xdebugr1outeven</a><br>
<a href='#sub_xdebugr1sum' class=toc>xdebugr1sum</a><br>
<a href='#sub_xdebugr2neg' class=toc>xdebugr2neg</a><br>
<a href='#sub_xdebugr2outsin' class=toc>xdebugr2outsin</a><br>
<a href='#sub_xdebugr2sum' class=toc>xdebugr2sum</a><br>
<a href='#sub_xdebugr2transpose' class=toc>xdebugr2transpose</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_xdebugrecord1'></a><h3 class=pageheader><code>xdebugrecord1</code> class</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************

*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> class xdebugrecord1
{
    <font color=navy>public</font> <font color=navy>int</font>                  i;
    <font color=navy>public</font> complex              c;
    <font color=navy>public</font> <font color=navy>double</font>[]             a;
}

</div></pre>
<a name='sub_xdebugb1appendcopy'></a><h3 class=pageheader><code>xdebugb1appendcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Appends copy of array to itself.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugb1appendcopy(<font color=navy>ref</font> <font color=navy>bool</font>[] a)

</div></pre>
<a name='sub_xdebugb1count'></a><h3 class=pageheader><code>xdebugb1count</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Counts number of True values in the boolean 1D array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.xdebugb1count(<font color=navy>bool</font>[] a)

</div></pre>
<a name='sub_xdebugb1not'></a><h3 class=pageheader><code>xdebugb1not</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by NOT(a[i]).
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugb1not(<font color=navy>ref</font> <font color=navy>bool</font>[] a)

</div></pre>
<a name='sub_xdebugb1outeven'></a><h3 class=pageheader><code>xdebugb1outeven</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate N-element array with even-numbered elements set to True.
Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugb1outeven(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>bool</font>[] a)

</div></pre>
<a name='sub_xdebugb2count'></a><h3 class=pageheader><code>xdebugb2count</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Counts number of True values in the boolean 2D array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.xdebugb2count(<font color=navy>bool</font>[,] a)

</div></pre>
<a name='sub_xdebugb2not'></a><h3 class=pageheader><code>xdebugb2not</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by NOT(a[i]).
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugb2not(<font color=navy>ref</font> <font color=navy>bool</font>[,] a)

</div></pre>
<a name='sub_xdebugb2outsin'></a><h3 class=pageheader><code>xdebugb2outsin</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate MxN matrix with elements set to &quot;Sin(3*I+5*J)&gt;0&quot;
Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugb2outsin(<font color=navy>int</font> m, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>bool</font>[,] a)

</div></pre>
<a name='sub_xdebugb2transpose'></a><h3 class=pageheader><code>xdebugb2transpose</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Transposes array.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugb2transpose(<font color=navy>ref</font> <font color=navy>bool</font>[,] a)

</div></pre>
<a name='sub_xdebugc1appendcopy'></a><h3 class=pageheader><code>xdebugc1appendcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Appends copy of array to itself.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugc1appendcopy(<font color=navy>ref</font> complex[] a)

</div></pre>
<a name='sub_xdebugc1neg'></a><h3 class=pageheader><code>xdebugc1neg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by -A[I]
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugc1neg(<font color=navy>ref</font> complex[] a)

</div></pre>
<a name='sub_xdebugc1outeven'></a><h3 class=pageheader><code>xdebugc1outeven</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate N-element array with even-numbered A[K] set to (x,y) = (K*0.25, K*0.125)
and odd-numbered ones are set to 0.

Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugc1outeven(<font color=navy>int</font> n, <font color=navy>out</font> complex[] a)

</div></pre>
<a name='sub_xdebugc1sum'></a><h3 class=pageheader><code>xdebugc1sum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of elements in the array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> complex alglib.xdebugc1sum(complex[] a)

</div></pre>
<a name='sub_xdebugc2neg'></a><h3 class=pageheader><code>xdebugc2neg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by -a[i,j]
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugc2neg(<font color=navy>ref</font> complex[,] a)

</div></pre>
<a name='sub_xdebugc2outsincos'></a><h3 class=pageheader><code>xdebugc2outsincos</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate MxN matrix with elements set to &quot;Sin(3*I+5*J),Cos(3*I+5*J)&quot;
Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugc2outsincos(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>out</font> complex[,] a)

</div></pre>
<a name='sub_xdebugc2sum'></a><h3 class=pageheader><code>xdebugc2sum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of elements in the array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> complex alglib.xdebugc2sum(complex[,] a)

</div></pre>
<a name='sub_xdebugc2transpose'></a><h3 class=pageheader><code>xdebugc2transpose</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Transposes array.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugc2transpose(<font color=navy>ref</font> complex[,] a)

</div></pre>
<a name='sub_xdebugi1appendcopy'></a><h3 class=pageheader><code>xdebugi1appendcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Appends copy of array to itself.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugi1appendcopy(<font color=navy>ref</font> <font color=navy>int</font>[] a)

</div></pre>
<a name='sub_xdebugi1neg'></a><h3 class=pageheader><code>xdebugi1neg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by -A[I]
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugi1neg(<font color=navy>ref</font> <font color=navy>int</font>[] a)

</div></pre>
<a name='sub_xdebugi1outeven'></a><h3 class=pageheader><code>xdebugi1outeven</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate N-element array with even-numbered A[I] set to I, and odd-numbered
ones set to 0.

Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugi1outeven(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>int</font>[] a)

</div></pre>
<a name='sub_xdebugi1sum'></a><h3 class=pageheader><code>xdebugi1sum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of elements in the array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.xdebugi1sum(<font color=navy>int</font>[] a)

</div></pre>
<a name='sub_xdebugi2neg'></a><h3 class=pageheader><code>xdebugi2neg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by -a[i,j]
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugi2neg(<font color=navy>ref</font> <font color=navy>int</font>[,] a)

</div></pre>
<a name='sub_xdebugi2outsin'></a><h3 class=pageheader><code>xdebugi2outsin</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate MxN matrix with elements set to &quot;Sign(Sin(3*I+5*J))&quot;
Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugi2outsin(<font color=navy>int</font> m, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>int</font>[,] a)

</div></pre>
<a name='sub_xdebugi2sum'></a><h3 class=pageheader><code>xdebugi2sum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of elements in the array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>int</font> alglib.xdebugi2sum(<font color=navy>int</font>[,] a)

</div></pre>
<a name='sub_xdebugi2transpose'></a><h3 class=pageheader><code>xdebugi2transpose</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Transposes array.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugi2transpose(<font color=navy>ref</font> <font color=navy>int</font>[,] a)

</div></pre>
<a name='sub_xdebuginitrecord1'></a><h3 class=pageheader><code>xdebuginitrecord1</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Creates and returns XDebugRecord1 structure:
* integer and complex fields of Rec1 are set to 1 and 1+i correspondingly
* array field of Rec1 is set to [2,3]

  -- ALGLIB --
     Copyright 27.05.2014 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebuginitrecord1(<font color=navy>out</font> xdebugrecord1 rec1)

</div></pre>
<a name='sub_xdebugmaskedbiasedproductsum'></a><h3 class=pageheader><code>xdebugmaskedbiasedproductsum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of a[i,j]*(1+b[i,j]) such that c[i,j] is True

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.xdebugmaskedbiasedproductsum(
    <font color=navy>int</font> m,
    <font color=navy>int</font> n,
    <font color=navy>double</font>[,] a,
    <font color=navy>double</font>[,] b,
    <font color=navy>bool</font>[,] c)

</div></pre>
<a name='sub_xdebugr1appendcopy'></a><h3 class=pageheader><code>xdebugr1appendcopy</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Appends copy of array to itself.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugr1appendcopy(<font color=navy>ref</font> <font color=navy>double</font>[] a)

</div></pre>
<a name='sub_xdebugr1neg'></a><h3 class=pageheader><code>xdebugr1neg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by -A[I]
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugr1neg(<font color=navy>ref</font> <font color=navy>double</font>[] a)

</div></pre>
<a name='sub_xdebugr1outeven'></a><h3 class=pageheader><code>xdebugr1outeven</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate N-element array with even-numbered A[I] set to I*0.25,
and odd-numbered ones are set to 0.

Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugr1outeven(<font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[] a)

</div></pre>
<a name='sub_xdebugr1sum'></a><h3 class=pageheader><code>xdebugr1sum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of elements in the array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.xdebugr1sum(<font color=navy>double</font>[] a)

</div></pre>
<a name='sub_xdebugr2neg'></a><h3 class=pageheader><code>xdebugr2neg</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Replace all values in array by -a[i,j]
Array is passed using &quot;shared&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugr2neg(<font color=navy>ref</font> <font color=navy>double</font>[,] a)

</div></pre>
<a name='sub_xdebugr2outsin'></a><h3 class=pageheader><code>xdebugr2outsin</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Generate MxN matrix with elements set to &quot;Sin(3*I+5*J)&quot;
Array is passed using &quot;out&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugr2outsin(<font color=navy>int</font> m, <font color=navy>int</font> n, <font color=navy>out</font> <font color=navy>double</font>[,] a)

</div></pre>
<a name='sub_xdebugr2sum'></a><h3 class=pageheader><code>xdebugr2sum</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Returns sum of elements in the array.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>double</font> alglib.xdebugr2sum(<font color=navy>double</font>[,] a)

</div></pre>
<a name='sub_xdebugr2transpose'></a><h3 class=pageheader><code>xdebugr2transpose</code> function</h3>
<pre class=source>
<div style='color: green; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This is debug function intended for testing ALGLIB interface generator.
Never use it in any real life project.

Transposes array.
Array is passed using &quot;var&quot; convention.

  -- ALGLIB --
     Copyright 11.10.2013 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><font color=navy>public</font> <font color=navy>static</font> <font color=navy>void</font> alglib.xdebugr2transpose(<font color=navy>ref</font> <font color=navy>double</font>[,] a)

</div></pre>

</body>
</html>