###########################################################################
# ALGLIB 3.10.0 (source code generated 2015-08-19)
# Copyright (c) Sergey Bochkanov (ALGLIB project).
# 
# >>> SOURCE LICENSE >>>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation (www.fsf.org); either version 2 of the 
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# A copy of the GNU General Public License is available at
# http://www.fsf.org/licensing/licenses
# >>> END OF LICENSE >>>
##########################################################################

import ctypes

import ctypes
import sys
import os

if ctypes.sizeof(ctypes.c_void_p)==4:
    c_ptrint_t = ctypes.c_int32
else:
    c_ptrint_t = ctypes.c_int64

DT_BOOL = 1
DT_INT = 2
DT_REAL = 3
DT_COMPLEX = 4

SIZE_BOOL = 1
SIZE_INT = ctypes.sizeof(ctypes.c_void_p)
SIZE_REAL = 8
SIZE_COMPLEX = 16

OWN_CALLER = 1
OWN_AE = 2

X_ASSERTION_FAILED = 5

X_SET     = 1 # data are copied into x-vector/matrix; previous contents of x-structure is freed
X_CREATE  = 2 # x-vector/matrix is created, its previous contents is ignored
X_REWRITE = 3 # data are copied into x-structure; size of Python structure must be equal to the x-structure size

class x_complex(ctypes.Structure):
    _fields_ = [("x", ctypes.c_double), ("y", ctypes.c_double)]

class x_multiptr(ctypes.Union):
    _fields_ = [("p_ptr",       ctypes.c_void_p),
                ("p_char",      ctypes.c_char_p),
                ("p_bool",      ctypes.POINTER(ctypes.c_int8)),
                ("p_int",       ctypes.POINTER(c_ptrint_t)),
                ("p_real",      ctypes.POINTER(ctypes.c_double)),
                ("p_complex",   ctypes.POINTER(x_complex))]

class x_int(ctypes.Union):
    _fields_ = [("val",         c_ptrint_t),
                ("longval",     ctypes.c_uint64)]

class x_string(ctypes.Structure):
    _fields_ = [("owner",       ctypes.c_uint64),
                ("last_action", ctypes.c_uint64),
                ("ptr",         x_multiptr)]

class x_vector(ctypes.Structure):
    _pack_   = 8
    _fields_ = [("cnt",         ctypes.c_uint64),
                ("datatype",    ctypes.c_uint64),
                ("owner",       ctypes.c_uint64),
                ("last_action", ctypes.c_uint64),
                ("ptr",         x_multiptr)]

class x_matrix(ctypes.Structure):
    _pack_   = 8
    _fields_ = [("rows",        ctypes.c_uint64),
                ("cols",        ctypes.c_uint64),
                ("stride",      ctypes.c_uint64),
                ("datatype",    ctypes.c_uint64),
                ("owner",       ctypes.c_uint64),
                ("last_action", ctypes.c_uint64),
                ("ptr",         x_multiptr)]

#
# Load ALGLIB shared library
#
_so_candidates = []
curdir = os.path.dirname(__file__)
if curdir=="":
    curdir = "."
if sys.platform=="win32" or sys.platform=="cygwin":
    _shared_lib_name = "alglib.dll"
    _so_candidates.append(os.path.join(curdir,_shared_lib_name))
    _so_candidates.append(os.path.join(sys.prefix,_shared_lib_name))
else:
    _shared_lib_name = "alglib.so"
    _so_candidates.append(os.path.join(curdir,_shared_lib_name))
    _so_candidates.append(os.path.join(sys.prefix,_shared_lib_name))
    _so_candidates.append(os.path.join(os.sep+"usr","local",_shared_lib_name))
for _candidate in _so_candidates:
    if os.path.isfile(_candidate):
        _lib_alglib = ctypes.cdll.LoadLibrary(_candidate)
        break
if _lib_alglib is None:
    raise RuntimeError("ALGLIB: unable to load shared library")

_lib_alglib.x_malloc.argtypes = [ctypes.c_void_p, ctypes.c_uint64]
_lib_alglib.x_malloc.restype = ctypes.c_int32
_lib_alglib.x_free.argtypes = [ctypes.c_void_p]
_lib_alglib.x_free.restype = ctypes.c_int32
_lib_alglib.x_setnworkers.argtypes = [ctypes.c_uint64]
_lib_alglib.x_setnworkers.restype = ctypes.c_uint8
_lib_alglib.x_alloc_counter.argtypes = []
_lib_alglib.x_alloc_counter.restype = ctypes.c_int64
_lib_alglib.x_is_symmetric_e_.argtypes = [ctypes.c_void_p]
_lib_alglib.x_is_symmetric_e_.restype = ctypes.c_uint8
_lib_alglib.x_is_hermitian_e_.argtypes = [ctypes.c_void_p]
_lib_alglib.x_is_hermitian_e_.restype = ctypes.c_uint8
_lib_alglib.x_force_symmetric_e_.argtypes = [ctypes.c_void_p]
_lib_alglib.x_force_symmetric_e_.restype = ctypes.c_uint8
_lib_alglib.x_force_hermitian_e_.argtypes = [ctypes.c_void_p]
_lib_alglib.x_force_hermitian_e_.restype = ctypes.c_uint8

def x_malloc(cnt):
    __cnt = ctypes.c_uint64(cnt)
    if __cnt.value!=cnt:
        raise RuntimeError("malloc() argument is too large!")
    __result = ctypes.c_void_p(0)
    if _lib_alglib.x_malloc(ctypes.byref(__result), __cnt)!=0:
        raise RuntimeError("Error while calling x_malloc()")
    return __result.value

def x_free(ptr):
    __ptr = ctypes.c_void_p(ptr)
    _lib_alglib.x_free(__ptr)
    return

def xsign(val):
    if val<0.0:
        return -1.0
    if val>0.0:
        return +1.0
    return 0.0

def setnworkers(nworkers):
    __nworkers = ctypes.c_uint64(nworkers)
    _lib_alglib.x_setnworkers(__nworkers)
    return

def x_alloc_counter():
    return _lib_alglib.x_alloc_counter()

def x_is_symmetric(x):
    return _lib_alglib.x_is_symmetric_e_(ctypes.byref(x))

def x_force_symmetric(x):
    return _lib_alglib.x_force_symmetric_e_(ctypes.byref(x))

def x_is_hermitian(x):
    return _lib_alglib.x_is_hermitian_e_(ctypes.byref(x))

def x_force_hermitian(x):
    return _lib_alglib.x_force_hermitian_e_(ctypes.byref(x))

def x_vector_clear(x):
    if x.owner==OWN_AE:
        x_free(x.ptr.p_ptr)
    x.cnt = 0
    x.ptr.p_ptr = 0
    return

def x_matrix_clear(x):
    if x.owner==OWN_AE:
        x_free(x.ptr.p_ptr)
    x.cols = 0
    x.rows = 0
    x.ptr.p_ptr = 0
    return

#
# safe vector length:
# * returns list length.
# * throws ValueError if 'v' is not list (it uses
#   'msg' parameter to generate error message
#
def safe_len(msg,v):
    if type(v)!=list:
        raise ValueError(msg)
    return len(v)

#
# safe matrix size
# * returns number of columns
# * throws ValueError if 'v' is not rectangular matrix 
#   (list of lists of same size)
#   it uses 'msg' parameter to generate error message
#
def safe_cols(msg,v):
    if type(v)!=list:
        raise ValueError(msg)
    if len(v)==0:
        return 0
    if type(v[0])!=list:
        raise ValueError(msg)
    cols = len(v[0])
    for x in v:
        if type(x)!=list:
            raise ValueError(msg)
        if len(x)!=cols:
            raise ValueError(msg)
    return cols

#
# safe matrix size
# * returns number of rows
# * throws ValueError if 'v' is not rectangular matrix 
#   (list of lists of same size)
#   it uses 'msg' parameter to generate error message
#
def safe_rows(msg,v):
    if type(v)!=list:
        raise ValueError(msg)
    if len(v)==0:
        return 0
    if type(v[0])!=list:
        raise ValueError(msg)
    cols = len(v[0])
    for x in v:
        if type(x)!=list:
            raise ValueError(msg)
        if len(x)!=cols:
            raise ValueError(msg)
    return len(v)

def create_real_vector(cnt):
    if cnt<=0:
        return []
    return [0]*cnt

def create_real_matrix(rows, cols):
    if rows<=0 or cols<=0:
        return [[]]
    matrix = []
    row = 0
    while row<rows:
        matrix += [[0]*cols]
        row += 1
    return matrix

def is_bool(v):
    try:
        tmp = bool(v)
    except:
        return False
    return True

def is_int(v):
    try:
        tmp = int(v)
    except:
        return False
    return True

def is_real(v):
    try:
        tmp = float(v)
    except:
        return False
    return True

def is_complex(v):
    try:
        tmp = complex(v)
    except:
        return False
    return True

def is_bool_vector(v):
    if type(v)!=list:
        return False
    for x in v:
        try:
            tmp = bool(x)
        except:
            return False
    return True

def is_bool_matrix(v):
    if type(v)!=list:
        return False
    if len(v)==0:
        return True
    if type(v[0])!=list:
        return False
    rows = len(v)
    cols = len(v[0])
    for x in v:
        if type(x)!=list:
            return False
        if len(x)!=cols:
            return False
        for y in x:
            try:
                tmp = bool(y)
            except:
                return False
    return True

def is_int_vector(v):
    if type(v)!=list:
        return False
    for x in v:
        try:
            tmp = int(x)
        except:
            return False
    return True

def is_int_matrix(v):
    if type(v)!=list:
        return False
    if len(v)==0:
        return True
    if type(v[0])!=list:
        return False
    rows = len(v)
    cols = len(v[0])
    for x in v:
        if type(x)!=list:
            return False
        if len(x)!=cols:
            return False
        for y in x:
            try:
                tmp = int(y)
            except:
                return False
    return True

def is_real_vector(v):
    if type(v)!=list:
        return False
    for x in v:
        try:
            tmp = float(x)
        except:
            return False
    return True

def is_real_matrix(v):
    if type(v)!=list:
        return False
    if len(v)==0:
        return True
    if type(v[0])!=list:
        return False
    rows = len(v)
    cols = len(v[0])
    for x in v:
        if type(x)!=list:
            return False
        if len(x)!=cols:
            return False
        for y in x:
            try:
                tmp = float(y)
            except:
                return False
    return True

def is_complex_vector(v):
    if type(v)!=list:
        return False
    for x in v:
        try:
            tmp = complex(x)
        except:
            return False
    return True

def is_complex_matrix(v):
    if type(v)!=list:
        return False
    if len(v)==0:
        return True
    if type(v[0])!=list:
        return False
    rows = len(v)
    cols = len(v[0])
    for x in v:
        if type(x)!=list:
            return False
        if len(x)!=cols:
            return False
        for y in x:
            try:
                tmp = complex(y)
            except:
                return False
    return True

#
# conversion from list to x-vector:
#
# x     x-vector. 
# v     list
# dt    datatype
# mode  one of the modes:
#       * X_CREATE -  x is assumed to be uninitialized
#       * X_SET -     x is assumed to be initialized; old contents is freed
#       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
#                     it is rewritten without reallocation of memory;
#
def x_from_list(x, v, dt, mode):
    #
    # check types
    #
    if dt==DT_BOOL:
        if not is_bool_vector(v):
            raise ValueError("can't cast to bool_vector")
        elemsize = SIZE_BOOL
    if dt==DT_INT:
        if not is_int_vector(v):
            raise ValueError("can't cast to int_vector")
        elemsize = SIZE_INT
    if dt==DT_REAL:
        if not is_real_vector(v):
            raise ValueError("can't cast to real_vector")
        elemsize = SIZE_REAL
    if dt==DT_COMPLEX:
        if not is_complex_vector(v):
            raise ValueError("can't cast to complex_vector")
        elemsize = SIZE_COMPLEX
    
    #
    # allocation
    #
    if mode==X_CREATE:
        x.datatype = dt
        x.cnt = len(v)
        x.owner = OWN_AE
        x.ptr.p_ptr = x_malloc(elemsize*x.cnt)
        x.last_action = 1
    if mode==X_SET:
        if x.owner==OWN_AE:
            x_free(x.ptr.p_ptr)
        x.datatype = dt
        x.cnt = len(v)
        x.owner = OWN_AE
        x.ptr.p_ptr = x_malloc(elemsize*x.cnt)
        x.last_action = 3
    if mode==X_REWRITE:
        if x.datatype!=dt:
            raise RuntimeError("Trying to rewrite vector - types don't match")
        if len(v)!=x.cnt:
            raise RuntimeError("Trying to rewrite vector - sizes don't match")
        x.last_action = 2
    
    #
    # copy
    #
    if dt==DT_BOOL:
        cnt = x.cnt
        i = 0
        while i<cnt:
            x.ptr.p_bool[i] =   bool(v[i])
            i += 1
    if dt==DT_INT:
        cnt = x.cnt
        i = 0
        while i<cnt:
            x.ptr.p_int[i] =    int(v[i])
            i += 1
    if dt==DT_REAL:
        cnt = x.cnt
        i = 0
        while i<cnt:
            x.ptr.p_real[i] = float(v[i])
            i += 1
    if dt==DT_COMPLEX:
        cnt = x.cnt
        i = 0
        while i<cnt:
            tmp = complex(v[i])
            x.ptr.p_complex[i].x = tmp.real
            x.ptr.p_complex[i].y = tmp.imag
            i += 1
    
    return


#
# conversion from list of lists to x-matrix:
#
# x     x-matrix.
# v     list
# dt    datatype
# mode  one of the modes:
#       * X_CREATE -  x is assumed to be uninitialized
#       * X_SET -     x is assumed to be initialized; old contents is freed
#       * X_REWRITE - x is assumed to have same size as v, exception is thrown otherwise
#                     it is rewritten without reallocation of memory;
#
def x_from_listlist(x, v, dt, mode):
    #
    # check types
    #
    if dt==DT_BOOL:
        if not is_bool_matrix(v):
            raise ValueError("can't cast to bool_matrix")
        elemsize = SIZE_BOOL
    if dt==DT_INT:
        if not is_int_matrix(v):
            raise ValueError("can't cast to int_matrix")
        elemsize = SIZE_INT
    if dt==DT_REAL:
        if not is_real_matrix(v):
            raise ValueError("can't cast to real_matrix")
        elemsize = SIZE_REAL
    if dt==DT_COMPLEX:
        if not is_complex_matrix(v):
            raise ValueError("can't cast to complex_matrix")
        elemsize = SIZE_COMPLEX
    
    #
    # determine size
    #
    rows = len(v)
    if rows>0:
        cols = len(v[0])
    else:
        cols = 0
    if cols==0:
        rows = 0
    
    #
    # allocation
    #
    if mode==X_CREATE:
        x.datatype = dt
        x.cols = cols
        x.rows = rows
        x.stride = cols
        x.owner = OWN_AE
        x.ptr.p_ptr = x_malloc(elemsize*x.stride*x.rows)
        x.last_action = 1
    if mode==X_SET:
        if x.owner==OWN_AE:
            x_free(x.ptr.p_ptr)
        x.cols = cols
        x.rows = rows
        x.stride =cols
        x.owner = OWN_AE
        x.ptr.p_ptr = x_malloc(elemsize*x.stride*x.rows)
        x.last_action = 3
    if mode==X_REWRITE:
        if x.datatype!=dt:
            raise RuntimeError("Trying to rewrite matrix - types don't match")
        if rows!=x.rows or cols!=x.cols:
            raise RuntimeError("Trying to rewrite vector - sizes don't match")
        x.last_action = 2
    
    #
    # copy
    #
    offs = 0
    endoffs = x.stride-x.cols
    for p in v:
        for q in p:
            if dt==DT_BOOL:
                x.ptr.p_bool[offs] = bool(q)
            if dt==DT_INT:
                x.ptr.p_int[offs]  = int(q)
            if dt==DT_REAL:
                x.ptr.p_real[offs] = float(q)
            if dt==DT_COMPLEX:
                tmp = complex(q)
                x.ptr.p_complex[offs].x = tmp.real
                x.ptr.p_complex[offs].y = tmp.imag
            offs = offs+1
        offs = offs+endoffs
    return


#
# conversion from x-vector to Python vector
#
# Function takes only one parameter - x, x-vector,
# which is NOT freed after use.
#
def list_from_x(x):
    if x.cnt==0:
        return []
    r = [0]*x.cnt
    i = 0
    if x.datatype==DT_BOOL:
        while i<x.cnt:
            r[i] = bool(x.ptr.p_bool[i])
            i += 1
    if x.datatype==DT_INT:
        while i<x.cnt:
            r[i] = x.ptr.p_int[i]
            i += 1
    if x.datatype==DT_REAL:
        while i<x.cnt:
            r[i] = x.ptr.p_real[i]
            i += 1
    if x.datatype==DT_COMPLEX:
        while i<x.cnt:
            r[i] = complex(x.ptr.p_complex[i].x, x.ptr.p_complex[i].y)
            i += 1
    return r


#
# conversion from x-matrix to Python matrix
#
# Function takes only one parameter - x, x-matrix,
# which is NOT freed after use.
#
def listlist_from_x(x):
    if x.cols==0 or x.rows==0:
        return [[]]
    r = create_real_matrix(x.rows, x.cols)
    offs = 0
    endoffs = x.stride-x.cols
    m = x.rows
    n = x.cols
    dt = x.datatype
    i = 0
    while i<m:
        j = 0
        while j<n:
            if dt==DT_BOOL:
                r[i][j] = bool(x.ptr.p_bool[offs])
            if dt==DT_INT:
                r[i][j] = x.ptr.p_int[offs]
            if dt==DT_REAL:
                r[i][j] = x.ptr.p_real[offs]
            if dt==DT_COMPLEX:
                r[i][j] = complex(x.ptr.p_complex[offs].x, x.ptr.p_complex[offs].y)
            offs += 1
            j += 1
        offs += endoffs
        i += 1
    return r



#
# this function copies x-vector to previously allocated list 
# which should be large enough to store x-vector.
#
# invalid access to list is generated if list is too small.
# x-vector is not freed after use.
#
def copy_x_to_list(x,r):
    if x.cnt==0:
        return
    i = 0
    if x.datatype==DT_BOOL:
        while i<x.cnt:
            r[i] = bool(x.ptr.p_bool[i])
            i += 1
    if x.datatype==DT_INT:
        while i<x.cnt:
            r[i] = x.ptr.p_int[i]
            i += 1
    if x.datatype==DT_REAL:
        while i<x.cnt:
            r[i] = x.ptr.p_real[i]
            i += 1
    if x.datatype==DT_COMPLEX:
        while i<x.cnt:
            r[i] = complex(x.ptr.p_complex[i].x, x.ptr.p_complex[i].y)
            i += 1
    return

_lib_alglib.x_obj_free_hqrndstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_hqrndstate.restype = None


class hqrndstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_hqrndstate(self.ptr)
_lib_alglib.alglib_hqrndrandomize.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndrandomize.restype = ctypes.c_int32
def hqrndrandomize():
    pass
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndrandomize(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndrandomize'")
        __r__state = hqrndstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_hqrndseed.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndseed.restype = ctypes.c_int32
def hqrndseed(s1, s2):
    pass
    __s1 = x_int()
    __s1.val = int(s1)
    if __s1.val!=s1:
        raise ValueError("Error while converting 's1' parameter to 'x_int'")
    __s2 = x_int()
    __s2.val = int(s2)
    if __s2.val!=s2:
        raise ValueError("Error while converting 's2' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndseed(ctypes.byref(_error_msg), ctypes.byref(__s1), ctypes.byref(__s2), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndseed'")
        __r__state = hqrndstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_hqrnduniformr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrnduniformr.restype = ctypes.c_int32
def hqrnduniformr(state):
    pass
    __result = ctypes.c_double(0)
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrnduniformr(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrnduniformr'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_hqrnduniformi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrnduniformi.restype = ctypes.c_int32
def hqrnduniformi(state, n):
    pass
    __result = x_int()
    __result.val = 0
    __state = state.ptr
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrnduniformi(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__state), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrnduniformi'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_hqrndnormal.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndnormal.restype = ctypes.c_int32
def hqrndnormal(state):
    pass
    __result = ctypes.c_double(0)
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndnormal(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndnormal'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_hqrndunit2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndunit2.restype = ctypes.c_int32
def hqrndunit2(state):
    pass
    __state = state.ptr
    __x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndunit2(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndunit2'")
        __r__x = __x.value
        __r__y = __y.value
        return (__r__x, __r__y)
    finally:
        pass


_lib_alglib.alglib_hqrndnormal2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndnormal2.restype = ctypes.c_int32
def hqrndnormal2(state):
    pass
    __state = state.ptr
    __x1 = ctypes.c_double(0)
    __x2 = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndnormal2(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x1), ctypes.byref(__x2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndnormal2'")
        __r__x1 = __x1.value
        __r__x2 = __x2.value
        return (__r__x1, __r__x2)
    finally:
        pass


_lib_alglib.alglib_hqrndexponential.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndexponential.restype = ctypes.c_int32
def hqrndexponential(state, lambdav):
    pass
    __result = ctypes.c_double(0)
    __state = state.ptr
    __lambdav = ctypes.c_double(lambdav)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndexponential(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__state), ctypes.byref(__lambdav))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndexponential'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_hqrnddiscrete.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrnddiscrete.restype = ctypes.c_int32
def hqrnddiscrete(state, x, n):
    pass
    __result = ctypes.c_double(0)
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrnddiscrete(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrnddiscrete'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_hqrndcontinuous.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hqrndcontinuous.restype = ctypes.c_int32
def hqrndcontinuous(state, x, n):
    pass
    __result = ctypes.c_double(0)
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hqrndcontinuous(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hqrndcontinuous'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.x_obj_free_kdtree.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_kdtree.restype = None


class kdtree(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_kdtree(self.ptr)
_lib_alglib.alglib_kdtreeserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreeserialize.restype = ctypes.c_int32

def kdtreeserialize(obj):
    error_msg = ctypes.c_char_p(0)
    _s_out = ctypes.c_char_p(0)
    retval = _lib_alglib.alglib_kdtreeserialize(ctypes.byref(error_msg), ctypes.byref(obj.ptr), ctypes.byref(_s_out))
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'kdtreeserialize'")
    s_out = _s_out.value
    _lib_alglib.x_free(_s_out)
    return s_out

_lib_alglib.alglib_kdtreeunserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreeunserialize.restype = ctypes.c_int32

def kdtreeunserialize(s_in):
    error_msg = ctypes.c_char_p(0)
    _s_in = ctypes.c_char_p(s_in)
    _obj = ctypes.c_void_p(0)
    retval = _lib_alglib.alglib_kdtreeunserialize(ctypes.byref(error_msg), ctypes.byref(_s_in), ctypes.byref(_obj), )
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'kdtreeserialize'")
    return kdtree(_obj)

_lib_alglib.alglib_kdtreebuild.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreebuild.restype = ctypes.c_int32
def kdtreebuild(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        xy,n,nx,ny,normtype = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        xy,nx,ny,normtype = functionargs
        n = safe_rows("'kdtreebuild': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'kdtreebuild': function must have 4 or 5 parameters")
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nx = x_int()
    __nx.val = int(nx)
    if __nx.val!=nx:
        raise ValueError("Error while converting 'nx' parameter to 'x_int'")
    __ny = x_int()
    __ny.val = int(ny)
    if __ny.val!=ny:
        raise ValueError("Error while converting 'ny' parameter to 'x_int'")
    __normtype = x_int()
    __normtype.val = int(normtype)
    if __normtype.val!=normtype:
        raise ValueError("Error while converting 'normtype' parameter to 'x_int'")
    __kdt = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreebuild(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__nx), ctypes.byref(__ny), ctypes.byref(__normtype), ctypes.byref(__kdt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreebuild'")
        __r__kdt = kdtree(__kdt)
        return __r__kdt
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_kdtreebuildtagged.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreebuildtagged.restype = ctypes.c_int32
def kdtreebuildtagged(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        xy,tags,n,nx,ny,normtype = functionargs
    elif len(functionargs)==5:
        __friendly_form = True
        xy,tags,nx,ny,normtype = functionargs
        if safe_rows("'kdtreebuildtagged': incorrect parameters",xy)!=safe_len("'kdtreebuildtagged': incorrect parameters",tags):
            raise RuntimeError("Error while calling 'kdtreebuildtagged': looks like one of arguments has wrong size")
        n = safe_rows("'kdtreebuildtagged': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'kdtreebuildtagged': function must have 5 or 6 parameters")
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(tags):
        raise ValueError("'tags' parameter can't be cast to int_vector")
    __tags = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nx = x_int()
    __nx.val = int(nx)
    if __nx.val!=nx:
        raise ValueError("Error while converting 'nx' parameter to 'x_int'")
    __ny = x_int()
    __ny.val = int(ny)
    if __ny.val!=ny:
        raise ValueError("Error while converting 'ny' parameter to 'x_int'")
    __normtype = x_int()
    __normtype.val = int(normtype)
    if __normtype.val!=normtype:
        raise ValueError("Error while converting 'normtype' parameter to 'x_int'")
    __kdt = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__tags, tags, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreebuildtagged(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__tags), ctypes.byref(__n), ctypes.byref(__nx), ctypes.byref(__ny), ctypes.byref(__normtype), ctypes.byref(__kdt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreebuildtagged'")
        __r__kdt = kdtree(__kdt)
        return __r__kdt
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__tags)


_lib_alglib.alglib_kdtreequeryknn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryknn.restype = ctypes.c_int32
def kdtreequeryknn(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        kdt,x,k,selfmatch = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        kdt,x,k = functionargs
        selfmatch = True
    else:
        raise RuntimeError("Error while calling 'kdtreequeryknn': function must have 3 or 4 parameters")
    __result = x_int()
    __result.val = 0
    __kdt = kdt.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __selfmatch = ctypes.c_uint8(selfmatch)
    if __selfmatch.value!=0:
        __selfmatch = ctypes.c_uint8(1)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryknn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__kdt), ctypes.byref(__x), ctypes.byref(__k), ctypes.byref(__selfmatch))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryknn'")
        __r__result = __result.val
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_kdtreequeryrnn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryrnn.restype = ctypes.c_int32
def kdtreequeryrnn(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        kdt,x,r,selfmatch = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        kdt,x,r = functionargs
        selfmatch = True
    else:
        raise RuntimeError("Error while calling 'kdtreequeryrnn': function must have 3 or 4 parameters")
    __result = x_int()
    __result.val = 0
    __kdt = kdt.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __r = ctypes.c_double(r)
    __selfmatch = ctypes.c_uint8(selfmatch)
    if __selfmatch.value!=0:
        __selfmatch = ctypes.c_uint8(1)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryrnn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__kdt), ctypes.byref(__x), ctypes.byref(__r), ctypes.byref(__selfmatch))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryrnn'")
        __r__result = __result.val
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_kdtreequeryaknn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryaknn.restype = ctypes.c_int32
def kdtreequeryaknn(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        kdt,x,k,selfmatch,eps = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        kdt,x,k,eps = functionargs
        selfmatch = True
    else:
        raise RuntimeError("Error while calling 'kdtreequeryaknn': function must have 4 or 5 parameters")
    __result = x_int()
    __result.val = 0
    __kdt = kdt.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __selfmatch = ctypes.c_uint8(selfmatch)
    if __selfmatch.value!=0:
        __selfmatch = ctypes.c_uint8(1)
    __eps = ctypes.c_double(eps)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryaknn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__kdt), ctypes.byref(__x), ctypes.byref(__k), ctypes.byref(__selfmatch), ctypes.byref(__eps))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryaknn'")
        __r__result = __result.val
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_kdtreequeryresultsx.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultsx.restype = ctypes.c_int32
def kdtreequeryresultsx(kdt, x):
    pass
    __kdt = kdt.ptr
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultsx(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultsx'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__x)


_lib_alglib.alglib_kdtreequeryresultsxy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultsxy.restype = ctypes.c_int32
def kdtreequeryresultsxy(kdt, xy):
    pass
    __kdt = kdt.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultsxy(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__xy))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultsxy'")
        __r__xy = listlist_from_x(__xy)
        return __r__xy
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_kdtreequeryresultstags.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultstags.restype = ctypes.c_int32
def kdtreequeryresultstags(kdt, tags):
    pass
    __kdt = kdt.ptr
    if not is_int_vector(tags):
        raise ValueError("'tags' parameter can't be cast to int_vector")
    __tags = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__tags, tags, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultstags(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__tags))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultstags'")
        __r__tags = list_from_x(__tags)
        return __r__tags
    finally:
        x_vector_clear(__tags)


_lib_alglib.alglib_kdtreequeryresultsdistances.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultsdistances.restype = ctypes.c_int32
def kdtreequeryresultsdistances(kdt, r):
    pass
    __kdt = kdt.ptr
    if not is_real_vector(r):
        raise ValueError("'r' parameter can't be cast to real_vector")
    __r = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__r, r, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultsdistances(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultsdistances'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__r)


_lib_alglib.alglib_kdtreequeryresultsxi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultsxi.restype = ctypes.c_int32
def kdtreequeryresultsxi(kdt):
    pass
    __kdt = kdt.ptr
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultsxi(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultsxi'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__x)


_lib_alglib.alglib_kdtreequeryresultsxyi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultsxyi.restype = ctypes.c_int32
def kdtreequeryresultsxyi(kdt):
    pass
    __kdt = kdt.ptr
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultsxyi(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__xy))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultsxyi'")
        __r__xy = listlist_from_x(__xy)
        return __r__xy
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_kdtreequeryresultstagsi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultstagsi.restype = ctypes.c_int32
def kdtreequeryresultstagsi(kdt):
    pass
    __kdt = kdt.ptr
    __tags = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultstagsi(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__tags))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultstagsi'")
        __r__tags = list_from_x(__tags)
        return __r__tags
    finally:
        x_vector_clear(__tags)


_lib_alglib.alglib_kdtreequeryresultsdistancesi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kdtreequeryresultsdistancesi.restype = ctypes.c_int32
def kdtreequeryresultsdistancesi(kdt):
    pass
    __kdt = kdt.ptr
    __r = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kdtreequeryresultsdistancesi(ctypes.byref(_error_msg), ctypes.byref(__kdt), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kdtreequeryresultsdistancesi'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__r)




class x_xdebugrecord1(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("i", x_int),
        ("c", x_complex),
        ("a", x_vector)
        ]




class xdebugrecord1(object):
    def __init__(self):
        self.i = 0
        self.c = 0
        self.a = []


def x_xdebugrecord1_zero_fields(x):
    x.i.val = 0
    x.c.x = 0
    x.c.y = 0
    x.a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    return




def x_xdebugrecord1_clear(x):
    x_vector_clear(x.a)
    x_xdebugrecord1_zero_fields(x)
    return




def x_from_xdebugrecord1(x,v):
    x.i.val = int(v.i)
    tmp = complex(v.c)
    x.c.x = tmp.real
    x.c.y = tmp.imag
    x_from_list(x.a, v.a, DT_REAL, X_CREATE)
    return




def xdebugrecord1_from_x(x):
    r = xdebugrecord1()
    r.i = x.i.val
    r.c = complex(x.c.x,x.c.y)
    r.a = list_from_x(x.a)
    return r


_lib_alglib.alglib_xdebuginitrecord1.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebuginitrecord1.restype = ctypes.c_int32
def xdebuginitrecord1():
    pass
    __rec1 = x_xdebugrecord1()
    x_xdebugrecord1_zero_fields(__rec1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebuginitrecord1(ctypes.byref(_error_msg), ctypes.byref(__rec1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebuginitrecord1'")
        __r__rec1 = xdebugrecord1_from_x(__rec1)
        return __r__rec1
    finally:
        x_xdebugrecord1_clear(__rec1)


_lib_alglib.alglib_xdebugb1count.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb1count.restype = ctypes.c_int32
def xdebugb1count(a):
    pass
    __result = x_int()
    __result.val = 0
    if not is_bool_vector(a):
        raise ValueError("'a' parameter can't be cast to bool_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb1count(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb1count'")
        __r__result = __result.val
        return __r__result
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugb1not.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb1not.restype = ctypes.c_int32
def xdebugb1not(a):
    pass
    if not is_bool_vector(a):
        raise ValueError("'a' parameter can't be cast to bool_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb1not(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb1not'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugb1appendcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb1appendcopy.restype = ctypes.c_int32
def xdebugb1appendcopy(a):
    pass
    if not is_bool_vector(a):
        raise ValueError("'a' parameter can't be cast to bool_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb1appendcopy(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb1appendcopy'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugb1outeven.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb1outeven.restype = ctypes.c_int32
def xdebugb1outeven(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_vector(cnt=0,datatype=DT_BOOL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb1outeven(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb1outeven'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugi1sum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi1sum.restype = ctypes.c_int32
def xdebugi1sum(a):
    pass
    __result = x_int()
    __result.val = 0
    if not is_int_vector(a):
        raise ValueError("'a' parameter can't be cast to int_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi1sum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi1sum'")
        __r__result = __result.val
        return __r__result
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugi1neg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi1neg.restype = ctypes.c_int32
def xdebugi1neg(a):
    pass
    if not is_int_vector(a):
        raise ValueError("'a' parameter can't be cast to int_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi1neg(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi1neg'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugi1appendcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi1appendcopy.restype = ctypes.c_int32
def xdebugi1appendcopy(a):
    pass
    if not is_int_vector(a):
        raise ValueError("'a' parameter can't be cast to int_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi1appendcopy(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi1appendcopy'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugi1outeven.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi1outeven.restype = ctypes.c_int32
def xdebugi1outeven(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi1outeven(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi1outeven'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugr1sum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr1sum.restype = ctypes.c_int32
def xdebugr1sum(a):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr1sum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr1sum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugr1neg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr1neg.restype = ctypes.c_int32
def xdebugr1neg(a):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr1neg(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr1neg'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugr1appendcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr1appendcopy.restype = ctypes.c_int32
def xdebugr1appendcopy(a):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr1appendcopy(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr1appendcopy'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugr1outeven.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr1outeven.restype = ctypes.c_int32
def xdebugr1outeven(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr1outeven(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr1outeven'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugc1sum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc1sum.restype = ctypes.c_int32
def xdebugc1sum(a):
    pass
    __result = x_complex(x=0,y=0)
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc1sum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc1sum'")
        __r__result = complex(__result.x,__result.y)
        return __r__result
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugc1neg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc1neg.restype = ctypes.c_int32
def xdebugc1neg(a):
    pass
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc1neg(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc1neg'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugc1appendcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc1appendcopy.restype = ctypes.c_int32
def xdebugc1appendcopy(a):
    pass
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc1appendcopy(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc1appendcopy'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugc1outeven.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc1outeven.restype = ctypes.c_int32
def xdebugc1outeven(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc1outeven(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc1outeven'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_xdebugb2count.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb2count.restype = ctypes.c_int32
def xdebugb2count(a):
    pass
    __result = x_int()
    __result.val = 0
    if not is_bool_matrix(a):
        raise ValueError("'a' parameter can't be cast to bool_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb2count(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb2count'")
        __r__result = __result.val
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugb2not.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb2not.restype = ctypes.c_int32
def xdebugb2not(a):
    pass
    if not is_bool_matrix(a):
        raise ValueError("'a' parameter can't be cast to bool_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb2not(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb2not'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugb2transpose.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb2transpose.restype = ctypes.c_int32
def xdebugb2transpose(a):
    pass
    if not is_bool_matrix(a):
        raise ValueError("'a' parameter can't be cast to bool_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb2transpose(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb2transpose'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugb2outsin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugb2outsin.restype = ctypes.c_int32
def xdebugb2outsin(m, n):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_BOOL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugb2outsin(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugb2outsin'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugi2sum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi2sum.restype = ctypes.c_int32
def xdebugi2sum(a):
    pass
    __result = x_int()
    __result.val = 0
    if not is_int_matrix(a):
        raise ValueError("'a' parameter can't be cast to int_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi2sum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi2sum'")
        __r__result = __result.val
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugi2neg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi2neg.restype = ctypes.c_int32
def xdebugi2neg(a):
    pass
    if not is_int_matrix(a):
        raise ValueError("'a' parameter can't be cast to int_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi2neg(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi2neg'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugi2transpose.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi2transpose.restype = ctypes.c_int32
def xdebugi2transpose(a):
    pass
    if not is_int_matrix(a):
        raise ValueError("'a' parameter can't be cast to int_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi2transpose(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi2transpose'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugi2outsin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugi2outsin.restype = ctypes.c_int32
def xdebugi2outsin(m, n):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugi2outsin(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugi2outsin'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugr2sum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr2sum.restype = ctypes.c_int32
def xdebugr2sum(a):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr2sum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr2sum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugr2neg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr2neg.restype = ctypes.c_int32
def xdebugr2neg(a):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr2neg(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr2neg'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugr2transpose.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr2transpose.restype = ctypes.c_int32
def xdebugr2transpose(a):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr2transpose(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr2transpose'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugr2outsin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugr2outsin.restype = ctypes.c_int32
def xdebugr2outsin(m, n):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugr2outsin(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugr2outsin'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugc2sum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc2sum.restype = ctypes.c_int32
def xdebugc2sum(a):
    pass
    __result = x_complex(x=0,y=0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc2sum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc2sum'")
        __r__result = complex(__result.x,__result.y)
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugc2neg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc2neg.restype = ctypes.c_int32
def xdebugc2neg(a):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc2neg(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc2neg'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugc2transpose.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc2transpose.restype = ctypes.c_int32
def xdebugc2transpose(a):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc2transpose(ctypes.byref(_error_msg), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc2transpose'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugc2outsincos.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugc2outsincos.restype = ctypes.c_int32
def xdebugc2outsincos(m, n):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugc2outsincos(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugc2outsincos'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_xdebugmaskedbiasedproductsum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_xdebugmaskedbiasedproductsum.restype = ctypes.c_int32
def xdebugmaskedbiasedproductsum(m, n, a, b, c):
    pass
    __result = ctypes.c_double(0)
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_bool_matrix(c):
        raise ValueError("'c' parameter can't be cast to bool_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        x_from_listlist(__c, c, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_xdebugmaskedbiasedproductsum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'xdebugmaskedbiasedproductsum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_matrix_clear(__c)


_lib_alglib.alglib_cmatrixtranspose.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixtranspose.restype = ctypes.c_int32
def cmatrixtranspose(m, n, a, ia, ja, b, ib, jb):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixtranspose(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixtranspose'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_rmatrixtranspose.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixtranspose.restype = ctypes.c_int32
def rmatrixtranspose(m, n, a, ia, ja, b, ib, jb):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixtranspose(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixtranspose'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_rmatrixenforcesymmetricity.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixenforcesymmetricity.restype = ctypes.c_int32
def rmatrixenforcesymmetricity(a, n, isupper):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixenforcesymmetricity(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixenforcesymmetricity'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixcopy.restype = ctypes.c_int32
def cmatrixcopy(m, n, a, ia, ja, b, ib, jb):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixcopy(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixcopy'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_rmatrixcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixcopy.restype = ctypes.c_int32
def rmatrixcopy(m, n, a, ia, ja, b, ib, jb):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixcopy(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixcopy'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_cmatrixrank1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrank1.restype = ctypes.c_int32
def cmatrixrank1(m, n, a, ia, ja, u, iu, v, iv):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    if not is_complex_vector(u):
        raise ValueError("'u' parameter can't be cast to complex_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __iu = x_int()
    __iu.val = int(iu)
    if __iu.val!=iu:
        raise ValueError("Error while converting 'iu' parameter to 'x_int'")
    if not is_complex_vector(v):
        raise ValueError("'v' parameter can't be cast to complex_vector")
    __v = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __iv = x_int()
    __iv.val = int(iv)
    if __iv.val!=iv:
        raise ValueError("Error while converting 'iv' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__u, u, DT_COMPLEX, X_CREATE)
        x_from_list(__v, v, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrank1(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__u), ctypes.byref(__iu), ctypes.byref(__v), ctypes.byref(__iv))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrank1'")
        __r__a = listlist_from_x(__a)
        __r__u = list_from_x(__u)
        __r__v = list_from_x(__v)
        return (__r__a, __r__u, __r__v)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__u)
        x_vector_clear(__v)


_lib_alglib.alglib_rmatrixrank1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrank1.restype = ctypes.c_int32
def rmatrixrank1(m, n, a, ia, ja, u, iu, v, iv):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    if not is_real_vector(u):
        raise ValueError("'u' parameter can't be cast to real_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __iu = x_int()
    __iu.val = int(iu)
    if __iu.val!=iu:
        raise ValueError("Error while converting 'iu' parameter to 'x_int'")
    if not is_real_vector(v):
        raise ValueError("'v' parameter can't be cast to real_vector")
    __v = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __iv = x_int()
    __iv.val = int(iv)
    if __iv.val!=iv:
        raise ValueError("Error while converting 'iv' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__u, u, DT_REAL, X_CREATE)
        x_from_list(__v, v, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrank1(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__u), ctypes.byref(__iu), ctypes.byref(__v), ctypes.byref(__iv))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrank1'")
        __r__a = listlist_from_x(__a)
        __r__u = list_from_x(__u)
        __r__v = list_from_x(__v)
        return (__r__a, __r__u, __r__v)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__u)
        x_vector_clear(__v)


_lib_alglib.alglib_cmatrixmv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixmv.restype = ctypes.c_int32
def cmatrixmv(m, n, a, ia, ja, opa, x, ix, y, iy):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __opa = x_int()
    __opa.val = int(opa)
    if __opa.val!=opa:
        raise ValueError("Error while converting 'opa' parameter to 'x_int'")
    if not is_complex_vector(x):
        raise ValueError("'x' parameter can't be cast to complex_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ix = x_int()
    __ix.val = int(ix)
    if __ix.val!=ix:
        raise ValueError("Error while converting 'ix' parameter to 'x_int'")
    if not is_complex_vector(y):
        raise ValueError("'y' parameter can't be cast to complex_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __iy = x_int()
    __iy.val = int(iy)
    if __iy.val!=iy:
        raise ValueError("Error while converting 'iy' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__x, x, DT_COMPLEX, X_CREATE)
        x_from_list(__y, y, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixmv(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__opa), ctypes.byref(__x), ctypes.byref(__ix), ctypes.byref(__y), ctypes.byref(__iy))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixmv'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_rmatrixmv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixmv.restype = ctypes.c_int32
def rmatrixmv(m, n, a, ia, ja, opa, x, ix, y, iy):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __opa = x_int()
    __opa.val = int(opa)
    if __opa.val!=opa:
        raise ValueError("Error while converting 'opa' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ix = x_int()
    __ix.val = int(ix)
    if __ix.val!=ix:
        raise ValueError("Error while converting 'ix' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __iy = x_int()
    __iy.val = int(iy)
    if __iy.val!=iy:
        raise ValueError("Error while converting 'iy' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixmv(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__opa), ctypes.byref(__x), ctypes.byref(__ix), ctypes.byref(__y), ctypes.byref(__iy))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixmv'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_cmatrixrighttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrighttrsm.restype = ctypes.c_int32
def cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_complex_matrix(x):
        raise ValueError("'x' parameter can't be cast to complex_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__x, x, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrighttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrighttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_cmatrixrighttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixrighttrsm.restype = ctypes.c_int32
def smp_cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_complex_matrix(x):
        raise ValueError("'x' parameter can't be cast to complex_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__x, x, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixrighttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixrighttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_cmatrixlefttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlefttrsm.restype = ctypes.c_int32
def cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_complex_matrix(x):
        raise ValueError("'x' parameter can't be cast to complex_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__x, x, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlefttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlefttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_cmatrixlefttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixlefttrsm.restype = ctypes.c_int32
def smp_cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_complex_matrix(x):
        raise ValueError("'x' parameter can't be cast to complex_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__x, x, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixlefttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixlefttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_rmatrixrighttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrighttrsm.restype = ctypes.c_int32
def rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrighttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrighttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_rmatrixrighttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixrighttrsm.restype = ctypes.c_int32
def smp_rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixrighttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixrighttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_rmatrixlefttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlefttrsm.restype = ctypes.c_int32
def rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlefttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlefttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_rmatrixlefttrsm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixlefttrsm.restype = ctypes.c_int32
def smp_rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __j1 = x_int()
    __j1.val = int(j1)
    if __j1.val!=j1:
        raise ValueError("Error while converting 'j1' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __j2 = x_int()
    __j2.val = int(j2)
    if __j2.val!=j2:
        raise ValueError("Error while converting 'j2' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixlefttrsm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__i1), ctypes.byref(__j1), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__i2), ctypes.byref(__j2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixlefttrsm'")
        __r__x = listlist_from_x(__x)
        return __r__x
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__x)


_lib_alglib.alglib_cmatrixherk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixherk.restype = ctypes.c_int32
def cmatrixherk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_complex_matrix(c):
        raise ValueError("'c' parameter can't be cast to complex_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__c, c, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixherk(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixherk'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_cmatrixherk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixherk.restype = ctypes.c_int32
def smp_cmatrixherk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_complex_matrix(c):
        raise ValueError("'c' parameter can't be cast to complex_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__c, c, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixherk(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixherk'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__c)


_lib_alglib.alglib_rmatrixsyrk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsyrk.restype = ctypes.c_int32
def rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsyrk(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsyrk'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_rmatrixsyrk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsyrk.restype = ctypes.c_int32
def smp_rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsyrk(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsyrk'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__c)


_lib_alglib.alglib_cmatrixgemm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixgemm.restype = ctypes.c_int32
def cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __tmp__val = complex(alpha)
    __alpha = x_complex(x=__tmp__val.real, y=__tmp__val.imag)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    __optypeb = x_int()
    __optypeb.val = int(optypeb)
    if __optypeb.val!=optypeb:
        raise ValueError("Error while converting 'optypeb' parameter to 'x_int'")
    __tmp__val = complex(beta)
    __beta = x_complex(x=__tmp__val.real, y=__tmp__val.imag)
    if not is_complex_matrix(c):
        raise ValueError("'c' parameter can't be cast to complex_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        x_from_listlist(__c, c, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixgemm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb), ctypes.byref(__optypeb), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixgemm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_cmatrixgemm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixgemm.restype = ctypes.c_int32
def smp_cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __tmp__val = complex(alpha)
    __alpha = x_complex(x=__tmp__val.real, y=__tmp__val.imag)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    __optypeb = x_int()
    __optypeb.val = int(optypeb)
    if __optypeb.val!=optypeb:
        raise ValueError("Error while converting 'optypeb' parameter to 'x_int'")
    __tmp__val = complex(beta)
    __beta = x_complex(x=__tmp__val.real, y=__tmp__val.imag)
    if not is_complex_matrix(c):
        raise ValueError("'c' parameter can't be cast to complex_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        x_from_listlist(__c, c, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixgemm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb), ctypes.byref(__optypeb), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixgemm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_matrix_clear(__c)


_lib_alglib.alglib_rmatrixgemm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixgemm.restype = ctypes.c_int32
def rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    __optypeb = x_int()
    __optypeb.val = int(optypeb)
    if __optypeb.val!=optypeb:
        raise ValueError("Error while converting 'optypeb' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixgemm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb), ctypes.byref(__optypeb), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixgemm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_rmatrixgemm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixgemm.restype = ctypes.c_int32
def smp_rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ib = x_int()
    __ib.val = int(ib)
    if __ib.val!=ib:
        raise ValueError("Error while converting 'ib' parameter to 'x_int'")
    __jb = x_int()
    __jb.val = int(jb)
    if __jb.val!=jb:
        raise ValueError("Error while converting 'jb' parameter to 'x_int'")
    __optypeb = x_int()
    __optypeb.val = int(optypeb)
    if __optypeb.val!=optypeb:
        raise ValueError("Error while converting 'optypeb' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixgemm(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__b), ctypes.byref(__ib), ctypes.byref(__jb), ctypes.byref(__optypeb), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixgemm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_matrix_clear(__c)


_lib_alglib.alglib_cmatrixsyrk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixsyrk.restype = ctypes.c_int32
def cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_complex_matrix(c):
        raise ValueError("'c' parameter can't be cast to complex_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__c, c, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixsyrk(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixsyrk'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_cmatrixsyrk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixsyrk.restype = ctypes.c_int32
def smp_cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ia = x_int()
    __ia.val = int(ia)
    if __ia.val!=ia:
        raise ValueError("Error while converting 'ia' parameter to 'x_int'")
    __ja = x_int()
    __ja.val = int(ja)
    if __ja.val!=ja:
        raise ValueError("Error while converting 'ja' parameter to 'x_int'")
    __optypea = x_int()
    __optypea.val = int(optypea)
    if __optypea.val!=optypea:
        raise ValueError("Error while converting 'optypea' parameter to 'x_int'")
    __beta = ctypes.c_double(beta)
    if not is_complex_matrix(c):
        raise ValueError("'c' parameter can't be cast to complex_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ic = x_int()
    __ic.val = int(ic)
    if __ic.val!=ic:
        raise ValueError("Error while converting 'ic' parameter to 'x_int'")
    __jc = x_int()
    __jc.val = int(jc)
    if __jc.val!=jc:
        raise ValueError("Error while converting 'jc' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__c, c, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixsyrk(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__alpha), ctypes.byref(__a), ctypes.byref(__ia), ctypes.byref(__ja), ctypes.byref(__optypea), ctypes.byref(__beta), ctypes.byref(__c), ctypes.byref(__ic), ctypes.byref(__jc), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixsyrk'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__c)


_lib_alglib.alglib_samplemoments.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_samplemoments.restype = ctypes.c_int32
def samplemoments(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'samplemoments': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'samplemoments': function must have 1 or 2 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __mean = ctypes.c_double(0)
    __variance = ctypes.c_double(0)
    __skewness = ctypes.c_double(0)
    __kurtosis = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_samplemoments(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__mean), ctypes.byref(__variance), ctypes.byref(__skewness), ctypes.byref(__kurtosis))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'samplemoments'")
        __r__mean = __mean.value
        __r__variance = __variance.value
        __r__skewness = __skewness.value
        __r__kurtosis = __kurtosis.value
        return (__r__mean, __r__variance, __r__skewness, __r__kurtosis)
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_samplemean.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_samplemean.restype = ctypes.c_int32
def samplemean(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'samplemean': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'samplemean': function must have 1 or 2 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_samplemean(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'samplemean'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_samplevariance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_samplevariance.restype = ctypes.c_int32
def samplevariance(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'samplevariance': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'samplevariance': function must have 1 or 2 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_samplevariance(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'samplevariance'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_sampleskewness.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sampleskewness.restype = ctypes.c_int32
def sampleskewness(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'sampleskewness': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'sampleskewness': function must have 1 or 2 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sampleskewness(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sampleskewness'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_samplekurtosis.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_samplekurtosis.restype = ctypes.c_int32
def samplekurtosis(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'samplekurtosis': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'samplekurtosis': function must have 1 or 2 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_samplekurtosis(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'samplekurtosis'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_sampleadev.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sampleadev.restype = ctypes.c_int32
def sampleadev(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'sampleadev': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'sampleadev': function must have 1 or 2 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __adev = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sampleadev(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__adev))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sampleadev'")
        __r__adev = __adev.value
        return __r__adev
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_samplemedian.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_samplemedian.restype = ctypes.c_int32
def samplemedian(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        x,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'samplemedian': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'samplemedian': function must have 1 or 2 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __median = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_samplemedian(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__median))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'samplemedian'")
        __r__median = __median.value
        return __r__median
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_samplepercentile.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_samplepercentile.restype = ctypes.c_int32
def samplepercentile(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,p = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,p = functionargs
        n = safe_len("'samplepercentile': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'samplepercentile': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_double(p)
    __v = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_samplepercentile(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__p), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'samplepercentile'")
        __r__v = __v.value
        return __r__v
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_cov2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cov2.restype = ctypes.c_int32
def cov2(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'cov2': incorrect parameters",x)!=safe_len("'cov2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'cov2': looks like one of arguments has wrong size")
        n = safe_len("'cov2': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'cov2': function must have 2 or 3 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cov2(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cov2'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_pearsoncorr2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pearsoncorr2.restype = ctypes.c_int32
def pearsoncorr2(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'pearsoncorr2': incorrect parameters",x)!=safe_len("'pearsoncorr2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'pearsoncorr2': looks like one of arguments has wrong size")
        n = safe_len("'pearsoncorr2': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'pearsoncorr2': function must have 2 or 3 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pearsoncorr2(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pearsoncorr2'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_spearmancorr2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spearmancorr2.restype = ctypes.c_int32
def spearmancorr2(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spearmancorr2': incorrect parameters",x)!=safe_len("'spearmancorr2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spearmancorr2': looks like one of arguments has wrong size")
        n = safe_len("'spearmancorr2': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spearmancorr2': function must have 2 or 3 parameters")
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spearmancorr2(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spearmancorr2'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_covm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_covm.restype = ctypes.c_int32
def covm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,m = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_rows("'covm': incorrect parameters",x)
        m = safe_cols("'covm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'covm': function must have 1 or 3 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_covm(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'covm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_covm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_covm.restype = ctypes.c_int32
def smp_covm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,m = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_rows("'smp_covm': incorrect parameters",x)
        m = safe_cols("'smp_covm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_covm': function must have 1 or 3 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_covm(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_covm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__c)


_lib_alglib.alglib_pearsoncorrm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pearsoncorrm.restype = ctypes.c_int32
def pearsoncorrm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,m = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_rows("'pearsoncorrm': incorrect parameters",x)
        m = safe_cols("'pearsoncorrm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'pearsoncorrm': function must have 1 or 3 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pearsoncorrm(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pearsoncorrm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_pearsoncorrm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_pearsoncorrm.restype = ctypes.c_int32
def smp_pearsoncorrm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,m = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_rows("'smp_pearsoncorrm': incorrect parameters",x)
        m = safe_cols("'smp_pearsoncorrm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_pearsoncorrm': function must have 1 or 3 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_pearsoncorrm(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_pearsoncorrm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__c)


_lib_alglib.alglib_spearmancorrm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spearmancorrm.restype = ctypes.c_int32
def spearmancorrm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,m = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_rows("'spearmancorrm': incorrect parameters",x)
        m = safe_cols("'spearmancorrm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spearmancorrm': function must have 1 or 3 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spearmancorrm(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spearmancorrm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_spearmancorrm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spearmancorrm.restype = ctypes.c_int32
def smp_spearmancorrm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,m = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_rows("'smp_spearmancorrm': incorrect parameters",x)
        m = safe_cols("'smp_spearmancorrm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_spearmancorrm': function must have 1 or 3 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spearmancorrm(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spearmancorrm'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__c)


_lib_alglib.alglib_covm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_covm2.restype = ctypes.c_int32
def covm2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m1,m2 = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_rows("'covm2': incorrect parameters",x)!=safe_rows("'covm2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'covm2': looks like one of arguments has wrong size")
        n = safe_rows("'covm2': incorrect parameters",x)
        m1 = safe_cols("'covm2': incorrect parameters",x)
        m2 = safe_cols("'covm2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'covm2': function must have 2 or 5 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(y):
        raise ValueError("'y' parameter can't be cast to real_matrix")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m1 = x_int()
    __m1.val = int(m1)
    if __m1.val!=m1:
        raise ValueError("Error while converting 'm1' parameter to 'x_int'")
    __m2 = x_int()
    __m2.val = int(m2)
    if __m2.val!=m2:
        raise ValueError("Error while converting 'm2' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_listlist(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_covm2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m1), ctypes.byref(__m2), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'covm2'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__y)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_covm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_covm2.restype = ctypes.c_int32
def smp_covm2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m1,m2 = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_rows("'smp_covm2': incorrect parameters",x)!=safe_rows("'smp_covm2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_covm2': looks like one of arguments has wrong size")
        n = safe_rows("'smp_covm2': incorrect parameters",x)
        m1 = safe_cols("'smp_covm2': incorrect parameters",x)
        m2 = safe_cols("'smp_covm2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'smp_covm2': function must have 2 or 5 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(y):
        raise ValueError("'y' parameter can't be cast to real_matrix")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m1 = x_int()
    __m1.val = int(m1)
    if __m1.val!=m1:
        raise ValueError("Error while converting 'm1' parameter to 'x_int'")
    __m2 = x_int()
    __m2.val = int(m2)
    if __m2.val!=m2:
        raise ValueError("Error while converting 'm2' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_listlist(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_covm2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m1), ctypes.byref(__m2), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_covm2'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__y)
        x_matrix_clear(__c)


_lib_alglib.alglib_pearsoncorrm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pearsoncorrm2.restype = ctypes.c_int32
def pearsoncorrm2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m1,m2 = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_rows("'pearsoncorrm2': incorrect parameters",x)!=safe_rows("'pearsoncorrm2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'pearsoncorrm2': looks like one of arguments has wrong size")
        n = safe_rows("'pearsoncorrm2': incorrect parameters",x)
        m1 = safe_cols("'pearsoncorrm2': incorrect parameters",x)
        m2 = safe_cols("'pearsoncorrm2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'pearsoncorrm2': function must have 2 or 5 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(y):
        raise ValueError("'y' parameter can't be cast to real_matrix")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m1 = x_int()
    __m1.val = int(m1)
    if __m1.val!=m1:
        raise ValueError("Error while converting 'm1' parameter to 'x_int'")
    __m2 = x_int()
    __m2.val = int(m2)
    if __m2.val!=m2:
        raise ValueError("Error while converting 'm2' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_listlist(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pearsoncorrm2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m1), ctypes.byref(__m2), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pearsoncorrm2'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__y)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_pearsoncorrm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_pearsoncorrm2.restype = ctypes.c_int32
def smp_pearsoncorrm2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m1,m2 = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_rows("'smp_pearsoncorrm2': incorrect parameters",x)!=safe_rows("'smp_pearsoncorrm2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_pearsoncorrm2': looks like one of arguments has wrong size")
        n = safe_rows("'smp_pearsoncorrm2': incorrect parameters",x)
        m1 = safe_cols("'smp_pearsoncorrm2': incorrect parameters",x)
        m2 = safe_cols("'smp_pearsoncorrm2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'smp_pearsoncorrm2': function must have 2 or 5 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(y):
        raise ValueError("'y' parameter can't be cast to real_matrix")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m1 = x_int()
    __m1.val = int(m1)
    if __m1.val!=m1:
        raise ValueError("Error while converting 'm1' parameter to 'x_int'")
    __m2 = x_int()
    __m2.val = int(m2)
    if __m2.val!=m2:
        raise ValueError("Error while converting 'm2' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_listlist(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_pearsoncorrm2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m1), ctypes.byref(__m2), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_pearsoncorrm2'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__y)
        x_matrix_clear(__c)


_lib_alglib.alglib_spearmancorrm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spearmancorrm2.restype = ctypes.c_int32
def spearmancorrm2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m1,m2 = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_rows("'spearmancorrm2': incorrect parameters",x)!=safe_rows("'spearmancorrm2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spearmancorrm2': looks like one of arguments has wrong size")
        n = safe_rows("'spearmancorrm2': incorrect parameters",x)
        m1 = safe_cols("'spearmancorrm2': incorrect parameters",x)
        m2 = safe_cols("'spearmancorrm2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'spearmancorrm2': function must have 2 or 5 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(y):
        raise ValueError("'y' parameter can't be cast to real_matrix")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m1 = x_int()
    __m1.val = int(m1)
    if __m1.val!=m1:
        raise ValueError("Error while converting 'm1' parameter to 'x_int'")
    __m2 = x_int()
    __m2.val = int(m2)
    if __m2.val!=m2:
        raise ValueError("Error while converting 'm2' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_listlist(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spearmancorrm2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m1), ctypes.byref(__m2), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spearmancorrm2'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__y)
        x_matrix_clear(__c)


_lib_alglib.alglib_smp_spearmancorrm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spearmancorrm2.restype = ctypes.c_int32
def smp_spearmancorrm2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m1,m2 = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_rows("'smp_spearmancorrm2': incorrect parameters",x)!=safe_rows("'smp_spearmancorrm2': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_spearmancorrm2': looks like one of arguments has wrong size")
        n = safe_rows("'smp_spearmancorrm2': incorrect parameters",x)
        m1 = safe_cols("'smp_spearmancorrm2': incorrect parameters",x)
        m2 = safe_cols("'smp_spearmancorrm2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'smp_spearmancorrm2': function must have 2 or 5 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(y):
        raise ValueError("'y' parameter can't be cast to real_matrix")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m1 = x_int()
    __m1.val = int(m1)
    if __m1.val!=m1:
        raise ValueError("Error while converting 'm1' parameter to 'x_int'")
    __m2 = x_int()
    __m2.val = int(m2)
    if __m2.val!=m2:
        raise ValueError("Error while converting 'm2' parameter to 'x_int'")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_listlist(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spearmancorrm2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m1), ctypes.byref(__m2), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spearmancorrm2'")
        __r__c = listlist_from_x(__c)
        return __r__c
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__y)
        x_matrix_clear(__c)


_lib_alglib.alglib_rankdata.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rankdata.restype = ctypes.c_int32
def rankdata(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        xy,npoints,nfeatures = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        xy, = functionargs
        npoints = safe_rows("'rankdata': incorrect parameters",xy)
        nfeatures = safe_cols("'rankdata': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'rankdata': function must have 1 or 3 parameters")
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rankdata(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rankdata'")
        __r__xy = listlist_from_x(__xy)
        return __r__xy
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_rankdata.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rankdata.restype = ctypes.c_int32
def smp_rankdata(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        xy,npoints,nfeatures = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        xy, = functionargs
        npoints = safe_rows("'smp_rankdata': incorrect parameters",xy)
        nfeatures = safe_cols("'smp_rankdata': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'smp_rankdata': function must have 1 or 3 parameters")
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rankdata(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rankdata'")
        __r__xy = listlist_from_x(__xy)
        return __r__xy
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_rankdatacentered.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rankdatacentered.restype = ctypes.c_int32
def rankdatacentered(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        xy,npoints,nfeatures = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        xy, = functionargs
        npoints = safe_rows("'rankdatacentered': incorrect parameters",xy)
        nfeatures = safe_cols("'rankdatacentered': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'rankdatacentered': function must have 1 or 3 parameters")
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rankdatacentered(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rankdatacentered'")
        __r__xy = listlist_from_x(__xy)
        return __r__xy
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_rankdatacentered.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rankdatacentered.restype = ctypes.c_int32
def smp_rankdatacentered(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        xy,npoints,nfeatures = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        xy, = functionargs
        npoints = safe_rows("'smp_rankdatacentered': incorrect parameters",xy)
        nfeatures = safe_cols("'smp_rankdatacentered': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'smp_rankdatacentered': function must have 1 or 3 parameters")
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rankdatacentered(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rankdatacentered'")
        __r__xy = listlist_from_x(__xy)
        return __r__xy
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_pearsoncorrelation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pearsoncorrelation.restype = ctypes.c_int32
def pearsoncorrelation(x, y, n):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pearsoncorrelation(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pearsoncorrelation'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_spearmanrankcorrelation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spearmanrankcorrelation.restype = ctypes.c_int32
def spearmanrankcorrelation(x, y, n):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spearmanrankcorrelation(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spearmanrankcorrelation'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_dsoptimalsplit2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dsoptimalsplit2.restype = ctypes.c_int32
def dsoptimalsplit2(a, c, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(c):
        raise ValueError("'c' parameter can't be cast to int_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __threshold = ctypes.c_double(0)
    __pal = ctypes.c_double(0)
    __pbl = ctypes.c_double(0)
    __par = ctypes.c_double(0)
    __pbr = ctypes.c_double(0)
    __cve = ctypes.c_double(0)
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dsoptimalsplit2(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__threshold), ctypes.byref(__pal), ctypes.byref(__pbl), ctypes.byref(__par), ctypes.byref(__pbr), ctypes.byref(__cve))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dsoptimalsplit2'")
        __r__info = __info.val
        __r__threshold = __threshold.value
        __r__pal = __pal.value
        __r__pbl = __pbl.value
        __r__par = __par.value
        __r__pbr = __pbr.value
        __r__cve = __cve.value
        return (__r__info, __r__threshold, __r__pal, __r__pbl, __r__par, __r__pbr, __r__cve)
    finally:
        x_vector_clear(__a)
        x_vector_clear(__c)


_lib_alglib.alglib_dsoptimalsplit2fast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dsoptimalsplit2fast.restype = ctypes.c_int32
def dsoptimalsplit2fast(a, c, tiesbuf, cntbuf, bufr, bufi, n, nc, alpha):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(c):
        raise ValueError("'c' parameter can't be cast to int_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(tiesbuf):
        raise ValueError("'tiesbuf' parameter can't be cast to int_vector")
    __tiesbuf = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(cntbuf):
        raise ValueError("'cntbuf' parameter can't be cast to int_vector")
    __cntbuf = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bufr):
        raise ValueError("'bufr' parameter can't be cast to real_vector")
    __bufr = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(bufi):
        raise ValueError("'bufi' parameter can't be cast to int_vector")
    __bufi = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nc = x_int()
    __nc.val = int(nc)
    if __nc.val!=nc:
        raise ValueError("Error while converting 'nc' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    __info = x_int()
    __info.val = 0
    __threshold = ctypes.c_double(0)
    __rms = ctypes.c_double(0)
    __cvrms = ctypes.c_double(0)
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_INT, X_CREATE)
        x_from_list(__tiesbuf, tiesbuf, DT_INT, X_CREATE)
        x_from_list(__cntbuf, cntbuf, DT_INT, X_CREATE)
        x_from_list(__bufr, bufr, DT_REAL, X_CREATE)
        x_from_list(__bufi, bufi, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dsoptimalsplit2fast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__c), ctypes.byref(__tiesbuf), ctypes.byref(__cntbuf), ctypes.byref(__bufr), ctypes.byref(__bufi), ctypes.byref(__n), ctypes.byref(__nc), ctypes.byref(__alpha), ctypes.byref(__info), ctypes.byref(__threshold), ctypes.byref(__rms), ctypes.byref(__cvrms))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dsoptimalsplit2fast'")
        __r__a = list_from_x(__a)
        __r__c = list_from_x(__c)
        __r__tiesbuf = list_from_x(__tiesbuf)
        __r__cntbuf = list_from_x(__cntbuf)
        __r__bufr = list_from_x(__bufr)
        __r__bufi = list_from_x(__bufi)
        __r__info = __info.val
        __r__threshold = __threshold.value
        __r__rms = __rms.value
        __r__cvrms = __cvrms.value
        return (__r__a, __r__c, __r__tiesbuf, __r__cntbuf, __r__bufr, __r__bufi, __r__info, __r__threshold, __r__rms, __r__cvrms)
    finally:
        x_vector_clear(__a)
        x_vector_clear(__c)
        x_vector_clear(__tiesbuf)
        x_vector_clear(__cntbuf)
        x_vector_clear(__bufr)
        x_vector_clear(__bufi)


_lib_alglib.x_obj_free_clusterizerstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_clusterizerstate.restype = None


class clusterizerstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_clusterizerstate(self.ptr)


class x_ahcreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("terminationtype", x_int),
        ("npoints", x_int),
        ("p", x_vector),
        ("z", x_matrix),
        ("pz", x_matrix),
        ("pm", x_matrix),
        ("mergedist", x_vector)
        ]




class ahcreport(object):
    def __init__(self):
        self.terminationtype = 0
        self.npoints = 0
        self.p = []
        self.z = [[]]
        self.pz = [[]]
        self.pm = [[]]
        self.mergedist = []


def x_ahcreport_zero_fields(x):
    x.terminationtype.val = 0
    x.npoints.val = 0
    x.p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.z = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.pz = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.pm = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.mergedist = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    return




def x_ahcreport_clear(x):
    x_vector_clear(x.p)
    x_matrix_clear(x.z)
    x_matrix_clear(x.pz)
    x_matrix_clear(x.pm)
    x_vector_clear(x.mergedist)
    x_ahcreport_zero_fields(x)
    return




def x_from_ahcreport(x,v):
    x.terminationtype.val = int(v.terminationtype)
    x.npoints.val = int(v.npoints)
    x_from_list(x.p, v.p, DT_INT, X_CREATE)
    x_from_listlist(x.z, v.z, DT_INT, X_CREATE)
    x_from_listlist(x.pz, v.pz, DT_INT, X_CREATE)
    x_from_listlist(x.pm, v.pm, DT_INT, X_CREATE)
    x_from_list(x.mergedist, v.mergedist, DT_REAL, X_CREATE)
    return




def ahcreport_from_x(x):
    r = ahcreport()
    r.terminationtype = x.terminationtype.val
    r.npoints = x.npoints.val
    r.p = list_from_x(x.p)
    r.z = listlist_from_x(x.z)
    r.pz = listlist_from_x(x.pz)
    r.pm = listlist_from_x(x.pm)
    r.mergedist = list_from_x(x.mergedist)
    return r




class x_kmeansreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("npoints", x_int),
        ("nfeatures", x_int),
        ("terminationtype", x_int),
        ("iterationscount", x_int),
        ("energy", ctypes.c_double),
        ("k", x_int),
        ("c", x_matrix),
        ("cidx", x_vector)
        ]




class kmeansreport(object):
    def __init__(self):
        self.npoints = 0
        self.nfeatures = 0
        self.terminationtype = 0
        self.iterationscount = 0
        self.energy = 0
        self.k = 0
        self.c = [[]]
        self.cidx = []


def x_kmeansreport_zero_fields(x):
    x.npoints.val = 0
    x.nfeatures.val = 0
    x.terminationtype.val = 0
    x.iterationscount.val = 0
    x.energy = 0
    x.k.val = 0
    x.c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.cidx = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    return




def x_kmeansreport_clear(x):
    x_matrix_clear(x.c)
    x_vector_clear(x.cidx)
    x_kmeansreport_zero_fields(x)
    return




def x_from_kmeansreport(x,v):
    x.npoints.val = int(v.npoints)
    x.nfeatures.val = int(v.nfeatures)
    x.terminationtype.val = int(v.terminationtype)
    x.iterationscount.val = int(v.iterationscount)
    x.energy = float(v.energy)
    x.k.val = int(v.k)
    x_from_listlist(x.c, v.c, DT_REAL, X_CREATE)
    x_from_list(x.cidx, v.cidx, DT_INT, X_CREATE)
    return




def kmeansreport_from_x(x):
    r = kmeansreport()
    r.npoints = x.npoints.val
    r.nfeatures = x.nfeatures.val
    r.terminationtype = x.terminationtype.val
    r.iterationscount = x.iterationscount.val
    r.energy = x.energy
    r.k = x.k.val
    r.c = listlist_from_x(x.c)
    r.cidx = list_from_x(x.cidx)
    return r


_lib_alglib.alglib_clusterizercreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizercreate.restype = ctypes.c_int32
def clusterizercreate():
    pass
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizercreate(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizercreate'")
        __r__s = clusterizerstate(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_clusterizersetpoints.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizersetpoints.restype = ctypes.c_int32
def clusterizersetpoints(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        s,xy,npoints,nfeatures,disttype = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        s,xy,disttype = functionargs
        npoints = safe_rows("'clusterizersetpoints': incorrect parameters",xy)
        nfeatures = safe_cols("'clusterizersetpoints': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'clusterizersetpoints': function must have 3 or 5 parameters")
    __s = s.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    __disttype = x_int()
    __disttype.val = int(disttype)
    if __disttype.val!=disttype:
        raise ValueError("Error while converting 'disttype' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizersetpoints(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures), ctypes.byref(__disttype))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizersetpoints'")
        return
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_clusterizersetdistances.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizersetdistances.restype = ctypes.c_int32
def clusterizersetdistances(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        s,d,npoints,isupper = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        s,d,isupper = functionargs
        if safe_rows("'clusterizersetdistances': incorrect parameters",d)!=safe_cols("'clusterizersetdistances': incorrect parameters",d):
            raise RuntimeError("Error while calling 'clusterizersetdistances': looks like one of arguments has wrong size")
        npoints = safe_rows("'clusterizersetdistances': incorrect parameters",d)
    else:
        raise RuntimeError("Error while calling 'clusterizersetdistances': function must have 3 or 4 parameters")
    __s = s.ptr
    if not is_real_matrix(d):
        raise ValueError("'d' parameter can't be cast to real_matrix")
    __d = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__d, d, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizersetdistances(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__d), ctypes.byref(__npoints), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizersetdistances'")
        return
    finally:
        x_matrix_clear(__d)


_lib_alglib.alglib_clusterizersetahcalgo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizersetahcalgo.restype = ctypes.c_int32
def clusterizersetahcalgo(s, algo):
    pass
    __s = s.ptr
    __algo = x_int()
    __algo.val = int(algo)
    if __algo.val!=algo:
        raise ValueError("Error while converting 'algo' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizersetahcalgo(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__algo))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizersetahcalgo'")
        return
    finally:
        pass


_lib_alglib.alglib_clusterizersetkmeanslimits.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizersetkmeanslimits.restype = ctypes.c_int32
def clusterizersetkmeanslimits(s, restarts, maxits):
    pass
    __s = s.ptr
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizersetkmeanslimits(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__restarts), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizersetkmeanslimits'")
        return
    finally:
        pass


_lib_alglib.alglib_clusterizersetkmeansinit.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizersetkmeansinit.restype = ctypes.c_int32
def clusterizersetkmeansinit(s, initalgo):
    pass
    __s = s.ptr
    __initalgo = x_int()
    __initalgo.val = int(initalgo)
    if __initalgo.val!=initalgo:
        raise ValueError("Error while converting 'initalgo' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizersetkmeansinit(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__initalgo))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizersetkmeansinit'")
        return
    finally:
        pass


_lib_alglib.alglib_clusterizerrunahc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizerrunahc.restype = ctypes.c_int32
def clusterizerrunahc(s):
    pass
    __s = s.ptr
    __rep = x_ahcreport()
    x_ahcreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizerrunahc(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizerrunahc'")
        __r__rep = ahcreport_from_x(__rep)
        return __r__rep
    finally:
        x_ahcreport_clear(__rep)


_lib_alglib.alglib_smp_clusterizerrunahc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_clusterizerrunahc.restype = ctypes.c_int32
def smp_clusterizerrunahc(s):
    pass
    __s = s.ptr
    __rep = x_ahcreport()
    x_ahcreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_clusterizerrunahc(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_clusterizerrunahc'")
        __r__rep = ahcreport_from_x(__rep)
        return __r__rep
    finally:
        x_ahcreport_clear(__rep)


_lib_alglib.alglib_clusterizerrunkmeans.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizerrunkmeans.restype = ctypes.c_int32
def clusterizerrunkmeans(s, k):
    pass
    __s = s.ptr
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __rep = x_kmeansreport()
    x_kmeansreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizerrunkmeans(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__k), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizerrunkmeans'")
        __r__rep = kmeansreport_from_x(__rep)
        return __r__rep
    finally:
        x_kmeansreport_clear(__rep)


_lib_alglib.alglib_smp_clusterizerrunkmeans.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_clusterizerrunkmeans.restype = ctypes.c_int32
def smp_clusterizerrunkmeans(s, k):
    pass
    __s = s.ptr
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __rep = x_kmeansreport()
    x_kmeansreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_clusterizerrunkmeans(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__k), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_clusterizerrunkmeans'")
        __r__rep = kmeansreport_from_x(__rep)
        return __r__rep
    finally:
        x_kmeansreport_clear(__rep)


_lib_alglib.alglib_clusterizergetdistances.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizergetdistances.restype = ctypes.c_int32
def clusterizergetdistances(xy, npoints, nfeatures, disttype):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    __disttype = x_int()
    __disttype.val = int(disttype)
    if __disttype.val!=disttype:
        raise ValueError("Error while converting 'disttype' parameter to 'x_int'")
    __d = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizergetdistances(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures), ctypes.byref(__disttype), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizergetdistances'")
        __r__d = listlist_from_x(__d)
        return __r__d
    finally:
        x_matrix_clear(__xy)
        x_matrix_clear(__d)


_lib_alglib.alglib_smp_clusterizergetdistances.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_clusterizergetdistances.restype = ctypes.c_int32
def smp_clusterizergetdistances(xy, npoints, nfeatures, disttype):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nfeatures = x_int()
    __nfeatures.val = int(nfeatures)
    if __nfeatures.val!=nfeatures:
        raise ValueError("Error while converting 'nfeatures' parameter to 'x_int'")
    __disttype = x_int()
    __disttype.val = int(disttype)
    if __disttype.val!=disttype:
        raise ValueError("Error while converting 'disttype' parameter to 'x_int'")
    __d = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_clusterizergetdistances(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nfeatures), ctypes.byref(__disttype), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_clusterizergetdistances'")
        __r__d = listlist_from_x(__d)
        return __r__d
    finally:
        x_matrix_clear(__xy)
        x_matrix_clear(__d)


_lib_alglib.alglib_clusterizergetkclusters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizergetkclusters.restype = ctypes.c_int32
def clusterizergetkclusters(rep, k):
    pass
    __rep = x_ahcreport()
    x_ahcreport_zero_fields(__rep)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __cidx = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __cz = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_ahcreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizergetkclusters(ctypes.byref(_error_msg), ctypes.byref(__rep), ctypes.byref(__k), ctypes.byref(__cidx), ctypes.byref(__cz))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizergetkclusters'")
        __r__cidx = list_from_x(__cidx)
        __r__cz = list_from_x(__cz)
        return (__r__cidx, __r__cz)
    finally:
        x_ahcreport_clear(__rep)
        x_vector_clear(__cidx)
        x_vector_clear(__cz)


_lib_alglib.alglib_clusterizerseparatedbydist.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizerseparatedbydist.restype = ctypes.c_int32
def clusterizerseparatedbydist(rep, r):
    pass
    __rep = x_ahcreport()
    x_ahcreport_zero_fields(__rep)
    __r = ctypes.c_double(r)
    __k = x_int()
    __k.val = 0
    __cidx = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __cz = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_ahcreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizerseparatedbydist(ctypes.byref(_error_msg), ctypes.byref(__rep), ctypes.byref(__r), ctypes.byref(__k), ctypes.byref(__cidx), ctypes.byref(__cz))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizerseparatedbydist'")
        __r__k = __k.val
        __r__cidx = list_from_x(__cidx)
        __r__cz = list_from_x(__cz)
        return (__r__k, __r__cidx, __r__cz)
    finally:
        x_ahcreport_clear(__rep)
        x_vector_clear(__cidx)
        x_vector_clear(__cz)


_lib_alglib.alglib_clusterizerseparatedbycorr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_clusterizerseparatedbycorr.restype = ctypes.c_int32
def clusterizerseparatedbycorr(rep, r):
    pass
    __rep = x_ahcreport()
    x_ahcreport_zero_fields(__rep)
    __r = ctypes.c_double(r)
    __k = x_int()
    __k.val = 0
    __cidx = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __cz = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_ahcreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_clusterizerseparatedbycorr(ctypes.byref(_error_msg), ctypes.byref(__rep), ctypes.byref(__r), ctypes.byref(__k), ctypes.byref(__cidx), ctypes.byref(__cz))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'clusterizerseparatedbycorr'")
        __r__k = __k.val
        __r__cidx = list_from_x(__cidx)
        __r__cz = list_from_x(__cz)
        return (__r__k, __r__cidx, __r__cz)
    finally:
        x_ahcreport_clear(__rep)
        x_vector_clear(__cidx)
        x_vector_clear(__cz)


_lib_alglib.alglib_kmeansgenerate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_kmeansgenerate.restype = ctypes.c_int32
def kmeansgenerate(xy, npoints, nvars, k, restarts):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __xyc = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_kmeansgenerate(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__k), ctypes.byref(__restarts), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__xyc))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'kmeansgenerate'")
        __r__info = __info.val
        __r__c = listlist_from_x(__c)
        __r__xyc = list_from_x(__xyc)
        return (__r__info, __r__c, __r__xyc)
    finally:
        x_matrix_clear(__xy)
        x_matrix_clear(__c)
        x_vector_clear(__xyc)


_lib_alglib.x_obj_free_decisionforest.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_decisionforest.restype = None


class decisionforest(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_decisionforest(self.ptr)


class x_dfreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("relclserror", ctypes.c_double),
        ("avgce", ctypes.c_double),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("oobrelclserror", ctypes.c_double),
        ("oobavgce", ctypes.c_double),
        ("oobrmserror", ctypes.c_double),
        ("oobavgerror", ctypes.c_double),
        ("oobavgrelerror", ctypes.c_double)
        ]




class dfreport(object):
    def __init__(self):
        self.relclserror = 0
        self.avgce = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.oobrelclserror = 0
        self.oobavgce = 0
        self.oobrmserror = 0
        self.oobavgerror = 0
        self.oobavgrelerror = 0


def x_dfreport_zero_fields(x):
    x.relclserror = 0
    x.avgce = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.oobrelclserror = 0
    x.oobavgce = 0
    x.oobrmserror = 0
    x.oobavgerror = 0
    x.oobavgrelerror = 0
    return




def x_dfreport_clear(x):
    x_dfreport_zero_fields(x)
    return




def x_from_dfreport(x,v):
    x.relclserror = float(v.relclserror)
    x.avgce = float(v.avgce)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.oobrelclserror = float(v.oobrelclserror)
    x.oobavgce = float(v.oobavgce)
    x.oobrmserror = float(v.oobrmserror)
    x.oobavgerror = float(v.oobavgerror)
    x.oobavgrelerror = float(v.oobavgrelerror)
    return




def dfreport_from_x(x):
    r = dfreport()
    r.relclserror = x.relclserror
    r.avgce = x.avgce
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.oobrelclserror = x.oobrelclserror
    r.oobavgce = x.oobavgce
    r.oobrmserror = x.oobrmserror
    r.oobavgerror = x.oobavgerror
    r.oobavgrelerror = x.oobavgrelerror
    return r


_lib_alglib.alglib_dfserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfserialize.restype = ctypes.c_int32

def dfserialize(obj):
    error_msg = ctypes.c_char_p(0)
    _s_out = ctypes.c_char_p(0)
    retval = _lib_alglib.alglib_dfserialize(ctypes.byref(error_msg), ctypes.byref(obj.ptr), ctypes.byref(_s_out))
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'dfserialize'")
    s_out = _s_out.value
    _lib_alglib.x_free(_s_out)
    return s_out

_lib_alglib.alglib_dfunserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfunserialize.restype = ctypes.c_int32

def dfunserialize(s_in):
    error_msg = ctypes.c_char_p(0)
    _s_in = ctypes.c_char_p(s_in)
    _obj = ctypes.c_void_p(0)
    retval = _lib_alglib.alglib_dfunserialize(ctypes.byref(error_msg), ctypes.byref(_s_in), ctypes.byref(_obj), )
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'dfserialize'")
    return decisionforest(_obj)

_lib_alglib.alglib_dfbuildrandomdecisionforest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfbuildrandomdecisionforest.restype = ctypes.c_int32
def dfbuildrandomdecisionforest(xy, npoints, nvars, nclasses, ntrees, r):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __ntrees = x_int()
    __ntrees.val = int(ntrees)
    if __ntrees.val!=ntrees:
        raise ValueError("Error while converting 'ntrees' parameter to 'x_int'")
    __r = ctypes.c_double(r)
    __info = x_int()
    __info.val = 0
    __df = ctypes.c_void_p(0)
    __rep = x_dfreport()
    x_dfreport_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfbuildrandomdecisionforest(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__ntrees), ctypes.byref(__r), ctypes.byref(__info), ctypes.byref(__df), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfbuildrandomdecisionforest'")
        __r__info = __info.val
        __r__df = decisionforest(__df)
        __r__rep = dfreport_from_x(__rep)
        return (__r__info, __r__df, __r__rep)
    finally:
        x_matrix_clear(__xy)
        x_dfreport_clear(__rep)


_lib_alglib.alglib_dfbuildrandomdecisionforestx1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfbuildrandomdecisionforestx1.restype = ctypes.c_int32
def dfbuildrandomdecisionforestx1(xy, npoints, nvars, nclasses, ntrees, nrndvars, r):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __ntrees = x_int()
    __ntrees.val = int(ntrees)
    if __ntrees.val!=ntrees:
        raise ValueError("Error while converting 'ntrees' parameter to 'x_int'")
    __nrndvars = x_int()
    __nrndvars.val = int(nrndvars)
    if __nrndvars.val!=nrndvars:
        raise ValueError("Error while converting 'nrndvars' parameter to 'x_int'")
    __r = ctypes.c_double(r)
    __info = x_int()
    __info.val = 0
    __df = ctypes.c_void_p(0)
    __rep = x_dfreport()
    x_dfreport_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfbuildrandomdecisionforestx1(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__ntrees), ctypes.byref(__nrndvars), ctypes.byref(__r), ctypes.byref(__info), ctypes.byref(__df), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfbuildrandomdecisionforestx1'")
        __r__info = __info.val
        __r__df = decisionforest(__df)
        __r__rep = dfreport_from_x(__rep)
        return (__r__info, __r__df, __r__rep)
    finally:
        x_matrix_clear(__xy)
        x_dfreport_clear(__rep)


_lib_alglib.alglib_dfprocess.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfprocess.restype = ctypes.c_int32
def dfprocess(df, x, y):
    pass
    __df = df.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfprocess(ctypes.byref(_error_msg), ctypes.byref(__df), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfprocess'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_dfprocessi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfprocessi.restype = ctypes.c_int32
def dfprocessi(df, x):
    pass
    __df = df.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfprocessi(ctypes.byref(_error_msg), ctypes.byref(__df), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfprocessi'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_dfrelclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfrelclserror.restype = ctypes.c_int32
def dfrelclserror(df, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __df = df.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfrelclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__df), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfrelclserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_dfavgce.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfavgce.restype = ctypes.c_int32
def dfavgce(df, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __df = df.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfavgce(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__df), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfavgce'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_dfrmserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfrmserror.restype = ctypes.c_int32
def dfrmserror(df, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __df = df.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfrmserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__df), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfrmserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_dfavgerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfavgerror.restype = ctypes.c_int32
def dfavgerror(df, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __df = df.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfavgerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__df), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfavgerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_dfavgrelerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dfavgrelerror.restype = ctypes.c_int32
def dfavgrelerror(df, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __df = df.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dfavgrelerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__df), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dfavgrelerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_gammafunction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gammafunction.restype = ctypes.c_int32
def gammafunction(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gammafunction(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gammafunction'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_lngamma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lngamma.restype = ctypes.c_int32
def lngamma(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    __sgngam = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lngamma(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__sgngam))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lngamma'")
        __r__result = __result.value
        __r__sgngam = __sgngam.value
        return (__r__result, __r__sgngam)
    finally:
        pass


_lib_alglib.alglib_errorfunction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_errorfunction.restype = ctypes.c_int32
def errorfunction(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_errorfunction(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'errorfunction'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_errorfunctionc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_errorfunctionc.restype = ctypes.c_int32
def errorfunctionc(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_errorfunctionc(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'errorfunctionc'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_normaldistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_normaldistribution.restype = ctypes.c_int32
def normaldistribution(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_normaldistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'normaldistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_inverf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_inverf.restype = ctypes.c_int32
def inverf(e):
    pass
    __result = ctypes.c_double(0)
    __e = ctypes.c_double(e)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_inverf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__e))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'inverf'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invnormaldistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invnormaldistribution.restype = ctypes.c_int32
def invnormaldistribution(y0):
    pass
    __result = ctypes.c_double(0)
    __y0 = ctypes.c_double(y0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invnormaldistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__y0))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invnormaldistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_incompletegamma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_incompletegamma.restype = ctypes.c_int32
def incompletegamma(a, x):
    pass
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_incompletegamma(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'incompletegamma'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_incompletegammac.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_incompletegammac.restype = ctypes.c_int32
def incompletegammac(a, x):
    pass
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_incompletegammac(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'incompletegammac'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invincompletegammac.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invincompletegammac.restype = ctypes.c_int32
def invincompletegammac(a, y0):
    pass
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __y0 = ctypes.c_double(y0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invincompletegammac(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__y0))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invincompletegammac'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_rmatrixqr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixqr.restype = ctypes.c_int32
def rmatrixqr(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixqr(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixqr'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_smp_rmatrixqr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixqr.restype = ctypes.c_int32
def smp_rmatrixqr(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixqr(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixqr'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_rmatrixlq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlq.restype = ctypes.c_int32
def rmatrixlq(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlq'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_smp_rmatrixlq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixlq.restype = ctypes.c_int32
def smp_rmatrixlq(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixlq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixlq'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_cmatrixqr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixqr.restype = ctypes.c_int32
def cmatrixqr(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixqr(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixqr'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_smp_cmatrixqr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixqr.restype = ctypes.c_int32
def smp_cmatrixqr(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixqr(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixqr'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_cmatrixlq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlq.restype = ctypes.c_int32
def cmatrixlq(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlq'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_smp_cmatrixlq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixlq.restype = ctypes.c_int32
def smp_cmatrixlq(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixlq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixlq'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_rmatrixqrunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixqrunpackq.restype = ctypes.c_int32
def rmatrixqrunpackq(a, m, n, tau, qcolumns):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tau):
        raise ValueError("'tau' parameter can't be cast to real_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qcolumns = x_int()
    __qcolumns.val = int(qcolumns)
    if __qcolumns.val!=qcolumns:
        raise ValueError("Error while converting 'qcolumns' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__tau, tau, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixqrunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qcolumns), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixqrunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_smp_rmatrixqrunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixqrunpackq.restype = ctypes.c_int32
def smp_rmatrixqrunpackq(a, m, n, tau, qcolumns):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tau):
        raise ValueError("'tau' parameter can't be cast to real_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qcolumns = x_int()
    __qcolumns.val = int(qcolumns)
    if __qcolumns.val!=qcolumns:
        raise ValueError("Error while converting 'qcolumns' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__tau, tau, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixqrunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qcolumns), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixqrunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_rmatrixqrunpackr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixqrunpackr.restype = ctypes.c_int32
def rmatrixqrunpackr(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixqrunpackr(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixqrunpackr'")
        __r__r = listlist_from_x(__r)
        return __r__r
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__r)


_lib_alglib.alglib_rmatrixlqunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlqunpackq.restype = ctypes.c_int32
def rmatrixlqunpackq(a, m, n, tau, qrows):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tau):
        raise ValueError("'tau' parameter can't be cast to real_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qrows = x_int()
    __qrows.val = int(qrows)
    if __qrows.val!=qrows:
        raise ValueError("Error while converting 'qrows' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__tau, tau, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlqunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qrows), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlqunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_smp_rmatrixlqunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixlqunpackq.restype = ctypes.c_int32
def smp_rmatrixlqunpackq(a, m, n, tau, qrows):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tau):
        raise ValueError("'tau' parameter can't be cast to real_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qrows = x_int()
    __qrows.val = int(qrows)
    if __qrows.val!=qrows:
        raise ValueError("Error while converting 'qrows' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__tau, tau, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixlqunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qrows), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixlqunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_rmatrixlqunpackl.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlqunpackl.restype = ctypes.c_int32
def rmatrixlqunpackl(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __l = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlqunpackl(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__l))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlqunpackl'")
        __r__l = listlist_from_x(__l)
        return __r__l
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__l)


_lib_alglib.alglib_cmatrixqrunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixqrunpackq.restype = ctypes.c_int32
def cmatrixqrunpackq(a, m, n, tau, qcolumns):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(tau):
        raise ValueError("'tau' parameter can't be cast to complex_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qcolumns = x_int()
    __qcolumns.val = int(qcolumns)
    if __qcolumns.val!=qcolumns:
        raise ValueError("Error while converting 'qcolumns' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__tau, tau, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixqrunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qcolumns), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixqrunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_smp_cmatrixqrunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixqrunpackq.restype = ctypes.c_int32
def smp_cmatrixqrunpackq(a, m, n, tau, qcolumns):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(tau):
        raise ValueError("'tau' parameter can't be cast to complex_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qcolumns = x_int()
    __qcolumns.val = int(qcolumns)
    if __qcolumns.val!=qcolumns:
        raise ValueError("Error while converting 'qcolumns' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__tau, tau, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixqrunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qcolumns), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixqrunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_cmatrixqrunpackr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixqrunpackr.restype = ctypes.c_int32
def cmatrixqrunpackr(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixqrunpackr(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixqrunpackr'")
        __r__r = listlist_from_x(__r)
        return __r__r
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__r)


_lib_alglib.alglib_cmatrixlqunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlqunpackq.restype = ctypes.c_int32
def cmatrixlqunpackq(a, m, n, tau, qrows):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(tau):
        raise ValueError("'tau' parameter can't be cast to complex_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qrows = x_int()
    __qrows.val = int(qrows)
    if __qrows.val!=qrows:
        raise ValueError("Error while converting 'qrows' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__tau, tau, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlqunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qrows), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlqunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_smp_cmatrixlqunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixlqunpackq.restype = ctypes.c_int32
def smp_cmatrixlqunpackq(a, m, n, tau, qrows):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(tau):
        raise ValueError("'tau' parameter can't be cast to complex_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qrows = x_int()
    __qrows.val = int(qrows)
    if __qrows.val!=qrows:
        raise ValueError("Error while converting 'qrows' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__tau, tau, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixlqunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__qrows), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixlqunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_cmatrixlqunpackl.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlqunpackl.restype = ctypes.c_int32
def cmatrixlqunpackl(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __l = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlqunpackl(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__l))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlqunpackl'")
        __r__l = listlist_from_x(__l)
        return __r__l
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__l)


_lib_alglib.alglib_rmatrixbd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbd.restype = ctypes.c_int32
def rmatrixbd(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tauq = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __taup = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbd(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tauq), ctypes.byref(__taup))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbd'")
        __r__a = listlist_from_x(__a)
        __r__tauq = list_from_x(__tauq)
        __r__taup = list_from_x(__taup)
        return (__r__a, __r__tauq, __r__taup)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tauq)
        x_vector_clear(__taup)


_lib_alglib.alglib_rmatrixbdunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbdunpackq.restype = ctypes.c_int32
def rmatrixbdunpackq(qp, m, n, tauq, qcolumns):
    pass
    if not is_real_matrix(qp):
        raise ValueError("'qp' parameter can't be cast to real_matrix")
    __qp = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tauq):
        raise ValueError("'tauq' parameter can't be cast to real_vector")
    __tauq = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __qcolumns = x_int()
    __qcolumns.val = int(qcolumns)
    if __qcolumns.val!=qcolumns:
        raise ValueError("Error while converting 'qcolumns' parameter to 'x_int'")
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__qp, qp, DT_REAL, X_CREATE)
        x_from_list(__tauq, tauq, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbdunpackq(ctypes.byref(_error_msg), ctypes.byref(__qp), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tauq), ctypes.byref(__qcolumns), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbdunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__qp)
        x_vector_clear(__tauq)
        x_matrix_clear(__q)


_lib_alglib.alglib_rmatrixbdmultiplybyq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbdmultiplybyq.restype = ctypes.c_int32
def rmatrixbdmultiplybyq(qp, m, n, tauq, z, zrows, zcolumns, fromtheright, dotranspose):
    pass
    if not is_real_matrix(qp):
        raise ValueError("'qp' parameter can't be cast to real_matrix")
    __qp = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tauq):
        raise ValueError("'tauq' parameter can't be cast to real_vector")
    __tauq = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(z):
        raise ValueError("'z' parameter can't be cast to real_matrix")
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __zrows = x_int()
    __zrows.val = int(zrows)
    if __zrows.val!=zrows:
        raise ValueError("Error while converting 'zrows' parameter to 'x_int'")
    __zcolumns = x_int()
    __zcolumns.val = int(zcolumns)
    if __zcolumns.val!=zcolumns:
        raise ValueError("Error while converting 'zcolumns' parameter to 'x_int'")
    __fromtheright = ctypes.c_uint8(fromtheright)
    if __fromtheright.value!=0:
        __fromtheright = ctypes.c_uint8(1)
    __dotranspose = ctypes.c_uint8(dotranspose)
    if __dotranspose.value!=0:
        __dotranspose = ctypes.c_uint8(1)
    try:
        x_from_listlist(__qp, qp, DT_REAL, X_CREATE)
        x_from_list(__tauq, tauq, DT_REAL, X_CREATE)
        x_from_listlist(__z, z, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbdmultiplybyq(ctypes.byref(_error_msg), ctypes.byref(__qp), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tauq), ctypes.byref(__z), ctypes.byref(__zrows), ctypes.byref(__zcolumns), ctypes.byref(__fromtheright), ctypes.byref(__dotranspose))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbdmultiplybyq'")
        __r__z = listlist_from_x(__z)
        return __r__z
    finally:
        x_matrix_clear(__qp)
        x_vector_clear(__tauq)
        x_matrix_clear(__z)


_lib_alglib.alglib_rmatrixbdunpackpt.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbdunpackpt.restype = ctypes.c_int32
def rmatrixbdunpackpt(qp, m, n, taup, ptrows):
    pass
    if not is_real_matrix(qp):
        raise ValueError("'qp' parameter can't be cast to real_matrix")
    __qp = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(taup):
        raise ValueError("'taup' parameter can't be cast to real_vector")
    __taup = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ptrows = x_int()
    __ptrows.val = int(ptrows)
    if __ptrows.val!=ptrows:
        raise ValueError("Error while converting 'ptrows' parameter to 'x_int'")
    __pt = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__qp, qp, DT_REAL, X_CREATE)
        x_from_list(__taup, taup, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbdunpackpt(ctypes.byref(_error_msg), ctypes.byref(__qp), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__taup), ctypes.byref(__ptrows), ctypes.byref(__pt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbdunpackpt'")
        __r__pt = listlist_from_x(__pt)
        return __r__pt
    finally:
        x_matrix_clear(__qp)
        x_vector_clear(__taup)
        x_matrix_clear(__pt)


_lib_alglib.alglib_rmatrixbdmultiplybyp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbdmultiplybyp.restype = ctypes.c_int32
def rmatrixbdmultiplybyp(qp, m, n, taup, z, zrows, zcolumns, fromtheright, dotranspose):
    pass
    if not is_real_matrix(qp):
        raise ValueError("'qp' parameter can't be cast to real_matrix")
    __qp = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(taup):
        raise ValueError("'taup' parameter can't be cast to real_vector")
    __taup = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(z):
        raise ValueError("'z' parameter can't be cast to real_matrix")
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __zrows = x_int()
    __zrows.val = int(zrows)
    if __zrows.val!=zrows:
        raise ValueError("Error while converting 'zrows' parameter to 'x_int'")
    __zcolumns = x_int()
    __zcolumns.val = int(zcolumns)
    if __zcolumns.val!=zcolumns:
        raise ValueError("Error while converting 'zcolumns' parameter to 'x_int'")
    __fromtheright = ctypes.c_uint8(fromtheright)
    if __fromtheright.value!=0:
        __fromtheright = ctypes.c_uint8(1)
    __dotranspose = ctypes.c_uint8(dotranspose)
    if __dotranspose.value!=0:
        __dotranspose = ctypes.c_uint8(1)
    try:
        x_from_listlist(__qp, qp, DT_REAL, X_CREATE)
        x_from_list(__taup, taup, DT_REAL, X_CREATE)
        x_from_listlist(__z, z, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbdmultiplybyp(ctypes.byref(_error_msg), ctypes.byref(__qp), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__taup), ctypes.byref(__z), ctypes.byref(__zrows), ctypes.byref(__zcolumns), ctypes.byref(__fromtheright), ctypes.byref(__dotranspose))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbdmultiplybyp'")
        __r__z = listlist_from_x(__z)
        return __r__z
    finally:
        x_matrix_clear(__qp)
        x_vector_clear(__taup)
        x_matrix_clear(__z)


_lib_alglib.alglib_rmatrixbdunpackdiagonals.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbdunpackdiagonals.restype = ctypes.c_int32
def rmatrixbdunpackdiagonals(b, m, n):
    pass
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(0)
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __e = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbdunpackdiagonals(ctypes.byref(_error_msg), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__d), ctypes.byref(__e))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbdunpackdiagonals'")
        __r__isupper = __isupper.value!=0
        __r__d = list_from_x(__d)
        __r__e = list_from_x(__e)
        return (__r__isupper, __r__d, __r__e)
    finally:
        x_matrix_clear(__b)
        x_vector_clear(__d)
        x_vector_clear(__e)


_lib_alglib.alglib_rmatrixhessenberg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixhessenberg.restype = ctypes.c_int32
def rmatrixhessenberg(a, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __tau = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixhessenberg(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__tau))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixhessenberg'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        return (__r__a, __r__tau)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)


_lib_alglib.alglib_rmatrixhessenbergunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixhessenbergunpackq.restype = ctypes.c_int32
def rmatrixhessenbergunpackq(a, n, tau):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(tau):
        raise ValueError("'tau' parameter can't be cast to real_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__tau, tau, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixhessenbergunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__tau), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixhessenbergunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_rmatrixhessenbergunpackh.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixhessenbergunpackh.restype = ctypes.c_int32
def rmatrixhessenbergunpackh(a, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __h = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixhessenbergunpackh(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__h))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixhessenbergunpackh'")
        __r__h = listlist_from_x(__h)
        return __r__h
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__h)


_lib_alglib.alglib_smatrixtd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixtd.restype = ctypes.c_int32
def smatrixtd(a, n, isupper):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __tau = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __e = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixtd(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__tau), ctypes.byref(__d), ctypes.byref(__e))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixtd'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        __r__d = list_from_x(__d)
        __r__e = list_from_x(__e)
        return (__r__a, __r__tau, __r__d, __r__e)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_vector_clear(__d)
        x_vector_clear(__e)


_lib_alglib.alglib_smatrixtdunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixtdunpackq.restype = ctypes.c_int32
def smatrixtdunpackq(a, n, isupper, tau):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(tau):
        raise ValueError("'tau' parameter can't be cast to real_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__tau, tau, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixtdunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__tau), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixtdunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_hmatrixtd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixtd.restype = ctypes.c_int32
def hmatrixtd(a, n, isupper):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __tau = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __e = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixtd(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__tau), ctypes.byref(__d), ctypes.byref(__e))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixtd'")
        __r__a = listlist_from_x(__a)
        __r__tau = list_from_x(__tau)
        __r__d = list_from_x(__d)
        __r__e = list_from_x(__e)
        return (__r__a, __r__tau, __r__d, __r__e)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_vector_clear(__d)
        x_vector_clear(__e)


_lib_alglib.alglib_hmatrixtdunpackq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixtdunpackq.restype = ctypes.c_int32
def hmatrixtdunpackq(a, n, isupper, tau):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(tau):
        raise ValueError("'tau' parameter can't be cast to complex_vector")
    __tau = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __q = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__tau, tau, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixtdunpackq(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__tau), ctypes.byref(__q))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixtdunpackq'")
        __r__q = listlist_from_x(__q)
        return __r__q
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__tau)
        x_matrix_clear(__q)


_lib_alglib.alglib_rmatrixbdsvd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixbdsvd.restype = ctypes.c_int32
def rmatrixbdsvd(d, e, n, isupper, isfractionalaccuracyrequired, u, nru, c, ncc, vt, ncvt):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(e):
        raise ValueError("'e' parameter can't be cast to real_vector")
    __e = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isfractionalaccuracyrequired = ctypes.c_uint8(isfractionalaccuracyrequired)
    if __isfractionalaccuracyrequired.value!=0:
        __isfractionalaccuracyrequired = ctypes.c_uint8(1)
    if not is_real_matrix(u):
        raise ValueError("'u' parameter can't be cast to real_matrix")
    __u = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nru = x_int()
    __nru.val = int(nru)
    if __nru.val!=nru:
        raise ValueError("Error while converting 'nru' parameter to 'x_int'")
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ncc = x_int()
    __ncc.val = int(ncc)
    if __ncc.val!=ncc:
        raise ValueError("Error while converting 'ncc' parameter to 'x_int'")
    if not is_real_matrix(vt):
        raise ValueError("'vt' parameter can't be cast to real_matrix")
    __vt = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ncvt = x_int()
    __ncvt.val = int(ncvt)
    if __ncvt.val!=ncvt:
        raise ValueError("Error while converting 'ncvt' parameter to 'x_int'")
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        x_from_list(__e, e, DT_REAL, X_CREATE)
        x_from_listlist(__u, u, DT_REAL, X_CREATE)
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        x_from_listlist(__vt, vt, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixbdsvd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__d), ctypes.byref(__e), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isfractionalaccuracyrequired), ctypes.byref(__u), ctypes.byref(__nru), ctypes.byref(__c), ctypes.byref(__ncc), ctypes.byref(__vt), ctypes.byref(__ncvt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixbdsvd'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__u = listlist_from_x(__u)
        __r__c = listlist_from_x(__c)
        __r__vt = listlist_from_x(__vt)
        return (__r__result, __r__d, __r__u, __r__c, __r__vt)
    finally:
        x_vector_clear(__d)
        x_vector_clear(__e)
        x_matrix_clear(__u)
        x_matrix_clear(__c)
        x_matrix_clear(__vt)


_lib_alglib.alglib_rmatrixsvd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsvd.restype = ctypes.c_int32
def rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __uneeded = x_int()
    __uneeded.val = int(uneeded)
    if __uneeded.val!=uneeded:
        raise ValueError("Error while converting 'uneeded' parameter to 'x_int'")
    __vtneeded = x_int()
    __vtneeded.val = int(vtneeded)
    if __vtneeded.val!=vtneeded:
        raise ValueError("Error while converting 'vtneeded' parameter to 'x_int'")
    __additionalmemory = x_int()
    __additionalmemory.val = int(additionalmemory)
    if __additionalmemory.val!=additionalmemory:
        raise ValueError("Error while converting 'additionalmemory' parameter to 'x_int'")
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __u = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __vt = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsvd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__uneeded), ctypes.byref(__vtneeded), ctypes.byref(__additionalmemory), ctypes.byref(__w), ctypes.byref(__u), ctypes.byref(__vt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsvd'")
        __r__result = __result.value!=0
        __r__w = list_from_x(__w)
        __r__u = listlist_from_x(__u)
        __r__vt = listlist_from_x(__vt)
        return (__r__result, __r__w, __r__u, __r__vt)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__w)
        x_matrix_clear(__u)
        x_matrix_clear(__vt)


_lib_alglib.alglib_smp_rmatrixsvd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsvd.restype = ctypes.c_int32
def smp_rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __uneeded = x_int()
    __uneeded.val = int(uneeded)
    if __uneeded.val!=uneeded:
        raise ValueError("Error while converting 'uneeded' parameter to 'x_int'")
    __vtneeded = x_int()
    __vtneeded.val = int(vtneeded)
    if __vtneeded.val!=vtneeded:
        raise ValueError("Error while converting 'vtneeded' parameter to 'x_int'")
    __additionalmemory = x_int()
    __additionalmemory.val = int(additionalmemory)
    if __additionalmemory.val!=additionalmemory:
        raise ValueError("Error while converting 'additionalmemory' parameter to 'x_int'")
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __u = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __vt = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsvd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__uneeded), ctypes.byref(__vtneeded), ctypes.byref(__additionalmemory), ctypes.byref(__w), ctypes.byref(__u), ctypes.byref(__vt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsvd'")
        __r__result = __result.value!=0
        __r__w = list_from_x(__w)
        __r__u = listlist_from_x(__u)
        __r__vt = listlist_from_x(__vt)
        return (__r__result, __r__w, __r__u, __r__vt)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__w)
        x_matrix_clear(__u)
        x_matrix_clear(__vt)


_lib_alglib.x_obj_free_linearmodel.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_linearmodel.restype = None


class linearmodel(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_linearmodel(self.ptr)


class x_lrreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("c", x_matrix),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("cvrmserror", ctypes.c_double),
        ("cvavgerror", ctypes.c_double),
        ("cvavgrelerror", ctypes.c_double),
        ("ncvdefects", x_int),
        ("cvdefects", x_vector)
        ]




class lrreport(object):
    def __init__(self):
        self.c = [[]]
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.cvrmserror = 0
        self.cvavgerror = 0
        self.cvavgrelerror = 0
        self.ncvdefects = 0
        self.cvdefects = []


def x_lrreport_zero_fields(x):
    x.c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.cvrmserror = 0
    x.cvavgerror = 0
    x.cvavgrelerror = 0
    x.ncvdefects.val = 0
    x.cvdefects = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    return




def x_lrreport_clear(x):
    x_matrix_clear(x.c)
    x_vector_clear(x.cvdefects)
    x_lrreport_zero_fields(x)
    return




def x_from_lrreport(x,v):
    x_from_listlist(x.c, v.c, DT_REAL, X_CREATE)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.cvrmserror = float(v.cvrmserror)
    x.cvavgerror = float(v.cvavgerror)
    x.cvavgrelerror = float(v.cvavgrelerror)
    x.ncvdefects.val = int(v.ncvdefects)
    x_from_list(x.cvdefects, v.cvdefects, DT_INT, X_CREATE)
    return




def lrreport_from_x(x):
    r = lrreport()
    r.c = listlist_from_x(x.c)
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.cvrmserror = x.cvrmserror
    r.cvavgerror = x.cvavgerror
    r.cvavgrelerror = x.cvavgrelerror
    r.ncvdefects = x.ncvdefects.val
    r.cvdefects = list_from_x(x.cvdefects)
    return r


_lib_alglib.alglib_lrbuild.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrbuild.restype = ctypes.c_int32
def lrbuild(xy, npoints, nvars):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __lm = ctypes.c_void_p(0)
    __ar = x_lrreport()
    x_lrreport_zero_fields(__ar)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrbuild(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__info), ctypes.byref(__lm), ctypes.byref(__ar))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrbuild'")
        __r__info = __info.val
        __r__lm = linearmodel(__lm)
        __r__ar = lrreport_from_x(__ar)
        return (__r__info, __r__lm, __r__ar)
    finally:
        x_matrix_clear(__xy)
        x_lrreport_clear(__ar)


_lib_alglib.alglib_lrbuilds.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrbuilds.restype = ctypes.c_int32
def lrbuilds(xy, s, npoints, nvars):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __lm = ctypes.c_void_p(0)
    __ar = x_lrreport()
    x_lrreport_zero_fields(__ar)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrbuilds(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__s), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__info), ctypes.byref(__lm), ctypes.byref(__ar))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrbuilds'")
        __r__info = __info.val
        __r__lm = linearmodel(__lm)
        __r__ar = lrreport_from_x(__ar)
        return (__r__info, __r__lm, __r__ar)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__s)
        x_lrreport_clear(__ar)


_lib_alglib.alglib_lrbuildzs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrbuildzs.restype = ctypes.c_int32
def lrbuildzs(xy, s, npoints, nvars):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __lm = ctypes.c_void_p(0)
    __ar = x_lrreport()
    x_lrreport_zero_fields(__ar)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrbuildzs(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__s), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__info), ctypes.byref(__lm), ctypes.byref(__ar))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrbuildzs'")
        __r__info = __info.val
        __r__lm = linearmodel(__lm)
        __r__ar = lrreport_from_x(__ar)
        return (__r__info, __r__lm, __r__ar)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__s)
        x_lrreport_clear(__ar)


_lib_alglib.alglib_lrbuildz.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrbuildz.restype = ctypes.c_int32
def lrbuildz(xy, npoints, nvars):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __lm = ctypes.c_void_p(0)
    __ar = x_lrreport()
    x_lrreport_zero_fields(__ar)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrbuildz(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__info), ctypes.byref(__lm), ctypes.byref(__ar))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrbuildz'")
        __r__info = __info.val
        __r__lm = linearmodel(__lm)
        __r__ar = lrreport_from_x(__ar)
        return (__r__info, __r__lm, __r__ar)
    finally:
        x_matrix_clear(__xy)
        x_lrreport_clear(__ar)


_lib_alglib.alglib_lrunpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrunpack.restype = ctypes.c_int32
def lrunpack(lm):
    pass
    __lm = lm.ptr
    __v = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nvars = x_int()
    __nvars.val = 0
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrunpack(ctypes.byref(_error_msg), ctypes.byref(__lm), ctypes.byref(__v), ctypes.byref(__nvars))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrunpack'")
        __r__v = list_from_x(__v)
        __r__nvars = __nvars.val
        return (__r__v, __r__nvars)
    finally:
        x_vector_clear(__v)


_lib_alglib.alglib_lrpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrpack.restype = ctypes.c_int32
def lrpack(v, nvars):
    pass
    if not is_real_vector(v):
        raise ValueError("'v' parameter can't be cast to real_vector")
    __v = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __lm = ctypes.c_void_p(0)
    try:
        x_from_list(__v, v, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrpack(ctypes.byref(_error_msg), ctypes.byref(__v), ctypes.byref(__nvars), ctypes.byref(__lm))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrpack'")
        __r__lm = linearmodel(__lm)
        return __r__lm
    finally:
        x_vector_clear(__v)


_lib_alglib.alglib_lrprocess.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrprocess.restype = ctypes.c_int32
def lrprocess(lm, x):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrprocess(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrprocess'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_lrrmserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lrrmserror.restype = ctypes.c_int32
def lrrmserror(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lrrmserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lrrmserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_lravgerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lravgerror.restype = ctypes.c_int32
def lravgerror(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lravgerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lravgerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_lravgrelerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lravgrelerror.restype = ctypes.c_int32
def lravgrelerror(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lravgrelerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lravgrelerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_filtersma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_filtersma.restype = ctypes.c_int32
def filtersma(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,k = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,k = functionargs
        n = safe_len("'filtersma': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'filtersma': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_filtersma(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'filtersma'")
        __r__x = list_from_x(__x)
        return __r__x
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_filterema.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_filterema.restype = ctypes.c_int32
def filterema(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,alpha = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,alpha = functionargs
        n = safe_len("'filterema': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'filterema': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_filterema(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__alpha))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'filterema'")
        __r__x = list_from_x(__x)
        return __r__x
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_filterlrma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_filterlrma.restype = ctypes.c_int32
def filterlrma(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,n,k = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,k = functionargs
        n = safe_len("'filterlrma': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'filterlrma': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_filterlrma(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'filterlrma'")
        __r__x = list_from_x(__x)
        return __r__x
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_smatrixevd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixevd.restype = ctypes.c_int32
def smatrixevd(a, n, zneeded, isupper):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixevd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__isupper), ctypes.byref(__d), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixevd'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__d, __r__z)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__d)
        x_matrix_clear(__z)


_lib_alglib.alglib_smatrixevdr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixevdr.restype = ctypes.c_int32
def smatrixevdr(a, n, zneeded, isupper, b1, b2):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __b1 = ctypes.c_double(b1)
    __b2 = ctypes.c_double(b2)
    __m = x_int()
    __m.val = 0
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixevdr(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__isupper), ctypes.byref(__b1), ctypes.byref(__b2), ctypes.byref(__m), ctypes.byref(__w), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixevdr'")
        __r__result = __result.value!=0
        __r__m = __m.val
        __r__w = list_from_x(__w)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__m, __r__w, __r__z)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__w)
        x_matrix_clear(__z)


_lib_alglib.alglib_smatrixevdi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixevdi.restype = ctypes.c_int32
def smatrixevdi(a, n, zneeded, isupper, i1, i2):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixevdi(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__isupper), ctypes.byref(__i1), ctypes.byref(__i2), ctypes.byref(__w), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixevdi'")
        __r__result = __result.value!=0
        __r__w = list_from_x(__w)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__w, __r__z)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__w)
        x_matrix_clear(__z)


_lib_alglib.alglib_hmatrixevd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixevd.restype = ctypes.c_int32
def hmatrixevd(a, n, zneeded, isupper):
    pass
    __result = ctypes.c_uint8(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixevd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__isupper), ctypes.byref(__d), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixevd'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__d, __r__z)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__d)
        x_matrix_clear(__z)


_lib_alglib.alglib_hmatrixevdr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixevdr.restype = ctypes.c_int32
def hmatrixevdr(a, n, zneeded, isupper, b1, b2):
    pass
    __result = ctypes.c_uint8(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __b1 = ctypes.c_double(b1)
    __b2 = ctypes.c_double(b2)
    __m = x_int()
    __m.val = 0
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixevdr(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__isupper), ctypes.byref(__b1), ctypes.byref(__b2), ctypes.byref(__m), ctypes.byref(__w), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixevdr'")
        __r__result = __result.value!=0
        __r__m = __m.val
        __r__w = list_from_x(__w)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__m, __r__w, __r__z)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__w)
        x_matrix_clear(__z)


_lib_alglib.alglib_hmatrixevdi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixevdi.restype = ctypes.c_int32
def hmatrixevdi(a, n, zneeded, isupper, i1, i2):
    pass
    __result = ctypes.c_uint8(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixevdi(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__isupper), ctypes.byref(__i1), ctypes.byref(__i2), ctypes.byref(__w), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixevdi'")
        __r__result = __result.value!=0
        __r__w = list_from_x(__w)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__w, __r__z)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__w)
        x_matrix_clear(__z)


_lib_alglib.alglib_smatrixtdevd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixtdevd.restype = ctypes.c_int32
def smatrixtdevd(d, e, n, zneeded, z):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(e):
        raise ValueError("'e' parameter can't be cast to real_vector")
    __e = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    if not is_real_matrix(z):
        raise ValueError("'z' parameter can't be cast to real_matrix")
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        x_from_list(__e, e, DT_REAL, X_CREATE)
        x_from_listlist(__z, z, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixtdevd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__d), ctypes.byref(__e), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixtdevd'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__d, __r__z)
    finally:
        x_vector_clear(__d)
        x_vector_clear(__e)
        x_matrix_clear(__z)


_lib_alglib.alglib_smatrixtdevdr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixtdevdr.restype = ctypes.c_int32
def smatrixtdevdr(d, e, n, zneeded, a, b, z):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(e):
        raise ValueError("'e' parameter can't be cast to real_vector")
    __e = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __m = x_int()
    __m.val = 0
    if not is_real_matrix(z):
        raise ValueError("'z' parameter can't be cast to real_matrix")
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        x_from_list(__e, e, DT_REAL, X_CREATE)
        x_from_listlist(__z, z, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixtdevdr(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__d), ctypes.byref(__e), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixtdevdr'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__m = __m.val
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__d, __r__m, __r__z)
    finally:
        x_vector_clear(__d)
        x_vector_clear(__e)
        x_matrix_clear(__z)


_lib_alglib.alglib_smatrixtdevdi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixtdevdi.restype = ctypes.c_int32
def smatrixtdevdi(d, e, n, zneeded, i1, i2, z):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(e):
        raise ValueError("'e' parameter can't be cast to real_vector")
    __e = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __i2 = x_int()
    __i2.val = int(i2)
    if __i2.val!=i2:
        raise ValueError("Error while converting 'i2' parameter to 'x_int'")
    if not is_real_matrix(z):
        raise ValueError("'z' parameter can't be cast to real_matrix")
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        x_from_list(__e, e, DT_REAL, X_CREATE)
        x_from_listlist(__z, z, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixtdevdi(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__d), ctypes.byref(__e), ctypes.byref(__n), ctypes.byref(__zneeded), ctypes.byref(__i1), ctypes.byref(__i2), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixtdevdi'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__d, __r__z)
    finally:
        x_vector_clear(__d)
        x_vector_clear(__e)
        x_matrix_clear(__z)


_lib_alglib.alglib_rmatrixevd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixevd.restype = ctypes.c_int32
def rmatrixevd(a, n, vneeded):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __vneeded = x_int()
    __vneeded.val = int(vneeded)
    if __vneeded.val!=vneeded:
        raise ValueError("Error while converting 'vneeded' parameter to 'x_int'")
    __wr = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wi = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __vl = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __vr = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixevd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__vneeded), ctypes.byref(__wr), ctypes.byref(__wi), ctypes.byref(__vl), ctypes.byref(__vr))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixevd'")
        __r__result = __result.value!=0
        __r__wr = list_from_x(__wr)
        __r__wi = list_from_x(__wi)
        __r__vl = listlist_from_x(__vl)
        __r__vr = listlist_from_x(__vr)
        return (__r__result, __r__wr, __r__wi, __r__vl, __r__vr)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__wr)
        x_vector_clear(__wi)
        x_matrix_clear(__vl)
        x_matrix_clear(__vr)


_lib_alglib.alglib_rmatrixrndorthogonal.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrndorthogonal.restype = ctypes.c_int32
def rmatrixrndorthogonal(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrndorthogonal(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrndorthogonal'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixrndcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrndcond.restype = ctypes.c_int32
def rmatrixrndcond(n, c):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrndcond(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrndcond'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixrndorthogonal.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrndorthogonal.restype = ctypes.c_int32
def cmatrixrndorthogonal(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrndorthogonal(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrndorthogonal'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixrndcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrndcond.restype = ctypes.c_int32
def cmatrixrndcond(n, c):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrndcond(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrndcond'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_smatrixrndcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixrndcond.restype = ctypes.c_int32
def smatrixrndcond(n, c):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixrndcond(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixrndcond'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_spdmatrixrndcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixrndcond.restype = ctypes.c_int32
def spdmatrixrndcond(n, c):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixrndcond(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixrndcond'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_hmatrixrndcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixrndcond.restype = ctypes.c_int32
def hmatrixrndcond(n, c):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixrndcond(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixrndcond'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_hpdmatrixrndcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixrndcond.restype = ctypes.c_int32
def hpdmatrixrndcond(n, c):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixrndcond(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixrndcond'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixrndorthogonalfromtheright.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrndorthogonalfromtheright.restype = ctypes.c_int32
def rmatrixrndorthogonalfromtheright(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrndorthogonalfromtheright(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrndorthogonalfromtheright'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixrndorthogonalfromtheleft.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrndorthogonalfromtheleft.restype = ctypes.c_int32
def rmatrixrndorthogonalfromtheleft(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrndorthogonalfromtheleft(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrndorthogonalfromtheleft'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixrndorthogonalfromtheright.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrndorthogonalfromtheright.restype = ctypes.c_int32
def cmatrixrndorthogonalfromtheright(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrndorthogonalfromtheright(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrndorthogonalfromtheright'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixrndorthogonalfromtheleft.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrndorthogonalfromtheleft.restype = ctypes.c_int32
def cmatrixrndorthogonalfromtheleft(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrndorthogonalfromtheleft(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrndorthogonalfromtheleft'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_smatrixrndmultiply.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixrndmultiply.restype = ctypes.c_int32
def smatrixrndmultiply(a, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixrndmultiply(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixrndmultiply'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_hmatrixrndmultiply.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hmatrixrndmultiply.restype = ctypes.c_int32
def hmatrixrndmultiply(a, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hmatrixrndmultiply(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hmatrixrndmultiply'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)


_lib_alglib.x_obj_free_sparsematrix.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_sparsematrix.restype = None


class sparsematrix(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_sparsematrix(self.ptr)
_lib_alglib.x_obj_free_sparsebuffers.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_sparsebuffers.restype = None


class sparsebuffers(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_sparsebuffers(self.ptr)
_lib_alglib.alglib_sparsecreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecreate.restype = ctypes.c_int32
def sparsecreate(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        m,n,k = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,n = functionargs
        k = 0
    else:
        raise RuntimeError("Error while calling 'sparsecreate': function must have 2 or 3 parameters")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecreate(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecreate'")
        __r__s = sparsematrix(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_sparsecreatebuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecreatebuf.restype = ctypes.c_int32
def sparsecreatebuf(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        m,n,k,s = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        m,n,s = functionargs
        k = 0
    else:
        raise RuntimeError("Error while calling 'sparsecreatebuf': function must have 3 or 4 parameters")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecreatebuf(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__k), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecreatebuf'")
        return
    finally:
        pass


_lib_alglib.alglib_sparsecreatecrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecreatecrs.restype = ctypes.c_int32
def sparsecreatecrs(m, n, ner):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_int_vector(ner):
        raise ValueError("'ner' parameter can't be cast to int_vector")
    __ner = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __s = ctypes.c_void_p(0)
    try:
        x_from_list(__ner, ner, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecreatecrs(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__ner), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecreatecrs'")
        __r__s = sparsematrix(__s)
        return __r__s
    finally:
        x_vector_clear(__ner)


_lib_alglib.alglib_sparsecreatecrsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecreatecrsbuf.restype = ctypes.c_int32
def sparsecreatecrsbuf(m, n, ner, s):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_int_vector(ner):
        raise ValueError("'ner' parameter can't be cast to int_vector")
    __ner = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __s = s.ptr
    try:
        x_from_list(__ner, ner, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecreatecrsbuf(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__ner), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecreatecrsbuf'")
        return
    finally:
        x_vector_clear(__ner)


_lib_alglib.alglib_sparsecreatesks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecreatesks.restype = ctypes.c_int32
def sparsecreatesks(m, n, d, u):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_int_vector(d):
        raise ValueError("'d' parameter can't be cast to int_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(u):
        raise ValueError("'u' parameter can't be cast to int_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __s = ctypes.c_void_p(0)
    try:
        x_from_list(__d, d, DT_INT, X_CREATE)
        x_from_list(__u, u, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecreatesks(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__d), ctypes.byref(__u), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecreatesks'")
        __r__s = sparsematrix(__s)
        return __r__s
    finally:
        x_vector_clear(__d)
        x_vector_clear(__u)


_lib_alglib.alglib_sparsecreatesksbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecreatesksbuf.restype = ctypes.c_int32
def sparsecreatesksbuf(m, n, d, u, s):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_int_vector(d):
        raise ValueError("'d' parameter can't be cast to int_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(u):
        raise ValueError("'u' parameter can't be cast to int_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __s = s.ptr
    try:
        x_from_list(__d, d, DT_INT, X_CREATE)
        x_from_list(__u, u, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecreatesksbuf(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__d), ctypes.byref(__u), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecreatesksbuf'")
        return
    finally:
        x_vector_clear(__d)
        x_vector_clear(__u)


_lib_alglib.alglib_sparsecopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopy.restype = ctypes.c_int32
def sparsecopy(s0):
    pass
    __s0 = s0.ptr
    __s1 = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopy(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopy'")
        __r__s1 = sparsematrix(__s1)
        return __r__s1
    finally:
        pass


_lib_alglib.alglib_sparsecopybuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopybuf.restype = ctypes.c_int32
def sparsecopybuf(s0, s1):
    pass
    __s0 = s0.ptr
    __s1 = s1.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopybuf(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopybuf'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseswap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseswap.restype = ctypes.c_int32
def sparseswap(s0, s1):
    pass
    __s0 = s0.ptr
    __s1 = s1.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseswap(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseswap'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseadd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseadd.restype = ctypes.c_int32
def sparseadd(s, i, j, v):
    pass
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __j = x_int()
    __j.val = int(j)
    if __j.val!=j:
        raise ValueError("Error while converting 'j' parameter to 'x_int'")
    __v = ctypes.c_double(v)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseadd(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__j), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseadd'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseset.restype = ctypes.c_int32
def sparseset(s, i, j, v):
    pass
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __j = x_int()
    __j.val = int(j)
    if __j.val!=j:
        raise ValueError("Error while converting 'j' parameter to 'x_int'")
    __v = ctypes.c_double(v)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseset(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__j), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseset'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseget.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseget.restype = ctypes.c_int32
def sparseget(s, i, j):
    pass
    __result = ctypes.c_double(0)
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __j = x_int()
    __j.val = int(j)
    if __j.val!=j:
        raise ValueError("Error while converting 'j' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseget(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__j))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseget'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsegetdiagonal.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetdiagonal.restype = ctypes.c_int32
def sparsegetdiagonal(s, i):
    pass
    __result = ctypes.c_double(0)
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetdiagonal(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__i))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetdiagonal'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsemv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsemv.restype = ctypes.c_int32
def sparsemv(s, x, y):
    pass
    __s = s.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsemv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsemv'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_sparsemtv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsemtv.restype = ctypes.c_int32
def sparsemtv(s, x, y):
    pass
    __s = s.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsemtv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsemtv'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_sparsemv2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsemv2.restype = ctypes.c_int32
def sparsemv2(s, x, y0, y1):
    pass
    __s = s.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y0):
        raise ValueError("'y0' parameter can't be cast to real_vector")
    __y0 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y1):
        raise ValueError("'y1' parameter can't be cast to real_vector")
    __y1 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y0, y0, DT_REAL, X_CREATE)
        x_from_list(__y1, y1, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsemv2(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__x), ctypes.byref(__y0), ctypes.byref(__y1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsemv2'")
        __r__y0 = list_from_x(__y0)
        __r__y1 = list_from_x(__y1)
        return (__r__y0, __r__y1)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y0)
        x_vector_clear(__y1)


_lib_alglib.alglib_sparsesmv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsesmv.restype = ctypes.c_int32
def sparsesmv(s, isupper, x, y):
    pass
    __s = s.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsesmv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__isupper), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsesmv'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_sparsevsmv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsevsmv.restype = ctypes.c_int32
def sparsevsmv(s, isupper, x):
    pass
    __result = ctypes.c_double(0)
    __s = s.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsevsmv(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__isupper), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsevsmv'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_sparsemm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsemm.restype = ctypes.c_int32
def sparsemm(s, a, k, b):
    pass
    __s = s.ptr
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsemm(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__a), ctypes.byref(__k), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsemm'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_sparsemtm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsemtm.restype = ctypes.c_int32
def sparsemtm(s, a, k, b):
    pass
    __s = s.ptr
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsemtm(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__a), ctypes.byref(__k), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsemtm'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_sparsemm2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsemm2.restype = ctypes.c_int32
def sparsemm2(s, a, k, b0, b1):
    pass
    __s = s.ptr
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    if not is_real_matrix(b0):
        raise ValueError("'b0' parameter can't be cast to real_matrix")
    __b0 = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(b1):
        raise ValueError("'b1' parameter can't be cast to real_matrix")
    __b1 = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b0, b0, DT_REAL, X_CREATE)
        x_from_listlist(__b1, b1, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsemm2(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__a), ctypes.byref(__k), ctypes.byref(__b0), ctypes.byref(__b1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsemm2'")
        __r__b0 = listlist_from_x(__b0)
        __r__b1 = listlist_from_x(__b1)
        return (__r__b0, __r__b1)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b0)
        x_matrix_clear(__b1)


_lib_alglib.alglib_sparsesmm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsesmm.restype = ctypes.c_int32
def sparsesmm(s, isupper, a, k, b):
    pass
    __s = s.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsesmm(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__isupper), ctypes.byref(__a), ctypes.byref(__k), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsesmm'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_sparsetrmv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsetrmv.restype = ctypes.c_int32
def sparsetrmv(s, isupper, isunit, optype, x, y):
    pass
    __s = s.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsetrmv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsetrmv'")
        __r__x = list_from_x(__x)
        __r__y = list_from_x(__y)
        return (__r__x, __r__y)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_sparsetrsv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsetrsv.restype = ctypes.c_int32
def sparsetrsv(s, isupper, isunit, optype, x):
    pass
    __s = s.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __optype = x_int()
    __optype.val = int(optype)
    if __optype.val!=optype:
        raise ValueError("Error while converting 'optype' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsetrsv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__optype), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsetrsv'")
        __r__x = list_from_x(__x)
        return __r__x
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_sparseresizematrix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseresizematrix.restype = ctypes.c_int32
def sparseresizematrix(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseresizematrix(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseresizematrix'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseenumerate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseenumerate.restype = ctypes.c_int32
def sparseenumerate(s, t0, t1):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    __t0 = x_int()
    __t0.val = int(t0)
    if __t0.val!=t0:
        raise ValueError("Error while converting 't0' parameter to 'x_int'")
    __t1 = x_int()
    __t1.val = int(t1)
    if __t1.val!=t1:
        raise ValueError("Error while converting 't1' parameter to 'x_int'")
    __i = x_int()
    __i.val = 0
    __j = x_int()
    __j.val = 0
    __v = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseenumerate(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__t0), ctypes.byref(__t1), ctypes.byref(__i), ctypes.byref(__j), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseenumerate'")
        __r__result = __result.value!=0
        __r__t0 = __t0.val
        __r__t1 = __t1.val
        __r__i = __i.val
        __r__j = __j.val
        __r__v = __v.value
        return (__r__result, __r__t0, __r__t1, __r__i, __r__j, __r__v)
    finally:
        pass


_lib_alglib.alglib_sparserewriteexisting.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparserewriteexisting.restype = ctypes.c_int32
def sparserewriteexisting(s, i, j, v):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __j = x_int()
    __j.val = int(j)
    if __j.val!=j:
        raise ValueError("Error while converting 'j' parameter to 'x_int'")
    __v = ctypes.c_double(v)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparserewriteexisting(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__j), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparserewriteexisting'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsegetrow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetrow.restype = ctypes.c_int32
def sparsegetrow(s, i, irow):
    pass
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    if not is_real_vector(irow):
        raise ValueError("'irow' parameter can't be cast to real_vector")
    __irow = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__irow, irow, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetrow(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__irow))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetrow'")
        __r__irow = list_from_x(__irow)
        return __r__irow
    finally:
        x_vector_clear(__irow)


_lib_alglib.alglib_sparsegetcompressedrow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetcompressedrow.restype = ctypes.c_int32
def sparsegetcompressedrow(s, i, colidx, vals):
    pass
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    if not is_int_vector(colidx):
        raise ValueError("'colidx' parameter can't be cast to int_vector")
    __colidx = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(vals):
        raise ValueError("'vals' parameter can't be cast to real_vector")
    __vals = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nzcnt = x_int()
    __nzcnt.val = 0
    try:
        x_from_list(__colidx, colidx, DT_INT, X_CREATE)
        x_from_list(__vals, vals, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetcompressedrow(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__colidx), ctypes.byref(__vals), ctypes.byref(__nzcnt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetcompressedrow'")
        __r__colidx = list_from_x(__colidx)
        __r__vals = list_from_x(__vals)
        __r__nzcnt = __nzcnt.val
        return (__r__colidx, __r__vals, __r__nzcnt)
    finally:
        x_vector_clear(__colidx)
        x_vector_clear(__vals)


_lib_alglib.alglib_sparsetransposesks.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsetransposesks.restype = ctypes.c_int32
def sparsetransposesks(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsetransposesks(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsetransposesks'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseconvertto.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseconvertto.restype = ctypes.c_int32
def sparseconvertto(s0, fmt):
    pass
    __s0 = s0.ptr
    __fmt = x_int()
    __fmt.val = int(fmt)
    if __fmt.val!=fmt:
        raise ValueError("Error while converting 'fmt' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseconvertto(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__fmt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseconvertto'")
        return
    finally:
        pass


_lib_alglib.alglib_sparsecopytobuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytobuf.restype = ctypes.c_int32
def sparsecopytobuf(s0, fmt, s1):
    pass
    __s0 = s0.ptr
    __fmt = x_int()
    __fmt.val = int(fmt)
    if __fmt.val!=fmt:
        raise ValueError("Error while converting 'fmt' parameter to 'x_int'")
    __s1 = s1.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytobuf(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__fmt), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytobuf'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseconverttohash.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseconverttohash.restype = ctypes.c_int32
def sparseconverttohash(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseconverttohash(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseconverttohash'")
        return
    finally:
        pass


_lib_alglib.alglib_sparsecopytohash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytohash.restype = ctypes.c_int32
def sparsecopytohash(s0):
    pass
    __s0 = s0.ptr
    __s1 = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytohash(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytohash'")
        __r__s1 = sparsematrix(__s1)
        return __r__s1
    finally:
        pass


_lib_alglib.alglib_sparsecopytohashbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytohashbuf.restype = ctypes.c_int32
def sparsecopytohashbuf(s0, s1):
    pass
    __s0 = s0.ptr
    __s1 = s1.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytohashbuf(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytohashbuf'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseconverttocrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseconverttocrs.restype = ctypes.c_int32
def sparseconverttocrs(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseconverttocrs(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseconverttocrs'")
        return
    finally:
        pass


_lib_alglib.alglib_sparsecopytocrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytocrs.restype = ctypes.c_int32
def sparsecopytocrs(s0):
    pass
    __s0 = s0.ptr
    __s1 = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytocrs(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytocrs'")
        __r__s1 = sparsematrix(__s1)
        return __r__s1
    finally:
        pass


_lib_alglib.alglib_sparsecopytocrsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytocrsbuf.restype = ctypes.c_int32
def sparsecopytocrsbuf(s0, s1):
    pass
    __s0 = s0.ptr
    __s1 = s1.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytocrsbuf(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytocrsbuf'")
        return
    finally:
        pass


_lib_alglib.alglib_sparseconverttosks.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseconverttosks.restype = ctypes.c_int32
def sparseconverttosks(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseconverttosks(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseconverttosks'")
        return
    finally:
        pass


_lib_alglib.alglib_sparsecopytosks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytosks.restype = ctypes.c_int32
def sparsecopytosks(s0):
    pass
    __s0 = s0.ptr
    __s1 = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytosks(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytosks'")
        __r__s1 = sparsematrix(__s1)
        return __r__s1
    finally:
        pass


_lib_alglib.alglib_sparsecopytosksbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecopytosksbuf.restype = ctypes.c_int32
def sparsecopytosksbuf(s0, s1):
    pass
    __s0 = s0.ptr
    __s1 = s1.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecopytosksbuf(ctypes.byref(_error_msg), ctypes.byref(__s0), ctypes.byref(__s1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecopytosksbuf'")
        return
    finally:
        pass


_lib_alglib.alglib_sparsegetmatrixtype.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetmatrixtype.restype = ctypes.c_int32
def sparsegetmatrixtype(s):
    pass
    __result = x_int()
    __result.val = 0
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetmatrixtype(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetmatrixtype'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparseishash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseishash.restype = ctypes.c_int32
def sparseishash(s):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseishash(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseishash'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparseiscrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseiscrs.restype = ctypes.c_int32
def sparseiscrs(s):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseiscrs(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseiscrs'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparseissks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparseissks.restype = ctypes.c_int32
def sparseissks(s):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparseissks(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparseissks'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsefree.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsefree.restype = ctypes.c_int32
def sparsefree():
    pass
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsefree(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsefree'")
        __r__s = sparsematrix(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_sparsegetnrows.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetnrows.restype = ctypes.c_int32
def sparsegetnrows(s):
    pass
    __result = x_int()
    __result.val = 0
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetnrows(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetnrows'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsegetncols.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetncols.restype = ctypes.c_int32
def sparsegetncols(s):
    pass
    __result = x_int()
    __result.val = 0
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetncols(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetncols'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsegetuppercount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetuppercount.restype = ctypes.c_int32
def sparsegetuppercount(s):
    pass
    __result = x_int()
    __result.val = 0
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetuppercount(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetuppercount'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sparsegetlowercount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsegetlowercount.restype = ctypes.c_int32
def sparsegetlowercount(s):
    pass
    __result = x_int()
    __result.val = 0
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsegetlowercount(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsegetlowercount'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_rmatrixlu.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlu.restype = ctypes.c_int32
def rmatrixlu(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __pivots = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlu(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__pivots))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlu'")
        __r__a = listlist_from_x(__a)
        __r__pivots = list_from_x(__pivots)
        return (__r__a, __r__pivots)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)


_lib_alglib.alglib_smp_rmatrixlu.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixlu.restype = ctypes.c_int32
def smp_rmatrixlu(a, m, n):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __pivots = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixlu(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__pivots))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixlu'")
        __r__a = listlist_from_x(__a)
        __r__pivots = list_from_x(__pivots)
        return (__r__a, __r__pivots)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)


_lib_alglib.alglib_cmatrixlu.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlu.restype = ctypes.c_int32
def cmatrixlu(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __pivots = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlu(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__pivots))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlu'")
        __r__a = listlist_from_x(__a)
        __r__pivots = list_from_x(__pivots)
        return (__r__a, __r__pivots)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)


_lib_alglib.alglib_smp_cmatrixlu.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixlu.restype = ctypes.c_int32
def smp_cmatrixlu(a, m, n):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __pivots = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixlu(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__pivots))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixlu'")
        __r__a = listlist_from_x(__a)
        __r__pivots = list_from_x(__pivots)
        return (__r__a, __r__pivots)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)


_lib_alglib.alglib_hpdmatrixcholesky.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholesky.restype = ctypes.c_int32
def hpdmatrixcholesky(a, n, isupper):
    pass
    __result = ctypes.c_uint8(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholesky(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholesky'")
        __r__result = __result.value!=0
        __r__a = listlist_from_x(__a)
        return (__r__result, __r__a)
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_smp_hpdmatrixcholesky.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixcholesky.restype = ctypes.c_int32
def smp_hpdmatrixcholesky(a, n, isupper):
    pass
    __result = ctypes.c_uint8(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixcholesky(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixcholesky'")
        __r__result = __result.value!=0
        __r__a = listlist_from_x(__a)
        return (__r__result, __r__a)
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_spdmatrixcholesky.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholesky.restype = ctypes.c_int32
def spdmatrixcholesky(a, n, isupper):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholesky(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholesky'")
        __r__result = __result.value!=0
        __r__a = listlist_from_x(__a)
        return (__r__result, __r__a)
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_smp_spdmatrixcholesky.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixcholesky.restype = ctypes.c_int32
def smp_spdmatrixcholesky(a, n, isupper):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixcholesky(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixcholesky'")
        __r__result = __result.value!=0
        __r__a = listlist_from_x(__a)
        return (__r__result, __r__a)
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_spdmatrixcholeskyupdateadd1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskyupdateadd1.restype = ctypes.c_int32
def spdmatrixcholeskyupdateadd1(a, n, isupper, u):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(u):
        raise ValueError("'u' parameter can't be cast to real_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__u, u, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskyupdateadd1(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__u))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskyupdateadd1'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__u)


_lib_alglib.alglib_spdmatrixcholeskyupdatefix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskyupdatefix.restype = ctypes.c_int32
def spdmatrixcholeskyupdatefix(a, n, isupper, fix):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_bool_vector(fix):
        raise ValueError("'fix' parameter can't be cast to bool_vector")
    __fix = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__fix, fix, DT_BOOL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskyupdatefix(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__fix))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskyupdatefix'")
        __r__a = listlist_from_x(__a)
        return __r__a
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__fix)


_lib_alglib.alglib_spdmatrixcholeskyupdateadd1buf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskyupdateadd1buf.restype = ctypes.c_int32
def spdmatrixcholeskyupdateadd1buf(a, n, isupper, u, bufr):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(u):
        raise ValueError("'u' parameter can't be cast to real_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bufr):
        raise ValueError("'bufr' parameter can't be cast to real_vector")
    __bufr = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__u, u, DT_REAL, X_CREATE)
        x_from_list(__bufr, bufr, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskyupdateadd1buf(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__u), ctypes.byref(__bufr))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskyupdateadd1buf'")
        __r__a = listlist_from_x(__a)
        __r__bufr = list_from_x(__bufr)
        return (__r__a, __r__bufr)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__u)
        x_vector_clear(__bufr)


_lib_alglib.alglib_spdmatrixcholeskyupdatefixbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskyupdatefixbuf.restype = ctypes.c_int32
def spdmatrixcholeskyupdatefixbuf(a, n, isupper, fix, bufr):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_bool_vector(fix):
        raise ValueError("'fix' parameter can't be cast to bool_vector")
    __fix = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bufr):
        raise ValueError("'bufr' parameter can't be cast to real_vector")
    __bufr = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__fix, fix, DT_BOOL, X_CREATE)
        x_from_list(__bufr, bufr, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskyupdatefixbuf(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__fix), ctypes.byref(__bufr))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskyupdatefixbuf'")
        __r__a = listlist_from_x(__a)
        __r__bufr = list_from_x(__bufr)
        return (__r__a, __r__bufr)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__fix)
        x_vector_clear(__bufr)


_lib_alglib.alglib_sparsecholeskyskyline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sparsecholeskyskyline.restype = ctypes.c_int32
def sparsecholeskyskyline(a, n, isupper):
    pass
    __result = ctypes.c_uint8(0)
    __a = a.ptr
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sparsecholeskyskyline(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sparsecholeskyskyline'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_rmatrixrcond1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrcond1.restype = ctypes.c_int32
def rmatrixrcond1(a, n):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrcond1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrcond1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixrcondinf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixrcondinf.restype = ctypes.c_int32
def rmatrixrcondinf(a, n):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixrcondinf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixrcondinf'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_spdmatrixrcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixrcond.restype = ctypes.c_int32
def spdmatrixrcond(a, n, isupper):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixrcond(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixrcond'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixtrrcond1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixtrrcond1.restype = ctypes.c_int32
def rmatrixtrrcond1(a, n, isupper, isunit):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixtrrcond1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixtrrcond1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixtrrcondinf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixtrrcondinf.restype = ctypes.c_int32
def rmatrixtrrcondinf(a, n, isupper, isunit):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixtrrcondinf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixtrrcondinf'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_hpdmatrixrcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixrcond.restype = ctypes.c_int32
def hpdmatrixrcond(a, n, isupper):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixrcond(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixrcond'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixrcond1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrcond1.restype = ctypes.c_int32
def cmatrixrcond1(a, n):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrcond1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrcond1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixrcondinf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixrcondinf.restype = ctypes.c_int32
def cmatrixrcondinf(a, n):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixrcondinf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixrcondinf'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_rmatrixlurcond1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlurcond1.restype = ctypes.c_int32
def rmatrixlurcond1(lua, n):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlurcond1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lua), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlurcond1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__lua)


_lib_alglib.alglib_rmatrixlurcondinf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlurcondinf.restype = ctypes.c_int32
def rmatrixlurcondinf(lua, n):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlurcondinf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lua), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlurcondinf'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__lua)


_lib_alglib.alglib_spdmatrixcholeskyrcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskyrcond.restype = ctypes.c_int32
def spdmatrixcholeskyrcond(a, n, isupper):
    pass
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskyrcond(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskyrcond'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_hpdmatrixcholeskyrcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholeskyrcond.restype = ctypes.c_int32
def hpdmatrixcholeskyrcond(a, n, isupper):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholeskyrcond(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholeskyrcond'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixlurcond1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlurcond1.restype = ctypes.c_int32
def cmatrixlurcond1(lua, n):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlurcond1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lua), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlurcond1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__lua)


_lib_alglib.alglib_cmatrixlurcondinf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlurcondinf.restype = ctypes.c_int32
def cmatrixlurcondinf(lua, n):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlurcondinf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lua), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlurcondinf'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__lua)


_lib_alglib.alglib_cmatrixtrrcond1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixtrrcond1.restype = ctypes.c_int32
def cmatrixtrrcond1(a, n, isupper, isunit):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixtrrcond1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixtrrcond1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixtrrcondinf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixtrrcondinf.restype = ctypes.c_int32
def cmatrixtrrcondinf(a, n, isupper, isunit):
    pass
    __result = ctypes.c_double(0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixtrrcondinf(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixtrrcondinf'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)




class x_matinvreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("r1", ctypes.c_double),
        ("rinf", ctypes.c_double)
        ]




class matinvreport(object):
    def __init__(self):
        self.r1 = 0
        self.rinf = 0


def x_matinvreport_zero_fields(x):
    x.r1 = 0
    x.rinf = 0
    return




def x_matinvreport_clear(x):
    x_matinvreport_zero_fields(x)
    return




def x_from_matinvreport(x,v):
    x.r1 = float(v.r1)
    x.rinf = float(v.rinf)
    return




def matinvreport_from_x(x):
    r = matinvreport()
    r.r1 = x.r1
    r.rinf = x.rinf
    return r


_lib_alglib.alglib_rmatrixluinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixluinverse.restype = ctypes.c_int32
def rmatrixluinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,pivots,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,pivots = functionargs
        if safe_cols("'rmatrixluinverse': incorrect parameters",a)!=safe_rows("'rmatrixluinverse': incorrect parameters",a) or safe_cols("'rmatrixluinverse': incorrect parameters",a)!=safe_len("'rmatrixluinverse': incorrect parameters",pivots):
            raise RuntimeError("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size")
        n = safe_cols("'rmatrixluinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'rmatrixluinverse': function must have 2 or 3 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(pivots):
        raise ValueError("'pivots' parameter can't be cast to int_vector")
    __pivots = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__pivots, pivots, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixluinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__pivots), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixluinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_rmatrixluinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixluinverse.restype = ctypes.c_int32
def smp_rmatrixluinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,pivots,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,pivots = functionargs
        if safe_cols("'smp_rmatrixluinverse': incorrect parameters",a)!=safe_rows("'smp_rmatrixluinverse': incorrect parameters",a) or safe_cols("'smp_rmatrixluinverse': incorrect parameters",a)!=safe_len("'smp_rmatrixluinverse': incorrect parameters",pivots):
            raise RuntimeError("Error while calling 'smp_rmatrixluinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_rmatrixluinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'smp_rmatrixluinverse': function must have 2 or 3 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(pivots):
        raise ValueError("'pivots' parameter can't be cast to int_vector")
    __pivots = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__pivots, pivots, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixluinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__pivots), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixluinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_rmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixinverse.restype = ctypes.c_int32
def rmatrixinverse(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'rmatrixinverse': incorrect parameters",a)!=safe_rows("'rmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'rmatrixinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'rmatrixinverse': function must have 1 or 2 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_rmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixinverse.restype = ctypes.c_int32
def smp_rmatrixinverse(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'smp_rmatrixinverse': incorrect parameters",a)!=safe_rows("'smp_rmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_rmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_rmatrixinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'smp_rmatrixinverse': function must have 1 or 2 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_cmatrixluinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixluinverse.restype = ctypes.c_int32
def cmatrixluinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,pivots,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,pivots = functionargs
        if safe_cols("'cmatrixluinverse': incorrect parameters",a)!=safe_rows("'cmatrixluinverse': incorrect parameters",a) or safe_cols("'cmatrixluinverse': incorrect parameters",a)!=safe_len("'cmatrixluinverse': incorrect parameters",pivots):
            raise RuntimeError("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size")
        n = safe_cols("'cmatrixluinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'cmatrixluinverse': function must have 2 or 3 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(pivots):
        raise ValueError("'pivots' parameter can't be cast to int_vector")
    __pivots = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__pivots, pivots, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixluinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__pivots), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixluinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_cmatrixluinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixluinverse.restype = ctypes.c_int32
def smp_cmatrixluinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,pivots,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,pivots = functionargs
        if safe_cols("'smp_cmatrixluinverse': incorrect parameters",a)!=safe_rows("'smp_cmatrixluinverse': incorrect parameters",a) or safe_cols("'smp_cmatrixluinverse': incorrect parameters",a)!=safe_len("'smp_cmatrixluinverse': incorrect parameters",pivots):
            raise RuntimeError("Error while calling 'smp_cmatrixluinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_cmatrixluinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'smp_cmatrixluinverse': function must have 2 or 3 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(pivots):
        raise ValueError("'pivots' parameter can't be cast to int_vector")
    __pivots = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__pivots, pivots, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixluinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__pivots), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixluinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_cmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixinverse.restype = ctypes.c_int32
def cmatrixinverse(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'cmatrixinverse': incorrect parameters",a)!=safe_rows("'cmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'cmatrixinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'cmatrixinverse': function must have 1 or 2 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_cmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixinverse.restype = ctypes.c_int32
def smp_cmatrixinverse(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'smp_cmatrixinverse': incorrect parameters",a)!=safe_rows("'smp_cmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_cmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_cmatrixinverse': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'smp_cmatrixinverse': function must have 1 or 2 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_spdmatrixcholeskyinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskyinverse.restype = ctypes.c_int32
def spdmatrixcholeskyinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'spdmatrixcholeskyinverse': incorrect parameters",a)!=safe_rows("'spdmatrixcholeskyinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size")
        n = safe_cols("'spdmatrixcholeskyinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'spdmatrixcholeskyinverse': function must have 1 or 3 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskyinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskyinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_spdmatrixcholeskyinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixcholeskyinverse.restype = ctypes.c_int32
def smp_spdmatrixcholeskyinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'smp_spdmatrixcholeskyinverse': incorrect parameters",a)!=safe_rows("'smp_spdmatrixcholeskyinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_spdmatrixcholeskyinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_spdmatrixcholeskyinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'smp_spdmatrixcholeskyinverse': function must have 1 or 3 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixcholeskyinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixcholeskyinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_spdmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixinverse.restype = ctypes.c_int32
def spdmatrixinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'spdmatrixinverse': incorrect parameters",a)!=safe_rows("'spdmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'spdmatrixinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'spdmatrixinverse': function must have 1 or 3 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to symmetric")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        if __friendly_form:
            if not x_is_symmetric(__a):
                raise ValueError("'a' parameter is not symmetric matrix")
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixinverse'")
        if __friendly_form:
            if not x_force_symmetric(__a):
                raise RuntimeError("Internal error while forcing symmetricity of 'a' parameter")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_spdmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixinverse.restype = ctypes.c_int32
def smp_spdmatrixinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'smp_spdmatrixinverse': incorrect parameters",a)!=safe_rows("'smp_spdmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_spdmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_spdmatrixinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'smp_spdmatrixinverse': function must have 1 or 3 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to symmetric")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        if __friendly_form:
            if not x_is_symmetric(__a):
                raise ValueError("'a' parameter is not symmetric matrix")
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixinverse'")
        if __friendly_form:
            if not x_force_symmetric(__a):
                raise RuntimeError("Internal error while forcing symmetricity of 'a' parameter")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_hpdmatrixcholeskyinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholeskyinverse.restype = ctypes.c_int32
def hpdmatrixcholeskyinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'hpdmatrixcholeskyinverse': incorrect parameters",a)!=safe_rows("'hpdmatrixcholeskyinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size")
        n = safe_cols("'hpdmatrixcholeskyinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'hpdmatrixcholeskyinverse': function must have 1 or 3 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholeskyinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholeskyinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_hpdmatrixcholeskyinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixcholeskyinverse.restype = ctypes.c_int32
def smp_hpdmatrixcholeskyinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'smp_hpdmatrixcholeskyinverse': incorrect parameters",a)!=safe_rows("'smp_hpdmatrixcholeskyinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_hpdmatrixcholeskyinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_hpdmatrixcholeskyinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'smp_hpdmatrixcholeskyinverse': function must have 1 or 3 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixcholeskyinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixcholeskyinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_hpdmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixinverse.restype = ctypes.c_int32
def hpdmatrixinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'hpdmatrixinverse': incorrect parameters",a)!=safe_rows("'hpdmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'hpdmatrixinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'hpdmatrixinverse': function must have 1 or 3 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to hermitian")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        if __friendly_form:
            if not x_is_hermitian(__a):
                raise ValueError("'a' parameter is not Hermitian matrix")
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixinverse'")
        if __friendly_form:
            if not x_force_hermitian(__a):
                raise RuntimeError("Internal error while forcing Hermitian properties of 'a' parameter")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_hpdmatrixinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixinverse.restype = ctypes.c_int32
def smp_hpdmatrixinverse(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_cols("'smp_hpdmatrixinverse': incorrect parameters",a)!=safe_rows("'smp_hpdmatrixinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_hpdmatrixinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_hpdmatrixinverse': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'smp_hpdmatrixinverse': function must have 1 or 3 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to hermitian")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        if __friendly_form:
            if not x_is_hermitian(__a):
                raise ValueError("'a' parameter is not Hermitian matrix")
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixinverse'")
        if __friendly_form:
            if not x_force_hermitian(__a):
                raise RuntimeError("Internal error while forcing Hermitian properties of 'a' parameter")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_rmatrixtrinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixtrinverse.restype = ctypes.c_int32
def rmatrixtrinverse(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,n,isupper,isunit = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,isupper = functionargs
        if safe_cols("'rmatrixtrinverse': incorrect parameters",a)!=safe_rows("'rmatrixtrinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size")
        n = safe_cols("'rmatrixtrinverse': incorrect parameters",a)
        isunit = False
    else:
        raise RuntimeError("Error while calling 'rmatrixtrinverse': function must have 2 or 4 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixtrinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixtrinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_rmatrixtrinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixtrinverse.restype = ctypes.c_int32
def smp_rmatrixtrinverse(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,n,isupper,isunit = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,isupper = functionargs
        if safe_cols("'smp_rmatrixtrinverse': incorrect parameters",a)!=safe_rows("'smp_rmatrixtrinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_rmatrixtrinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_rmatrixtrinverse': incorrect parameters",a)
        isunit = False
    else:
        raise RuntimeError("Error while calling 'smp_rmatrixtrinverse': function must have 2 or 4 parameters")
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixtrinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixtrinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_cmatrixtrinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixtrinverse.restype = ctypes.c_int32
def cmatrixtrinverse(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,n,isupper,isunit = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,isupper = functionargs
        if safe_cols("'cmatrixtrinverse': incorrect parameters",a)!=safe_rows("'cmatrixtrinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size")
        n = safe_cols("'cmatrixtrinverse': incorrect parameters",a)
        isunit = False
    else:
        raise RuntimeError("Error while calling 'cmatrixtrinverse': function must have 2 or 4 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixtrinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixtrinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_smp_cmatrixtrinverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixtrinverse.restype = ctypes.c_int32
def smp_cmatrixtrinverse(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,n,isupper,isunit = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,isupper = functionargs
        if safe_cols("'smp_cmatrixtrinverse': incorrect parameters",a)!=safe_rows("'smp_cmatrixtrinverse': incorrect parameters",a):
            raise RuntimeError("Error while calling 'smp_cmatrixtrinverse': looks like one of arguments has wrong size")
        n = safe_cols("'smp_cmatrixtrinverse': incorrect parameters",a)
        isunit = False
    else:
        raise RuntimeError("Error while calling 'smp_cmatrixtrinverse': function must have 2 or 4 parameters")
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    __isunit = ctypes.c_uint8(isunit)
    if __isunit.value!=0:
        __isunit = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_matinvreport()
    x_matinvreport_zero_fields(__rep)
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixtrinverse(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__isunit), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixtrinverse'")
        __r__a = listlist_from_x(__a)
        __r__info = __info.val
        __r__rep = matinvreport_from_x(__rep)
        return (__r__a, __r__info, __r__rep)
    finally:
        x_matrix_clear(__a)
        x_matinvreport_clear(__rep)


_lib_alglib.alglib_fisherlda.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fisherlda.restype = ctypes.c_int32
def fisherlda(xy, npoints, nvars, nclasses):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fisherlda(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__info), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fisherlda'")
        __r__info = __info.val
        __r__w = list_from_x(__w)
        return (__r__info, __r__w)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__w)


_lib_alglib.alglib_fisherldan.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fisherldan.restype = ctypes.c_int32
def fisherldan(xy, npoints, nvars, nclasses):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __w = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fisherldan(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__info), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fisherldan'")
        __r__info = __info.val
        __r__w = listlist_from_x(__w)
        return (__r__info, __r__w)
    finally:
        x_matrix_clear(__xy)
        x_matrix_clear(__w)


_lib_alglib.alglib_smp_fisherldan.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_fisherldan.restype = ctypes.c_int32
def smp_fisherldan(xy, npoints, nvars, nclasses):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __w = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_fisherldan(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__info), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_fisherldan'")
        __r__info = __info.val
        __r__w = listlist_from_x(__w)
        return (__r__info, __r__w)
    finally:
        x_matrix_clear(__xy)
        x_matrix_clear(__w)




class x_modelerrors(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("relclserror", ctypes.c_double),
        ("avgce", ctypes.c_double),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double)
        ]




class modelerrors(object):
    def __init__(self):
        self.relclserror = 0
        self.avgce = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0


def x_modelerrors_zero_fields(x):
    x.relclserror = 0
    x.avgce = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    return




def x_modelerrors_clear(x):
    x_modelerrors_zero_fields(x)
    return




def x_from_modelerrors(x,v):
    x.relclserror = float(v.relclserror)
    x.avgce = float(v.avgce)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    return




def modelerrors_from_x(x):
    r = modelerrors()
    r.relclserror = x.relclserror
    r.avgce = x.avgce
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    return r


_lib_alglib.x_obj_free_multilayerperceptron.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_multilayerperceptron.restype = None


class multilayerperceptron(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_multilayerperceptron(self.ptr)
_lib_alglib.alglib_mlpserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpserialize.restype = ctypes.c_int32

def mlpserialize(obj):
    error_msg = ctypes.c_char_p(0)
    _s_out = ctypes.c_char_p(0)
    retval = _lib_alglib.alglib_mlpserialize(ctypes.byref(error_msg), ctypes.byref(obj.ptr), ctypes.byref(_s_out))
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'mlpserialize'")
    s_out = _s_out.value
    _lib_alglib.x_free(_s_out)
    return s_out

_lib_alglib.alglib_mlpunserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpunserialize.restype = ctypes.c_int32

def mlpunserialize(s_in):
    error_msg = ctypes.c_char_p(0)
    _s_in = ctypes.c_char_p(s_in)
    _obj = ctypes.c_void_p(0)
    retval = _lib_alglib.alglib_mlpunserialize(ctypes.byref(error_msg), ctypes.byref(_s_in), ctypes.byref(_obj), )
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'mlpserialize'")
    return multilayerperceptron(_obj)

_lib_alglib.alglib_mlpcreate0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreate0.restype = ctypes.c_int32
def mlpcreate0(nin, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreate0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreate0'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreate1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreate1.restype = ctypes.c_int32
def mlpcreate1(nin, nhid, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreate1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreate1'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreate2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreate2.restype = ctypes.c_int32
def mlpcreate2(nin, nhid1, nhid2, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreate2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreate2'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreateb0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreateb0.restype = ctypes.c_int32
def mlpcreateb0(nin, nout, b, d):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __b = ctypes.c_double(b)
    __d = ctypes.c_double(d)
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreateb0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__b), ctypes.byref(__d), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreateb0'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreateb1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreateb1.restype = ctypes.c_int32
def mlpcreateb1(nin, nhid, nout, b, d):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __b = ctypes.c_double(b)
    __d = ctypes.c_double(d)
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreateb1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__b), ctypes.byref(__d), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreateb1'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreateb2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreateb2.restype = ctypes.c_int32
def mlpcreateb2(nin, nhid1, nhid2, nout, b, d):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __b = ctypes.c_double(b)
    __d = ctypes.c_double(d)
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreateb2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__b), ctypes.byref(__d), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreateb2'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreater0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreater0.restype = ctypes.c_int32
def mlpcreater0(nin, nout, a, b):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreater0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreater0'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreater1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreater1.restype = ctypes.c_int32
def mlpcreater1(nin, nhid, nout, a, b):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreater1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreater1'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreater2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreater2.restype = ctypes.c_int32
def mlpcreater2(nin, nhid1, nhid2, nout, a, b):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreater2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreater2'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreatec0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreatec0.restype = ctypes.c_int32
def mlpcreatec0(nin, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreatec0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreatec0'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreatec1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreatec1.restype = ctypes.c_int32
def mlpcreatec1(nin, nhid, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreatec1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreatec1'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcreatec2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreatec2.restype = ctypes.c_int32
def mlpcreatec2(nin, nhid1, nhid2, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __network = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreatec2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreatec2'")
        __r__network = multilayerperceptron(__network)
        return __r__network
    finally:
        pass


_lib_alglib.alglib_mlpcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcopy.restype = ctypes.c_int32
def mlpcopy(network1):
    pass
    __network1 = network1.ptr
    __network2 = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcopy(ctypes.byref(_error_msg), ctypes.byref(__network1), ctypes.byref(__network2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcopy'")
        __r__network2 = multilayerperceptron(__network2)
        return __r__network2
    finally:
        pass


_lib_alglib.alglib_mlpcopytunableparameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcopytunableparameters.restype = ctypes.c_int32
def mlpcopytunableparameters(network1, network2):
    pass
    __network1 = network1.ptr
    __network2 = network2.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcopytunableparameters(ctypes.byref(_error_msg), ctypes.byref(__network1), ctypes.byref(__network2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcopytunableparameters'")
        return
    finally:
        pass


_lib_alglib.alglib_mlprandomize.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlprandomize.restype = ctypes.c_int32
def mlprandomize(network):
    pass
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlprandomize(ctypes.byref(_error_msg), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlprandomize'")
        return
    finally:
        pass


_lib_alglib.alglib_mlprandomizefull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlprandomizefull.restype = ctypes.c_int32
def mlprandomizefull(network):
    pass
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlprandomizefull(ctypes.byref(_error_msg), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlprandomizefull'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpinitpreprocessor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpinitpreprocessor.restype = ctypes.c_int32
def mlpinitpreprocessor(network, xy, ssize):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpinitpreprocessor(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpinitpreprocessor'")
        return
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpproperties.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpproperties.restype = ctypes.c_int32
def mlpproperties(network):
    pass
    __network = network.ptr
    __nin = x_int()
    __nin.val = 0
    __nout = x_int()
    __nout.val = 0
    __wcount = x_int()
    __wcount.val = 0
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpproperties(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__wcount))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpproperties'")
        __r__nin = __nin.val
        __r__nout = __nout.val
        __r__wcount = __wcount.val
        return (__r__nin, __r__nout, __r__wcount)
    finally:
        pass


_lib_alglib.alglib_mlpgetinputscount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetinputscount.restype = ctypes.c_int32
def mlpgetinputscount(network):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetinputscount(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetinputscount'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpgetoutputscount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetoutputscount.restype = ctypes.c_int32
def mlpgetoutputscount(network):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetoutputscount(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetoutputscount'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpgetweightscount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetweightscount.restype = ctypes.c_int32
def mlpgetweightscount(network):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetweightscount(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetweightscount'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpissoftmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpissoftmax.restype = ctypes.c_int32
def mlpissoftmax(network):
    pass
    __result = ctypes.c_uint8(0)
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpissoftmax(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpissoftmax'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpgetlayerscount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetlayerscount.restype = ctypes.c_int32
def mlpgetlayerscount(network):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetlayerscount(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetlayerscount'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpgetlayersize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetlayersize.restype = ctypes.c_int32
def mlpgetlayersize(network, k):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetlayersize(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetlayersize'")
        __r__result = __result.val
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpgetinputscaling.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetinputscaling.restype = ctypes.c_int32
def mlpgetinputscaling(network, i):
    pass
    __network = network.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __mean = ctypes.c_double(0)
    __sigma = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetinputscaling(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__i), ctypes.byref(__mean), ctypes.byref(__sigma))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetinputscaling'")
        __r__mean = __mean.value
        __r__sigma = __sigma.value
        return (__r__mean, __r__sigma)
    finally:
        pass


_lib_alglib.alglib_mlpgetoutputscaling.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetoutputscaling.restype = ctypes.c_int32
def mlpgetoutputscaling(network, i):
    pass
    __network = network.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __mean = ctypes.c_double(0)
    __sigma = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetoutputscaling(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__i), ctypes.byref(__mean), ctypes.byref(__sigma))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetoutputscaling'")
        __r__mean = __mean.value
        __r__sigma = __sigma.value
        return (__r__mean, __r__sigma)
    finally:
        pass


_lib_alglib.alglib_mlpgetneuroninfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetneuroninfo.restype = ctypes.c_int32
def mlpgetneuroninfo(network, k, i):
    pass
    __network = network.ptr
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __fkind = x_int()
    __fkind.val = 0
    __threshold = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetneuroninfo(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__k), ctypes.byref(__i), ctypes.byref(__fkind), ctypes.byref(__threshold))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetneuroninfo'")
        __r__fkind = __fkind.val
        __r__threshold = __threshold.value
        return (__r__fkind, __r__threshold)
    finally:
        pass


_lib_alglib.alglib_mlpgetweight.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgetweight.restype = ctypes.c_int32
def mlpgetweight(network, k0, i0, k1, i1):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __k0 = x_int()
    __k0.val = int(k0)
    if __k0.val!=k0:
        raise ValueError("Error while converting 'k0' parameter to 'x_int'")
    __i0 = x_int()
    __i0.val = int(i0)
    if __i0.val!=i0:
        raise ValueError("Error while converting 'i0' parameter to 'x_int'")
    __k1 = x_int()
    __k1.val = int(k1)
    if __k1.val!=k1:
        raise ValueError("Error while converting 'k1' parameter to 'x_int'")
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgetweight(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__k0), ctypes.byref(__i0), ctypes.byref(__k1), ctypes.byref(__i1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgetweight'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpsetinputscaling.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetinputscaling.restype = ctypes.c_int32
def mlpsetinputscaling(network, i, mean, sigma):
    pass
    __network = network.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __mean = ctypes.c_double(mean)
    __sigma = ctypes.c_double(sigma)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetinputscaling(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__i), ctypes.byref(__mean), ctypes.byref(__sigma))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetinputscaling'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpsetoutputscaling.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetoutputscaling.restype = ctypes.c_int32
def mlpsetoutputscaling(network, i, mean, sigma):
    pass
    __network = network.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __mean = ctypes.c_double(mean)
    __sigma = ctypes.c_double(sigma)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetoutputscaling(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__i), ctypes.byref(__mean), ctypes.byref(__sigma))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetoutputscaling'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpsetneuroninfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetneuroninfo.restype = ctypes.c_int32
def mlpsetneuroninfo(network, k, i, fkind, threshold):
    pass
    __network = network.ptr
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __fkind = x_int()
    __fkind.val = int(fkind)
    if __fkind.val!=fkind:
        raise ValueError("Error while converting 'fkind' parameter to 'x_int'")
    __threshold = ctypes.c_double(threshold)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetneuroninfo(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__k), ctypes.byref(__i), ctypes.byref(__fkind), ctypes.byref(__threshold))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetneuroninfo'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpsetweight.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetweight.restype = ctypes.c_int32
def mlpsetweight(network, k0, i0, k1, i1, w):
    pass
    __network = network.ptr
    __k0 = x_int()
    __k0.val = int(k0)
    if __k0.val!=k0:
        raise ValueError("Error while converting 'k0' parameter to 'x_int'")
    __i0 = x_int()
    __i0.val = int(i0)
    if __i0.val!=i0:
        raise ValueError("Error while converting 'i0' parameter to 'x_int'")
    __k1 = x_int()
    __k1.val = int(k1)
    if __k1.val!=k1:
        raise ValueError("Error while converting 'k1' parameter to 'x_int'")
    __i1 = x_int()
    __i1.val = int(i1)
    if __i1.val!=i1:
        raise ValueError("Error while converting 'i1' parameter to 'x_int'")
    __w = ctypes.c_double(w)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetweight(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__k0), ctypes.byref(__i0), ctypes.byref(__k1), ctypes.byref(__i1), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetweight'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpactivationfunction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpactivationfunction.restype = ctypes.c_int32
def mlpactivationfunction(net, k):
    pass
    __net = ctypes.c_double(net)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __f = ctypes.c_double(0)
    __df = ctypes.c_double(0)
    __d2f = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpactivationfunction(ctypes.byref(_error_msg), ctypes.byref(__net), ctypes.byref(__k), ctypes.byref(__f), ctypes.byref(__df), ctypes.byref(__d2f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpactivationfunction'")
        __r__f = __f.value
        __r__df = __df.value
        __r__d2f = __d2f.value
        return (__r__f, __r__df, __r__d2f)
    finally:
        pass


_lib_alglib.alglib_mlpprocess.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpprocess.restype = ctypes.c_int32
def mlpprocess(network, x, y):
    pass
    __network = network.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpprocess(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpprocess'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_mlpprocessi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpprocessi.restype = ctypes.c_int32
def mlpprocessi(network, x):
    pass
    __network = network.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpprocessi(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpprocessi'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_mlperror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperror.restype = ctypes.c_int32
def mlperror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlperror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlperror.restype = ctypes.c_int32
def smp_mlperror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlperror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlperror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlperrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperrorsparse.restype = ctypes.c_int32
def mlperrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlperrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlperrorsparse.restype = ctypes.c_int32
def smp_mlperrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlperrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlperrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlperrorn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperrorn.restype = ctypes.c_int32
def mlperrorn(network, xy, ssize):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperrorn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperrorn'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpclserror.restype = ctypes.c_int32
def mlpclserror(network, xy, npoints):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpclserror'")
        __r__result = __result.val
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlpclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpclserror.restype = ctypes.c_int32
def smp_mlpclserror(network, xy, npoints):
    pass
    __result = x_int()
    __result.val = 0
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpclserror'")
        __r__result = __result.val
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlprelclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlprelclserror.restype = ctypes.c_int32
def mlprelclserror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlprelclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlprelclserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlprelclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlprelclserror.restype = ctypes.c_int32
def smp_mlprelclserror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlprelclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlprelclserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlprelclserrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlprelclserrorsparse.restype = ctypes.c_int32
def mlprelclserrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlprelclserrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlprelclserrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlprelclserrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlprelclserrorsparse.restype = ctypes.c_int32
def smp_mlprelclserrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlprelclserrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlprelclserrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpavgce.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpavgce.restype = ctypes.c_int32
def mlpavgce(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpavgce(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpavgce'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlpavgce.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpavgce.restype = ctypes.c_int32
def smp_mlpavgce(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpavgce(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpavgce'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpavgcesparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpavgcesparse.restype = ctypes.c_int32
def mlpavgcesparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpavgcesparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpavgcesparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlpavgcesparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpavgcesparse.restype = ctypes.c_int32
def smp_mlpavgcesparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpavgcesparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpavgcesparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlprmserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlprmserror.restype = ctypes.c_int32
def mlprmserror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlprmserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlprmserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlprmserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlprmserror.restype = ctypes.c_int32
def smp_mlprmserror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlprmserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlprmserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlprmserrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlprmserrorsparse.restype = ctypes.c_int32
def mlprmserrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlprmserrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlprmserrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlprmserrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlprmserrorsparse.restype = ctypes.c_int32
def smp_mlprmserrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlprmserrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlprmserrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpavgerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpavgerror.restype = ctypes.c_int32
def mlpavgerror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpavgerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpavgerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlpavgerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpavgerror.restype = ctypes.c_int32
def smp_mlpavgerror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpavgerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpavgerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpavgerrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpavgerrorsparse.restype = ctypes.c_int32
def mlpavgerrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpavgerrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpavgerrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlpavgerrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpavgerrorsparse.restype = ctypes.c_int32
def smp_mlpavgerrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpavgerrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpavgerrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpavgrelerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpavgrelerror.restype = ctypes.c_int32
def mlpavgrelerror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpavgrelerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpavgrelerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_smp_mlpavgrelerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpavgrelerror.restype = ctypes.c_int32
def smp_mlpavgrelerror(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpavgrelerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpavgrelerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpavgrelerrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpavgrelerrorsparse.restype = ctypes.c_int32
def mlpavgrelerrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpavgrelerrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpavgrelerrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlpavgrelerrorsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpavgrelerrorsparse.restype = ctypes.c_int32
def smp_mlpavgrelerrorsparse(network, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpavgrelerrorsparse(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpavgrelerrorsparse'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpgrad.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgrad.restype = ctypes.c_int32
def mlpgrad(network, x, desiredy, grad):
    pass
    __network = network.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(desiredy):
        raise ValueError("'desiredy' parameter can't be cast to real_vector")
    __desiredy = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__desiredy, desiredy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgrad(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__x), ctypes.byref(__desiredy), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgrad'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__desiredy)
        x_vector_clear(__grad)


_lib_alglib.alglib_mlpgradn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgradn.restype = ctypes.c_int32
def mlpgradn(network, x, desiredy, grad):
    pass
    __network = network.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(desiredy):
        raise ValueError("'desiredy' parameter can't be cast to real_vector")
    __desiredy = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__desiredy, desiredy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgradn(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__x), ctypes.byref(__desiredy), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgradn'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__desiredy)
        x_vector_clear(__grad)


_lib_alglib.alglib_mlpgradbatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgradbatch.restype = ctypes.c_int32
def mlpgradbatch(network, xy, ssize, grad):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgradbatch(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgradbatch'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__grad)


_lib_alglib.alglib_smp_mlpgradbatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpgradbatch.restype = ctypes.c_int32
def smp_mlpgradbatch(network, xy, ssize, grad):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpgradbatch(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpgradbatch'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__grad)


_lib_alglib.alglib_mlpgradbatchsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgradbatchsparse.restype = ctypes.c_int32
def mlpgradbatchsparse(network, xy, ssize, grad):
    pass
    __network = network.ptr
    __xy = xy.ptr
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgradbatchsparse(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgradbatchsparse'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_vector_clear(__grad)


_lib_alglib.alglib_smp_mlpgradbatchsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpgradbatchsparse.restype = ctypes.c_int32
def smp_mlpgradbatchsparse(network, xy, ssize, grad):
    pass
    __network = network.ptr
    __xy = xy.ptr
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpgradbatchsparse(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpgradbatchsparse'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_vector_clear(__grad)


_lib_alglib.alglib_mlpgradbatchsubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgradbatchsubset.restype = ctypes.c_int32
def mlpgradbatchsubset(network, xy, setsize, idx, subsetsize, grad):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(idx):
        raise ValueError("'idx' parameter can't be cast to int_vector")
    __idx = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__idx, idx, DT_INT, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgradbatchsubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__idx), ctypes.byref(__subsetsize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgradbatchsubset'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__idx)
        x_vector_clear(__grad)


_lib_alglib.alglib_smp_mlpgradbatchsubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpgradbatchsubset.restype = ctypes.c_int32
def smp_mlpgradbatchsubset(network, xy, setsize, idx, subsetsize, grad):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(idx):
        raise ValueError("'idx' parameter can't be cast to int_vector")
    __idx = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__idx, idx, DT_INT, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpgradbatchsubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__idx), ctypes.byref(__subsetsize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpgradbatchsubset'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__idx)
        x_vector_clear(__grad)


_lib_alglib.alglib_mlpgradbatchsparsesubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgradbatchsparsesubset.restype = ctypes.c_int32
def mlpgradbatchsparsesubset(network, xy, setsize, idx, subsetsize, grad):
    pass
    __network = network.ptr
    __xy = xy.ptr
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(idx):
        raise ValueError("'idx' parameter can't be cast to int_vector")
    __idx = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__idx, idx, DT_INT, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgradbatchsparsesubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__idx), ctypes.byref(__subsetsize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgradbatchsparsesubset'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_vector_clear(__idx)
        x_vector_clear(__grad)


_lib_alglib.alglib_smp_mlpgradbatchsparsesubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpgradbatchsparsesubset.restype = ctypes.c_int32
def smp_mlpgradbatchsparsesubset(network, xy, setsize, idx, subsetsize, grad):
    pass
    __network = network.ptr
    __xy = xy.ptr
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(idx):
        raise ValueError("'idx' parameter can't be cast to int_vector")
    __idx = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__idx, idx, DT_INT, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpgradbatchsparsesubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__idx), ctypes.byref(__subsetsize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpgradbatchsparsesubset'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_vector_clear(__idx)
        x_vector_clear(__grad)


_lib_alglib.alglib_mlpgradnbatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpgradnbatch.restype = ctypes.c_int32
def mlpgradnbatch(network, xy, ssize, grad):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpgradnbatch(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpgradnbatch'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        return (__r__e, __r__grad)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__grad)


_lib_alglib.alglib_mlphessiannbatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlphessiannbatch.restype = ctypes.c_int32
def mlphessiannbatch(network, xy, ssize, grad, h):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(h):
        raise ValueError("'h' parameter can't be cast to real_matrix")
    __h = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        x_from_listlist(__h, h, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlphessiannbatch(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad), ctypes.byref(__h))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlphessiannbatch'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        __r__h = listlist_from_x(__h)
        return (__r__e, __r__grad, __r__h)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__grad)
        x_matrix_clear(__h)


_lib_alglib.alglib_mlphessianbatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlphessianbatch.restype = ctypes.c_int32
def mlphessianbatch(network, xy, ssize, grad, h):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    __e = ctypes.c_double(0)
    if not is_real_vector(grad):
        raise ValueError("'grad' parameter can't be cast to real_vector")
    __grad = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(h):
        raise ValueError("'h' parameter can't be cast to real_matrix")
    __h = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__grad, grad, DT_REAL, X_CREATE)
        x_from_listlist(__h, h, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlphessianbatch(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__ssize), ctypes.byref(__e), ctypes.byref(__grad), ctypes.byref(__h))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlphessianbatch'")
        __r__e = __e.value
        __r__grad = list_from_x(__grad)
        __r__h = listlist_from_x(__h)
        return (__r__e, __r__grad, __r__h)
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__grad)
        x_matrix_clear(__h)


_lib_alglib.alglib_mlpallerrorssubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpallerrorssubset.restype = ctypes.c_int32
def mlpallerrorssubset(network, xy, setsize, subset, subsetsize):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __rep = x_modelerrors()
    x_modelerrors_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpallerrorssubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpallerrorssubset'")
        __r__rep = modelerrors_from_x(__rep)
        return __r__rep
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__subset)
        x_modelerrors_clear(__rep)


_lib_alglib.alglib_smp_mlpallerrorssubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpallerrorssubset.restype = ctypes.c_int32
def smp_mlpallerrorssubset(network, xy, setsize, subset, subsetsize):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __rep = x_modelerrors()
    x_modelerrors_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpallerrorssubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpallerrorssubset'")
        __r__rep = modelerrors_from_x(__rep)
        return __r__rep
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__subset)
        x_modelerrors_clear(__rep)


_lib_alglib.alglib_mlpallerrorssparsesubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpallerrorssparsesubset.restype = ctypes.c_int32
def mlpallerrorssparsesubset(network, xy, setsize, subset, subsetsize):
    pass
    __network = network.ptr
    __xy = xy.ptr
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __rep = x_modelerrors()
    x_modelerrors_zero_fields(__rep)
    try:
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpallerrorssparsesubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpallerrorssparsesubset'")
        __r__rep = modelerrors_from_x(__rep)
        return __r__rep
    finally:
        x_vector_clear(__subset)
        x_modelerrors_clear(__rep)


_lib_alglib.alglib_smp_mlpallerrorssparsesubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpallerrorssparsesubset.restype = ctypes.c_int32
def smp_mlpallerrorssparsesubset(network, xy, setsize, subset, subsetsize):
    pass
    __network = network.ptr
    __xy = xy.ptr
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    __rep = x_modelerrors()
    x_modelerrors_zero_fields(__rep)
    try:
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpallerrorssparsesubset(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpallerrorssparsesubset'")
        __r__rep = modelerrors_from_x(__rep)
        return __r__rep
    finally:
        x_vector_clear(__subset)
        x_modelerrors_clear(__rep)


_lib_alglib.alglib_mlperrorsubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperrorsubset.restype = ctypes.c_int32
def mlperrorsubset(network, xy, setsize, subset, subsetsize):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperrorsubset(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperrorsubset'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__subset)


_lib_alglib.alglib_smp_mlperrorsubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlperrorsubset.restype = ctypes.c_int32
def smp_mlperrorsubset(network, xy, setsize, subset, subsetsize):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlperrorsubset(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlperrorsubset'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)
        x_vector_clear(__subset)


_lib_alglib.alglib_mlperrorsparsesubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperrorsparsesubset.restype = ctypes.c_int32
def mlperrorsparsesubset(network, xy, setsize, subset, subsetsize):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    try:
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperrorsparsesubset(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperrorsparsesubset'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__subset)


_lib_alglib.alglib_smp_mlperrorsparsesubset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlperrorsparsesubset.restype = ctypes.c_int32
def smp_mlperrorsparsesubset(network, xy, setsize, subset, subsetsize):
    pass
    __result = ctypes.c_double(0)
    __network = network.ptr
    __xy = xy.ptr
    __setsize = x_int()
    __setsize.val = int(setsize)
    if __setsize.val!=setsize:
        raise ValueError("Error while converting 'setsize' parameter to 'x_int'")
    if not is_int_vector(subset):
        raise ValueError("'subset' parameter can't be cast to int_vector")
    __subset = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __subsetsize = x_int()
    __subsetsize.val = int(subsetsize)
    if __subsetsize.val!=subsetsize:
        raise ValueError("Error while converting 'subsetsize' parameter to 'x_int'")
    try:
        x_from_list(__subset, subset, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlperrorsparsesubset(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__setsize), ctypes.byref(__subset), ctypes.byref(__subsetsize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlperrorsparsesubset'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__subset)




class x_densesolverreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("r1", ctypes.c_double),
        ("rinf", ctypes.c_double)
        ]




class densesolverreport(object):
    def __init__(self):
        self.r1 = 0
        self.rinf = 0


def x_densesolverreport_zero_fields(x):
    x.r1 = 0
    x.rinf = 0
    return




def x_densesolverreport_clear(x):
    x_densesolverreport_zero_fields(x)
    return




def x_from_densesolverreport(x,v):
    x.r1 = float(v.r1)
    x.rinf = float(v.rinf)
    return




def densesolverreport_from_x(x):
    r = densesolverreport()
    r.r1 = x.r1
    r.rinf = x.rinf
    return r




class x_densesolverlsreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("r2", ctypes.c_double),
        ("cx", x_matrix),
        ("n", x_int),
        ("k", x_int)
        ]




class densesolverlsreport(object):
    def __init__(self):
        self.r2 = 0
        self.cx = [[]]
        self.n = 0
        self.k = 0


def x_densesolverlsreport_zero_fields(x):
    x.r2 = 0
    x.cx = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.n.val = 0
    x.k.val = 0
    return




def x_densesolverlsreport_clear(x):
    x_matrix_clear(x.cx)
    x_densesolverlsreport_zero_fields(x)
    return




def x_from_densesolverlsreport(x,v):
    x.r2 = float(v.r2)
    x_from_listlist(x.cx, v.cx, DT_REAL, X_CREATE)
    x.n.val = int(v.n)
    x.k.val = int(v.k)
    return




def densesolverlsreport_from_x(x):
    r = densesolverlsreport()
    r.r2 = x.r2
    r.cx = listlist_from_x(x.cx)
    r.n = x.n.val
    r.k = x.k.val
    return r


_lib_alglib.alglib_rmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsolve.restype = ctypes.c_int32
def rmatrixsolve(a, n, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_smp_rmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsolve.restype = ctypes.c_int32
def smp_rmatrixsolve(a, n, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_rmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsolvefast.restype = ctypes.c_int32
def rmatrixsolvefast(a, n, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_smp_rmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsolvefast.restype = ctypes.c_int32
def smp_rmatrixsolvefast(a, n, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_rmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsolvem.restype = ctypes.c_int32
def rmatrixsolvem(a, n, b, m, rfs):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rfs = ctypes.c_uint8(rfs)
    if __rfs.value!=0:
        __rfs = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__rfs), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_rmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsolvem.restype = ctypes.c_int32
def smp_rmatrixsolvem(a, n, b, m, rfs):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rfs = ctypes.c_uint8(rfs)
    if __rfs.value!=0:
        __rfs = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__rfs), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_rmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsolvemfast.restype = ctypes.c_int32
def rmatrixsolvemfast(a, n, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_rmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsolvemfast.restype = ctypes.c_int32
def smp_rmatrixsolvemfast(a, n, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_rmatrixlusolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlusolve.restype = ctypes.c_int32
def rmatrixlusolve(lua, p, n, b):
    pass
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlusolve(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlusolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_rmatrixlusolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlusolvefast.restype = ctypes.c_int32
def rmatrixlusolvefast(lua, p, n, b):
    pass
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlusolvefast(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlusolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_vector_clear(__b)


_lib_alglib.alglib_rmatrixlusolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlusolvem.restype = ctypes.c_int32
def rmatrixlusolvem(lua, p, n, b, m):
    pass
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlusolvem(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlusolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_rmatrixlusolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixlusolvem.restype = ctypes.c_int32
def smp_rmatrixlusolvem(lua, p, n, b, m):
    pass
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixlusolvem(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixlusolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_rmatrixlusolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixlusolvemfast.restype = ctypes.c_int32
def rmatrixlusolvemfast(lua, p, n, b, m):
    pass
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixlusolvemfast(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixlusolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_rmatrixlusolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixlusolvemfast.restype = ctypes.c_int32
def smp_rmatrixlusolvemfast(lua, p, n, b, m):
    pass
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixlusolvemfast(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixlusolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)


_lib_alglib.alglib_rmatrixmixedsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixmixedsolve.restype = ctypes.c_int32
def rmatrixmixedsolve(a, lua, p, n, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixmixedsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixmixedsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_rmatrixmixedsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixmixedsolvem.restype = ctypes.c_int32
def rmatrixmixedsolvem(a, lua, p, n, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to real_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__lua, lua, DT_REAL, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixmixedsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixmixedsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_cmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixsolvem.restype = ctypes.c_int32
def cmatrixsolvem(a, n, b, m, rfs):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rfs = ctypes.c_uint8(rfs)
    if __rfs.value!=0:
        __rfs = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__rfs), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_cmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixsolvem.restype = ctypes.c_int32
def smp_cmatrixsolvem(a, n, b, m, rfs):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rfs = ctypes.c_uint8(rfs)
    if __rfs.value!=0:
        __rfs = ctypes.c_uint8(1)
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__rfs), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_cmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixsolvemfast.restype = ctypes.c_int32
def cmatrixsolvemfast(a, n, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_cmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixsolvemfast.restype = ctypes.c_int32
def smp_cmatrixsolvemfast(a, n, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_cmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixsolve.restype = ctypes.c_int32
def cmatrixsolve(a, n, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_smp_cmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixsolve.restype = ctypes.c_int32
def smp_cmatrixsolve(a, n, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_cmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixsolvefast.restype = ctypes.c_int32
def cmatrixsolvefast(a, n, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_smp_cmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixsolvefast.restype = ctypes.c_int32
def smp_cmatrixsolvefast(a, n, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_cmatrixlusolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlusolvem.restype = ctypes.c_int32
def cmatrixlusolvem(lua, p, n, b, m):
    pass
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlusolvem(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlusolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_cmatrixlusolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixlusolvem.restype = ctypes.c_int32
def smp_cmatrixlusolvem(lua, p, n, b, m):
    pass
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixlusolvem(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixlusolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_cmatrixlusolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlusolvemfast.restype = ctypes.c_int32
def cmatrixlusolvemfast(lua, p, n, b, m):
    pass
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlusolvemfast(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlusolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_cmatrixlusolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_cmatrixlusolvemfast.restype = ctypes.c_int32
def smp_cmatrixlusolvemfast(lua, p, n, b, m):
    pass
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_cmatrixlusolvemfast(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_cmatrixlusolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)


_lib_alglib.alglib_cmatrixlusolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlusolve.restype = ctypes.c_int32
def cmatrixlusolve(lua, p, n, b):
    pass
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlusolve(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlusolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_cmatrixlusolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixlusolvefast.restype = ctypes.c_int32
def cmatrixlusolvefast(lua, p, n, b):
    pass
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixlusolvefast(ctypes.byref(_error_msg), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixlusolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_vector_clear(__b)


_lib_alglib.alglib_cmatrixmixedsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixmixedsolvem.restype = ctypes.c_int32
def cmatrixmixedsolvem(a, lua, p, n, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixmixedsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixmixedsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_cmatrixmixedsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixmixedsolve.restype = ctypes.c_int32
def cmatrixmixedsolve(a, lua, p, n, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_complex_matrix(lua):
        raise ValueError("'lua' parameter can't be cast to complex_matrix")
    __lua = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(p):
        raise ValueError("'p' parameter can't be cast to int_vector")
    __p = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__lua, lua, DT_COMPLEX, X_CREATE)
        x_from_list(__p, p, DT_INT, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixmixedsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__lua), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixmixedsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__lua)
        x_vector_clear(__p)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_spdmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixsolvem.restype = ctypes.c_int32
def spdmatrixsolvem(a, n, isupper, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_spdmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixsolvem.restype = ctypes.c_int32
def smp_spdmatrixsolvem(a, n, isupper, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_spdmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixsolvemfast.restype = ctypes.c_int32
def spdmatrixsolvemfast(a, n, isupper, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_spdmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixsolvemfast.restype = ctypes.c_int32
def smp_spdmatrixsolvemfast(a, n, isupper, b, m):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_spdmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixsolve.restype = ctypes.c_int32
def spdmatrixsolve(a, n, isupper, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_smp_spdmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixsolve.restype = ctypes.c_int32
def smp_spdmatrixsolve(a, n, isupper, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_spdmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixsolvefast.restype = ctypes.c_int32
def spdmatrixsolvefast(a, n, isupper, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_smp_spdmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixsolvefast.restype = ctypes.c_int32
def smp_spdmatrixsolvefast(a, n, isupper, b):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_spdmatrixcholeskysolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskysolvem.restype = ctypes.c_int32
def spdmatrixcholeskysolvem(cha, n, isupper, b, m):
    pass
    if not is_real_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to real_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__cha, cha, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskysolvem(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskysolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_spdmatrixcholeskysolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixcholeskysolvem.restype = ctypes.c_int32
def smp_spdmatrixcholeskysolvem(cha, n, isupper, b, m):
    pass
    if not is_real_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to real_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__cha, cha, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixcholeskysolvem(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixcholeskysolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_spdmatrixcholeskysolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskysolvemfast.restype = ctypes.c_int32
def spdmatrixcholeskysolvemfast(cha, n, isupper, b, m):
    pass
    if not is_real_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to real_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__cha, cha, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskysolvemfast(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskysolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_spdmatrixcholeskysolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spdmatrixcholeskysolvemfast.restype = ctypes.c_int32
def smp_spdmatrixcholeskysolvemfast(cha, n, isupper, b, m):
    pass
    if not is_real_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to real_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__cha, cha, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spdmatrixcholeskysolvemfast(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spdmatrixcholeskysolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)


_lib_alglib.alglib_spdmatrixcholeskysolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskysolve.restype = ctypes.c_int32
def spdmatrixcholeskysolve(cha, n, isupper, b):
    pass
    if not is_real_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to real_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__cha, cha, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskysolve(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskysolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__cha)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_spdmatrixcholeskysolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskysolvefast.restype = ctypes.c_int32
def spdmatrixcholeskysolvefast(cha, n, isupper, b):
    pass
    if not is_real_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to real_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__cha, cha, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskysolvefast(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskysolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__cha)
        x_vector_clear(__b)


_lib_alglib.alglib_hpdmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixsolvem.restype = ctypes.c_int32
def hpdmatrixsolvem(a, n, isupper, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_hpdmatrixsolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixsolvem.restype = ctypes.c_int32
def smp_hpdmatrixsolvem(a, n, isupper, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixsolvem(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixsolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_hpdmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixsolvemfast.restype = ctypes.c_int32
def hpdmatrixsolvemfast(a, n, isupper, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_hpdmatrixsolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixsolvemfast.restype = ctypes.c_int32
def smp_hpdmatrixsolvemfast(a, n, isupper, b, m):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixsolvemfast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixsolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_hpdmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixsolve.restype = ctypes.c_int32
def hpdmatrixsolve(a, n, isupper, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_smp_hpdmatrixsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixsolve.restype = ctypes.c_int32
def smp_hpdmatrixsolve(a, n, isupper, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixsolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_hpdmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixsolvefast.restype = ctypes.c_int32
def hpdmatrixsolvefast(a, n, isupper, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_smp_hpdmatrixsolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixsolvefast.restype = ctypes.c_int32
def smp_hpdmatrixsolvefast(a, n, isupper, b):
    pass
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixsolvefast(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixsolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_hpdmatrixcholeskysolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholeskysolvem.restype = ctypes.c_int32
def hpdmatrixcholeskysolvem(cha, n, isupper, b, m):
    pass
    if not is_complex_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to complex_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__cha, cha, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholeskysolvem(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholeskysolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_smp_hpdmatrixcholeskysolvem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixcholeskysolvem.restype = ctypes.c_int32
def smp_hpdmatrixcholeskysolvem(cha, n, isupper, b, m):
    pass
    if not is_complex_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to complex_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__cha, cha, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixcholeskysolvem(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixcholeskysolvem'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = listlist_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)
        x_densesolverreport_clear(__rep)
        x_matrix_clear(__x)


_lib_alglib.alglib_hpdmatrixcholeskysolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholeskysolvemfast.restype = ctypes.c_int32
def hpdmatrixcholeskysolvemfast(cha, n, isupper, b, m):
    pass
    if not is_complex_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to complex_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__cha, cha, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholeskysolvemfast(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholeskysolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)


_lib_alglib.alglib_smp_hpdmatrixcholeskysolvemfast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_hpdmatrixcholeskysolvemfast.restype = ctypes.c_int32
def smp_hpdmatrixcholeskysolvemfast(cha, n, isupper, b, m):
    pass
    if not is_complex_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to complex_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_matrix(b):
        raise ValueError("'b' parameter can't be cast to complex_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__cha, cha, DT_COMPLEX, X_CREATE)
        x_from_listlist(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_hpdmatrixcholeskysolvemfast(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__m), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_hpdmatrixcholeskysolvemfast'")
        __r__b = listlist_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__cha)
        x_matrix_clear(__b)


_lib_alglib.alglib_hpdmatrixcholeskysolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholeskysolve.restype = ctypes.c_int32
def hpdmatrixcholeskysolve(cha, n, isupper, b):
    pass
    if not is_complex_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to complex_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverreport()
    x_densesolverreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__cha, cha, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholeskysolve(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholeskysolve'")
        __r__info = __info.val
        __r__rep = densesolverreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__cha)
        x_vector_clear(__b)
        x_densesolverreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_hpdmatrixcholeskysolvefast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hpdmatrixcholeskysolvefast.restype = ctypes.c_int32
def hpdmatrixcholeskysolvefast(cha, n, isupper, b):
    pass
    if not is_complex_matrix(cha):
        raise ValueError("'cha' parameter can't be cast to complex_matrix")
    __cha = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __info = x_int()
    __info.val = 0
    try:
        x_from_listlist(__cha, cha, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hpdmatrixcholeskysolvefast(ctypes.byref(_error_msg), ctypes.byref(__cha), ctypes.byref(__n), ctypes.byref(__isupper), ctypes.byref(__b), ctypes.byref(__info))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hpdmatrixcholeskysolvefast'")
        __r__b = list_from_x(__b)
        __r__info = __info.val
        return (__r__b, __r__info)
    finally:
        x_matrix_clear(__cha)
        x_vector_clear(__b)


_lib_alglib.alglib_rmatrixsolvels.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixsolvels.restype = ctypes.c_int32
def rmatrixsolvels(a, nrows, ncols, b, threshold):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nrows = x_int()
    __nrows.val = int(nrows)
    if __nrows.val!=nrows:
        raise ValueError("Error while converting 'nrows' parameter to 'x_int'")
    __ncols = x_int()
    __ncols.val = int(ncols)
    if __ncols.val!=ncols:
        raise ValueError("Error while converting 'ncols' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __threshold = ctypes.c_double(threshold)
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverlsreport()
    x_densesolverlsreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixsolvels(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__nrows), ctypes.byref(__ncols), ctypes.byref(__b), ctypes.byref(__threshold), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixsolvels'")
        __r__info = __info.val
        __r__rep = densesolverlsreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverlsreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.alglib_smp_rmatrixsolvels.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_rmatrixsolvels.restype = ctypes.c_int32
def smp_rmatrixsolvels(a, nrows, ncols, b, threshold):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nrows = x_int()
    __nrows.val = int(nrows)
    if __nrows.val!=nrows:
        raise ValueError("Error while converting 'nrows' parameter to 'x_int'")
    __ncols = x_int()
    __ncols.val = int(ncols)
    if __ncols.val!=ncols:
        raise ValueError("Error while converting 'ncols' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __threshold = ctypes.c_double(threshold)
    __info = x_int()
    __info.val = 0
    __rep = x_densesolverlsreport()
    x_densesolverlsreport_zero_fields(__rep)
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_rmatrixsolvels(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__nrows), ctypes.byref(__ncols), ctypes.byref(__b), ctypes.byref(__threshold), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_rmatrixsolvels'")
        __r__info = __info.val
        __r__rep = densesolverlsreport_from_x(__rep)
        __r__x = list_from_x(__x)
        return (__r__info, __r__rep, __r__x)
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__b)
        x_densesolverlsreport_clear(__rep)
        x_vector_clear(__x)


_lib_alglib.x_obj_free_logitmodel.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_logitmodel.restype = None


class logitmodel(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_logitmodel(self.ptr)


class x_mnlreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("ngrad", x_int),
        ("nhess", x_int)
        ]




class mnlreport(object):
    def __init__(self):
        self.ngrad = 0
        self.nhess = 0


def x_mnlreport_zero_fields(x):
    x.ngrad.val = 0
    x.nhess.val = 0
    return




def x_mnlreport_clear(x):
    x_mnlreport_zero_fields(x)
    return




def x_from_mnlreport(x,v):
    x.ngrad.val = int(v.ngrad)
    x.nhess.val = int(v.nhess)
    return




def mnlreport_from_x(x):
    r = mnlreport()
    r.ngrad = x.ngrad.val
    r.nhess = x.nhess.val
    return r


_lib_alglib.alglib_mnltrainh.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnltrainh.restype = ctypes.c_int32
def mnltrainh(xy, npoints, nvars, nclasses):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __lm = ctypes.c_void_p(0)
    __rep = x_mnlreport()
    x_mnlreport_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnltrainh(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__info), ctypes.byref(__lm), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnltrainh'")
        __r__info = __info.val
        __r__lm = logitmodel(__lm)
        __r__rep = mnlreport_from_x(__rep)
        return (__r__info, __r__lm, __r__rep)
    finally:
        x_matrix_clear(__xy)
        x_mnlreport_clear(__rep)


_lib_alglib.alglib_mnlprocess.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlprocess.restype = ctypes.c_int32
def mnlprocess(lm, x, y):
    pass
    __lm = lm.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlprocess(ctypes.byref(_error_msg), ctypes.byref(__lm), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlprocess'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_mnlprocessi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlprocessi.restype = ctypes.c_int32
def mnlprocessi(lm, x):
    pass
    __lm = lm.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlprocessi(ctypes.byref(_error_msg), ctypes.byref(__lm), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlprocessi'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_mnlunpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlunpack.restype = ctypes.c_int32
def mnlunpack(lm):
    pass
    __lm = lm.ptr
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nvars = x_int()
    __nvars.val = 0
    __nclasses = x_int()
    __nclasses.val = 0
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlunpack(ctypes.byref(_error_msg), ctypes.byref(__lm), ctypes.byref(__a), ctypes.byref(__nvars), ctypes.byref(__nclasses))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlunpack'")
        __r__a = listlist_from_x(__a)
        __r__nvars = __nvars.val
        __r__nclasses = __nclasses.val
        return (__r__a, __r__nvars, __r__nclasses)
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_mnlpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlpack.restype = ctypes.c_int32
def mnlpack(a, nvars, nclasses):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __lm = ctypes.c_void_p(0)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlpack(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__nvars), ctypes.byref(__nclasses), ctypes.byref(__lm))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlpack'")
        __r__lm = logitmodel(__lm)
        return __r__lm
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_mnlavgce.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlavgce.restype = ctypes.c_int32
def mnlavgce(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlavgce(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlavgce'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mnlrelclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlrelclserror.restype = ctypes.c_int32
def mnlrelclserror(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlrelclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlrelclserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mnlrmserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlrmserror.restype = ctypes.c_int32
def mnlrmserror(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlrmserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlrmserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mnlavgerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlavgerror.restype = ctypes.c_int32
def mnlavgerror(lm, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlavgerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlavgerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mnlavgrelerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlavgrelerror.restype = ctypes.c_int32
def mnlavgrelerror(lm, xy, ssize):
    pass
    __result = ctypes.c_double(0)
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ssize = x_int()
    __ssize.val = int(ssize)
    if __ssize.val!=ssize:
        raise ValueError("Error while converting 'ssize' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlavgrelerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__ssize))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlavgrelerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mnlclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mnlclserror.restype = ctypes.c_int32
def mnlclserror(lm, xy, npoints):
    pass
    __result = x_int()
    __result.val = 0
    __lm = lm.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mnlclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__lm), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mnlclserror'")
        __r__result = __result.val
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.x_obj_free_mincgstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_mincgstate.restype = None
_lib_alglib.x_mincgstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_get_needf.restype = None
_lib_alglib.x_mincgstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_set_needf.restype = None
_lib_alglib.x_mincgstate_get_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_get_needfg.restype = None
_lib_alglib.x_mincgstate_set_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_set_needfg.restype = None
_lib_alglib.x_mincgstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_get_xupdated.restype = None
_lib_alglib.x_mincgstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_set_xupdated.restype = None
_lib_alglib.x_mincgstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_get_f.restype = None
_lib_alglib.x_mincgstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_set_f.restype = None
_lib_alglib.x_mincgstate_get_g.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_get_g.restype = None
_lib_alglib.x_mincgstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_mincgstate_get_x.restype = None


class mincgstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_mincgstate(self.ptr)


class x_mincgreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfev", x_int),
        ("varidx", x_int),
        ("terminationtype", x_int)
        ]




class mincgreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfev = 0
        self.varidx = 0
        self.terminationtype = 0


def x_mincgreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfev.val = 0
    x.varidx.val = 0
    x.terminationtype.val = 0
    return




def x_mincgreport_clear(x):
    x_mincgreport_zero_fields(x)
    return




def x_from_mincgreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfev.val = int(v.nfev)
    x.varidx.val = int(v.varidx)
    x.terminationtype.val = int(v.terminationtype)
    return




def mincgreport_from_x(x):
    r = mincgreport()
    r.iterationscount = x.iterationscount.val
    r.nfev = x.nfev.val
    r.varidx = x.varidx.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_mincgcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgcreate.restype = ctypes.c_int32
def mincgcreate(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        n,x = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'mincgcreate': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'mincgcreate': function must have 1 or 2 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgcreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgcreate'")
        __r__state = mincgstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_mincgcreatef.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgcreatef.restype = ctypes.c_int32
def mincgcreatef(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,x,diffstep = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,diffstep = functionargs
        n = safe_len("'mincgcreatef': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'mincgcreatef': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgcreatef(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgcreatef'")
        __r__state = mincgstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_mincgsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetcond.restype = ctypes.c_int32
def mincgsetcond(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetscale.restype = ctypes.c_int32
def mincgsetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_mincgsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetxrep.restype = ctypes.c_int32
def mincgsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsetcgtype.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetcgtype.restype = ctypes.c_int32
def mincgsetcgtype(state, cgtype):
    pass
    __state = state.ptr
    __cgtype = x_int()
    __cgtype.val = int(cgtype)
    if __cgtype.val!=cgtype:
        raise ValueError("Error while converting 'cgtype' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetcgtype(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__cgtype))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetcgtype'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetstpmax.restype = ctypes.c_int32
def mincgsetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetstpmax'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsuggeststep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsuggeststep.restype = ctypes.c_int32
def mincgsuggeststep(state, stp):
    pass
    __state = state.ptr
    __stp = ctypes.c_double(stp)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsuggeststep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stp))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsuggeststep'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsetprecdefault.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetprecdefault.restype = ctypes.c_int32
def mincgsetprecdefault(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetprecdefault(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetprecdefault'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsetprecdiag.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetprecdiag.restype = ctypes.c_int32
def mincgsetprecdiag(state, d):
    pass
    __state = state.ptr
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetprecdiag(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetprecdiag'")
        return
    finally:
        x_vector_clear(__d)


_lib_alglib.alglib_mincgsetprecscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetprecscale.restype = ctypes.c_int32
def mincgsetprecscale(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetprecscale(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetprecscale'")
        return
    finally:
        pass




def mincgoptimize_f(state, func, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_mincgstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    while True:
        retval = _lib_alglib.alglib_mincgiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_mincgstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_mincgstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_mincgstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_mincgstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'mincgoptimize' (some derivatives were not provided?)")
    return


def mincgoptimize_g(state, grad, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_mincgstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_mincgstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    while True:
        retval = _lib_alglib.alglib_mincgiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_mincgstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = grad(_py_x, _py_g, param)
            _lib_alglib.x_mincgstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_mincgstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_mincgstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'mincgoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_mincgresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgresults.restype = ctypes.c_int32
def mincgresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_mincgreport()
    x_mincgreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgresults'")
        __r__x = list_from_x(__x)
        __r__rep = mincgreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_mincgreport_clear(__rep)


_lib_alglib.alglib_mincgresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgresultsbuf.restype = ctypes.c_int32
def mincgresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_mincgreport()
    x_mincgreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_mincgreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = mincgreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_mincgreport_clear(__rep)


_lib_alglib.alglib_mincgrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgrestartfrom.restype = ctypes.c_int32
def mincgrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgrestartfrom'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_mincgrequesttermination.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgrequesttermination.restype = ctypes.c_int32
def mincgrequesttermination(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgrequesttermination(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgrequesttermination'")
        return
    finally:
        pass


_lib_alglib.alglib_mincgsetgradientcheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mincgsetgradientcheck.restype = ctypes.c_int32
def mincgsetgradientcheck(state, teststep):
    pass
    __state = state.ptr
    __teststep = ctypes.c_double(teststep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mincgsetgradientcheck(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__teststep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mincgsetgradientcheck'")
        return
    finally:
        pass


_lib_alglib.x_obj_free_minbleicstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minbleicstate.restype = None
_lib_alglib.x_minbleicstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_get_needf.restype = None
_lib_alglib.x_minbleicstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_set_needf.restype = None
_lib_alglib.x_minbleicstate_get_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_get_needfg.restype = None
_lib_alglib.x_minbleicstate_set_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_set_needfg.restype = None
_lib_alglib.x_minbleicstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_get_xupdated.restype = None
_lib_alglib.x_minbleicstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_set_xupdated.restype = None
_lib_alglib.x_minbleicstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_get_f.restype = None
_lib_alglib.x_minbleicstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_set_f.restype = None
_lib_alglib.x_minbleicstate_get_g.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_get_g.restype = None
_lib_alglib.x_minbleicstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minbleicstate_get_x.restype = None


class minbleicstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minbleicstate(self.ptr)


class x_minbleicreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfev", x_int),
        ("varidx", x_int),
        ("terminationtype", x_int),
        ("debugeqerr", ctypes.c_double),
        ("debugfs", ctypes.c_double),
        ("debugff", ctypes.c_double),
        ("debugdx", ctypes.c_double),
        ("debugfeasqpits", x_int),
        ("debugfeasgpaits", x_int),
        ("inneriterationscount", x_int),
        ("outeriterationscount", x_int)
        ]




class minbleicreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfev = 0
        self.varidx = 0
        self.terminationtype = 0
        self.debugeqerr = 0
        self.debugfs = 0
        self.debugff = 0
        self.debugdx = 0
        self.debugfeasqpits = 0
        self.debugfeasgpaits = 0
        self.inneriterationscount = 0
        self.outeriterationscount = 0


def x_minbleicreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfev.val = 0
    x.varidx.val = 0
    x.terminationtype.val = 0
    x.debugeqerr = 0
    x.debugfs = 0
    x.debugff = 0
    x.debugdx = 0
    x.debugfeasqpits.val = 0
    x.debugfeasgpaits.val = 0
    x.inneriterationscount.val = 0
    x.outeriterationscount.val = 0
    return




def x_minbleicreport_clear(x):
    x_minbleicreport_zero_fields(x)
    return




def x_from_minbleicreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfev.val = int(v.nfev)
    x.varidx.val = int(v.varidx)
    x.terminationtype.val = int(v.terminationtype)
    x.debugeqerr = float(v.debugeqerr)
    x.debugfs = float(v.debugfs)
    x.debugff = float(v.debugff)
    x.debugdx = float(v.debugdx)
    x.debugfeasqpits.val = int(v.debugfeasqpits)
    x.debugfeasgpaits.val = int(v.debugfeasgpaits)
    x.inneriterationscount.val = int(v.inneriterationscount)
    x.outeriterationscount.val = int(v.outeriterationscount)
    return




def minbleicreport_from_x(x):
    r = minbleicreport()
    r.iterationscount = x.iterationscount.val
    r.nfev = x.nfev.val
    r.varidx = x.varidx.val
    r.terminationtype = x.terminationtype.val
    r.debugeqerr = x.debugeqerr
    r.debugfs = x.debugfs
    r.debugff = x.debugff
    r.debugdx = x.debugdx
    r.debugfeasqpits = x.debugfeasqpits.val
    r.debugfeasgpaits = x.debugfeasgpaits.val
    r.inneriterationscount = x.inneriterationscount.val
    r.outeriterationscount = x.outeriterationscount.val
    return r


_lib_alglib.alglib_minbleiccreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleiccreate.restype = ctypes.c_int32
def minbleiccreate(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        n,x = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'minbleiccreate': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minbleiccreate': function must have 1 or 2 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleiccreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleiccreate'")
        __r__state = minbleicstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minbleiccreatef.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleiccreatef.restype = ctypes.c_int32
def minbleiccreatef(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,x,diffstep = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,diffstep = functionargs
        n = safe_len("'minbleiccreatef': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minbleiccreatef': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleiccreatef(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleiccreatef'")
        __r__state = minbleicstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minbleicsetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetbc.restype = ctypes.c_int32
def minbleicsetbc(state, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetbc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetbc'")
        return
    finally:
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.alglib_minbleicsetlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetlc.restype = ctypes.c_int32
def minbleicsetlc(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        state,c,ct,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        state,c,ct = functionargs
        if safe_rows("'minbleicsetlc': incorrect parameters",c)!=safe_len("'minbleicsetlc': incorrect parameters",ct):
            raise RuntimeError("Error while calling 'minbleicsetlc': looks like one of arguments has wrong size")
        k = safe_rows("'minbleicsetlc': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'minbleicsetlc': function must have 3 or 4 parameters")
    __state = state.ptr
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(ct):
        raise ValueError("'ct' parameter can't be cast to int_vector")
    __ct = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        x_from_list(__ct, ct, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetlc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__c), ctypes.byref(__ct), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetlc'")
        return
    finally:
        x_matrix_clear(__c)
        x_vector_clear(__ct)


_lib_alglib.alglib_minbleicsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetcond.restype = ctypes.c_int32
def minbleicsetcond(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_minbleicsetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetscale.restype = ctypes.c_int32
def minbleicsetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_minbleicsetprecdefault.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetprecdefault.restype = ctypes.c_int32
def minbleicsetprecdefault(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetprecdefault(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetprecdefault'")
        return
    finally:
        pass


_lib_alglib.alglib_minbleicsetprecdiag.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetprecdiag.restype = ctypes.c_int32
def minbleicsetprecdiag(state, d):
    pass
    __state = state.ptr
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetprecdiag(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetprecdiag'")
        return
    finally:
        x_vector_clear(__d)


_lib_alglib.alglib_minbleicsetprecscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetprecscale.restype = ctypes.c_int32
def minbleicsetprecscale(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetprecscale(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetprecscale'")
        return
    finally:
        pass


_lib_alglib.alglib_minbleicsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetxrep.restype = ctypes.c_int32
def minbleicsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_minbleicsetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetstpmax.restype = ctypes.c_int32
def minbleicsetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetstpmax'")
        return
    finally:
        pass




def minbleicoptimize_f(state, func, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minbleicstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    while True:
        retval = _lib_alglib.alglib_minbleiciteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleiciteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minbleicstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_minbleicstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_minbleicstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minbleicstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minbleicoptimize' (some derivatives were not provided?)")
    return


def minbleicoptimize_g(state, grad, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minbleicstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_minbleicstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    while True:
        retval = _lib_alglib.alglib_minbleiciteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleiciteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minbleicstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = grad(_py_x, _py_g, param)
            _lib_alglib.x_minbleicstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minbleicstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minbleicstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minbleicoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_minbleicresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicresults.restype = ctypes.c_int32
def minbleicresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minbleicreport()
    x_minbleicreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicresults'")
        __r__x = list_from_x(__x)
        __r__rep = minbleicreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minbleicreport_clear(__rep)


_lib_alglib.alglib_minbleicresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicresultsbuf.restype = ctypes.c_int32
def minbleicresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minbleicreport()
    x_minbleicreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minbleicreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minbleicreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minbleicreport_clear(__rep)


_lib_alglib.alglib_minbleicrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicrestartfrom.restype = ctypes.c_int32
def minbleicrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicrestartfrom'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minbleicrequesttermination.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicrequesttermination.restype = ctypes.c_int32
def minbleicrequesttermination(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicrequesttermination(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicrequesttermination'")
        return
    finally:
        pass


_lib_alglib.alglib_minbleicsetgradientcheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetgradientcheck.restype = ctypes.c_int32
def minbleicsetgradientcheck(state, teststep):
    pass
    __state = state.ptr
    __teststep = ctypes.c_double(teststep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetgradientcheck(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__teststep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetgradientcheck'")
        return
    finally:
        pass


_lib_alglib.x_obj_free_mcpdstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_mcpdstate.restype = None


class mcpdstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_mcpdstate(self.ptr)


class x_mcpdreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("inneriterationscount", x_int),
        ("outeriterationscount", x_int),
        ("nfev", x_int),
        ("terminationtype", x_int)
        ]




class mcpdreport(object):
    def __init__(self):
        self.inneriterationscount = 0
        self.outeriterationscount = 0
        self.nfev = 0
        self.terminationtype = 0


def x_mcpdreport_zero_fields(x):
    x.inneriterationscount.val = 0
    x.outeriterationscount.val = 0
    x.nfev.val = 0
    x.terminationtype.val = 0
    return




def x_mcpdreport_clear(x):
    x_mcpdreport_zero_fields(x)
    return




def x_from_mcpdreport(x,v):
    x.inneriterationscount.val = int(v.inneriterationscount)
    x.outeriterationscount.val = int(v.outeriterationscount)
    x.nfev.val = int(v.nfev)
    x.terminationtype.val = int(v.terminationtype)
    return




def mcpdreport_from_x(x):
    r = mcpdreport()
    r.inneriterationscount = x.inneriterationscount.val
    r.outeriterationscount = x.outeriterationscount.val
    r.nfev = x.nfev.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_mcpdcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdcreate.restype = ctypes.c_int32
def mcpdcreate(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdcreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdcreate'")
        __r__s = mcpdstate(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_mcpdcreateentry.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdcreateentry.restype = ctypes.c_int32
def mcpdcreateentry(n, entrystate):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __entrystate = x_int()
    __entrystate.val = int(entrystate)
    if __entrystate.val!=entrystate:
        raise ValueError("Error while converting 'entrystate' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdcreateentry(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__entrystate), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdcreateentry'")
        __r__s = mcpdstate(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_mcpdcreateexit.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdcreateexit.restype = ctypes.c_int32
def mcpdcreateexit(n, exitstate):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __exitstate = x_int()
    __exitstate.val = int(exitstate)
    if __exitstate.val!=exitstate:
        raise ValueError("Error while converting 'exitstate' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdcreateexit(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__exitstate), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdcreateexit'")
        __r__s = mcpdstate(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_mcpdcreateentryexit.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdcreateentryexit.restype = ctypes.c_int32
def mcpdcreateentryexit(n, entrystate, exitstate):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __entrystate = x_int()
    __entrystate.val = int(entrystate)
    if __entrystate.val!=entrystate:
        raise ValueError("Error while converting 'entrystate' parameter to 'x_int'")
    __exitstate = x_int()
    __exitstate.val = int(exitstate)
    if __exitstate.val!=exitstate:
        raise ValueError("Error while converting 'exitstate' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdcreateentryexit(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__entrystate), ctypes.byref(__exitstate), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdcreateentryexit'")
        __r__s = mcpdstate(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_mcpdaddtrack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdaddtrack.restype = ctypes.c_int32
def mcpdaddtrack(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        s,xy,k = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        s,xy = functionargs
        k = safe_rows("'mcpdaddtrack': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'mcpdaddtrack': function must have 2 or 3 parameters")
    __s = s.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdaddtrack(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__xy), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdaddtrack'")
        return
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mcpdsetec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsetec.restype = ctypes.c_int32
def mcpdsetec(s, ec):
    pass
    __s = s.ptr
    if not is_real_matrix(ec):
        raise ValueError("'ec' parameter can't be cast to real_matrix")
    __ec = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__ec, ec, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsetec(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__ec))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsetec'")
        return
    finally:
        x_matrix_clear(__ec)


_lib_alglib.alglib_mcpdaddec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdaddec.restype = ctypes.c_int32
def mcpdaddec(s, i, j, c):
    pass
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __j = x_int()
    __j.val = int(j)
    if __j.val!=j:
        raise ValueError("Error while converting 'j' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdaddec(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__j), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdaddec'")
        return
    finally:
        pass


_lib_alglib.alglib_mcpdsetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsetbc.restype = ctypes.c_int32
def mcpdsetbc(s, bndl, bndu):
    pass
    __s = s.ptr
    if not is_real_matrix(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_matrix")
    __bndl = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_matrix")
    __bndu = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_listlist(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsetbc(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsetbc'")
        return
    finally:
        x_matrix_clear(__bndl)
        x_matrix_clear(__bndu)


_lib_alglib.alglib_mcpdaddbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdaddbc.restype = ctypes.c_int32
def mcpdaddbc(s, i, j, bndl, bndu):
    pass
    __s = s.ptr
    __i = x_int()
    __i.val = int(i)
    if __i.val!=i:
        raise ValueError("Error while converting 'i' parameter to 'x_int'")
    __j = x_int()
    __j.val = int(j)
    if __j.val!=j:
        raise ValueError("Error while converting 'j' parameter to 'x_int'")
    __bndl = ctypes.c_double(bndl)
    __bndu = ctypes.c_double(bndu)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdaddbc(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__i), ctypes.byref(__j), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdaddbc'")
        return
    finally:
        pass


_lib_alglib.alglib_mcpdsetlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsetlc.restype = ctypes.c_int32
def mcpdsetlc(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        s,c,ct,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        s,c,ct = functionargs
        if safe_rows("'mcpdsetlc': incorrect parameters",c)!=safe_len("'mcpdsetlc': incorrect parameters",ct):
            raise RuntimeError("Error while calling 'mcpdsetlc': looks like one of arguments has wrong size")
        k = safe_rows("'mcpdsetlc': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'mcpdsetlc': function must have 3 or 4 parameters")
    __s = s.ptr
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(ct):
        raise ValueError("'ct' parameter can't be cast to int_vector")
    __ct = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        x_from_list(__ct, ct, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsetlc(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__c), ctypes.byref(__ct), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsetlc'")
        return
    finally:
        x_matrix_clear(__c)
        x_vector_clear(__ct)


_lib_alglib.alglib_mcpdsettikhonovregularizer.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsettikhonovregularizer.restype = ctypes.c_int32
def mcpdsettikhonovregularizer(s, v):
    pass
    __s = s.ptr
    __v = ctypes.c_double(v)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsettikhonovregularizer(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsettikhonovregularizer'")
        return
    finally:
        pass


_lib_alglib.alglib_mcpdsetprior.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsetprior.restype = ctypes.c_int32
def mcpdsetprior(s, pp):
    pass
    __s = s.ptr
    if not is_real_matrix(pp):
        raise ValueError("'pp' parameter can't be cast to real_matrix")
    __pp = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__pp, pp, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsetprior(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__pp))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsetprior'")
        return
    finally:
        x_matrix_clear(__pp)


_lib_alglib.alglib_mcpdsetpredictionweights.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsetpredictionweights.restype = ctypes.c_int32
def mcpdsetpredictionweights(s, pw):
    pass
    __s = s.ptr
    if not is_real_vector(pw):
        raise ValueError("'pw' parameter can't be cast to real_vector")
    __pw = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__pw, pw, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsetpredictionweights(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__pw))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsetpredictionweights'")
        return
    finally:
        x_vector_clear(__pw)


_lib_alglib.alglib_mcpdsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdsolve.restype = ctypes.c_int32
def mcpdsolve(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdsolve(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdsolve'")
        return
    finally:
        pass


_lib_alglib.alglib_mcpdresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mcpdresults.restype = ctypes.c_int32
def mcpdresults(s):
    pass
    __s = s.ptr
    __p = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_mcpdreport()
    x_mcpdreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mcpdresults(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__p), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mcpdresults'")
        __r__p = listlist_from_x(__p)
        __r__rep = mcpdreport_from_x(__rep)
        return (__r__p, __r__rep)
    finally:
        x_matrix_clear(__p)
        x_mcpdreport_clear(__rep)


_lib_alglib.x_obj_free_mlpensemble.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_mlpensemble.restype = None


class mlpensemble(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_mlpensemble(self.ptr)
_lib_alglib.alglib_mlpeserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeserialize.restype = ctypes.c_int32

def mlpeserialize(obj):
    error_msg = ctypes.c_char_p(0)
    _s_out = ctypes.c_char_p(0)
    retval = _lib_alglib.alglib_mlpeserialize(ctypes.byref(error_msg), ctypes.byref(obj.ptr), ctypes.byref(_s_out))
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'mlpeserialize'")
    s_out = _s_out.value
    _lib_alglib.x_free(_s_out)
    return s_out

_lib_alglib.alglib_mlpeunserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeunserialize.restype = ctypes.c_int32

def mlpeunserialize(s_in):
    error_msg = ctypes.c_char_p(0)
    _s_in = ctypes.c_char_p(s_in)
    _obj = ctypes.c_void_p(0)
    retval = _lib_alglib.alglib_mlpeunserialize(ctypes.byref(error_msg), ctypes.byref(_s_in), ctypes.byref(_obj), )
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'mlpeserialize'")
    return mlpensemble(_obj)

_lib_alglib.alglib_mlpecreate0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreate0.restype = ctypes.c_int32
def mlpecreate0(nin, nout, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreate0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreate0'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreate1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreate1.restype = ctypes.c_int32
def mlpecreate1(nin, nhid, nout, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreate1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreate1'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreate2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreate2.restype = ctypes.c_int32
def mlpecreate2(nin, nhid1, nhid2, nout, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreate2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreate2'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreateb0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreateb0.restype = ctypes.c_int32
def mlpecreateb0(nin, nout, b, d, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __b = ctypes.c_double(b)
    __d = ctypes.c_double(d)
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreateb0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__b), ctypes.byref(__d), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreateb0'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreateb1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreateb1.restype = ctypes.c_int32
def mlpecreateb1(nin, nhid, nout, b, d, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __b = ctypes.c_double(b)
    __d = ctypes.c_double(d)
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreateb1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__b), ctypes.byref(__d), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreateb1'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreateb2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreateb2.restype = ctypes.c_int32
def mlpecreateb2(nin, nhid1, nhid2, nout, b, d, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __b = ctypes.c_double(b)
    __d = ctypes.c_double(d)
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreateb2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__b), ctypes.byref(__d), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreateb2'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreater0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreater0.restype = ctypes.c_int32
def mlpecreater0(nin, nout, a, b, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreater0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreater0'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreater1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreater1.restype = ctypes.c_int32
def mlpecreater1(nin, nhid, nout, a, b, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreater1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreater1'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreater2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreater2.restype = ctypes.c_int32
def mlpecreater2(nin, nhid1, nhid2, nout, a, b, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreater2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreater2'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreatec0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreatec0.restype = ctypes.c_int32
def mlpecreatec0(nin, nout, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreatec0(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreatec0'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreatec1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreatec1.restype = ctypes.c_int32
def mlpecreatec1(nin, nhid, nout, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid = x_int()
    __nhid.val = int(nhid)
    if __nhid.val!=nhid:
        raise ValueError("Error while converting 'nhid' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreatec1(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid), ctypes.byref(__nout), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreatec1'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreatec2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreatec2.restype = ctypes.c_int32
def mlpecreatec2(nin, nhid1, nhid2, nout, ensemblesize):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nhid1 = x_int()
    __nhid1.val = int(nhid1)
    if __nhid1.val!=nhid1:
        raise ValueError("Error while converting 'nhid1' parameter to 'x_int'")
    __nhid2 = x_int()
    __nhid2.val = int(nhid2)
    if __nhid2.val!=nhid2:
        raise ValueError("Error while converting 'nhid2' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreatec2(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nhid1), ctypes.byref(__nhid2), ctypes.byref(__nout), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreatec2'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlpecreatefromnetwork.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpecreatefromnetwork.restype = ctypes.c_int32
def mlpecreatefromnetwork(network, ensemblesize):
    pass
    __network = network.ptr
    __ensemblesize = x_int()
    __ensemblesize.val = int(ensemblesize)
    if __ensemblesize.val!=ensemblesize:
        raise ValueError("Error while converting 'ensemblesize' parameter to 'x_int'")
    __ensemble = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpecreatefromnetwork(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__ensemblesize), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpecreatefromnetwork'")
        __r__ensemble = mlpensemble(__ensemble)
        return __r__ensemble
    finally:
        pass


_lib_alglib.alglib_mlperandomize.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperandomize.restype = ctypes.c_int32
def mlperandomize(ensemble):
    pass
    __ensemble = ensemble.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperandomize(ctypes.byref(_error_msg), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperandomize'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpeproperties.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeproperties.restype = ctypes.c_int32
def mlpeproperties(ensemble):
    pass
    __ensemble = ensemble.ptr
    __nin = x_int()
    __nin.val = 0
    __nout = x_int()
    __nout.val = 0
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeproperties(ctypes.byref(_error_msg), ctypes.byref(__ensemble), ctypes.byref(__nin), ctypes.byref(__nout))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeproperties'")
        __r__nin = __nin.val
        __r__nout = __nout.val
        return (__r__nin, __r__nout)
    finally:
        pass


_lib_alglib.alglib_mlpeissoftmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeissoftmax.restype = ctypes.c_int32
def mlpeissoftmax(ensemble):
    pass
    __result = ctypes.c_uint8(0)
    __ensemble = ensemble.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeissoftmax(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__ensemble))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeissoftmax'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpeprocess.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeprocess.restype = ctypes.c_int32
def mlpeprocess(ensemble, x, y):
    pass
    __ensemble = ensemble.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeprocess(ctypes.byref(_error_msg), ctypes.byref(__ensemble), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeprocess'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_mlpeprocessi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeprocessi.restype = ctypes.c_int32
def mlpeprocessi(ensemble, x):
    pass
    __ensemble = ensemble.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeprocessi(ctypes.byref(_error_msg), ctypes.byref(__ensemble), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeprocessi'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_mlperelclserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlperelclserror.restype = ctypes.c_int32
def mlperelclserror(ensemble, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlperelclserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlperelclserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpeavgce.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeavgce.restype = ctypes.c_int32
def mlpeavgce(ensemble, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeavgce(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeavgce'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpermserror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpermserror.restype = ctypes.c_int32
def mlpermserror(ensemble, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpermserror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpermserror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpeavgerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeavgerror.restype = ctypes.c_int32
def mlpeavgerror(ensemble, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeavgerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeavgerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpeavgrelerror.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpeavgrelerror.restype = ctypes.c_int32
def mlpeavgrelerror(ensemble, xy, npoints):
    pass
    __result = ctypes.c_double(0)
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpeavgrelerror(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpeavgrelerror'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__xy)


_lib_alglib.x_obj_free_minlbfgsstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minlbfgsstate.restype = None
_lib_alglib.x_minlbfgsstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_get_needf.restype = None
_lib_alglib.x_minlbfgsstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_set_needf.restype = None
_lib_alglib.x_minlbfgsstate_get_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_get_needfg.restype = None
_lib_alglib.x_minlbfgsstate_set_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_set_needfg.restype = None
_lib_alglib.x_minlbfgsstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_get_xupdated.restype = None
_lib_alglib.x_minlbfgsstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_set_xupdated.restype = None
_lib_alglib.x_minlbfgsstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_get_f.restype = None
_lib_alglib.x_minlbfgsstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_set_f.restype = None
_lib_alglib.x_minlbfgsstate_get_g.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_get_g.restype = None
_lib_alglib.x_minlbfgsstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlbfgsstate_get_x.restype = None


class minlbfgsstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minlbfgsstate(self.ptr)


class x_minlbfgsreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfev", x_int),
        ("varidx", x_int),
        ("terminationtype", x_int)
        ]




class minlbfgsreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfev = 0
        self.varidx = 0
        self.terminationtype = 0


def x_minlbfgsreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfev.val = 0
    x.varidx.val = 0
    x.terminationtype.val = 0
    return




def x_minlbfgsreport_clear(x):
    x_minlbfgsreport_zero_fields(x)
    return




def x_from_minlbfgsreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfev.val = int(v.nfev)
    x.varidx.val = int(v.varidx)
    x.terminationtype.val = int(v.terminationtype)
    return




def minlbfgsreport_from_x(x):
    r = minlbfgsreport()
    r.iterationscount = x.iterationscount.val
    r.nfev = x.nfev.val
    r.varidx = x.varidx.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_minlbfgscreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgscreate.restype = ctypes.c_int32
def minlbfgscreate(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,m,x = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,x = functionargs
        n = safe_len("'minlbfgscreate': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlbfgscreate': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgscreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgscreate'")
        __r__state = minlbfgsstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlbfgscreatef.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgscreatef.restype = ctypes.c_int32
def minlbfgscreatef(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        n,m,x,diffstep = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        m,x,diffstep = functionargs
        n = safe_len("'minlbfgscreatef': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlbfgscreatef': function must have 3 or 4 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgscreatef(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgscreatef'")
        __r__state = minlbfgsstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlbfgssetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetcond.restype = ctypes.c_int32
def minlbfgssetcond(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_minlbfgssetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetxrep.restype = ctypes.c_int32
def minlbfgssetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_minlbfgssetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetstpmax.restype = ctypes.c_int32
def minlbfgssetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetstpmax'")
        return
    finally:
        pass


_lib_alglib.alglib_minlbfgssetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetscale.restype = ctypes.c_int32
def minlbfgssetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_minlbfgssetprecdefault.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetprecdefault.restype = ctypes.c_int32
def minlbfgssetprecdefault(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetprecdefault(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetprecdefault'")
        return
    finally:
        pass


_lib_alglib.alglib_minlbfgssetpreccholesky.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetpreccholesky.restype = ctypes.c_int32
def minlbfgssetpreccholesky(state, p, isupper):
    pass
    __state = state.ptr
    if not is_real_matrix(p):
        raise ValueError("'p' parameter can't be cast to real_matrix")
    __p = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__p, p, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetpreccholesky(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__p), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetpreccholesky'")
        return
    finally:
        x_matrix_clear(__p)


_lib_alglib.alglib_minlbfgssetprecdiag.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetprecdiag.restype = ctypes.c_int32
def minlbfgssetprecdiag(state, d):
    pass
    __state = state.ptr
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__d, d, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetprecdiag(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetprecdiag'")
        return
    finally:
        x_vector_clear(__d)


_lib_alglib.alglib_minlbfgssetprecscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetprecscale.restype = ctypes.c_int32
def minlbfgssetprecscale(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetprecscale(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetprecscale'")
        return
    finally:
        pass




def minlbfgsoptimize_f(state, func, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlbfgsstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    while True:
        retval = _lib_alglib.alglib_minlbfgsiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgsiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlbfgsstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_minlbfgsstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_minlbfgsstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlbfgsstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlbfgsoptimize' (some derivatives were not provided?)")
    return


def minlbfgsoptimize_g(state, grad, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlbfgsstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_minlbfgsstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    while True:
        retval = _lib_alglib.alglib_minlbfgsiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgsiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlbfgsstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = grad(_py_x, _py_g, param)
            _lib_alglib.x_minlbfgsstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlbfgsstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlbfgsstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlbfgsoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_minlbfgsresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgsresults.restype = ctypes.c_int32
def minlbfgsresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minlbfgsreport()
    x_minlbfgsreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgsresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgsresults'")
        __r__x = list_from_x(__x)
        __r__rep = minlbfgsreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minlbfgsreport_clear(__rep)


_lib_alglib.alglib_minlbfgsresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgsresultsbuf.restype = ctypes.c_int32
def minlbfgsresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minlbfgsreport()
    x_minlbfgsreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minlbfgsreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgsresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgsresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minlbfgsreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minlbfgsreport_clear(__rep)


_lib_alglib.alglib_minlbfgsrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgsrestartfrom.restype = ctypes.c_int32
def minlbfgsrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgsrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgsrestartfrom'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlbfgsrequesttermination.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgsrequesttermination.restype = ctypes.c_int32
def minlbfgsrequesttermination(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgsrequesttermination(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgsrequesttermination'")
        return
    finally:
        pass


_lib_alglib.alglib_minlbfgssetgradientcheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetgradientcheck.restype = ctypes.c_int32
def minlbfgssetgradientcheck(state, teststep):
    pass
    __state = state.ptr
    __teststep = ctypes.c_double(teststep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetgradientcheck(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__teststep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetgradientcheck'")
        return
    finally:
        pass




class x_mlpreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("relclserror", ctypes.c_double),
        ("avgce", ctypes.c_double),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("ngrad", x_int),
        ("nhess", x_int),
        ("ncholesky", x_int)
        ]




class mlpreport(object):
    def __init__(self):
        self.relclserror = 0
        self.avgce = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.ngrad = 0
        self.nhess = 0
        self.ncholesky = 0


def x_mlpreport_zero_fields(x):
    x.relclserror = 0
    x.avgce = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.ngrad.val = 0
    x.nhess.val = 0
    x.ncholesky.val = 0
    return




def x_mlpreport_clear(x):
    x_mlpreport_zero_fields(x)
    return




def x_from_mlpreport(x,v):
    x.relclserror = float(v.relclserror)
    x.avgce = float(v.avgce)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.ngrad.val = int(v.ngrad)
    x.nhess.val = int(v.nhess)
    x.ncholesky.val = int(v.ncholesky)
    return




def mlpreport_from_x(x):
    r = mlpreport()
    r.relclserror = x.relclserror
    r.avgce = x.avgce
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.ngrad = x.ngrad.val
    r.nhess = x.nhess.val
    r.ncholesky = x.ncholesky.val
    return r




class x_mlpcvreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("relclserror", ctypes.c_double),
        ("avgce", ctypes.c_double),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double)
        ]




class mlpcvreport(object):
    def __init__(self):
        self.relclserror = 0
        self.avgce = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0


def x_mlpcvreport_zero_fields(x):
    x.relclserror = 0
    x.avgce = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    return




def x_mlpcvreport_clear(x):
    x_mlpcvreport_zero_fields(x)
    return




def x_from_mlpcvreport(x,v):
    x.relclserror = float(v.relclserror)
    x.avgce = float(v.avgce)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    return




def mlpcvreport_from_x(x):
    r = mlpcvreport()
    r.relclserror = x.relclserror
    r.avgce = x.avgce
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    return r


_lib_alglib.x_obj_free_mlptrainer.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_mlptrainer.restype = None


class mlptrainer(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_mlptrainer(self.ptr)
_lib_alglib.alglib_mlptrainlm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlptrainlm.restype = ctypes.c_int32
def mlptrainlm(network, xy, npoints, decay, restarts):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlptrainlm(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlptrainlm'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        return (__r__info, __r__rep)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_mlptrainlbfgs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlptrainlbfgs.restype = ctypes.c_int32
def mlptrainlbfgs(network, xy, npoints, decay, restarts, wstep, maxits):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __wstep = ctypes.c_double(wstep)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlptrainlbfgs(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__wstep), ctypes.byref(__maxits), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlptrainlbfgs'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        return (__r__info, __r__rep)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_mlptraines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlptraines.restype = ctypes.c_int32
def mlptraines(network, trnxy, trnsize, valxy, valsize, decay, restarts):
    pass
    __network = network.ptr
    if not is_real_matrix(trnxy):
        raise ValueError("'trnxy' parameter can't be cast to real_matrix")
    __trnxy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __trnsize = x_int()
    __trnsize.val = int(trnsize)
    if __trnsize.val!=trnsize:
        raise ValueError("Error while converting 'trnsize' parameter to 'x_int'")
    if not is_real_matrix(valxy):
        raise ValueError("'valxy' parameter can't be cast to real_matrix")
    __valxy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __valsize = x_int()
    __valsize.val = int(valsize)
    if __valsize.val!=valsize:
        raise ValueError("Error while converting 'valsize' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        x_from_listlist(__trnxy, trnxy, DT_REAL, X_CREATE)
        x_from_listlist(__valxy, valxy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlptraines(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__trnxy), ctypes.byref(__trnsize), ctypes.byref(__valxy), ctypes.byref(__valsize), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlptraines'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        return (__r__info, __r__rep)
    finally:
        x_matrix_clear(__trnxy)
        x_matrix_clear(__valxy)
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_mlpkfoldcvlbfgs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpkfoldcvlbfgs.restype = ctypes.c_int32
def mlpkfoldcvlbfgs(network, xy, npoints, decay, restarts, wstep, maxits, foldscount):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __wstep = ctypes.c_double(wstep)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    __foldscount = x_int()
    __foldscount.val = int(foldscount)
    if __foldscount.val!=foldscount:
        raise ValueError("Error while converting 'foldscount' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    __cvrep = x_mlpcvreport()
    x_mlpcvreport_zero_fields(__cvrep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpkfoldcvlbfgs(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__wstep), ctypes.byref(__maxits), ctypes.byref(__foldscount), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__cvrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpkfoldcvlbfgs'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        __r__cvrep = mlpcvreport_from_x(__cvrep)
        return (__r__info, __r__rep, __r__cvrep)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)
        x_mlpcvreport_clear(__cvrep)


_lib_alglib.alglib_mlpkfoldcvlm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpkfoldcvlm.restype = ctypes.c_int32
def mlpkfoldcvlm(network, xy, npoints, decay, restarts, foldscount):
    pass
    __network = network.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __foldscount = x_int()
    __foldscount.val = int(foldscount)
    if __foldscount.val!=foldscount:
        raise ValueError("Error while converting 'foldscount' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    __cvrep = x_mlpcvreport()
    x_mlpcvreport_zero_fields(__cvrep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpkfoldcvlm(ctypes.byref(_error_msg), ctypes.byref(__network), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__foldscount), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__cvrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpkfoldcvlm'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        __r__cvrep = mlpcvreport_from_x(__cvrep)
        return (__r__info, __r__rep, __r__cvrep)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)
        x_mlpcvreport_clear(__cvrep)


_lib_alglib.alglib_mlpkfoldcv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpkfoldcv.restype = ctypes.c_int32
def mlpkfoldcv(s, network, nrestarts, foldscount):
    pass
    __s = s.ptr
    __network = network.ptr
    __nrestarts = x_int()
    __nrestarts.val = int(nrestarts)
    if __nrestarts.val!=nrestarts:
        raise ValueError("Error while converting 'nrestarts' parameter to 'x_int'")
    __foldscount = x_int()
    __foldscount.val = int(foldscount)
    if __foldscount.val!=foldscount:
        raise ValueError("Error while converting 'foldscount' parameter to 'x_int'")
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpkfoldcv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__network), ctypes.byref(__nrestarts), ctypes.byref(__foldscount), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpkfoldcv'")
        __r__rep = mlpreport_from_x(__rep)
        return __r__rep
    finally:
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_smp_mlpkfoldcv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpkfoldcv.restype = ctypes.c_int32
def smp_mlpkfoldcv(s, network, nrestarts, foldscount):
    pass
    __s = s.ptr
    __network = network.ptr
    __nrestarts = x_int()
    __nrestarts.val = int(nrestarts)
    if __nrestarts.val!=nrestarts:
        raise ValueError("Error while converting 'nrestarts' parameter to 'x_int'")
    __foldscount = x_int()
    __foldscount.val = int(foldscount)
    if __foldscount.val!=foldscount:
        raise ValueError("Error while converting 'foldscount' parameter to 'x_int'")
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpkfoldcv(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__network), ctypes.byref(__nrestarts), ctypes.byref(__foldscount), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpkfoldcv'")
        __r__rep = mlpreport_from_x(__rep)
        return __r__rep
    finally:
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_mlpcreatetrainer.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreatetrainer.restype = ctypes.c_int32
def mlpcreatetrainer(nin, nout):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nout = x_int()
    __nout.val = int(nout)
    if __nout.val!=nout:
        raise ValueError("Error while converting 'nout' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreatetrainer(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nout), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreatetrainer'")
        __r__s = mlptrainer(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_mlpcreatetrainercls.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcreatetrainercls.restype = ctypes.c_int32
def mlpcreatetrainercls(nin, nclasses):
    pass
    __nin = x_int()
    __nin.val = int(nin)
    if __nin.val!=nin:
        raise ValueError("Error while converting 'nin' parameter to 'x_int'")
    __nclasses = x_int()
    __nclasses.val = int(nclasses)
    if __nclasses.val!=nclasses:
        raise ValueError("Error while converting 'nclasses' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcreatetrainercls(ctypes.byref(_error_msg), ctypes.byref(__nin), ctypes.byref(__nclasses), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcreatetrainercls'")
        __r__s = mlptrainer(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_mlpsetdataset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetdataset.restype = ctypes.c_int32
def mlpsetdataset(s, xy, npoints):
    pass
    __s = s.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetdataset(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetdataset'")
        return
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_mlpsetsparsedataset.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetsparsedataset.restype = ctypes.c_int32
def mlpsetsparsedataset(s, xy, npoints):
    pass
    __s = s.ptr
    __xy = xy.ptr
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetsparsedataset(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__xy), ctypes.byref(__npoints))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetsparsedataset'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpsetdecay.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetdecay.restype = ctypes.c_int32
def mlpsetdecay(s, decay):
    pass
    __s = s.ptr
    __decay = ctypes.c_double(decay)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetdecay(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__decay))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetdecay'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetcond.restype = ctypes.c_int32
def mlpsetcond(s, wstep, maxits):
    pass
    __s = s.ptr
    __wstep = ctypes.c_double(wstep)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetcond(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__wstep), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpsetalgobatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpsetalgobatch.restype = ctypes.c_int32
def mlpsetalgobatch(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpsetalgobatch(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpsetalgobatch'")
        return
    finally:
        pass


_lib_alglib.alglib_mlptrainnetwork.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlptrainnetwork.restype = ctypes.c_int32
def mlptrainnetwork(s, network, nrestarts):
    pass
    __s = s.ptr
    __network = network.ptr
    __nrestarts = x_int()
    __nrestarts.val = int(nrestarts)
    if __nrestarts.val!=nrestarts:
        raise ValueError("Error while converting 'nrestarts' parameter to 'x_int'")
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlptrainnetwork(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__network), ctypes.byref(__nrestarts), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlptrainnetwork'")
        __r__rep = mlpreport_from_x(__rep)
        return __r__rep
    finally:
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_smp_mlptrainnetwork.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlptrainnetwork.restype = ctypes.c_int32
def smp_mlptrainnetwork(s, network, nrestarts):
    pass
    __s = s.ptr
    __network = network.ptr
    __nrestarts = x_int()
    __nrestarts.val = int(nrestarts)
    if __nrestarts.val!=nrestarts:
        raise ValueError("Error while converting 'nrestarts' parameter to 'x_int'")
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlptrainnetwork(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__network), ctypes.byref(__nrestarts), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlptrainnetwork'")
        __r__rep = mlpreport_from_x(__rep)
        return __r__rep
    finally:
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_mlpstarttraining.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpstarttraining.restype = ctypes.c_int32
def mlpstarttraining(s, network, randomstart):
    pass
    __s = s.ptr
    __network = network.ptr
    __randomstart = ctypes.c_uint8(randomstart)
    if __randomstart.value!=0:
        __randomstart = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpstarttraining(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__network), ctypes.byref(__randomstart))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpstarttraining'")
        return
    finally:
        pass


_lib_alglib.alglib_mlpcontinuetraining.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpcontinuetraining.restype = ctypes.c_int32
def mlpcontinuetraining(s, network):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpcontinuetraining(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpcontinuetraining'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_smp_mlpcontinuetraining.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlpcontinuetraining.restype = ctypes.c_int32
def smp_mlpcontinuetraining(s, network):
    pass
    __result = ctypes.c_uint8(0)
    __s = s.ptr
    __network = network.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlpcontinuetraining(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__network))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlpcontinuetraining'")
        __r__result = __result.value!=0
        return __r__result
    finally:
        pass


_lib_alglib.alglib_mlpebagginglm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpebagginglm.restype = ctypes.c_int32
def mlpebagginglm(ensemble, xy, npoints, decay, restarts):
    pass
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    __ooberrors = x_mlpcvreport()
    x_mlpcvreport_zero_fields(__ooberrors)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpebagginglm(ctypes.byref(_error_msg), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__ooberrors))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpebagginglm'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        __r__ooberrors = mlpcvreport_from_x(__ooberrors)
        return (__r__info, __r__rep, __r__ooberrors)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)
        x_mlpcvreport_clear(__ooberrors)


_lib_alglib.alglib_mlpebagginglbfgs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpebagginglbfgs.restype = ctypes.c_int32
def mlpebagginglbfgs(ensemble, xy, npoints, decay, restarts, wstep, maxits):
    pass
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __wstep = ctypes.c_double(wstep)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    __ooberrors = x_mlpcvreport()
    x_mlpcvreport_zero_fields(__ooberrors)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpebagginglbfgs(ctypes.byref(_error_msg), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__wstep), ctypes.byref(__maxits), ctypes.byref(__info), ctypes.byref(__rep), ctypes.byref(__ooberrors))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpebagginglbfgs'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        __r__ooberrors = mlpcvreport_from_x(__ooberrors)
        return (__r__info, __r__rep, __r__ooberrors)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)
        x_mlpcvreport_clear(__ooberrors)


_lib_alglib.alglib_mlpetraines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlpetraines.restype = ctypes.c_int32
def mlpetraines(ensemble, xy, npoints, decay, restarts):
    pass
    __ensemble = ensemble.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __decay = ctypes.c_double(decay)
    __restarts = x_int()
    __restarts.val = int(restarts)
    if __restarts.val!=restarts:
        raise ValueError("Error while converting 'restarts' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlpetraines(ctypes.byref(_error_msg), ctypes.byref(__ensemble), ctypes.byref(__xy), ctypes.byref(__npoints), ctypes.byref(__decay), ctypes.byref(__restarts), ctypes.byref(__info), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlpetraines'")
        __r__info = __info.val
        __r__rep = mlpreport_from_x(__rep)
        return (__r__info, __r__rep)
    finally:
        x_matrix_clear(__xy)
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_mlptrainensemblees.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mlptrainensemblees.restype = ctypes.c_int32
def mlptrainensemblees(s, ensemble, nrestarts):
    pass
    __s = s.ptr
    __ensemble = ensemble.ptr
    __nrestarts = x_int()
    __nrestarts.val = int(nrestarts)
    if __nrestarts.val!=nrestarts:
        raise ValueError("Error while converting 'nrestarts' parameter to 'x_int'")
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mlptrainensemblees(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__ensemble), ctypes.byref(__nrestarts), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mlptrainensemblees'")
        __r__rep = mlpreport_from_x(__rep)
        return __r__rep
    finally:
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_smp_mlptrainensemblees.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_mlptrainensemblees.restype = ctypes.c_int32
def smp_mlptrainensemblees(s, ensemble, nrestarts):
    pass
    __s = s.ptr
    __ensemble = ensemble.ptr
    __nrestarts = x_int()
    __nrestarts.val = int(nrestarts)
    if __nrestarts.val!=nrestarts:
        raise ValueError("Error while converting 'nrestarts' parameter to 'x_int'")
    __rep = x_mlpreport()
    x_mlpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_mlptrainensemblees(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__ensemble), ctypes.byref(__nrestarts), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_mlptrainensemblees'")
        __r__rep = mlpreport_from_x(__rep)
        return __r__rep
    finally:
        x_mlpreport_clear(__rep)


_lib_alglib.alglib_pcabuildbasis.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pcabuildbasis.restype = ctypes.c_int32
def pcabuildbasis(x, npoints, nvars):
    pass
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __npoints = x_int()
    __npoints.val = int(npoints)
    if __npoints.val!=npoints:
        raise ValueError("Error while converting 'npoints' parameter to 'x_int'")
    __nvars = x_int()
    __nvars.val = int(nvars)
    if __nvars.val!=nvars:
        raise ValueError("Error while converting 'nvars' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __v = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pcabuildbasis(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__npoints), ctypes.byref(__nvars), ctypes.byref(__info), ctypes.byref(__s2), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pcabuildbasis'")
        __r__info = __info.val
        __r__s2 = list_from_x(__s2)
        __r__v = listlist_from_x(__v)
        return (__r__info, __r__s2, __r__v)
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__s2)
        x_matrix_clear(__v)


_lib_alglib.x_obj_free_odesolverstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_odesolverstate.restype = None
_lib_alglib.x_odesolverstate_get_needdy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_odesolverstate_get_needdy.restype = None
_lib_alglib.x_odesolverstate_set_needdy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_odesolverstate_set_needdy.restype = None
_lib_alglib.x_odesolverstate_get_y.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_odesolverstate_get_y.restype = None
_lib_alglib.x_odesolverstate_get_dy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_odesolverstate_get_dy.restype = None
_lib_alglib.x_odesolverstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_odesolverstate_get_x.restype = None
_lib_alglib.x_odesolverstate_set_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_odesolverstate_set_x.restype = None


class odesolverstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_odesolverstate(self.ptr)


class x_odesolverreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("nfev", x_int),
        ("terminationtype", x_int)
        ]




class odesolverreport(object):
    def __init__(self):
        self.nfev = 0
        self.terminationtype = 0


def x_odesolverreport_zero_fields(x):
    x.nfev.val = 0
    x.terminationtype.val = 0
    return




def x_odesolverreport_clear(x):
    x_odesolverreport_zero_fields(x)
    return




def x_from_odesolverreport(x,v):
    x.nfev.val = int(v.nfev)
    x.terminationtype.val = int(v.terminationtype)
    return




def odesolverreport_from_x(x):
    r = odesolverreport()
    r.nfev = x.nfev.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_odesolverrkck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_odesolverrkck.restype = ctypes.c_int32
def odesolverrkck(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        y,n,x,m,eps,h = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        y,x,eps,h = functionargs
        n = safe_len("'odesolverrkck': incorrect parameters",y)
        m = safe_len("'odesolverrkck': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'odesolverrkck': function must have 4 or 6 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __eps = ctypes.c_double(eps)
    __h = ctypes.c_double(h)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_odesolverrkck(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__m), ctypes.byref(__eps), ctypes.byref(__h), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'odesolverrkck'")
        __r__state = odesolverstate(__state)
        return __r__state
    finally:
        x_vector_clear(__y)
        x_vector_clear(__x)




def odesolversolve(state, dy, param = None):
    # initialize temporaries
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_flag = ctypes.c_uint8()
    
    # initialize reverse communication variables
    _xc_y = x_vector()
    _lib_alglib.x_odesolverstate_get_y(state.ptr, ctypes.byref(_xc_y))
    _py_y = create_real_vector(_xc_y.cnt)
    _xc_x = ctypes.c_double()
    _xc_dy = x_vector()
    _lib_alglib.x_odesolverstate_get_dy(state.ptr, ctypes.byref(_xc_dy))
    _py_dy = create_real_vector(_xc_dy.cnt)
    
    # algorithm iterations
    while True:
        retval = _lib_alglib.alglib_odesolveriteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'odesolveriteration'")
        if not _xc_result:
            break
        _lib_alglib.x_odesolverstate_get_needdy(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_y, _py_y)
            _lib_alglib.x_odesolverstate_get_x(state.ptr, ctypes.byref(_xc_x))
            dy(_py_y, _xc_x.value, _py_dy, param)
            x_from_list(_xc_dy, _py_dy, DT_REAL, X_REWRITE)
            continue
        raise RuntimeError("ALGLIB: unexpected error in 'odesolversolve'")
    return


_lib_alglib.alglib_odesolverresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_odesolverresults.restype = ctypes.c_int32
def odesolverresults(state):
    pass
    __state = state.ptr
    __m = x_int()
    __m.val = 0
    __xtbl = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __ytbl = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_odesolverreport()
    x_odesolverreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_odesolverresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__m), ctypes.byref(__xtbl), ctypes.byref(__ytbl), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'odesolverresults'")
        __r__m = __m.val
        __r__xtbl = list_from_x(__xtbl)
        __r__ytbl = listlist_from_x(__ytbl)
        __r__rep = odesolverreport_from_x(__rep)
        return (__r__m, __r__xtbl, __r__ytbl, __r__rep)
    finally:
        x_vector_clear(__xtbl)
        x_matrix_clear(__ytbl)
        x_odesolverreport_clear(__rep)


_lib_alglib.alglib_fftc1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fftc1d.restype = ctypes.c_int32
def fftc1d(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        n = safe_len("'fftc1d': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'fftc1d': function must have 1 or 2 parameters")
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fftc1d(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fftc1d'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_fftc1dinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fftc1dinv.restype = ctypes.c_int32
def fftc1dinv(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        n = safe_len("'fftc1dinv': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'fftc1dinv': function must have 1 or 2 parameters")
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fftc1dinv(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fftc1dinv'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_fftr1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fftr1d.restype = ctypes.c_int32
def fftr1d(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        n = safe_len("'fftr1d': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'fftr1d': function must have 1 or 2 parameters")
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __f = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fftr1d(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fftr1d'")
        __r__f = list_from_x(__f)
        return __r__f
    finally:
        x_vector_clear(__a)
        x_vector_clear(__f)


_lib_alglib.alglib_fftr1dinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fftr1dinv.restype = ctypes.c_int32
def fftr1dinv(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        f,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        f, = functionargs
        n = safe_len("'fftr1dinv': incorrect parameters",f)
    else:
        raise RuntimeError("Error while calling 'fftr1dinv': function must have 1 or 2 parameters")
    if not is_complex_vector(f):
        raise ValueError("'f' parameter can't be cast to complex_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__f, f, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fftr1dinv(ctypes.byref(_error_msg), ctypes.byref(__f), ctypes.byref(__n), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fftr1dinv'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__f)
        x_vector_clear(__a)


_lib_alglib.alglib_convc1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convc1d.restype = ctypes.c_int32
def convc1d(a, m, b, n):
    pass
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convc1d(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convc1d'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)
        x_vector_clear(__r)


_lib_alglib.alglib_convc1dinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convc1dinv.restype = ctypes.c_int32
def convc1dinv(a, m, b, n):
    pass
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convc1dinv(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convc1dinv'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)
        x_vector_clear(__r)


_lib_alglib.alglib_convc1dcircular.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convc1dcircular.restype = ctypes.c_int32
def convc1dcircular(s, m, r, n):
    pass
    if not is_complex_vector(s):
        raise ValueError("'s' parameter can't be cast to complex_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_complex_vector(r):
        raise ValueError("'r' parameter can't be cast to complex_vector")
    __r = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_COMPLEX, X_CREATE)
        x_from_list(__r, r, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convc1dcircular(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__m), ctypes.byref(__r), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convc1dcircular'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__s)
        x_vector_clear(__r)
        x_vector_clear(__c)


_lib_alglib.alglib_convc1dcircularinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convc1dcircularinv.restype = ctypes.c_int32
def convc1dcircularinv(a, m, b, n):
    pass
    if not is_complex_vector(a):
        raise ValueError("'a' parameter can't be cast to complex_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_complex_vector(b):
        raise ValueError("'b' parameter can't be cast to complex_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__b, b, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convc1dcircularinv(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convc1dcircularinv'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)
        x_vector_clear(__r)


_lib_alglib.alglib_convr1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convr1d.restype = ctypes.c_int32
def convr1d(a, m, b, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convr1d(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convr1d'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)
        x_vector_clear(__r)


_lib_alglib.alglib_convr1dinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convr1dinv.restype = ctypes.c_int32
def convr1dinv(a, m, b, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convr1dinv(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convr1dinv'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)
        x_vector_clear(__r)


_lib_alglib.alglib_convr1dcircular.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convr1dcircular.restype = ctypes.c_int32
def convr1dcircular(s, m, r, n):
    pass
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(r):
        raise ValueError("'r' parameter can't be cast to real_vector")
    __r = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        x_from_list(__r, r, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convr1dcircular(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__m), ctypes.byref(__r), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convr1dcircular'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__s)
        x_vector_clear(__r)
        x_vector_clear(__c)


_lib_alglib.alglib_convr1dcircularinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_convr1dcircularinv.restype = ctypes.c_int32
def convr1dcircularinv(a, m, b, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_convr1dcircularinv(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__m), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'convr1dcircularinv'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)
        x_vector_clear(__r)


_lib_alglib.alglib_corrc1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_corrc1d.restype = ctypes.c_int32
def corrc1d(signal, n, pattern, m):
    pass
    if not is_complex_vector(signal):
        raise ValueError("'signal' parameter can't be cast to complex_vector")
    __signal = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_complex_vector(pattern):
        raise ValueError("'pattern' parameter can't be cast to complex_vector")
    __pattern = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__signal, signal, DT_COMPLEX, X_CREATE)
        x_from_list(__pattern, pattern, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_corrc1d(ctypes.byref(_error_msg), ctypes.byref(__signal), ctypes.byref(__n), ctypes.byref(__pattern), ctypes.byref(__m), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'corrc1d'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__signal)
        x_vector_clear(__pattern)
        x_vector_clear(__r)


_lib_alglib.alglib_corrc1dcircular.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_corrc1dcircular.restype = ctypes.c_int32
def corrc1dcircular(signal, m, pattern, n):
    pass
    if not is_complex_vector(signal):
        raise ValueError("'signal' parameter can't be cast to complex_vector")
    __signal = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_complex_vector(pattern):
        raise ValueError("'pattern' parameter can't be cast to complex_vector")
    __pattern = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__signal, signal, DT_COMPLEX, X_CREATE)
        x_from_list(__pattern, pattern, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_corrc1dcircular(ctypes.byref(_error_msg), ctypes.byref(__signal), ctypes.byref(__m), ctypes.byref(__pattern), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'corrc1dcircular'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__signal)
        x_vector_clear(__pattern)
        x_vector_clear(__c)


_lib_alglib.alglib_corrr1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_corrr1d.restype = ctypes.c_int32
def corrr1d(signal, n, pattern, m):
    pass
    if not is_real_vector(signal):
        raise ValueError("'signal' parameter can't be cast to real_vector")
    __signal = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(pattern):
        raise ValueError("'pattern' parameter can't be cast to real_vector")
    __pattern = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __r = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__signal, signal, DT_REAL, X_CREATE)
        x_from_list(__pattern, pattern, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_corrr1d(ctypes.byref(_error_msg), ctypes.byref(__signal), ctypes.byref(__n), ctypes.byref(__pattern), ctypes.byref(__m), ctypes.byref(__r))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'corrr1d'")
        __r__r = list_from_x(__r)
        return __r__r
    finally:
        x_vector_clear(__signal)
        x_vector_clear(__pattern)
        x_vector_clear(__r)


_lib_alglib.alglib_corrr1dcircular.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_corrr1dcircular.restype = ctypes.c_int32
def corrr1dcircular(signal, m, pattern, n):
    pass
    if not is_real_vector(signal):
        raise ValueError("'signal' parameter can't be cast to real_vector")
    __signal = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(pattern):
        raise ValueError("'pattern' parameter can't be cast to real_vector")
    __pattern = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__signal, signal, DT_REAL, X_CREATE)
        x_from_list(__pattern, pattern, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_corrr1dcircular(ctypes.byref(_error_msg), ctypes.byref(__signal), ctypes.byref(__m), ctypes.byref(__pattern), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'corrr1dcircular'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__signal)
        x_vector_clear(__pattern)
        x_vector_clear(__c)


_lib_alglib.alglib_fhtr1d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fhtr1d.restype = ctypes.c_int32
def fhtr1d(a, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fhtr1d(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fhtr1d'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_fhtr1dinv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fhtr1dinv.restype = ctypes.c_int32
def fhtr1dinv(a, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fhtr1dinv(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fhtr1dinv'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_gqgeneraterec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgeneraterec.restype = ctypes.c_int32
def gqgeneraterec(alpha, beta, mu0, n):
    pass
    if not is_real_vector(alpha):
        raise ValueError("'alpha' parameter can't be cast to real_vector")
    __alpha = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(beta):
        raise ValueError("'beta' parameter can't be cast to real_vector")
    __beta = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __mu0 = ctypes.c_double(mu0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__alpha, alpha, DT_REAL, X_CREATE)
        x_from_list(__beta, beta, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgeneraterec(ctypes.byref(_error_msg), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__mu0), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgeneraterec'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__alpha)
        x_vector_clear(__beta)
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gqgenerategausslobattorec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgenerategausslobattorec.restype = ctypes.c_int32
def gqgenerategausslobattorec(alpha, beta, mu0, a, b, n):
    pass
    if not is_real_vector(alpha):
        raise ValueError("'alpha' parameter can't be cast to real_vector")
    __alpha = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(beta):
        raise ValueError("'beta' parameter can't be cast to real_vector")
    __beta = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __mu0 = ctypes.c_double(mu0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__alpha, alpha, DT_REAL, X_CREATE)
        x_from_list(__beta, beta, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgenerategausslobattorec(ctypes.byref(_error_msg), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__mu0), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgenerategausslobattorec'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__alpha)
        x_vector_clear(__beta)
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gqgenerategaussradaurec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgenerategaussradaurec.restype = ctypes.c_int32
def gqgenerategaussradaurec(alpha, beta, mu0, a, n):
    pass
    if not is_real_vector(alpha):
        raise ValueError("'alpha' parameter can't be cast to real_vector")
    __alpha = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(beta):
        raise ValueError("'beta' parameter can't be cast to real_vector")
    __beta = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __mu0 = ctypes.c_double(mu0)
    __a = ctypes.c_double(a)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__alpha, alpha, DT_REAL, X_CREATE)
        x_from_list(__beta, beta, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgenerategaussradaurec(ctypes.byref(_error_msg), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__mu0), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgenerategaussradaurec'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__alpha)
        x_vector_clear(__beta)
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gqgenerategausslegendre.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgenerategausslegendre.restype = ctypes.c_int32
def gqgenerategausslegendre(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgenerategausslegendre(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgenerategausslegendre'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gqgenerategaussjacobi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgenerategaussjacobi.restype = ctypes.c_int32
def gqgenerategaussjacobi(n, alpha, beta):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    __beta = ctypes.c_double(beta)
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgenerategaussjacobi(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgenerategaussjacobi'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gqgenerategausslaguerre.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgenerategausslaguerre.restype = ctypes.c_int32
def gqgenerategausslaguerre(n, alpha):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgenerategausslaguerre(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__alpha), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgenerategausslaguerre'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gqgenerategausshermite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gqgenerategausshermite.restype = ctypes.c_int32
def gqgenerategausshermite(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gqgenerategausshermite(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gqgenerategausshermite'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__w = list_from_x(__w)
        return (__r__info, __r__x, __r__w)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__w)


_lib_alglib.alglib_gkqgeneraterec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gkqgeneraterec.restype = ctypes.c_int32
def gkqgeneraterec(alpha, beta, mu0, n):
    pass
    if not is_real_vector(alpha):
        raise ValueError("'alpha' parameter can't be cast to real_vector")
    __alpha = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(beta):
        raise ValueError("'beta' parameter can't be cast to real_vector")
    __beta = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __mu0 = ctypes.c_double(mu0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wkronrod = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wgauss = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__alpha, alpha, DT_REAL, X_CREATE)
        x_from_list(__beta, beta, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gkqgeneraterec(ctypes.byref(_error_msg), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__mu0), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__wkronrod), ctypes.byref(__wgauss))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gkqgeneraterec'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__wkronrod = list_from_x(__wkronrod)
        __r__wgauss = list_from_x(__wgauss)
        return (__r__info, __r__x, __r__wkronrod, __r__wgauss)
    finally:
        x_vector_clear(__alpha)
        x_vector_clear(__beta)
        x_vector_clear(__x)
        x_vector_clear(__wkronrod)
        x_vector_clear(__wgauss)


_lib_alglib.alglib_gkqgenerategausslegendre.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gkqgenerategausslegendre.restype = ctypes.c_int32
def gkqgenerategausslegendre(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wkronrod = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wgauss = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gkqgenerategausslegendre(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__wkronrod), ctypes.byref(__wgauss))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gkqgenerategausslegendre'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__wkronrod = list_from_x(__wkronrod)
        __r__wgauss = list_from_x(__wgauss)
        return (__r__info, __r__x, __r__wkronrod, __r__wgauss)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__wkronrod)
        x_vector_clear(__wgauss)


_lib_alglib.alglib_gkqgenerategaussjacobi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gkqgenerategaussjacobi.restype = ctypes.c_int32
def gkqgenerategaussjacobi(n, alpha, beta):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __alpha = ctypes.c_double(alpha)
    __beta = ctypes.c_double(beta)
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wkronrod = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wgauss = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gkqgenerategaussjacobi(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__wkronrod), ctypes.byref(__wgauss))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gkqgenerategaussjacobi'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__wkronrod = list_from_x(__wkronrod)
        __r__wgauss = list_from_x(__wgauss)
        return (__r__info, __r__x, __r__wkronrod, __r__wgauss)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__wkronrod)
        x_vector_clear(__wgauss)


_lib_alglib.alglib_gkqlegendrecalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gkqlegendrecalc.restype = ctypes.c_int32
def gkqlegendrecalc(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wkronrod = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wgauss = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gkqlegendrecalc(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__info), ctypes.byref(__x), ctypes.byref(__wkronrod), ctypes.byref(__wgauss))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gkqlegendrecalc'")
        __r__info = __info.val
        __r__x = list_from_x(__x)
        __r__wkronrod = list_from_x(__wkronrod)
        __r__wgauss = list_from_x(__wgauss)
        return (__r__info, __r__x, __r__wkronrod, __r__wgauss)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__wkronrod)
        x_vector_clear(__wgauss)


_lib_alglib.alglib_gkqlegendretbl.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_gkqlegendretbl.restype = ctypes.c_int32
def gkqlegendretbl(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wkronrod = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __wgauss = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __eps = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_gkqlegendretbl(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__wkronrod), ctypes.byref(__wgauss), ctypes.byref(__eps))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'gkqlegendretbl'")
        __r__x = list_from_x(__x)
        __r__wkronrod = list_from_x(__wkronrod)
        __r__wgauss = list_from_x(__wgauss)
        __r__eps = __eps.value
        return (__r__x, __r__wkronrod, __r__wgauss, __r__eps)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__wkronrod)
        x_vector_clear(__wgauss)




class x_autogkreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("terminationtype", x_int),
        ("nfev", x_int),
        ("nintervals", x_int)
        ]




class autogkreport(object):
    def __init__(self):
        self.terminationtype = 0
        self.nfev = 0
        self.nintervals = 0


def x_autogkreport_zero_fields(x):
    x.terminationtype.val = 0
    x.nfev.val = 0
    x.nintervals.val = 0
    return




def x_autogkreport_clear(x):
    x_autogkreport_zero_fields(x)
    return




def x_from_autogkreport(x,v):
    x.terminationtype.val = int(v.terminationtype)
    x.nfev.val = int(v.nfev)
    x.nintervals.val = int(v.nintervals)
    return




def autogkreport_from_x(x):
    r = autogkreport()
    r.terminationtype = x.terminationtype.val
    r.nfev = x.nfev.val
    r.nintervals = x.nintervals.val
    return r


_lib_alglib.x_obj_free_autogkstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_autogkstate.restype = None
_lib_alglib.x_autogkstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_get_needf.restype = None
_lib_alglib.x_autogkstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_set_needf.restype = None
_lib_alglib.x_autogkstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_get_x.restype = None
_lib_alglib.x_autogkstate_set_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_set_x.restype = None
_lib_alglib.x_autogkstate_get_xminusa.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_get_xminusa.restype = None
_lib_alglib.x_autogkstate_set_xminusa.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_set_xminusa.restype = None
_lib_alglib.x_autogkstate_get_bminusx.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_get_bminusx.restype = None
_lib_alglib.x_autogkstate_set_bminusx.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_set_bminusx.restype = None
_lib_alglib.x_autogkstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_get_f.restype = None
_lib_alglib.x_autogkstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_autogkstate_set_f.restype = None


class autogkstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_autogkstate(self.ptr)
_lib_alglib.alglib_autogksmooth.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_autogksmooth.restype = ctypes.c_int32
def autogksmooth(a, b):
    pass
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_autogksmooth(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'autogksmooth'")
        __r__state = autogkstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_autogksmoothw.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_autogksmoothw.restype = ctypes.c_int32
def autogksmoothw(a, b, xwidth):
    pass
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __xwidth = ctypes.c_double(xwidth)
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_autogksmoothw(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__xwidth), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'autogksmoothw'")
        __r__state = autogkstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_autogksingular.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_autogksingular.restype = ctypes.c_int32
def autogksingular(a, b, alpha, beta):
    pass
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __alpha = ctypes.c_double(alpha)
    __beta = ctypes.c_double(beta)
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_autogksingular(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__alpha), ctypes.byref(__beta), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'autogksingular'")
        __r__state = autogkstate(__state)
        return __r__state
    finally:
        pass




def autogkintegrate(state, func, param = None):
    # initialize temporaries
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_flag = ctypes.c_uint8()
    
    # initialize reverse communication variables
    _xc_x = ctypes.c_double()
    _xc_xminusa = ctypes.c_double()
    _xc_bminusx = ctypes.c_double()
    _xc_f = ctypes.c_double()
    
    # algorithm iterations
    while True:
        retval = _lib_alglib.alglib_autogkiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'autogkiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_autogkstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            _lib_alglib.x_autogkstate_get_x(state.ptr, ctypes.byref(_xc_x))
            _lib_alglib.x_autogkstate_get_xminusa(state.ptr, ctypes.byref(_xc_xminusa))
            _lib_alglib.x_autogkstate_get_bminusx(state.ptr, ctypes.byref(_xc_bminusx))
            _xc_f.value = func(_xc_x.value, _xc_xminusa.value, _xc_bminusx.value, param)
            _lib_alglib.x_autogkstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        raise RuntimeError("ALGLIB: unexpected error in 'autogkintegrate'")
    return


_lib_alglib.alglib_autogkresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_autogkresults.restype = ctypes.c_int32
def autogkresults(state):
    pass
    __state = state.ptr
    __v = ctypes.c_double(0)
    __rep = x_autogkreport()
    x_autogkreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_autogkresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__v), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'autogkresults'")
        __r__v = __v.value
        __r__rep = autogkreport_from_x(__rep)
        return (__r__v, __r__rep)
    finally:
        x_autogkreport_clear(__rep)


_lib_alglib.x_obj_free_idwinterpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_idwinterpolant.restype = None


class idwinterpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_idwinterpolant(self.ptr)
_lib_alglib.alglib_idwcalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_idwcalc.restype = ctypes.c_int32
def idwcalc(z, x):
    pass
    __result = ctypes.c_double(0)
    __z = z.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_idwcalc(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__z), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'idwcalc'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_idwbuildmodifiedshepard.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_idwbuildmodifiedshepard.restype = ctypes.c_int32
def idwbuildmodifiedshepard(xy, n, nx, d, nq, nw):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nx = x_int()
    __nx.val = int(nx)
    if __nx.val!=nx:
        raise ValueError("Error while converting 'nx' parameter to 'x_int'")
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __nq = x_int()
    __nq.val = int(nq)
    if __nq.val!=nq:
        raise ValueError("Error while converting 'nq' parameter to 'x_int'")
    __nw = x_int()
    __nw.val = int(nw)
    if __nw.val!=nw:
        raise ValueError("Error while converting 'nw' parameter to 'x_int'")
    __z = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_idwbuildmodifiedshepard(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__nx), ctypes.byref(__d), ctypes.byref(__nq), ctypes.byref(__nw), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'idwbuildmodifiedshepard'")
        __r__z = idwinterpolant(__z)
        return __r__z
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_idwbuildmodifiedshepardr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_idwbuildmodifiedshepardr.restype = ctypes.c_int32
def idwbuildmodifiedshepardr(xy, n, nx, r):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nx = x_int()
    __nx.val = int(nx)
    if __nx.val!=nx:
        raise ValueError("Error while converting 'nx' parameter to 'x_int'")
    __r = ctypes.c_double(r)
    __z = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_idwbuildmodifiedshepardr(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__nx), ctypes.byref(__r), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'idwbuildmodifiedshepardr'")
        __r__z = idwinterpolant(__z)
        return __r__z
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_idwbuildnoisy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_idwbuildnoisy.restype = ctypes.c_int32
def idwbuildnoisy(xy, n, nx, d, nq, nw):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nx = x_int()
    __nx.val = int(nx)
    if __nx.val!=nx:
        raise ValueError("Error while converting 'nx' parameter to 'x_int'")
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __nq = x_int()
    __nq.val = int(nq)
    if __nq.val!=nq:
        raise ValueError("Error while converting 'nq' parameter to 'x_int'")
    __nw = x_int()
    __nw.val = int(nw)
    if __nw.val!=nw:
        raise ValueError("Error while converting 'nw' parameter to 'x_int'")
    __z = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_idwbuildnoisy(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__nx), ctypes.byref(__d), ctypes.byref(__nq), ctypes.byref(__nw), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'idwbuildnoisy'")
        __r__z = idwinterpolant(__z)
        return __r__z
    finally:
        x_matrix_clear(__xy)


_lib_alglib.x_obj_free_barycentricinterpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_barycentricinterpolant.restype = None


class barycentricinterpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_barycentricinterpolant(self.ptr)
_lib_alglib.alglib_barycentriccalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentriccalc.restype = ctypes.c_int32
def barycentriccalc(b, t):
    pass
    __result = ctypes.c_double(0)
    __b = b.ptr
    __t = ctypes.c_double(t)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentriccalc(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__b), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentriccalc'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_barycentricdiff1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricdiff1.restype = ctypes.c_int32
def barycentricdiff1(b, t):
    pass
    __b = b.ptr
    __t = ctypes.c_double(t)
    __f = ctypes.c_double(0)
    __df = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricdiff1(ctypes.byref(_error_msg), ctypes.byref(__b), ctypes.byref(__t), ctypes.byref(__f), ctypes.byref(__df))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricdiff1'")
        __r__f = __f.value
        __r__df = __df.value
        return (__r__f, __r__df)
    finally:
        pass


_lib_alglib.alglib_barycentricdiff2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricdiff2.restype = ctypes.c_int32
def barycentricdiff2(b, t):
    pass
    __b = b.ptr
    __t = ctypes.c_double(t)
    __f = ctypes.c_double(0)
    __df = ctypes.c_double(0)
    __d2f = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricdiff2(ctypes.byref(_error_msg), ctypes.byref(__b), ctypes.byref(__t), ctypes.byref(__f), ctypes.byref(__df), ctypes.byref(__d2f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricdiff2'")
        __r__f = __f.value
        __r__df = __df.value
        __r__d2f = __d2f.value
        return (__r__f, __r__df, __r__d2f)
    finally:
        pass


_lib_alglib.alglib_barycentriclintransx.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentriclintransx.restype = ctypes.c_int32
def barycentriclintransx(b, ca, cb):
    pass
    __b = b.ptr
    __ca = ctypes.c_double(ca)
    __cb = ctypes.c_double(cb)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentriclintransx(ctypes.byref(_error_msg), ctypes.byref(__b), ctypes.byref(__ca), ctypes.byref(__cb))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentriclintransx'")
        return
    finally:
        pass


_lib_alglib.alglib_barycentriclintransy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentriclintransy.restype = ctypes.c_int32
def barycentriclintransy(b, ca, cb):
    pass
    __b = b.ptr
    __ca = ctypes.c_double(ca)
    __cb = ctypes.c_double(cb)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentriclintransy(ctypes.byref(_error_msg), ctypes.byref(__b), ctypes.byref(__ca), ctypes.byref(__cb))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentriclintransy'")
        return
    finally:
        pass


_lib_alglib.alglib_barycentricunpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricunpack.restype = ctypes.c_int32
def barycentricunpack(b):
    pass
    __b = b.ptr
    __n = x_int()
    __n.val = 0
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __w = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricunpack(ctypes.byref(_error_msg), ctypes.byref(__b), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricunpack'")
        __r__n = __n.val
        __r__x = list_from_x(__x)
        __r__y = list_from_x(__y)
        __r__w = list_from_x(__w)
        return (__r__n, __r__x, __r__y, __r__w)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)


_lib_alglib.alglib_barycentricbuildxyw.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricbuildxyw.restype = ctypes.c_int32
def barycentricbuildxyw(x, y, w, n):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __b = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricbuildxyw(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricbuildxyw'")
        __r__b = barycentricinterpolant(__b)
        return __r__b
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)


_lib_alglib.alglib_barycentricbuildfloaterhormann.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricbuildfloaterhormann.restype = ctypes.c_int32
def barycentricbuildfloaterhormann(x, y, n, d):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __b = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricbuildfloaterhormann(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__d), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricbuildfloaterhormann'")
        __r__b = barycentricinterpolant(__b)
        return __r__b
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_polynomialbar2cheb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialbar2cheb.restype = ctypes.c_int32
def polynomialbar2cheb(p, a, b):
    pass
    __p = p.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __t = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialbar2cheb(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialbar2cheb'")
        __r__t = list_from_x(__t)
        return __r__t
    finally:
        x_vector_clear(__t)


_lib_alglib.alglib_polynomialcheb2bar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialcheb2bar.restype = ctypes.c_int32
def polynomialcheb2bar(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        t,n,a,b = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        t,a,b = functionargs
        n = safe_len("'polynomialcheb2bar': incorrect parameters",t)
    else:
        raise RuntimeError("Error while calling 'polynomialcheb2bar': function must have 3 or 4 parameters")
    if not is_real_vector(t):
        raise ValueError("'t' parameter can't be cast to real_vector")
    __t = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __p = ctypes.c_void_p(0)
    try:
        x_from_list(__t, t, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialcheb2bar(ctypes.byref(_error_msg), ctypes.byref(__t), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialcheb2bar'")
        __r__p = barycentricinterpolant(__p)
        return __r__p
    finally:
        x_vector_clear(__t)


_lib_alglib.alglib_polynomialbar2pow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialbar2pow.restype = ctypes.c_int32
def polynomialbar2pow(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        p,c,s = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        p, = functionargs
        c = 0
        s = 1
    else:
        raise RuntimeError("Error while calling 'polynomialbar2pow': function must have 1 or 3 parameters")
    __p = p.ptr
    __c = ctypes.c_double(c)
    __s = ctypes.c_double(s)
    __a = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialbar2pow(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__c), ctypes.byref(__s), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialbar2pow'")
        __r__a = list_from_x(__a)
        return __r__a
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_polynomialpow2bar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialpow2bar.restype = ctypes.c_int32
def polynomialpow2bar(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,n,c,s = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        n = safe_len("'polynomialpow2bar': incorrect parameters",a)
        c = 0
        s = 1
    else:
        raise RuntimeError("Error while calling 'polynomialpow2bar': function must have 1 or 4 parameters")
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_double(c)
    __s = ctypes.c_double(s)
    __p = ctypes.c_void_p(0)
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialpow2bar(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__c), ctypes.byref(__s), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialpow2bar'")
        __r__p = barycentricinterpolant(__p)
        return __r__p
    finally:
        x_vector_clear(__a)


_lib_alglib.alglib_polynomialbuild.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialbuild.restype = ctypes.c_int32
def polynomialbuild(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'polynomialbuild': incorrect parameters",x)!=safe_len("'polynomialbuild': incorrect parameters",y):
            raise RuntimeError("Error while calling 'polynomialbuild': looks like one of arguments has wrong size")
        n = safe_len("'polynomialbuild': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'polynomialbuild': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialbuild(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialbuild'")
        __r__p = barycentricinterpolant(__p)
        return __r__p
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_polynomialbuildeqdist.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialbuildeqdist.restype = ctypes.c_int32
def polynomialbuildeqdist(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,b,y,n = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        a,b,y = functionargs
        n = safe_len("'polynomialbuildeqdist': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'polynomialbuildeqdist': function must have 3 or 4 parameters")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialbuildeqdist(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialbuildeqdist'")
        __r__p = barycentricinterpolant(__p)
        return __r__p
    finally:
        x_vector_clear(__y)


_lib_alglib.alglib_polynomialbuildcheb1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialbuildcheb1.restype = ctypes.c_int32
def polynomialbuildcheb1(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,b,y,n = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        a,b,y = functionargs
        n = safe_len("'polynomialbuildcheb1': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'polynomialbuildcheb1': function must have 3 or 4 parameters")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialbuildcheb1(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialbuildcheb1'")
        __r__p = barycentricinterpolant(__p)
        return __r__p
    finally:
        x_vector_clear(__y)


_lib_alglib.alglib_polynomialbuildcheb2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialbuildcheb2.restype = ctypes.c_int32
def polynomialbuildcheb2(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        a,b,y,n = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        a,b,y = functionargs
        n = safe_len("'polynomialbuildcheb2': incorrect parameters",y)
    else:
        raise RuntimeError("Error while calling 'polynomialbuildcheb2': function must have 3 or 4 parameters")
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialbuildcheb2(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialbuildcheb2'")
        __r__p = barycentricinterpolant(__p)
        return __r__p
    finally:
        x_vector_clear(__y)


_lib_alglib.alglib_polynomialcalceqdist.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialcalceqdist.restype = ctypes.c_int32
def polynomialcalceqdist(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        a,b,f,n,t = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        a,b,f,t = functionargs
        n = safe_len("'polynomialcalceqdist': incorrect parameters",f)
    else:
        raise RuntimeError("Error while calling 'polynomialcalceqdist': function must have 4 or 5 parameters")
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __t = ctypes.c_double(t)
    try:
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialcalceqdist(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__f), ctypes.byref(__n), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialcalceqdist'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__f)


_lib_alglib.alglib_polynomialcalccheb1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialcalccheb1.restype = ctypes.c_int32
def polynomialcalccheb1(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        a,b,f,n,t = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        a,b,f,t = functionargs
        n = safe_len("'polynomialcalccheb1': incorrect parameters",f)
    else:
        raise RuntimeError("Error while calling 'polynomialcalccheb1': function must have 4 or 5 parameters")
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __t = ctypes.c_double(t)
    try:
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialcalccheb1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__f), ctypes.byref(__n), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialcalccheb1'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__f)


_lib_alglib.alglib_polynomialcalccheb2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialcalccheb2.restype = ctypes.c_int32
def polynomialcalccheb2(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        a,b,f,n,t = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        a,b,f,t = functionargs
        n = safe_len("'polynomialcalccheb2': incorrect parameters",f)
    else:
        raise RuntimeError("Error while calling 'polynomialcalccheb2': function must have 4 or 5 parameters")
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __t = ctypes.c_double(t)
    try:
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialcalccheb2(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__f), ctypes.byref(__n), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialcalccheb2'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__f)


_lib_alglib.x_obj_free_spline1dinterpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_spline1dinterpolant.restype = None


class spline1dinterpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_spline1dinterpolant(self.ptr)
_lib_alglib.alglib_spline1dbuildlinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dbuildlinear.restype = ctypes.c_int32
def spline1dbuildlinear(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dbuildlinear': incorrect parameters",x)!=safe_len("'spline1dbuildlinear': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size")
        n = safe_len("'spline1dbuildlinear': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dbuildlinear': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dbuildlinear(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dbuildlinear'")
        __r__c = spline1dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_spline1dbuildcubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dbuildcubic.restype = ctypes.c_int32
def spline1dbuildcubic(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        x,y,n,boundltype,boundl,boundrtype,boundr = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dbuildcubic': incorrect parameters",x)!=safe_len("'spline1dbuildcubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dbuildcubic': incorrect parameters",x)
        boundltype = 0
        boundl = 0
        boundrtype = 0
        boundr = 0
    else:
        raise RuntimeError("Error while calling 'spline1dbuildcubic': function must have 2 or 7 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundltype = x_int()
    __boundltype.val = int(boundltype)
    if __boundltype.val!=boundltype:
        raise ValueError("Error while converting 'boundltype' parameter to 'x_int'")
    __boundl = ctypes.c_double(boundl)
    __boundrtype = x_int()
    __boundrtype.val = int(boundrtype)
    if __boundrtype.val!=boundrtype:
        raise ValueError("Error while converting 'boundrtype' parameter to 'x_int'")
    __boundr = ctypes.c_double(boundr)
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dbuildcubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundltype), ctypes.byref(__boundl), ctypes.byref(__boundrtype), ctypes.byref(__boundr), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dbuildcubic'")
        __r__c = spline1dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_spline1dgriddiffcubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dgriddiffcubic.restype = ctypes.c_int32
def spline1dgriddiffcubic(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        x,y,n,boundltype,boundl,boundrtype,boundr = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dgriddiffcubic': incorrect parameters",x)!=safe_len("'spline1dgriddiffcubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dgriddiffcubic': incorrect parameters",x)
        boundltype = 0
        boundl = 0
        boundrtype = 0
        boundr = 0
    else:
        raise RuntimeError("Error while calling 'spline1dgriddiffcubic': function must have 2 or 7 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundltype = x_int()
    __boundltype.val = int(boundltype)
    if __boundltype.val!=boundltype:
        raise ValueError("Error while converting 'boundltype' parameter to 'x_int'")
    __boundl = ctypes.c_double(boundl)
    __boundrtype = x_int()
    __boundrtype.val = int(boundrtype)
    if __boundrtype.val!=boundrtype:
        raise ValueError("Error while converting 'boundrtype' parameter to 'x_int'")
    __boundr = ctypes.c_double(boundr)
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dgriddiffcubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundltype), ctypes.byref(__boundl), ctypes.byref(__boundrtype), ctypes.byref(__boundr), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dgriddiffcubic'")
        __r__d = list_from_x(__d)
        return __r__d
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__d)


_lib_alglib.alglib_spline1dgriddiff2cubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dgriddiff2cubic.restype = ctypes.c_int32
def spline1dgriddiff2cubic(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        x,y,n,boundltype,boundl,boundrtype,boundr = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dgriddiff2cubic': incorrect parameters",x)!=safe_len("'spline1dgriddiff2cubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dgriddiff2cubic': incorrect parameters",x)
        boundltype = 0
        boundl = 0
        boundrtype = 0
        boundr = 0
    else:
        raise RuntimeError("Error while calling 'spline1dgriddiff2cubic': function must have 2 or 7 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundltype = x_int()
    __boundltype.val = int(boundltype)
    if __boundltype.val!=boundltype:
        raise ValueError("Error while converting 'boundltype' parameter to 'x_int'")
    __boundl = ctypes.c_double(boundl)
    __boundrtype = x_int()
    __boundrtype.val = int(boundrtype)
    if __boundrtype.val!=boundrtype:
        raise ValueError("Error while converting 'boundrtype' parameter to 'x_int'")
    __boundr = ctypes.c_double(boundr)
    __d1 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dgriddiff2cubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundltype), ctypes.byref(__boundl), ctypes.byref(__boundrtype), ctypes.byref(__boundr), ctypes.byref(__d1), ctypes.byref(__d2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dgriddiff2cubic'")
        __r__d1 = list_from_x(__d1)
        __r__d2 = list_from_x(__d2)
        return (__r__d1, __r__d2)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__d1)
        x_vector_clear(__d2)


_lib_alglib.alglib_spline1dconvcubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dconvcubic.restype = ctypes.c_int32
def spline1dconvcubic(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,n,boundltype,boundl,boundrtype,boundr,x2,n2 = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,x2 = functionargs
        if safe_len("'spline1dconvcubic': incorrect parameters",x)!=safe_len("'spline1dconvcubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dconvcubic': incorrect parameters",x)
        boundltype = 0
        boundl = 0
        boundrtype = 0
        boundr = 0
        n2 = safe_len("'spline1dconvcubic': incorrect parameters",x2)
    else:
        raise RuntimeError("Error while calling 'spline1dconvcubic': function must have 3 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundltype = x_int()
    __boundltype.val = int(boundltype)
    if __boundltype.val!=boundltype:
        raise ValueError("Error while converting 'boundltype' parameter to 'x_int'")
    __boundl = ctypes.c_double(boundl)
    __boundrtype = x_int()
    __boundrtype.val = int(boundrtype)
    if __boundrtype.val!=boundrtype:
        raise ValueError("Error while converting 'boundrtype' parameter to 'x_int'")
    __boundr = ctypes.c_double(boundr)
    if not is_real_vector(x2):
        raise ValueError("'x2' parameter can't be cast to real_vector")
    __x2 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n2 = x_int()
    __n2.val = int(n2)
    if __n2.val!=n2:
        raise ValueError("Error while converting 'n2' parameter to 'x_int'")
    __y2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__x2, x2, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dconvcubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundltype), ctypes.byref(__boundl), ctypes.byref(__boundrtype), ctypes.byref(__boundr), ctypes.byref(__x2), ctypes.byref(__n2), ctypes.byref(__y2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dconvcubic'")
        __r__y2 = list_from_x(__y2)
        return __r__y2
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__x2)
        x_vector_clear(__y2)


_lib_alglib.alglib_spline1dconvdiffcubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dconvdiffcubic.restype = ctypes.c_int32
def spline1dconvdiffcubic(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,n,boundltype,boundl,boundrtype,boundr,x2,n2 = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,x2 = functionargs
        if safe_len("'spline1dconvdiffcubic': incorrect parameters",x)!=safe_len("'spline1dconvdiffcubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dconvdiffcubic': incorrect parameters",x)
        boundltype = 0
        boundl = 0
        boundrtype = 0
        boundr = 0
        n2 = safe_len("'spline1dconvdiffcubic': incorrect parameters",x2)
    else:
        raise RuntimeError("Error while calling 'spline1dconvdiffcubic': function must have 3 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundltype = x_int()
    __boundltype.val = int(boundltype)
    if __boundltype.val!=boundltype:
        raise ValueError("Error while converting 'boundltype' parameter to 'x_int'")
    __boundl = ctypes.c_double(boundl)
    __boundrtype = x_int()
    __boundrtype.val = int(boundrtype)
    if __boundrtype.val!=boundrtype:
        raise ValueError("Error while converting 'boundrtype' parameter to 'x_int'")
    __boundr = ctypes.c_double(boundr)
    if not is_real_vector(x2):
        raise ValueError("'x2' parameter can't be cast to real_vector")
    __x2 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n2 = x_int()
    __n2.val = int(n2)
    if __n2.val!=n2:
        raise ValueError("Error while converting 'n2' parameter to 'x_int'")
    __y2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__x2, x2, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dconvdiffcubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundltype), ctypes.byref(__boundl), ctypes.byref(__boundrtype), ctypes.byref(__boundr), ctypes.byref(__x2), ctypes.byref(__n2), ctypes.byref(__y2), ctypes.byref(__d2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dconvdiffcubic'")
        __r__y2 = list_from_x(__y2)
        __r__d2 = list_from_x(__d2)
        return (__r__y2, __r__d2)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__x2)
        x_vector_clear(__y2)
        x_vector_clear(__d2)


_lib_alglib.alglib_spline1dconvdiff2cubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dconvdiff2cubic.restype = ctypes.c_int32
def spline1dconvdiff2cubic(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,n,boundltype,boundl,boundrtype,boundr,x2,n2 = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,x2 = functionargs
        if safe_len("'spline1dconvdiff2cubic': incorrect parameters",x)!=safe_len("'spline1dconvdiff2cubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dconvdiff2cubic': incorrect parameters",x)
        boundltype = 0
        boundl = 0
        boundrtype = 0
        boundr = 0
        n2 = safe_len("'spline1dconvdiff2cubic': incorrect parameters",x2)
    else:
        raise RuntimeError("Error while calling 'spline1dconvdiff2cubic': function must have 3 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundltype = x_int()
    __boundltype.val = int(boundltype)
    if __boundltype.val!=boundltype:
        raise ValueError("Error while converting 'boundltype' parameter to 'x_int'")
    __boundl = ctypes.c_double(boundl)
    __boundrtype = x_int()
    __boundrtype.val = int(boundrtype)
    if __boundrtype.val!=boundrtype:
        raise ValueError("Error while converting 'boundrtype' parameter to 'x_int'")
    __boundr = ctypes.c_double(boundr)
    if not is_real_vector(x2):
        raise ValueError("'x2' parameter can't be cast to real_vector")
    __x2 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n2 = x_int()
    __n2.val = int(n2)
    if __n2.val!=n2:
        raise ValueError("Error while converting 'n2' parameter to 'x_int'")
    __y2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __dd2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__x2, x2, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dconvdiff2cubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundltype), ctypes.byref(__boundl), ctypes.byref(__boundrtype), ctypes.byref(__boundr), ctypes.byref(__x2), ctypes.byref(__n2), ctypes.byref(__y2), ctypes.byref(__d2), ctypes.byref(__dd2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dconvdiff2cubic'")
        __r__y2 = list_from_x(__y2)
        __r__d2 = list_from_x(__d2)
        __r__dd2 = list_from_x(__dd2)
        return (__r__y2, __r__d2, __r__dd2)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__x2)
        x_vector_clear(__y2)
        x_vector_clear(__d2)
        x_vector_clear(__dd2)


_lib_alglib.alglib_spline1dbuildcatmullrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dbuildcatmullrom.restype = ctypes.c_int32
def spline1dbuildcatmullrom(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,boundtype,tension = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dbuildcatmullrom': incorrect parameters",x)!=safe_len("'spline1dbuildcatmullrom': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size")
        n = safe_len("'spline1dbuildcatmullrom': incorrect parameters",x)
        boundtype = 0
        tension = 0
    else:
        raise RuntimeError("Error while calling 'spline1dbuildcatmullrom': function must have 2 or 5 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __boundtype = x_int()
    __boundtype.val = int(boundtype)
    if __boundtype.val!=boundtype:
        raise ValueError("Error while converting 'boundtype' parameter to 'x_int'")
    __tension = ctypes.c_double(tension)
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dbuildcatmullrom(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__boundtype), ctypes.byref(__tension), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dbuildcatmullrom'")
        __r__c = spline1dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_spline1dbuildhermite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dbuildhermite.restype = ctypes.c_int32
def spline1dbuildhermite(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,d,n = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,d = functionargs
        if safe_len("'spline1dbuildhermite': incorrect parameters",x)!=safe_len("'spline1dbuildhermite': incorrect parameters",y) or safe_len("'spline1dbuildhermite': incorrect parameters",x)!=safe_len("'spline1dbuildhermite': incorrect parameters",d):
            raise RuntimeError("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size")
        n = safe_len("'spline1dbuildhermite': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dbuildhermite': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(d):
        raise ValueError("'d' parameter can't be cast to real_vector")
    __d = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__d, d, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dbuildhermite(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__d), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dbuildhermite'")
        __r__c = spline1dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__d)


_lib_alglib.alglib_spline1dbuildakima.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dbuildakima.restype = ctypes.c_int32
def spline1dbuildakima(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dbuildakima': incorrect parameters",x)!=safe_len("'spline1dbuildakima': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size")
        n = safe_len("'spline1dbuildakima': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dbuildakima': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dbuildakima(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dbuildakima'")
        __r__c = spline1dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_spline1dcalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dcalc.restype = ctypes.c_int32
def spline1dcalc(c, x):
    pass
    __result = ctypes.c_double(0)
    __c = c.ptr
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dcalc(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dcalc'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_spline1ddiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1ddiff.restype = ctypes.c_int32
def spline1ddiff(c, x):
    pass
    __c = c.ptr
    __x = ctypes.c_double(x)
    __s = ctypes.c_double(0)
    __ds = ctypes.c_double(0)
    __d2s = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1ddiff(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__s), ctypes.byref(__ds), ctypes.byref(__d2s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1ddiff'")
        __r__s = __s.value
        __r__ds = __ds.value
        __r__d2s = __d2s.value
        return (__r__s, __r__ds, __r__d2s)
    finally:
        pass


_lib_alglib.alglib_spline1dunpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dunpack.restype = ctypes.c_int32
def spline1dunpack(c):
    pass
    __c = c.ptr
    __n = x_int()
    __n.val = 0
    __tbl = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dunpack(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__tbl))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dunpack'")
        __r__n = __n.val
        __r__tbl = listlist_from_x(__tbl)
        return (__r__n, __r__tbl)
    finally:
        x_matrix_clear(__tbl)


_lib_alglib.alglib_spline1dlintransx.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dlintransx.restype = ctypes.c_int32
def spline1dlintransx(c, a, b):
    pass
    __c = c.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dlintransx(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dlintransx'")
        return
    finally:
        pass


_lib_alglib.alglib_spline1dlintransy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dlintransy.restype = ctypes.c_int32
def spline1dlintransy(c, a, b):
    pass
    __c = c.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dlintransy(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dlintransy'")
        return
    finally:
        pass


_lib_alglib.alglib_spline1dintegrate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dintegrate.restype = ctypes.c_int32
def spline1dintegrate(c, x):
    pass
    __result = ctypes.c_double(0)
    __c = c.ptr
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dintegrate(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dintegrate'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_spline1dbuildmonotone.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dbuildmonotone.restype = ctypes.c_int32
def spline1dbuildmonotone(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        x,y,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,y = functionargs
        if safe_len("'spline1dbuildmonotone': incorrect parameters",x)!=safe_len("'spline1dbuildmonotone': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size")
        n = safe_len("'spline1dbuildmonotone': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dbuildmonotone': function must have 2 or 3 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dbuildmonotone(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dbuildmonotone'")
        __r__c = spline1dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.x_obj_free_normestimatorstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_normestimatorstate.restype = None


class normestimatorstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_normestimatorstate(self.ptr)
_lib_alglib.alglib_normestimatorcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_normestimatorcreate.restype = ctypes.c_int32
def normestimatorcreate(m, n, nstart, nits):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __nstart = x_int()
    __nstart.val = int(nstart)
    if __nstart.val!=nstart:
        raise ValueError("Error while converting 'nstart' parameter to 'x_int'")
    __nits = x_int()
    __nits.val = int(nits)
    if __nits.val!=nits:
        raise ValueError("Error while converting 'nits' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_normestimatorcreate(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__nstart), ctypes.byref(__nits), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'normestimatorcreate'")
        __r__state = normestimatorstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_normestimatorsetseed.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_normestimatorsetseed.restype = ctypes.c_int32
def normestimatorsetseed(state, seedval):
    pass
    __state = state.ptr
    __seedval = x_int()
    __seedval.val = int(seedval)
    if __seedval.val!=seedval:
        raise ValueError("Error while converting 'seedval' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_normestimatorsetseed(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__seedval))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'normestimatorsetseed'")
        return
    finally:
        pass


_lib_alglib.alglib_normestimatorestimatesparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_normestimatorestimatesparse.restype = ctypes.c_int32
def normestimatorestimatesparse(state, a):
    pass
    __state = state.ptr
    __a = a.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_normestimatorestimatesparse(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__a))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'normestimatorestimatesparse'")
        return
    finally:
        pass


_lib_alglib.alglib_normestimatorresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_normestimatorresults.restype = ctypes.c_int32
def normestimatorresults(state):
    pass
    __state = state.ptr
    __nrm = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_normestimatorresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__nrm))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'normestimatorresults'")
        __r__nrm = __nrm.value
        return __r__nrm
    finally:
        pass


_lib_alglib.x_obj_free_minqpstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minqpstate.restype = None


class minqpstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minqpstate(self.ptr)


class x_minqpreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("inneriterationscount", x_int),
        ("outeriterationscount", x_int),
        ("nmv", x_int),
        ("ncholesky", x_int),
        ("terminationtype", x_int)
        ]




class minqpreport(object):
    def __init__(self):
        self.inneriterationscount = 0
        self.outeriterationscount = 0
        self.nmv = 0
        self.ncholesky = 0
        self.terminationtype = 0


def x_minqpreport_zero_fields(x):
    x.inneriterationscount.val = 0
    x.outeriterationscount.val = 0
    x.nmv.val = 0
    x.ncholesky.val = 0
    x.terminationtype.val = 0
    return




def x_minqpreport_clear(x):
    x_minqpreport_zero_fields(x)
    return




def x_from_minqpreport(x,v):
    x.inneriterationscount.val = int(v.inneriterationscount)
    x.outeriterationscount.val = int(v.outeriterationscount)
    x.nmv.val = int(v.nmv)
    x.ncholesky.val = int(v.ncholesky)
    x.terminationtype.val = int(v.terminationtype)
    return




def minqpreport_from_x(x):
    r = minqpreport()
    r.inneriterationscount = x.inneriterationscount.val
    r.outeriterationscount = x.outeriterationscount.val
    r.nmv = x.nmv.val
    r.ncholesky = x.ncholesky.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_minqpcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpcreate.restype = ctypes.c_int32
def minqpcreate(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpcreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpcreate'")
        __r__state = minqpstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_minqpsetlinearterm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetlinearterm.restype = ctypes.c_int32
def minqpsetlinearterm(state, b):
    pass
    __state = state.ptr
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetlinearterm(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetlinearterm'")
        return
    finally:
        x_vector_clear(__b)


_lib_alglib.alglib_minqpsetquadraticterm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetquadraticterm.restype = ctypes.c_int32
def minqpsetquadraticterm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        state,a,isupper = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        state,a = functionargs
        isupper = False
    else:
        raise RuntimeError("Error while calling 'minqpsetquadraticterm': function must have 2 or 3 parameters")
    __state = state.ptr
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to symmetric")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        if __friendly_form:
            if not x_is_symmetric(__a):
                raise ValueError("'a' parameter is not symmetric matrix")
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetquadraticterm(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__a), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetquadraticterm'")
        return
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_minqpsetquadratictermsparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetquadratictermsparse.restype = ctypes.c_int32
def minqpsetquadratictermsparse(state, a, isupper):
    pass
    __state = state.ptr
    __a = a.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetquadratictermsparse(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__a), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetquadratictermsparse'")
        return
    finally:
        pass


_lib_alglib.alglib_minqpsetstartingpoint.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetstartingpoint.restype = ctypes.c_int32
def minqpsetstartingpoint(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetstartingpoint(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetstartingpoint'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minqpsetorigin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetorigin.restype = ctypes.c_int32
def minqpsetorigin(state, xorigin):
    pass
    __state = state.ptr
    if not is_real_vector(xorigin):
        raise ValueError("'xorigin' parameter can't be cast to real_vector")
    __xorigin = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__xorigin, xorigin, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetorigin(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__xorigin))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetorigin'")
        return
    finally:
        x_vector_clear(__xorigin)


_lib_alglib.alglib_minqpsetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetscale.restype = ctypes.c_int32
def minqpsetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_minqpsetalgocholesky.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetalgocholesky.restype = ctypes.c_int32
def minqpsetalgocholesky(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetalgocholesky(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetalgocholesky'")
        return
    finally:
        pass


_lib_alglib.alglib_minqpsetalgobleic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetalgobleic.restype = ctypes.c_int32
def minqpsetalgobleic(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetalgobleic(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetalgobleic'")
        return
    finally:
        pass


_lib_alglib.alglib_minqpsetalgoquickqp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetalgoquickqp.restype = ctypes.c_int32
def minqpsetalgoquickqp(state, epsg, epsf, epsx, maxouterits, usenewton):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxouterits = x_int()
    __maxouterits.val = int(maxouterits)
    if __maxouterits.val!=maxouterits:
        raise ValueError("Error while converting 'maxouterits' parameter to 'x_int'")
    __usenewton = ctypes.c_uint8(usenewton)
    if __usenewton.value!=0:
        __usenewton = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetalgoquickqp(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxouterits), ctypes.byref(__usenewton))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetalgoquickqp'")
        return
    finally:
        pass


_lib_alglib.alglib_minqpsetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetbc.restype = ctypes.c_int32
def minqpsetbc(state, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetbc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetbc'")
        return
    finally:
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.alglib_minqpsetlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpsetlc.restype = ctypes.c_int32
def minqpsetlc(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        state,c,ct,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        state,c,ct = functionargs
        if safe_rows("'minqpsetlc': incorrect parameters",c)!=safe_len("'minqpsetlc': incorrect parameters",ct):
            raise RuntimeError("Error while calling 'minqpsetlc': looks like one of arguments has wrong size")
        k = safe_rows("'minqpsetlc': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'minqpsetlc': function must have 3 or 4 parameters")
    __state = state.ptr
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(ct):
        raise ValueError("'ct' parameter can't be cast to int_vector")
    __ct = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        x_from_list(__ct, ct, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpsetlc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__c), ctypes.byref(__ct), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpsetlc'")
        return
    finally:
        x_matrix_clear(__c)
        x_vector_clear(__ct)


_lib_alglib.alglib_minqpoptimize.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpoptimize.restype = ctypes.c_int32
def minqpoptimize(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpoptimize(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpoptimize'")
        return
    finally:
        pass


_lib_alglib.alglib_minqpresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpresults.restype = ctypes.c_int32
def minqpresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minqpreport()
    x_minqpreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpresults'")
        __r__x = list_from_x(__x)
        __r__rep = minqpreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minqpreport_clear(__rep)


_lib_alglib.alglib_minqpresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minqpresultsbuf.restype = ctypes.c_int32
def minqpresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minqpreport()
    x_minqpreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minqpreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minqpresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minqpresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minqpreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minqpreport_clear(__rep)


_lib_alglib.x_obj_free_minlmstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minlmstate.restype = None
_lib_alglib.x_minlmstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_needf.restype = None
_lib_alglib.x_minlmstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_needf.restype = None
_lib_alglib.x_minlmstate_get_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_needfg.restype = None
_lib_alglib.x_minlmstate_set_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_needfg.restype = None
_lib_alglib.x_minlmstate_get_needfgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_needfgh.restype = None
_lib_alglib.x_minlmstate_set_needfgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_needfgh.restype = None
_lib_alglib.x_minlmstate_get_needfi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_needfi.restype = None
_lib_alglib.x_minlmstate_set_needfi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_needfi.restype = None
_lib_alglib.x_minlmstate_get_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_needfij.restype = None
_lib_alglib.x_minlmstate_set_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_needfij.restype = None
_lib_alglib.x_minlmstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_xupdated.restype = None
_lib_alglib.x_minlmstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_xupdated.restype = None
_lib_alglib.x_minlmstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_f.restype = None
_lib_alglib.x_minlmstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_set_f.restype = None
_lib_alglib.x_minlmstate_get_fi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_fi.restype = None
_lib_alglib.x_minlmstate_get_g.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_g.restype = None
_lib_alglib.x_minlmstate_get_h.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_h.restype = None
_lib_alglib.x_minlmstate_get_j.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_j.restype = None
_lib_alglib.x_minlmstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minlmstate_get_x.restype = None


class minlmstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minlmstate(self.ptr)


class x_minlmreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("terminationtype", x_int),
        ("funcidx", x_int),
        ("varidx", x_int),
        ("nfunc", x_int),
        ("njac", x_int),
        ("ngrad", x_int),
        ("nhess", x_int),
        ("ncholesky", x_int)
        ]




class minlmreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.terminationtype = 0
        self.funcidx = 0
        self.varidx = 0
        self.nfunc = 0
        self.njac = 0
        self.ngrad = 0
        self.nhess = 0
        self.ncholesky = 0


def x_minlmreport_zero_fields(x):
    x.iterationscount.val = 0
    x.terminationtype.val = 0
    x.funcidx.val = 0
    x.varidx.val = 0
    x.nfunc.val = 0
    x.njac.val = 0
    x.ngrad.val = 0
    x.nhess.val = 0
    x.ncholesky.val = 0
    return




def x_minlmreport_clear(x):
    x_minlmreport_zero_fields(x)
    return




def x_from_minlmreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.terminationtype.val = int(v.terminationtype)
    x.funcidx.val = int(v.funcidx)
    x.varidx.val = int(v.varidx)
    x.nfunc.val = int(v.nfunc)
    x.njac.val = int(v.njac)
    x.ngrad.val = int(v.ngrad)
    x.nhess.val = int(v.nhess)
    x.ncholesky.val = int(v.ncholesky)
    return




def minlmreport_from_x(x):
    r = minlmreport()
    r.iterationscount = x.iterationscount.val
    r.terminationtype = x.terminationtype.val
    r.funcidx = x.funcidx.val
    r.varidx = x.varidx.val
    r.nfunc = x.nfunc.val
    r.njac = x.njac.val
    r.ngrad = x.ngrad.val
    r.nhess = x.nhess.val
    r.ncholesky = x.ncholesky.val
    return r


_lib_alglib.alglib_minlmcreatevj.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmcreatevj.restype = ctypes.c_int32
def minlmcreatevj(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,m,x = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,x = functionargs
        n = safe_len("'minlmcreatevj': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlmcreatevj': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmcreatevj(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmcreatevj'")
        __r__state = minlmstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmcreatev.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmcreatev.restype = ctypes.c_int32
def minlmcreatev(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        n,m,x,diffstep = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        m,x,diffstep = functionargs
        n = safe_len("'minlmcreatev': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlmcreatev': function must have 3 or 4 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmcreatev(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmcreatev'")
        __r__state = minlmstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmcreatefgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmcreatefgh.restype = ctypes.c_int32
def minlmcreatefgh(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        n,x = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'minlmcreatefgh': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlmcreatefgh': function must have 1 or 2 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmcreatefgh(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmcreatefgh'")
        __r__state = minlmstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetcond.restype = ctypes.c_int32
def minlmsetcond(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_minlmsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetxrep.restype = ctypes.c_int32
def minlmsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_minlmsetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetstpmax.restype = ctypes.c_int32
def minlmsetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetstpmax'")
        return
    finally:
        pass


_lib_alglib.alglib_minlmsetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetscale.restype = ctypes.c_int32
def minlmsetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_minlmsetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetbc.restype = ctypes.c_int32
def minlmsetbc(state, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetbc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetbc'")
        return
    finally:
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.alglib_minlmsetacctype.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetacctype.restype = ctypes.c_int32
def minlmsetacctype(state, acctype):
    pass
    __state = state.ptr
    __acctype = x_int()
    __acctype.val = int(acctype)
    if __acctype.val!=acctype:
        raise ValueError("Error while converting 'acctype' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetacctype(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__acctype))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetacctype'")
        return
    finally:
        pass




def minlmoptimize_v(state, fvec, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlmstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_fi  = x_vector()
    _lib_alglib.x_minlmstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    while True:
        retval = _lib_alglib.alglib_minlmiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlmstate_get_needfi(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            fvec(_py_x, _py_fi, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlmstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)")
    return


def minlmoptimize_vj(state, fvec, jac, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlmstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_fi  = x_vector()
    _lib_alglib.x_minlmstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    _xc_j  = x_matrix()
    _lib_alglib.x_minlmstate_get_j(state.ptr, ctypes.byref(_xc_j))
    _py_j = create_real_matrix(_xc_j.rows,_xc_j.cols)
    while True:
        retval = _lib_alglib.alglib_minlmiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlmstate_get_needfi(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            fvec(_py_x, _py_fi, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_needfij(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            jac(_py_x, _py_fi, _py_j, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_j, _py_j, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlmstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)")
    return


def minlmoptimize_fgh(state, func, grad, hess, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlmstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_minlmstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    _xc_h  = x_matrix()
    _lib_alglib.x_minlmstate_get_h(state.ptr, ctypes.byref(_xc_h))
    _py_h = create_real_matrix(_xc_h.rows,_xc_h.cols)
    while True:
        retval = _lib_alglib.alglib_minlmiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlmstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_minlmstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_minlmstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = grad(_py_x, _py_g, param)
            _lib_alglib.x_minlmstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_needfgh(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = hess(_py_x, _py_g, _py_h, param)
            _lib_alglib.x_minlmstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_h, _py_h, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlmstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)")
    return


def minlmoptimize_fj(state, func, jac, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlmstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_fi  = x_vector()
    _lib_alglib.x_minlmstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    _xc_j  = x_matrix()
    _lib_alglib.x_minlmstate_get_j(state.ptr, ctypes.byref(_xc_j))
    _py_j = create_real_matrix(_xc_j.rows,_xc_j.cols)
    while True:
        retval = _lib_alglib.alglib_minlmiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlmstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_minlmstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_minlmstate_get_needfij(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            jac(_py_x, _py_fi, _py_j, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_j, _py_j, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlmstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)")
    return


def minlmoptimize_fgj(state, func, grad, jac, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minlmstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_minlmstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    _xc_fi  = x_vector()
    _lib_alglib.x_minlmstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    _xc_j  = x_matrix()
    _lib_alglib.x_minlmstate_get_j(state.ptr, ctypes.byref(_xc_j))
    _py_j = create_real_matrix(_xc_j.rows,_xc_j.cols)
    while True:
        retval = _lib_alglib.alglib_minlmiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minlmstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_minlmstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_minlmstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = grad(_py_x, _py_g, param)
            _lib_alglib.x_minlmstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_needfij(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            jac(_py_x, _py_fi, _py_j, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_j, _py_j, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minlmstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minlmstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_minlmresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmresults.restype = ctypes.c_int32
def minlmresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minlmreport()
    x_minlmreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmresults'")
        __r__x = list_from_x(__x)
        __r__rep = minlmreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minlmreport_clear(__rep)


_lib_alglib.alglib_minlmresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmresultsbuf.restype = ctypes.c_int32
def minlmresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minlmreport()
    x_minlmreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minlmreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minlmreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minlmreport_clear(__rep)


_lib_alglib.alglib_minlmrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmrestartfrom.restype = ctypes.c_int32
def minlmrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmrestartfrom'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmrequesttermination.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmrequesttermination.restype = ctypes.c_int32
def minlmrequesttermination(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmrequesttermination(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmrequesttermination'")
        return
    finally:
        pass


_lib_alglib.alglib_minlmcreatevgj.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmcreatevgj.restype = ctypes.c_int32
def minlmcreatevgj(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,m,x = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,x = functionargs
        n = safe_len("'minlmcreatevgj': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlmcreatevgj': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmcreatevgj(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmcreatevgj'")
        __r__state = minlmstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmcreatefgj.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmcreatefgj.restype = ctypes.c_int32
def minlmcreatefgj(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,m,x = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,x = functionargs
        n = safe_len("'minlmcreatefgj': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlmcreatefgj': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmcreatefgj(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmcreatefgj'")
        __r__state = minlmstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmcreatefj.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmcreatefj.restype = ctypes.c_int32
def minlmcreatefj(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,m,x = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,x = functionargs
        n = safe_len("'minlmcreatefj': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minlmcreatefj': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmcreatefj(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmcreatefj'")
        __r__state = minlmstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minlmsetgradientcheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlmsetgradientcheck.restype = ctypes.c_int32
def minlmsetgradientcheck(state, teststep):
    pass
    __state = state.ptr
    __teststep = ctypes.c_double(teststep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlmsetgradientcheck(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__teststep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlmsetgradientcheck'")
        return
    finally:
        pass




class x_polynomialfitreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("taskrcond", ctypes.c_double),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("maxerror", ctypes.c_double)
        ]




class polynomialfitreport(object):
    def __init__(self):
        self.taskrcond = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.maxerror = 0


def x_polynomialfitreport_zero_fields(x):
    x.taskrcond = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.maxerror = 0
    return




def x_polynomialfitreport_clear(x):
    x_polynomialfitreport_zero_fields(x)
    return




def x_from_polynomialfitreport(x,v):
    x.taskrcond = float(v.taskrcond)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.maxerror = float(v.maxerror)
    return




def polynomialfitreport_from_x(x):
    r = polynomialfitreport()
    r.taskrcond = x.taskrcond
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.maxerror = x.maxerror
    return r




class x_barycentricfitreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("taskrcond", ctypes.c_double),
        ("dbest", x_int),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("maxerror", ctypes.c_double)
        ]




class barycentricfitreport(object):
    def __init__(self):
        self.taskrcond = 0
        self.dbest = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.maxerror = 0


def x_barycentricfitreport_zero_fields(x):
    x.taskrcond = 0
    x.dbest.val = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.maxerror = 0
    return




def x_barycentricfitreport_clear(x):
    x_barycentricfitreport_zero_fields(x)
    return




def x_from_barycentricfitreport(x,v):
    x.taskrcond = float(v.taskrcond)
    x.dbest.val = int(v.dbest)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.maxerror = float(v.maxerror)
    return




def barycentricfitreport_from_x(x):
    r = barycentricfitreport()
    r.taskrcond = x.taskrcond
    r.dbest = x.dbest.val
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.maxerror = x.maxerror
    return r




class x_spline1dfitreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("taskrcond", ctypes.c_double),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("maxerror", ctypes.c_double)
        ]




class spline1dfitreport(object):
    def __init__(self):
        self.taskrcond = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.maxerror = 0


def x_spline1dfitreport_zero_fields(x):
    x.taskrcond = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.maxerror = 0
    return




def x_spline1dfitreport_clear(x):
    x_spline1dfitreport_zero_fields(x)
    return




def x_from_spline1dfitreport(x,v):
    x.taskrcond = float(v.taskrcond)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.maxerror = float(v.maxerror)
    return




def spline1dfitreport_from_x(x):
    r = spline1dfitreport()
    r.taskrcond = x.taskrcond
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.maxerror = x.maxerror
    return r




class x_lsfitreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("taskrcond", ctypes.c_double),
        ("iterationscount", x_int),
        ("varidx", x_int),
        ("rmserror", ctypes.c_double),
        ("avgerror", ctypes.c_double),
        ("avgrelerror", ctypes.c_double),
        ("maxerror", ctypes.c_double),
        ("wrmserror", ctypes.c_double),
        ("covpar", x_matrix),
        ("errpar", x_vector),
        ("errcurve", x_vector),
        ("noise", x_vector),
        ("r2", ctypes.c_double)
        ]




class lsfitreport(object):
    def __init__(self):
        self.taskrcond = 0
        self.iterationscount = 0
        self.varidx = 0
        self.rmserror = 0
        self.avgerror = 0
        self.avgrelerror = 0
        self.maxerror = 0
        self.wrmserror = 0
        self.covpar = [[]]
        self.errpar = []
        self.errcurve = []
        self.noise = []
        self.r2 = 0


def x_lsfitreport_zero_fields(x):
    x.taskrcond = 0
    x.iterationscount.val = 0
    x.varidx.val = 0
    x.rmserror = 0
    x.avgerror = 0
    x.avgrelerror = 0
    x.maxerror = 0
    x.wrmserror = 0
    x.covpar = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.errpar = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.errcurve = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.noise = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    x.r2 = 0
    return




def x_lsfitreport_clear(x):
    x_matrix_clear(x.covpar)
    x_vector_clear(x.errpar)
    x_vector_clear(x.errcurve)
    x_vector_clear(x.noise)
    x_lsfitreport_zero_fields(x)
    return




def x_from_lsfitreport(x,v):
    x.taskrcond = float(v.taskrcond)
    x.iterationscount.val = int(v.iterationscount)
    x.varidx.val = int(v.varidx)
    x.rmserror = float(v.rmserror)
    x.avgerror = float(v.avgerror)
    x.avgrelerror = float(v.avgrelerror)
    x.maxerror = float(v.maxerror)
    x.wrmserror = float(v.wrmserror)
    x_from_listlist(x.covpar, v.covpar, DT_REAL, X_CREATE)
    x_from_list(x.errpar, v.errpar, DT_REAL, X_CREATE)
    x_from_list(x.errcurve, v.errcurve, DT_REAL, X_CREATE)
    x_from_list(x.noise, v.noise, DT_REAL, X_CREATE)
    x.r2 = float(v.r2)
    return




def lsfitreport_from_x(x):
    r = lsfitreport()
    r.taskrcond = x.taskrcond
    r.iterationscount = x.iterationscount.val
    r.varidx = x.varidx.val
    r.rmserror = x.rmserror
    r.avgerror = x.avgerror
    r.avgrelerror = x.avgrelerror
    r.maxerror = x.maxerror
    r.wrmserror = x.wrmserror
    r.covpar = listlist_from_x(x.covpar)
    r.errpar = list_from_x(x.errpar)
    r.errcurve = list_from_x(x.errcurve)
    r.noise = list_from_x(x.noise)
    r.r2 = x.r2
    return r


_lib_alglib.x_obj_free_lsfitstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_lsfitstate.restype = None
_lib_alglib.x_lsfitstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_needf.restype = None
_lib_alglib.x_lsfitstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_set_needf.restype = None
_lib_alglib.x_lsfitstate_get_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_needfg.restype = None
_lib_alglib.x_lsfitstate_set_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_set_needfg.restype = None
_lib_alglib.x_lsfitstate_get_needfgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_needfgh.restype = None
_lib_alglib.x_lsfitstate_set_needfgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_set_needfgh.restype = None
_lib_alglib.x_lsfitstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_xupdated.restype = None
_lib_alglib.x_lsfitstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_set_xupdated.restype = None
_lib_alglib.x_lsfitstate_get_c.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_c.restype = None
_lib_alglib.x_lsfitstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_f.restype = None
_lib_alglib.x_lsfitstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_set_f.restype = None
_lib_alglib.x_lsfitstate_get_g.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_g.restype = None
_lib_alglib.x_lsfitstate_get_h.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_h.restype = None
_lib_alglib.x_lsfitstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_lsfitstate_get_x.restype = None


class lsfitstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_lsfitstate(self.ptr)
_lib_alglib.alglib_lstfitpiecewiselinearrdpfixed.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lstfitpiecewiselinearrdpfixed.restype = ctypes.c_int32
def lstfitpiecewiselinearrdpfixed(x, y, n, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __x2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nsections = x_int()
    __nsections.val = 0
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lstfitpiecewiselinearrdpfixed(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x2), ctypes.byref(__y2), ctypes.byref(__nsections))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lstfitpiecewiselinearrdpfixed'")
        __r__x2 = list_from_x(__x2)
        __r__y2 = list_from_x(__y2)
        __r__nsections = __nsections.val
        return (__r__x2, __r__y2, __r__nsections)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__x2)
        x_vector_clear(__y2)


_lib_alglib.alglib_lstfitpiecewiselinearrdp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lstfitpiecewiselinearrdp.restype = ctypes.c_int32
def lstfitpiecewiselinearrdp(x, y, n, eps):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __eps = ctypes.c_double(eps)
    __x2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y2 = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nsections = x_int()
    __nsections.val = 0
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lstfitpiecewiselinearrdp(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__eps), ctypes.byref(__x2), ctypes.byref(__y2), ctypes.byref(__nsections))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lstfitpiecewiselinearrdp'")
        __r__x2 = list_from_x(__x2)
        __r__y2 = list_from_x(__y2)
        __r__nsections = __nsections.val
        return (__r__x2, __r__y2, __r__nsections)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__x2)
        x_vector_clear(__y2)


_lib_alglib.alglib_polynomialfit.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialfit.restype = ctypes.c_int32
def polynomialfit(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,m = functionargs
        if safe_len("'polynomialfit': incorrect parameters",x)!=safe_len("'polynomialfit': incorrect parameters",y):
            raise RuntimeError("Error while calling 'polynomialfit': looks like one of arguments has wrong size")
        n = safe_len("'polynomialfit': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'polynomialfit': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __p = ctypes.c_void_p(0)
    __rep = x_polynomialfitreport()
    x_polynomialfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialfit(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__p), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialfit'")
        __r__info = __info.val
        __r__p = barycentricinterpolant(__p)
        __r__rep = polynomialfitreport_from_x(__rep)
        return (__r__info, __r__p, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_polynomialfitreport_clear(__rep)


_lib_alglib.alglib_smp_polynomialfit.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_polynomialfit.restype = ctypes.c_int32
def smp_polynomialfit(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,m = functionargs
        if safe_len("'smp_polynomialfit': incorrect parameters",x)!=safe_len("'smp_polynomialfit': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_polynomialfit': looks like one of arguments has wrong size")
        n = safe_len("'smp_polynomialfit': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_polynomialfit': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __p = ctypes.c_void_p(0)
    __rep = x_polynomialfitreport()
    x_polynomialfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_polynomialfit(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__p), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_polynomialfit'")
        __r__info = __info.val
        __r__p = barycentricinterpolant(__p)
        __r__rep = polynomialfitreport_from_x(__rep)
        return (__r__info, __r__p, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_polynomialfitreport_clear(__rep)


_lib_alglib.alglib_polynomialfitwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialfitwc.restype = ctypes.c_int32
def polynomialfitwc(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,w,n,xc,yc,dc,k,m = functionargs
    elif len(functionargs)==7:
        __friendly_form = True
        x,y,w,xc,yc,dc,m = functionargs
        if safe_len("'polynomialfitwc': incorrect parameters",x)!=safe_len("'polynomialfitwc': incorrect parameters",y) or safe_len("'polynomialfitwc': incorrect parameters",x)!=safe_len("'polynomialfitwc': incorrect parameters",w):
            raise RuntimeError("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size")
        n = safe_len("'polynomialfitwc': incorrect parameters",x)
        if safe_len("'polynomialfitwc': incorrect parameters",xc)!=safe_len("'polynomialfitwc': incorrect parameters",yc) or safe_len("'polynomialfitwc': incorrect parameters",xc)!=safe_len("'polynomialfitwc': incorrect parameters",dc):
            raise RuntimeError("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size")
        k = safe_len("'polynomialfitwc': incorrect parameters",xc)
    else:
        raise RuntimeError("Error while calling 'polynomialfitwc': function must have 7 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __p = ctypes.c_void_p(0)
    __rep = x_polynomialfitreport()
    x_polynomialfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialfitwc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__p), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialfitwc'")
        __r__info = __info.val
        __r__p = barycentricinterpolant(__p)
        __r__rep = polynomialfitreport_from_x(__rep)
        return (__r__info, __r__p, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_polynomialfitreport_clear(__rep)


_lib_alglib.alglib_smp_polynomialfitwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_polynomialfitwc.restype = ctypes.c_int32
def smp_polynomialfitwc(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,w,n,xc,yc,dc,k,m = functionargs
    elif len(functionargs)==7:
        __friendly_form = True
        x,y,w,xc,yc,dc,m = functionargs
        if safe_len("'smp_polynomialfitwc': incorrect parameters",x)!=safe_len("'smp_polynomialfitwc': incorrect parameters",y) or safe_len("'smp_polynomialfitwc': incorrect parameters",x)!=safe_len("'smp_polynomialfitwc': incorrect parameters",w):
            raise RuntimeError("Error while calling 'smp_polynomialfitwc': looks like one of arguments has wrong size")
        n = safe_len("'smp_polynomialfitwc': incorrect parameters",x)
        if safe_len("'smp_polynomialfitwc': incorrect parameters",xc)!=safe_len("'smp_polynomialfitwc': incorrect parameters",yc) or safe_len("'smp_polynomialfitwc': incorrect parameters",xc)!=safe_len("'smp_polynomialfitwc': incorrect parameters",dc):
            raise RuntimeError("Error while calling 'smp_polynomialfitwc': looks like one of arguments has wrong size")
        k = safe_len("'smp_polynomialfitwc': incorrect parameters",xc)
    else:
        raise RuntimeError("Error while calling 'smp_polynomialfitwc': function must have 7 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __p = ctypes.c_void_p(0)
    __rep = x_polynomialfitreport()
    x_polynomialfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_polynomialfitwc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__p), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_polynomialfitwc'")
        __r__info = __info.val
        __r__p = barycentricinterpolant(__p)
        __r__rep = polynomialfitreport_from_x(__rep)
        return (__r__info, __r__p, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_polynomialfitreport_clear(__rep)


_lib_alglib.alglib_logisticcalc4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticcalc4.restype = ctypes.c_int32
def logisticcalc4(x, a, b, c, d):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __c = ctypes.c_double(c)
    __d = ctypes.c_double(d)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticcalc4(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticcalc4'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_logisticcalc5.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticcalc5.restype = ctypes.c_int32
def logisticcalc5(x, a, b, c, d, g):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __c = ctypes.c_double(c)
    __d = ctypes.c_double(d)
    __g = ctypes.c_double(g)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticcalc5(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d), ctypes.byref(__g))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticcalc5'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_logisticfit4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticfit4.restype = ctypes.c_int32
def logisticfit4(x, y, n):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = ctypes.c_double(0)
    __b = ctypes.c_double(0)
    __c = ctypes.c_double(0)
    __d = ctypes.c_double(0)
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticfit4(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticfit4'")
        __r__a = __a.value
        __r__b = __b.value
        __r__c = __c.value
        __r__d = __d.value
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__a, __r__b, __r__c, __r__d, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_logisticfit4ec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticfit4ec.restype = ctypes.c_int32
def logisticfit4ec(x, y, n, cnstrleft, cnstrright):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __cnstrleft = ctypes.c_double(cnstrleft)
    __cnstrright = ctypes.c_double(cnstrright)
    __a = ctypes.c_double(0)
    __b = ctypes.c_double(0)
    __c = ctypes.c_double(0)
    __d = ctypes.c_double(0)
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticfit4ec(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__cnstrleft), ctypes.byref(__cnstrright), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticfit4ec'")
        __r__a = __a.value
        __r__b = __b.value
        __r__c = __c.value
        __r__d = __d.value
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__a, __r__b, __r__c, __r__d, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_logisticfit5.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticfit5.restype = ctypes.c_int32
def logisticfit5(x, y, n):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __a = ctypes.c_double(0)
    __b = ctypes.c_double(0)
    __c = ctypes.c_double(0)
    __d = ctypes.c_double(0)
    __g = ctypes.c_double(0)
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticfit5(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d), ctypes.byref(__g), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticfit5'")
        __r__a = __a.value
        __r__b = __b.value
        __r__c = __c.value
        __r__d = __d.value
        __r__g = __g.value
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__a, __r__b, __r__c, __r__d, __r__g, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_logisticfit5ec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticfit5ec.restype = ctypes.c_int32
def logisticfit5ec(x, y, n, cnstrleft, cnstrright):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __cnstrleft = ctypes.c_double(cnstrleft)
    __cnstrright = ctypes.c_double(cnstrright)
    __a = ctypes.c_double(0)
    __b = ctypes.c_double(0)
    __c = ctypes.c_double(0)
    __d = ctypes.c_double(0)
    __g = ctypes.c_double(0)
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticfit5ec(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__cnstrleft), ctypes.byref(__cnstrright), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d), ctypes.byref(__g), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticfit5ec'")
        __r__a = __a.value
        __r__b = __b.value
        __r__c = __c.value
        __r__d = __d.value
        __r__g = __g.value
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__a, __r__b, __r__c, __r__d, __r__g, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_logisticfit45x.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_logisticfit45x.restype = ctypes.c_int32
def logisticfit45x(x, y, n, cnstrleft, cnstrright, is4pl, lambdav, epsx, rscnt):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __cnstrleft = ctypes.c_double(cnstrleft)
    __cnstrright = ctypes.c_double(cnstrright)
    __is4pl = ctypes.c_uint8(is4pl)
    if __is4pl.value!=0:
        __is4pl = ctypes.c_uint8(1)
    __lambdav = ctypes.c_double(lambdav)
    __epsx = ctypes.c_double(epsx)
    __rscnt = x_int()
    __rscnt.val = int(rscnt)
    if __rscnt.val!=rscnt:
        raise ValueError("Error while converting 'rscnt' parameter to 'x_int'")
    __a = ctypes.c_double(0)
    __b = ctypes.c_double(0)
    __c = ctypes.c_double(0)
    __d = ctypes.c_double(0)
    __g = ctypes.c_double(0)
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_logisticfit45x(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__cnstrleft), ctypes.byref(__cnstrright), ctypes.byref(__is4pl), ctypes.byref(__lambdav), ctypes.byref(__epsx), ctypes.byref(__rscnt), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__c), ctypes.byref(__d), ctypes.byref(__g), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'logisticfit45x'")
        __r__a = __a.value
        __r__b = __b.value
        __r__c = __c.value
        __r__d = __d.value
        __r__g = __g.value
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__a, __r__b, __r__c, __r__d, __r__g, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_barycentricfitfloaterhormannwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricfitfloaterhormannwc.restype = ctypes.c_int32
def barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __b = ctypes.c_void_p(0)
    __rep = x_barycentricfitreport()
    x_barycentricfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricfitfloaterhormannwc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__b), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricfitfloaterhormannwc'")
        __r__info = __info.val
        __r__b = barycentricinterpolant(__b)
        __r__rep = barycentricfitreport_from_x(__rep)
        return (__r__info, __r__b, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_barycentricfitreport_clear(__rep)


_lib_alglib.alglib_smp_barycentricfitfloaterhormannwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_barycentricfitfloaterhormannwc.restype = ctypes.c_int32
def smp_barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __b = ctypes.c_void_p(0)
    __rep = x_barycentricfitreport()
    x_barycentricfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_barycentricfitfloaterhormannwc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__b), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_barycentricfitfloaterhormannwc'")
        __r__info = __info.val
        __r__b = barycentricinterpolant(__b)
        __r__rep = barycentricfitreport_from_x(__rep)
        return (__r__info, __r__b, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_barycentricfitreport_clear(__rep)


_lib_alglib.alglib_barycentricfitfloaterhormann.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_barycentricfitfloaterhormann.restype = ctypes.c_int32
def barycentricfitfloaterhormann(x, y, n, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __b = ctypes.c_void_p(0)
    __rep = x_barycentricfitreport()
    x_barycentricfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_barycentricfitfloaterhormann(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__b), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'barycentricfitfloaterhormann'")
        __r__info = __info.val
        __r__b = barycentricinterpolant(__b)
        __r__rep = barycentricfitreport_from_x(__rep)
        return (__r__info, __r__b, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_barycentricfitreport_clear(__rep)


_lib_alglib.alglib_smp_barycentricfitfloaterhormann.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_barycentricfitfloaterhormann.restype = ctypes.c_int32
def smp_barycentricfitfloaterhormann(x, y, n, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __b = ctypes.c_void_p(0)
    __rep = x_barycentricfitreport()
    x_barycentricfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_barycentricfitfloaterhormann(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__b), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_barycentricfitfloaterhormann'")
        __r__info = __info.val
        __r__b = barycentricinterpolant(__b)
        __r__rep = barycentricfitreport_from_x(__rep)
        return (__r__info, __r__b, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_barycentricfitreport_clear(__rep)


_lib_alglib.alglib_spline1dfitpenalized.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dfitpenalized.restype = ctypes.c_int32
def spline1dfitpenalized(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m,rho = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        x,y,m,rho = functionargs
        if safe_len("'spline1dfitpenalized': incorrect parameters",x)!=safe_len("'spline1dfitpenalized': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size")
        n = safe_len("'spline1dfitpenalized': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dfitpenalized': function must have 4 or 5 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rho = ctypes.c_double(rho)
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dfitpenalized(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__rho), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dfitpenalized'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_smp_spline1dfitpenalized.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spline1dfitpenalized.restype = ctypes.c_int32
def smp_spline1dfitpenalized(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        x,y,n,m,rho = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        x,y,m,rho = functionargs
        if safe_len("'smp_spline1dfitpenalized': incorrect parameters",x)!=safe_len("'smp_spline1dfitpenalized': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_spline1dfitpenalized': looks like one of arguments has wrong size")
        n = safe_len("'smp_spline1dfitpenalized': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_spline1dfitpenalized': function must have 4 or 5 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rho = ctypes.c_double(rho)
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spline1dfitpenalized(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__rho), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spline1dfitpenalized'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_spline1dfitpenalizedw.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dfitpenalizedw.restype = ctypes.c_int32
def spline1dfitpenalizedw(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        x,y,w,n,m,rho = functionargs
    elif len(functionargs)==5:
        __friendly_form = True
        x,y,w,m,rho = functionargs
        if safe_len("'spline1dfitpenalizedw': incorrect parameters",x)!=safe_len("'spline1dfitpenalizedw': incorrect parameters",y) or safe_len("'spline1dfitpenalizedw': incorrect parameters",x)!=safe_len("'spline1dfitpenalizedw': incorrect parameters",w):
            raise RuntimeError("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size")
        n = safe_len("'spline1dfitpenalizedw': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dfitpenalizedw': function must have 5 or 6 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rho = ctypes.c_double(rho)
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dfitpenalizedw(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__rho), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dfitpenalizedw'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_smp_spline1dfitpenalizedw.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spline1dfitpenalizedw.restype = ctypes.c_int32
def smp_spline1dfitpenalizedw(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        x,y,w,n,m,rho = functionargs
    elif len(functionargs)==5:
        __friendly_form = True
        x,y,w,m,rho = functionargs
        if safe_len("'smp_spline1dfitpenalizedw': incorrect parameters",x)!=safe_len("'smp_spline1dfitpenalizedw': incorrect parameters",y) or safe_len("'smp_spline1dfitpenalizedw': incorrect parameters",x)!=safe_len("'smp_spline1dfitpenalizedw': incorrect parameters",w):
            raise RuntimeError("Error while calling 'smp_spline1dfitpenalizedw': looks like one of arguments has wrong size")
        n = safe_len("'smp_spline1dfitpenalizedw': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_spline1dfitpenalizedw': function must have 5 or 6 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __rho = ctypes.c_double(rho)
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spline1dfitpenalizedw(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__rho), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spline1dfitpenalizedw'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_spline1dfitcubicwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dfitcubicwc.restype = ctypes.c_int32
def spline1dfitcubicwc(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,w,n,xc,yc,dc,k,m = functionargs
    elif len(functionargs)==7:
        __friendly_form = True
        x,y,w,xc,yc,dc,m = functionargs
        if safe_len("'spline1dfitcubicwc': incorrect parameters",x)!=safe_len("'spline1dfitcubicwc': incorrect parameters",y) or safe_len("'spline1dfitcubicwc': incorrect parameters",x)!=safe_len("'spline1dfitcubicwc': incorrect parameters",w):
            raise RuntimeError("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size")
        n = safe_len("'spline1dfitcubicwc': incorrect parameters",x)
        if safe_len("'spline1dfitcubicwc': incorrect parameters",xc)!=safe_len("'spline1dfitcubicwc': incorrect parameters",yc) or safe_len("'spline1dfitcubicwc': incorrect parameters",xc)!=safe_len("'spline1dfitcubicwc': incorrect parameters",dc):
            raise RuntimeError("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size")
        k = safe_len("'spline1dfitcubicwc': incorrect parameters",xc)
    else:
        raise RuntimeError("Error while calling 'spline1dfitcubicwc': function must have 7 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dfitcubicwc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dfitcubicwc'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_smp_spline1dfitcubicwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spline1dfitcubicwc.restype = ctypes.c_int32
def smp_spline1dfitcubicwc(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,w,n,xc,yc,dc,k,m = functionargs
    elif len(functionargs)==7:
        __friendly_form = True
        x,y,w,xc,yc,dc,m = functionargs
        if safe_len("'smp_spline1dfitcubicwc': incorrect parameters",x)!=safe_len("'smp_spline1dfitcubicwc': incorrect parameters",y) or safe_len("'smp_spline1dfitcubicwc': incorrect parameters",x)!=safe_len("'smp_spline1dfitcubicwc': incorrect parameters",w):
            raise RuntimeError("Error while calling 'smp_spline1dfitcubicwc': looks like one of arguments has wrong size")
        n = safe_len("'smp_spline1dfitcubicwc': incorrect parameters",x)
        if safe_len("'smp_spline1dfitcubicwc': incorrect parameters",xc)!=safe_len("'smp_spline1dfitcubicwc': incorrect parameters",yc) or safe_len("'smp_spline1dfitcubicwc': incorrect parameters",xc)!=safe_len("'smp_spline1dfitcubicwc': incorrect parameters",dc):
            raise RuntimeError("Error while calling 'smp_spline1dfitcubicwc': looks like one of arguments has wrong size")
        k = safe_len("'smp_spline1dfitcubicwc': incorrect parameters",xc)
    else:
        raise RuntimeError("Error while calling 'smp_spline1dfitcubicwc': function must have 7 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spline1dfitcubicwc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spline1dfitcubicwc'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_spline1dfithermitewc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dfithermitewc.restype = ctypes.c_int32
def spline1dfithermitewc(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,w,n,xc,yc,dc,k,m = functionargs
    elif len(functionargs)==7:
        __friendly_form = True
        x,y,w,xc,yc,dc,m = functionargs
        if safe_len("'spline1dfithermitewc': incorrect parameters",x)!=safe_len("'spline1dfithermitewc': incorrect parameters",y) or safe_len("'spline1dfithermitewc': incorrect parameters",x)!=safe_len("'spline1dfithermitewc': incorrect parameters",w):
            raise RuntimeError("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size")
        n = safe_len("'spline1dfithermitewc': incorrect parameters",x)
        if safe_len("'spline1dfithermitewc': incorrect parameters",xc)!=safe_len("'spline1dfithermitewc': incorrect parameters",yc) or safe_len("'spline1dfithermitewc': incorrect parameters",xc)!=safe_len("'spline1dfithermitewc': incorrect parameters",dc):
            raise RuntimeError("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size")
        k = safe_len("'spline1dfithermitewc': incorrect parameters",xc)
    else:
        raise RuntimeError("Error while calling 'spline1dfithermitewc': function must have 7 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dfithermitewc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dfithermitewc'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_smp_spline1dfithermitewc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spline1dfithermitewc.restype = ctypes.c_int32
def smp_spline1dfithermitewc(*functionargs):
    if len(functionargs)==9:
        __friendly_form = False
        x,y,w,n,xc,yc,dc,k,m = functionargs
    elif len(functionargs)==7:
        __friendly_form = True
        x,y,w,xc,yc,dc,m = functionargs
        if safe_len("'smp_spline1dfithermitewc': incorrect parameters",x)!=safe_len("'smp_spline1dfithermitewc': incorrect parameters",y) or safe_len("'smp_spline1dfithermitewc': incorrect parameters",x)!=safe_len("'smp_spline1dfithermitewc': incorrect parameters",w):
            raise RuntimeError("Error while calling 'smp_spline1dfithermitewc': looks like one of arguments has wrong size")
        n = safe_len("'smp_spline1dfithermitewc': incorrect parameters",x)
        if safe_len("'smp_spline1dfithermitewc': incorrect parameters",xc)!=safe_len("'smp_spline1dfithermitewc': incorrect parameters",yc) or safe_len("'smp_spline1dfithermitewc': incorrect parameters",xc)!=safe_len("'smp_spline1dfithermitewc': incorrect parameters",dc):
            raise RuntimeError("Error while calling 'smp_spline1dfithermitewc': looks like one of arguments has wrong size")
        k = safe_len("'smp_spline1dfithermitewc': incorrect parameters",xc)
    else:
        raise RuntimeError("Error while calling 'smp_spline1dfithermitewc': function must have 7 or 9 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(xc):
        raise ValueError("'xc' parameter can't be cast to real_vector")
    __xc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(yc):
        raise ValueError("'yc' parameter can't be cast to real_vector")
    __yc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(dc):
        raise ValueError("'dc' parameter can't be cast to int_vector")
    __dc = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__xc, xc, DT_REAL, X_CREATE)
        x_from_list(__yc, yc, DT_REAL, X_CREATE)
        x_from_list(__dc, dc, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spline1dfithermitewc(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__n), ctypes.byref(__xc), ctypes.byref(__yc), ctypes.byref(__dc), ctypes.byref(__k), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spline1dfithermitewc'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__xc)
        x_vector_clear(__yc)
        x_vector_clear(__dc)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_spline1dfitcubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dfitcubic.restype = ctypes.c_int32
def spline1dfitcubic(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,m = functionargs
        if safe_len("'spline1dfitcubic': incorrect parameters",x)!=safe_len("'spline1dfitcubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size")
        n = safe_len("'spline1dfitcubic': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dfitcubic': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dfitcubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dfitcubic'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_smp_spline1dfitcubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spline1dfitcubic.restype = ctypes.c_int32
def smp_spline1dfitcubic(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,m = functionargs
        if safe_len("'smp_spline1dfitcubic': incorrect parameters",x)!=safe_len("'smp_spline1dfitcubic': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_spline1dfitcubic': looks like one of arguments has wrong size")
        n = safe_len("'smp_spline1dfitcubic': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_spline1dfitcubic': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spline1dfitcubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spline1dfitcubic'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_spline1dfithermite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline1dfithermite.restype = ctypes.c_int32
def spline1dfithermite(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,m = functionargs
        if safe_len("'spline1dfithermite': incorrect parameters",x)!=safe_len("'spline1dfithermite': incorrect parameters",y):
            raise RuntimeError("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size")
        n = safe_len("'spline1dfithermite': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'spline1dfithermite': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline1dfithermite(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline1dfithermite'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_smp_spline1dfithermite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_spline1dfithermite.restype = ctypes.c_int32
def smp_spline1dfithermite(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        x,y,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,m = functionargs
        if safe_len("'smp_spline1dfithermite': incorrect parameters",x)!=safe_len("'smp_spline1dfithermite': incorrect parameters",y):
            raise RuntimeError("Error while calling 'smp_spline1dfithermite': looks like one of arguments has wrong size")
        n = safe_len("'smp_spline1dfithermite': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'smp_spline1dfithermite': function must have 3 or 4 parameters")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __s = ctypes.c_void_p(0)
    __rep = x_spline1dfitreport()
    x_spline1dfitreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_spline1dfithermite(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_spline1dfithermite'")
        __r__info = __info.val
        __r__s = spline1dinterpolant(__s)
        __r__rep = spline1dfitreport_from_x(__rep)
        return (__r__info, __r__s, __r__rep)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_spline1dfitreport_clear(__rep)


_lib_alglib.alglib_lsfitlinearw.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitlinearw.restype = ctypes.c_int32
def lsfitlinearw(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        y,w,fmatrix,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        y,w,fmatrix = functionargs
        if safe_len("'lsfitlinearw': incorrect parameters",y)!=safe_len("'lsfitlinearw': incorrect parameters",w) or safe_len("'lsfitlinearw': incorrect parameters",y)!=safe_rows("'lsfitlinearw': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size")
        n = safe_len("'lsfitlinearw': incorrect parameters",y)
        m = safe_cols("'lsfitlinearw': incorrect parameters",fmatrix)
    else:
        raise RuntimeError("Error while calling 'lsfitlinearw': function must have 3 or 5 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitlinearw(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__fmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitlinearw'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_matrix_clear(__fmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_smp_lsfitlinearw.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_lsfitlinearw.restype = ctypes.c_int32
def smp_lsfitlinearw(*functionargs):
    if len(functionargs)==5:
        __friendly_form = False
        y,w,fmatrix,n,m = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        y,w,fmatrix = functionargs
        if safe_len("'smp_lsfitlinearw': incorrect parameters",y)!=safe_len("'smp_lsfitlinearw': incorrect parameters",w) or safe_len("'smp_lsfitlinearw': incorrect parameters",y)!=safe_rows("'smp_lsfitlinearw': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'smp_lsfitlinearw': looks like one of arguments has wrong size")
        n = safe_len("'smp_lsfitlinearw': incorrect parameters",y)
        m = safe_cols("'smp_lsfitlinearw': incorrect parameters",fmatrix)
    else:
        raise RuntimeError("Error while calling 'smp_lsfitlinearw': function must have 3 or 5 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_lsfitlinearw(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__fmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_lsfitlinearw'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_matrix_clear(__fmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_lsfitlinearwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitlinearwc.restype = ctypes.c_int32
def lsfitlinearwc(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        y,w,fmatrix,cmatrix,n,m,k = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        y,w,fmatrix,cmatrix = functionargs
        if safe_len("'lsfitlinearwc': incorrect parameters",y)!=safe_len("'lsfitlinearwc': incorrect parameters",w) or safe_len("'lsfitlinearwc': incorrect parameters",y)!=safe_rows("'lsfitlinearwc': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size")
        n = safe_len("'lsfitlinearwc': incorrect parameters",y)
        if safe_cols("'lsfitlinearwc': incorrect parameters",fmatrix)!=safe_cols("'lsfitlinearwc': incorrect parameters",cmatrix)-1:
            raise RuntimeError("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size")
        m = safe_cols("'lsfitlinearwc': incorrect parameters",fmatrix)
        k = safe_rows("'lsfitlinearwc': incorrect parameters",cmatrix)
    else:
        raise RuntimeError("Error while calling 'lsfitlinearwc': function must have 4 or 7 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(cmatrix):
        raise ValueError("'cmatrix' parameter can't be cast to real_matrix")
    __cmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        x_from_listlist(__cmatrix, cmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitlinearwc(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__fmatrix), ctypes.byref(__cmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitlinearwc'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_matrix_clear(__fmatrix)
        x_matrix_clear(__cmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_smp_lsfitlinearwc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_lsfitlinearwc.restype = ctypes.c_int32
def smp_lsfitlinearwc(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        y,w,fmatrix,cmatrix,n,m,k = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        y,w,fmatrix,cmatrix = functionargs
        if safe_len("'smp_lsfitlinearwc': incorrect parameters",y)!=safe_len("'smp_lsfitlinearwc': incorrect parameters",w) or safe_len("'smp_lsfitlinearwc': incorrect parameters",y)!=safe_rows("'smp_lsfitlinearwc': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'smp_lsfitlinearwc': looks like one of arguments has wrong size")
        n = safe_len("'smp_lsfitlinearwc': incorrect parameters",y)
        if safe_cols("'smp_lsfitlinearwc': incorrect parameters",fmatrix)!=safe_cols("'smp_lsfitlinearwc': incorrect parameters",cmatrix)-1:
            raise RuntimeError("Error while calling 'smp_lsfitlinearwc': looks like one of arguments has wrong size")
        m = safe_cols("'smp_lsfitlinearwc': incorrect parameters",fmatrix)
        k = safe_rows("'smp_lsfitlinearwc': incorrect parameters",cmatrix)
    else:
        raise RuntimeError("Error while calling 'smp_lsfitlinearwc': function must have 4 or 7 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(cmatrix):
        raise ValueError("'cmatrix' parameter can't be cast to real_matrix")
    __cmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        x_from_listlist(__cmatrix, cmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_lsfitlinearwc(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__fmatrix), ctypes.byref(__cmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_lsfitlinearwc'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_matrix_clear(__fmatrix)
        x_matrix_clear(__cmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_lsfitlinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitlinear.restype = ctypes.c_int32
def lsfitlinear(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        y,fmatrix,n,m = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        y,fmatrix = functionargs
        if safe_len("'lsfitlinear': incorrect parameters",y)!=safe_rows("'lsfitlinear': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'lsfitlinear': looks like one of arguments has wrong size")
        n = safe_len("'lsfitlinear': incorrect parameters",y)
        m = safe_cols("'lsfitlinear': incorrect parameters",fmatrix)
    else:
        raise RuntimeError("Error while calling 'lsfitlinear': function must have 2 or 4 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitlinear(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__fmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitlinear'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_matrix_clear(__fmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_smp_lsfitlinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_lsfitlinear.restype = ctypes.c_int32
def smp_lsfitlinear(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        y,fmatrix,n,m = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        y,fmatrix = functionargs
        if safe_len("'smp_lsfitlinear': incorrect parameters",y)!=safe_rows("'smp_lsfitlinear': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'smp_lsfitlinear': looks like one of arguments has wrong size")
        n = safe_len("'smp_lsfitlinear': incorrect parameters",y)
        m = safe_cols("'smp_lsfitlinear': incorrect parameters",fmatrix)
    else:
        raise RuntimeError("Error while calling 'smp_lsfitlinear': function must have 2 or 4 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_lsfitlinear(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__fmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_lsfitlinear'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_matrix_clear(__fmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_lsfitlinearc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitlinearc.restype = ctypes.c_int32
def lsfitlinearc(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        y,fmatrix,cmatrix,n,m,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        y,fmatrix,cmatrix = functionargs
        if safe_len("'lsfitlinearc': incorrect parameters",y)!=safe_rows("'lsfitlinearc': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size")
        n = safe_len("'lsfitlinearc': incorrect parameters",y)
        if safe_cols("'lsfitlinearc': incorrect parameters",fmatrix)!=safe_cols("'lsfitlinearc': incorrect parameters",cmatrix)-1:
            raise RuntimeError("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size")
        m = safe_cols("'lsfitlinearc': incorrect parameters",fmatrix)
        k = safe_rows("'lsfitlinearc': incorrect parameters",cmatrix)
    else:
        raise RuntimeError("Error while calling 'lsfitlinearc': function must have 3 or 6 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(cmatrix):
        raise ValueError("'cmatrix' parameter can't be cast to real_matrix")
    __cmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        x_from_listlist(__cmatrix, cmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitlinearc(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__fmatrix), ctypes.byref(__cmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitlinearc'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_matrix_clear(__fmatrix)
        x_matrix_clear(__cmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_smp_lsfitlinearc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smp_lsfitlinearc.restype = ctypes.c_int32
def smp_lsfitlinearc(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        y,fmatrix,cmatrix,n,m,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        y,fmatrix,cmatrix = functionargs
        if safe_len("'smp_lsfitlinearc': incorrect parameters",y)!=safe_rows("'smp_lsfitlinearc': incorrect parameters",fmatrix):
            raise RuntimeError("Error while calling 'smp_lsfitlinearc': looks like one of arguments has wrong size")
        n = safe_len("'smp_lsfitlinearc': incorrect parameters",y)
        if safe_cols("'smp_lsfitlinearc': incorrect parameters",fmatrix)!=safe_cols("'smp_lsfitlinearc': incorrect parameters",cmatrix)-1:
            raise RuntimeError("Error while calling 'smp_lsfitlinearc': looks like one of arguments has wrong size")
        m = safe_cols("'smp_lsfitlinearc': incorrect parameters",fmatrix)
        k = safe_rows("'smp_lsfitlinearc': incorrect parameters",cmatrix)
    else:
        raise RuntimeError("Error while calling 'smp_lsfitlinearc': function must have 3 or 6 parameters")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(fmatrix):
        raise ValueError("'fmatrix' parameter can't be cast to real_matrix")
    __fmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(cmatrix):
        raise ValueError("'cmatrix' parameter can't be cast to real_matrix")
    __cmatrix = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_listlist(__fmatrix, fmatrix, DT_REAL, X_CREATE)
        x_from_listlist(__cmatrix, cmatrix, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smp_lsfitlinearc(ctypes.byref(_error_msg), ctypes.byref(__y), ctypes.byref(__fmatrix), ctypes.byref(__cmatrix), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smp_lsfitlinearc'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__y)
        x_matrix_clear(__fmatrix)
        x_matrix_clear(__cmatrix)
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_lsfitcreatewf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitcreatewf.restype = ctypes.c_int32
def lsfitcreatewf(*functionargs):
    if len(functionargs)==8:
        __friendly_form = False
        x,y,w,c,n,m,k,diffstep = functionargs
    elif len(functionargs)==5:
        __friendly_form = True
        x,y,w,c,diffstep = functionargs
        if safe_rows("'lsfitcreatewf': incorrect parameters",x)!=safe_len("'lsfitcreatewf': incorrect parameters",y) or safe_rows("'lsfitcreatewf': incorrect parameters",x)!=safe_len("'lsfitcreatewf': incorrect parameters",w):
            raise RuntimeError("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size")
        n = safe_rows("'lsfitcreatewf': incorrect parameters",x)
        m = safe_cols("'lsfitcreatewf': incorrect parameters",x)
        k = safe_len("'lsfitcreatewf': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'lsfitcreatewf': function must have 5 or 8 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitcreatewf(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitcreatewf'")
        __r__state = lsfitstate(__state)
        return __r__state
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__c)


_lib_alglib.alglib_lsfitcreatef.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitcreatef.restype = ctypes.c_int32
def lsfitcreatef(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        x,y,c,n,m,k,diffstep = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        x,y,c,diffstep = functionargs
        if safe_rows("'lsfitcreatef': incorrect parameters",x)!=safe_len("'lsfitcreatef': incorrect parameters",y):
            raise RuntimeError("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size")
        n = safe_rows("'lsfitcreatef': incorrect parameters",x)
        m = safe_cols("'lsfitcreatef': incorrect parameters",x)
        k = safe_len("'lsfitcreatef': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'lsfitcreatef': function must have 4 or 7 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitcreatef(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitcreatef'")
        __r__state = lsfitstate(__state)
        return __r__state
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__c)


_lib_alglib.alglib_lsfitcreatewfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitcreatewfg.restype = ctypes.c_int32
def lsfitcreatewfg(*functionargs):
    if len(functionargs)==8:
        __friendly_form = False
        x,y,w,c,n,m,k,cheapfg = functionargs
    elif len(functionargs)==5:
        __friendly_form = True
        x,y,w,c,cheapfg = functionargs
        if safe_rows("'lsfitcreatewfg': incorrect parameters",x)!=safe_len("'lsfitcreatewfg': incorrect parameters",y) or safe_rows("'lsfitcreatewfg': incorrect parameters",x)!=safe_len("'lsfitcreatewfg': incorrect parameters",w):
            raise RuntimeError("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size")
        n = safe_rows("'lsfitcreatewfg': incorrect parameters",x)
        m = safe_cols("'lsfitcreatewfg': incorrect parameters",x)
        k = safe_len("'lsfitcreatewfg': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'lsfitcreatewfg': function must have 5 or 8 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __cheapfg = ctypes.c_uint8(cheapfg)
    if __cheapfg.value!=0:
        __cheapfg = ctypes.c_uint8(1)
    __state = ctypes.c_void_p(0)
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitcreatewfg(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__cheapfg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitcreatewfg'")
        __r__state = lsfitstate(__state)
        return __r__state
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__c)


_lib_alglib.alglib_lsfitcreatefg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitcreatefg.restype = ctypes.c_int32
def lsfitcreatefg(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        x,y,c,n,m,k,cheapfg = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        x,y,c,cheapfg = functionargs
        if safe_rows("'lsfitcreatefg': incorrect parameters",x)!=safe_len("'lsfitcreatefg': incorrect parameters",y):
            raise RuntimeError("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size")
        n = safe_rows("'lsfitcreatefg': incorrect parameters",x)
        m = safe_cols("'lsfitcreatefg': incorrect parameters",x)
        k = safe_len("'lsfitcreatefg': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'lsfitcreatefg': function must have 4 or 7 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __cheapfg = ctypes.c_uint8(cheapfg)
    if __cheapfg.value!=0:
        __cheapfg = ctypes.c_uint8(1)
    __state = ctypes.c_void_p(0)
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitcreatefg(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__cheapfg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitcreatefg'")
        __r__state = lsfitstate(__state)
        return __r__state
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__c)


_lib_alglib.alglib_lsfitcreatewfgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitcreatewfgh.restype = ctypes.c_int32
def lsfitcreatewfgh(*functionargs):
    if len(functionargs)==7:
        __friendly_form = False
        x,y,w,c,n,m,k = functionargs
    elif len(functionargs)==4:
        __friendly_form = True
        x,y,w,c = functionargs
        if safe_rows("'lsfitcreatewfgh': incorrect parameters",x)!=safe_len("'lsfitcreatewfgh': incorrect parameters",y) or safe_rows("'lsfitcreatewfgh': incorrect parameters",x)!=safe_len("'lsfitcreatewfgh': incorrect parameters",w):
            raise RuntimeError("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size")
        n = safe_rows("'lsfitcreatewfgh': incorrect parameters",x)
        m = safe_cols("'lsfitcreatewfgh': incorrect parameters",x)
        k = safe_len("'lsfitcreatewfgh': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'lsfitcreatewfgh': function must have 4 or 7 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(w):
        raise ValueError("'w' parameter can't be cast to real_vector")
    __w = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__w, w, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitcreatewfgh(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__w), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitcreatewfgh'")
        __r__state = lsfitstate(__state)
        return __r__state
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__w)
        x_vector_clear(__c)


_lib_alglib.alglib_lsfitcreatefgh.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitcreatefgh.restype = ctypes.c_int32
def lsfitcreatefgh(*functionargs):
    if len(functionargs)==6:
        __friendly_form = False
        x,y,c,n,m,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,y,c = functionargs
        if safe_rows("'lsfitcreatefgh': incorrect parameters",x)!=safe_len("'lsfitcreatefgh': incorrect parameters",y):
            raise RuntimeError("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size")
        n = safe_rows("'lsfitcreatefgh': incorrect parameters",x)
        m = safe_cols("'lsfitcreatefgh': incorrect parameters",x)
        k = safe_len("'lsfitcreatefgh': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'lsfitcreatefgh': function must have 3 or 6 parameters")
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitcreatefgh(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__k), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitcreatefgh'")
        __r__state = lsfitstate(__state)
        return __r__state
    finally:
        x_matrix_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__c)


_lib_alglib.alglib_lsfitsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitsetcond.restype = ctypes.c_int32
def lsfitsetcond(state, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_lsfitsetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitsetstpmax.restype = ctypes.c_int32
def lsfitsetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitsetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitsetstpmax'")
        return
    finally:
        pass


_lib_alglib.alglib_lsfitsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitsetxrep.restype = ctypes.c_int32
def lsfitsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitsetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_lsfitsetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitsetscale.restype = ctypes.c_int32
def lsfitsetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitsetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitsetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_lsfitsetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitsetbc.restype = ctypes.c_int32
def lsfitsetbc(state, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitsetbc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitsetbc'")
        return
    finally:
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)




def lsfitfit_f(state, func, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_c  = x_vector()
    _lib_alglib.x_lsfitstate_get_c(state.ptr, ctypes.byref(_xc_c))
    _py_c = create_real_vector(_xc_c.cnt)
    _xc_x  = x_vector()
    _lib_alglib.x_lsfitstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    while True:
        retval = _lib_alglib.alglib_lsfititeration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfititeration'")
        if not _xc_result:
            break
        _lib_alglib.x_lsfitstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_c, _py_c)
            copy_x_to_list(_xc_x, _py_x)
            _xc_f.value = func(_py_c, _py_x, param)
            _lib_alglib.x_lsfitstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_lsfitstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_c, _py_c)
                _lib_alglib.x_lsfitstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_c, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)")
    return


def lsfitfit_fg(state, func, grad, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_c  = x_vector()
    _lib_alglib.x_lsfitstate_get_c(state.ptr, ctypes.byref(_xc_c))
    _py_c = create_real_vector(_xc_c.cnt)
    _xc_x  = x_vector()
    _lib_alglib.x_lsfitstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_lsfitstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    while True:
        retval = _lib_alglib.alglib_lsfititeration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfititeration'")
        if not _xc_result:
            break
        _lib_alglib.x_lsfitstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_c, _py_c)
            copy_x_to_list(_xc_x, _py_x)
            _xc_f.value = func(_py_c, _py_x, param)
            _lib_alglib.x_lsfitstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_lsfitstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_c, _py_c)
            copy_x_to_list(_xc_x, _py_x)
            _xc_f.value = grad(_py_c, _py_x, _py_g, param)
            _lib_alglib.x_lsfitstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_lsfitstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_c, _py_c)
                _lib_alglib.x_lsfitstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_c, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)")
    return


def lsfitfit_fgh(state, func, grad, hess, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_c  = x_vector()
    _lib_alglib.x_lsfitstate_get_c(state.ptr, ctypes.byref(_xc_c))
    _py_c = create_real_vector(_xc_c.cnt)
    _xc_x  = x_vector()
    _lib_alglib.x_lsfitstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_lsfitstate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    _xc_h  = x_matrix()
    _lib_alglib.x_lsfitstate_get_h(state.ptr, ctypes.byref(_xc_h))
    _py_h = create_real_matrix(_xc_h.rows,_xc_h.cols)
    while True:
        retval = _lib_alglib.alglib_lsfititeration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfititeration'")
        if not _xc_result:
            break
        _lib_alglib.x_lsfitstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_c, _py_c)
            copy_x_to_list(_xc_x, _py_x)
            _xc_f.value = func(_py_c, _py_x, param)
            _lib_alglib.x_lsfitstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_lsfitstate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_c, _py_c)
            copy_x_to_list(_xc_x, _py_x)
            _xc_f.value = grad(_py_c, _py_x, _py_g, param)
            _lib_alglib.x_lsfitstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_lsfitstate_get_needfgh(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_c, _py_c)
            copy_x_to_list(_xc_x, _py_x)
            _xc_f.value = hess(_py_c, _py_x, _py_g, _py_h, param)
            _lib_alglib.x_lsfitstate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_h, _py_h, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_lsfitstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_c, _py_c)
                _lib_alglib.x_lsfitstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_c, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_lsfitresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitresults.restype = ctypes.c_int32
def lsfitresults(state):
    pass
    __state = state.ptr
    __info = x_int()
    __info.val = 0
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lsfitreport()
    x_lsfitreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__info), ctypes.byref(__c), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitresults'")
        __r__info = __info.val
        __r__c = list_from_x(__c)
        __r__rep = lsfitreport_from_x(__rep)
        return (__r__info, __r__c, __r__rep)
    finally:
        x_vector_clear(__c)
        x_lsfitreport_clear(__rep)


_lib_alglib.alglib_lsfitsetgradientcheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lsfitsetgradientcheck.restype = ctypes.c_int32
def lsfitsetgradientcheck(state, teststep):
    pass
    __state = state.ptr
    __teststep = ctypes.c_double(teststep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lsfitsetgradientcheck(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__teststep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lsfitsetgradientcheck'")
        return
    finally:
        pass


_lib_alglib.x_obj_free_pspline2interpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_pspline2interpolant.restype = None


class pspline2interpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_pspline2interpolant(self.ptr)
_lib_alglib.x_obj_free_pspline3interpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_pspline3interpolant.restype = None


class pspline3interpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_pspline3interpolant(self.ptr)
_lib_alglib.alglib_pspline2build.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2build.restype = ctypes.c_int32
def pspline2build(xy, n, st, pt):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __st = x_int()
    __st.val = int(st)
    if __st.val!=st:
        raise ValueError("Error while converting 'st' parameter to 'x_int'")
    __pt = x_int()
    __pt.val = int(pt)
    if __pt.val!=pt:
        raise ValueError("Error while converting 'pt' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2build(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__st), ctypes.byref(__pt), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2build'")
        __r__p = pspline2interpolant(__p)
        return __r__p
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_pspline3build.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3build.restype = ctypes.c_int32
def pspline3build(xy, n, st, pt):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __st = x_int()
    __st.val = int(st)
    if __st.val!=st:
        raise ValueError("Error while converting 'st' parameter to 'x_int'")
    __pt = x_int()
    __pt.val = int(pt)
    if __pt.val!=pt:
        raise ValueError("Error while converting 'pt' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3build(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__st), ctypes.byref(__pt), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3build'")
        __r__p = pspline3interpolant(__p)
        return __r__p
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_pspline2buildperiodic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2buildperiodic.restype = ctypes.c_int32
def pspline2buildperiodic(xy, n, st, pt):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __st = x_int()
    __st.val = int(st)
    if __st.val!=st:
        raise ValueError("Error while converting 'st' parameter to 'x_int'")
    __pt = x_int()
    __pt.val = int(pt)
    if __pt.val!=pt:
        raise ValueError("Error while converting 'pt' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2buildperiodic(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__st), ctypes.byref(__pt), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2buildperiodic'")
        __r__p = pspline2interpolant(__p)
        return __r__p
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_pspline3buildperiodic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3buildperiodic.restype = ctypes.c_int32
def pspline3buildperiodic(xy, n, st, pt):
    pass
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __st = x_int()
    __st.val = int(st)
    if __st.val!=st:
        raise ValueError("Error while converting 'st' parameter to 'x_int'")
    __pt = x_int()
    __pt.val = int(pt)
    if __pt.val!=pt:
        raise ValueError("Error while converting 'pt' parameter to 'x_int'")
    __p = ctypes.c_void_p(0)
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3buildperiodic(ctypes.byref(_error_msg), ctypes.byref(__xy), ctypes.byref(__n), ctypes.byref(__st), ctypes.byref(__pt), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3buildperiodic'")
        __r__p = pspline3interpolant(__p)
        return __r__p
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_pspline2parametervalues.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2parametervalues.restype = ctypes.c_int32
def pspline2parametervalues(p):
    pass
    __p = p.ptr
    __n = x_int()
    __n.val = 0
    __t = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2parametervalues(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2parametervalues'")
        __r__n = __n.val
        __r__t = list_from_x(__t)
        return (__r__n, __r__t)
    finally:
        x_vector_clear(__t)


_lib_alglib.alglib_pspline3parametervalues.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3parametervalues.restype = ctypes.c_int32
def pspline3parametervalues(p):
    pass
    __p = p.ptr
    __n = x_int()
    __n.val = 0
    __t = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3parametervalues(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__n), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3parametervalues'")
        __r__n = __n.val
        __r__t = list_from_x(__t)
        return (__r__n, __r__t)
    finally:
        x_vector_clear(__t)


_lib_alglib.alglib_pspline2calc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2calc.restype = ctypes.c_int32
def pspline2calc(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2calc(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2calc'")
        __r__x = __x.value
        __r__y = __y.value
        return (__r__x, __r__y)
    finally:
        pass


_lib_alglib.alglib_pspline3calc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3calc.restype = ctypes.c_int32
def pspline3calc(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    __z = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3calc(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3calc'")
        __r__x = __x.value
        __r__y = __y.value
        __r__z = __z.value
        return (__r__x, __r__y, __r__z)
    finally:
        pass


_lib_alglib.alglib_pspline2tangent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2tangent.restype = ctypes.c_int32
def pspline2tangent(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2tangent(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2tangent'")
        __r__x = __x.value
        __r__y = __y.value
        return (__r__x, __r__y)
    finally:
        pass


_lib_alglib.alglib_pspline3tangent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3tangent.restype = ctypes.c_int32
def pspline3tangent(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    __z = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3tangent(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3tangent'")
        __r__x = __x.value
        __r__y = __y.value
        __r__z = __z.value
        return (__r__x, __r__y, __r__z)
    finally:
        pass


_lib_alglib.alglib_pspline2diff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2diff.restype = ctypes.c_int32
def pspline2diff(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __dx = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    __dy = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2diff(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__dx), ctypes.byref(__y), ctypes.byref(__dy))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2diff'")
        __r__x = __x.value
        __r__dx = __dx.value
        __r__y = __y.value
        __r__dy = __dy.value
        return (__r__x, __r__dx, __r__y, __r__dy)
    finally:
        pass


_lib_alglib.alglib_pspline3diff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3diff.restype = ctypes.c_int32
def pspline3diff(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __dx = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    __dy = ctypes.c_double(0)
    __z = ctypes.c_double(0)
    __dz = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3diff(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__dx), ctypes.byref(__y), ctypes.byref(__dy), ctypes.byref(__z), ctypes.byref(__dz))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3diff'")
        __r__x = __x.value
        __r__dx = __dx.value
        __r__y = __y.value
        __r__dy = __dy.value
        __r__z = __z.value
        __r__dz = __dz.value
        return (__r__x, __r__dx, __r__y, __r__dy, __r__z, __r__dz)
    finally:
        pass


_lib_alglib.alglib_pspline2diff2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2diff2.restype = ctypes.c_int32
def pspline2diff2(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __dx = ctypes.c_double(0)
    __d2x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    __dy = ctypes.c_double(0)
    __d2y = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2diff2(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__dx), ctypes.byref(__d2x), ctypes.byref(__y), ctypes.byref(__dy), ctypes.byref(__d2y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2diff2'")
        __r__x = __x.value
        __r__dx = __dx.value
        __r__d2x = __d2x.value
        __r__y = __y.value
        __r__dy = __dy.value
        __r__d2y = __d2y.value
        return (__r__x, __r__dx, __r__d2x, __r__y, __r__dy, __r__d2y)
    finally:
        pass


_lib_alglib.alglib_pspline3diff2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3diff2.restype = ctypes.c_int32
def pspline3diff2(p, t):
    pass
    __p = p.ptr
    __t = ctypes.c_double(t)
    __x = ctypes.c_double(0)
    __dx = ctypes.c_double(0)
    __d2x = ctypes.c_double(0)
    __y = ctypes.c_double(0)
    __dy = ctypes.c_double(0)
    __d2y = ctypes.c_double(0)
    __z = ctypes.c_double(0)
    __dz = ctypes.c_double(0)
    __d2z = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3diff2(ctypes.byref(_error_msg), ctypes.byref(__p), ctypes.byref(__t), ctypes.byref(__x), ctypes.byref(__dx), ctypes.byref(__d2x), ctypes.byref(__y), ctypes.byref(__dy), ctypes.byref(__d2y), ctypes.byref(__z), ctypes.byref(__dz), ctypes.byref(__d2z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3diff2'")
        __r__x = __x.value
        __r__dx = __dx.value
        __r__d2x = __d2x.value
        __r__y = __y.value
        __r__dy = __dy.value
        __r__d2y = __d2y.value
        __r__z = __z.value
        __r__dz = __dz.value
        __r__d2z = __d2z.value
        return (__r__x, __r__dx, __r__d2x, __r__y, __r__dy, __r__d2y, __r__z, __r__dz, __r__d2z)
    finally:
        pass


_lib_alglib.alglib_pspline2arclength.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline2arclength.restype = ctypes.c_int32
def pspline2arclength(p, a, b):
    pass
    __result = ctypes.c_double(0)
    __p = p.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline2arclength(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__p), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline2arclength'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_pspline3arclength.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pspline3arclength.restype = ctypes.c_int32
def pspline3arclength(p, a, b):
    pass
    __result = ctypes.c_double(0)
    __p = p.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pspline3arclength(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__p), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pspline3arclength'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_parametricrdpfixed.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_parametricrdpfixed.restype = ctypes.c_int32
def parametricrdpfixed(x, n, d, stopm, stopeps):
    pass
    if not is_real_matrix(x):
        raise ValueError("'x' parameter can't be cast to real_matrix")
    __x = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __stopm = x_int()
    __stopm.val = int(stopm)
    if __stopm.val!=stopm:
        raise ValueError("Error while converting 'stopm' parameter to 'x_int'")
    __stopeps = ctypes.c_double(stopeps)
    __x2 = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __idx2 = x_vector(cnt=0,datatype=DT_INT,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nsections = x_int()
    __nsections.val = 0
    try:
        x_from_listlist(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_parametricrdpfixed(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__d), ctypes.byref(__stopm), ctypes.byref(__stopeps), ctypes.byref(__x2), ctypes.byref(__idx2), ctypes.byref(__nsections))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'parametricrdpfixed'")
        __r__x2 = listlist_from_x(__x2)
        __r__idx2 = list_from_x(__idx2)
        __r__nsections = __nsections.val
        return (__r__x2, __r__idx2, __r__nsections)
    finally:
        x_matrix_clear(__x)
        x_matrix_clear(__x2)
        x_vector_clear(__idx2)


_lib_alglib.x_obj_free_linlsqrstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_linlsqrstate.restype = None


class linlsqrstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_linlsqrstate(self.ptr)


class x_linlsqrreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nmv", x_int),
        ("terminationtype", x_int)
        ]




class linlsqrreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nmv = 0
        self.terminationtype = 0


def x_linlsqrreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nmv.val = 0
    x.terminationtype.val = 0
    return




def x_linlsqrreport_clear(x):
    x_linlsqrreport_zero_fields(x)
    return




def x_from_linlsqrreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nmv.val = int(v.nmv)
    x.terminationtype.val = int(v.terminationtype)
    return




def linlsqrreport_from_x(x):
    r = linlsqrreport()
    r.iterationscount = x.iterationscount.val
    r.nmv = x.nmv.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_linlsqrcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrcreate.restype = ctypes.c_int32
def linlsqrcreate(m, n):
    pass
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrcreate(ctypes.byref(_error_msg), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrcreate'")
        __r__state = linlsqrstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_linlsqrsetprecunit.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrsetprecunit.restype = ctypes.c_int32
def linlsqrsetprecunit(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrsetprecunit(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrsetprecunit'")
        return
    finally:
        pass


_lib_alglib.alglib_linlsqrsetprecdiag.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrsetprecdiag.restype = ctypes.c_int32
def linlsqrsetprecdiag(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrsetprecdiag(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrsetprecdiag'")
        return
    finally:
        pass


_lib_alglib.alglib_linlsqrsetlambdai.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrsetlambdai.restype = ctypes.c_int32
def linlsqrsetlambdai(state, lambdai):
    pass
    __state = state.ptr
    __lambdai = ctypes.c_double(lambdai)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrsetlambdai(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__lambdai))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrsetlambdai'")
        return
    finally:
        pass


_lib_alglib.alglib_linlsqrsolvesparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrsolvesparse.restype = ctypes.c_int32
def linlsqrsolvesparse(state, a, b):
    pass
    __state = state.ptr
    __a = a.ptr
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrsolvesparse(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrsolvesparse'")
        return
    finally:
        x_vector_clear(__b)


_lib_alglib.alglib_linlsqrsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrsetcond.restype = ctypes.c_int32
def linlsqrsetcond(state, epsa, epsb, maxits):
    pass
    __state = state.ptr
    __epsa = ctypes.c_double(epsa)
    __epsb = ctypes.c_double(epsb)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsa), ctypes.byref(__epsb), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_linlsqrresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrresults.restype = ctypes.c_int32
def linlsqrresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_linlsqrreport()
    x_linlsqrreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrresults'")
        __r__x = list_from_x(__x)
        __r__rep = linlsqrreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_linlsqrreport_clear(__rep)


_lib_alglib.alglib_linlsqrsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_linlsqrsetxrep.restype = ctypes.c_int32
def linlsqrsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_linlsqrsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'linlsqrsetxrep'")
        return
    finally:
        pass


_lib_alglib.x_obj_free_rbfmodel.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_rbfmodel.restype = None


class rbfmodel(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_rbfmodel(self.ptr)


class x_rbfreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("arows", x_int),
        ("acols", x_int),
        ("annz", x_int),
        ("iterationscount", x_int),
        ("nmv", x_int),
        ("terminationtype", x_int)
        ]




class rbfreport(object):
    def __init__(self):
        self.arows = 0
        self.acols = 0
        self.annz = 0
        self.iterationscount = 0
        self.nmv = 0
        self.terminationtype = 0


def x_rbfreport_zero_fields(x):
    x.arows.val = 0
    x.acols.val = 0
    x.annz.val = 0
    x.iterationscount.val = 0
    x.nmv.val = 0
    x.terminationtype.val = 0
    return




def x_rbfreport_clear(x):
    x_rbfreport_zero_fields(x)
    return




def x_from_rbfreport(x,v):
    x.arows.val = int(v.arows)
    x.acols.val = int(v.acols)
    x.annz.val = int(v.annz)
    x.iterationscount.val = int(v.iterationscount)
    x.nmv.val = int(v.nmv)
    x.terminationtype.val = int(v.terminationtype)
    return




def rbfreport_from_x(x):
    r = rbfreport()
    r.arows = x.arows.val
    r.acols = x.acols.val
    r.annz = x.annz.val
    r.iterationscount = x.iterationscount.val
    r.nmv = x.nmv.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_rbfserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfserialize.restype = ctypes.c_int32

def rbfserialize(obj):
    error_msg = ctypes.c_char_p(0)
    _s_out = ctypes.c_char_p(0)
    retval = _lib_alglib.alglib_rbfserialize(ctypes.byref(error_msg), ctypes.byref(obj.ptr), ctypes.byref(_s_out))
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'rbfserialize'")
    s_out = _s_out.value
    _lib_alglib.x_free(_s_out)
    return s_out

_lib_alglib.alglib_rbfunserialize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfunserialize.restype = ctypes.c_int32

def rbfunserialize(s_in):
    error_msg = ctypes.c_char_p(0)
    _s_in = ctypes.c_char_p(s_in)
    _obj = ctypes.c_void_p(0)
    retval = _lib_alglib.alglib_rbfunserialize(ctypes.byref(error_msg), ctypes.byref(_s_in), ctypes.byref(_obj), )
    if retval!=0:
        if retval==X_ASSERTION_FAILED:
            raise RuntimeError(error_msg.value)
        else:
            raise RuntimeError("Error while calling 'rbfserialize'")
    return rbfmodel(_obj)

_lib_alglib.alglib_rbfcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfcreate.restype = ctypes.c_int32
def rbfcreate(nx, ny):
    pass
    __nx = x_int()
    __nx.val = int(nx)
    if __nx.val!=nx:
        raise ValueError("Error while converting 'nx' parameter to 'x_int'")
    __ny = x_int()
    __ny.val = int(ny)
    if __ny.val!=ny:
        raise ValueError("Error while converting 'ny' parameter to 'x_int'")
    __s = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfcreate(ctypes.byref(_error_msg), ctypes.byref(__nx), ctypes.byref(__ny), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfcreate'")
        __r__s = rbfmodel(__s)
        return __r__s
    finally:
        pass


_lib_alglib.alglib_rbfsetpoints.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfsetpoints.restype = ctypes.c_int32
def rbfsetpoints(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        s,xy,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        s,xy = functionargs
        n = safe_rows("'rbfsetpoints': incorrect parameters",xy)
    else:
        raise RuntimeError("Error while calling 'rbfsetpoints': function must have 2 or 3 parameters")
    __s = s.ptr
    if not is_real_matrix(xy):
        raise ValueError("'xy' parameter can't be cast to real_matrix")
    __xy = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__xy, xy, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfsetpoints(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__xy), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfsetpoints'")
        return
    finally:
        x_matrix_clear(__xy)


_lib_alglib.alglib_rbfsetalgoqnn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfsetalgoqnn.restype = ctypes.c_int32
def rbfsetalgoqnn(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        s,q,z = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        s, = functionargs
        q = 1.0
        z = 5.0
    else:
        raise RuntimeError("Error while calling 'rbfsetalgoqnn': function must have 1 or 3 parameters")
    __s = s.ptr
    __q = ctypes.c_double(q)
    __z = ctypes.c_double(z)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfsetalgoqnn(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__q), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfsetalgoqnn'")
        return
    finally:
        pass


_lib_alglib.alglib_rbfsetalgomultilayer.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfsetalgomultilayer.restype = ctypes.c_int32
def rbfsetalgomultilayer(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        s,rbase,nlayers,lambdav = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        s,rbase,nlayers = functionargs
        lambdav = 0.01
    else:
        raise RuntimeError("Error while calling 'rbfsetalgomultilayer': function must have 3 or 4 parameters")
    __s = s.ptr
    __rbase = ctypes.c_double(rbase)
    __nlayers = x_int()
    __nlayers.val = int(nlayers)
    if __nlayers.val!=nlayers:
        raise ValueError("Error while converting 'nlayers' parameter to 'x_int'")
    __lambdav = ctypes.c_double(lambdav)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfsetalgomultilayer(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__rbase), ctypes.byref(__nlayers), ctypes.byref(__lambdav))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfsetalgomultilayer'")
        return
    finally:
        pass


_lib_alglib.alglib_rbfsetlinterm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfsetlinterm.restype = ctypes.c_int32
def rbfsetlinterm(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfsetlinterm(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfsetlinterm'")
        return
    finally:
        pass


_lib_alglib.alglib_rbfsetconstterm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfsetconstterm.restype = ctypes.c_int32
def rbfsetconstterm(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfsetconstterm(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfsetconstterm'")
        return
    finally:
        pass


_lib_alglib.alglib_rbfsetzeroterm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfsetzeroterm.restype = ctypes.c_int32
def rbfsetzeroterm(s):
    pass
    __s = s.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfsetzeroterm(ctypes.byref(_error_msg), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfsetzeroterm'")
        return
    finally:
        pass


_lib_alglib.alglib_rbfbuildmodel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfbuildmodel.restype = ctypes.c_int32
def rbfbuildmodel(s):
    pass
    __s = s.ptr
    __rep = x_rbfreport()
    x_rbfreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfbuildmodel(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfbuildmodel'")
        __r__rep = rbfreport_from_x(__rep)
        return __r__rep
    finally:
        x_rbfreport_clear(__rep)


_lib_alglib.alglib_rbfcalc2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfcalc2.restype = ctypes.c_int32
def rbfcalc2(s, x0, x1):
    pass
    __result = ctypes.c_double(0)
    __s = s.ptr
    __x0 = ctypes.c_double(x0)
    __x1 = ctypes.c_double(x1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfcalc2(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__x0), ctypes.byref(__x1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfcalc2'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_rbfcalc3.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfcalc3.restype = ctypes.c_int32
def rbfcalc3(s, x0, x1, x2):
    pass
    __result = ctypes.c_double(0)
    __s = s.ptr
    __x0 = ctypes.c_double(x0)
    __x1 = ctypes.c_double(x1)
    __x2 = ctypes.c_double(x2)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfcalc3(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__s), ctypes.byref(__x0), ctypes.byref(__x1), ctypes.byref(__x2))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfcalc3'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_rbfcalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfcalc.restype = ctypes.c_int32
def rbfcalc(s, x):
    pass
    __s = s.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __y = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfcalc(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfcalc'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_rbfcalcbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfcalcbuf.restype = ctypes.c_int32
def rbfcalcbuf(s, x, y):
    pass
    __s = s.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfcalcbuf(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfcalcbuf'")
        __r__y = list_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_rbfgridcalc2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfgridcalc2.restype = ctypes.c_int32
def rbfgridcalc2(s, x0, n0, x1, n1):
    pass
    __s = s.ptr
    if not is_real_vector(x0):
        raise ValueError("'x0' parameter can't be cast to real_vector")
    __x0 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n0 = x_int()
    __n0.val = int(n0)
    if __n0.val!=n0:
        raise ValueError("Error while converting 'n0' parameter to 'x_int'")
    if not is_real_vector(x1):
        raise ValueError("'x1' parameter can't be cast to real_vector")
    __x1 = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n1 = x_int()
    __n1.val = int(n1)
    if __n1.val!=n1:
        raise ValueError("Error while converting 'n1' parameter to 'x_int'")
    __y = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x0, x0, DT_REAL, X_CREATE)
        x_from_list(__x1, x1, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfgridcalc2(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__x0), ctypes.byref(__n0), ctypes.byref(__x1), ctypes.byref(__n1), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfgridcalc2'")
        __r__y = listlist_from_x(__y)
        return __r__y
    finally:
        x_vector_clear(__x0)
        x_vector_clear(__x1)
        x_matrix_clear(__y)


_lib_alglib.alglib_rbfunpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rbfunpack.restype = ctypes.c_int32
def rbfunpack(s):
    pass
    __s = s.ptr
    __nx = x_int()
    __nx.val = 0
    __ny = x_int()
    __ny.val = 0
    __xwr = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __nc = x_int()
    __nc.val = 0
    __v = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rbfunpack(ctypes.byref(_error_msg), ctypes.byref(__s), ctypes.byref(__nx), ctypes.byref(__ny), ctypes.byref(__xwr), ctypes.byref(__nc), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rbfunpack'")
        __r__nx = __nx.val
        __r__ny = __ny.val
        __r__xwr = listlist_from_x(__xwr)
        __r__nc = __nc.val
        __r__v = listlist_from_x(__v)
        return (__r__nx, __r__ny, __r__xwr, __r__nc, __r__v)
    finally:
        x_matrix_clear(__xwr)
        x_matrix_clear(__v)


_lib_alglib.x_obj_free_spline2dinterpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_spline2dinterpolant.restype = None


class spline2dinterpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_spline2dinterpolant(self.ptr)
_lib_alglib.alglib_spline2dcalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dcalc.restype = ctypes.c_int32
def spline2dcalc(c, x, y):
    pass
    __result = ctypes.c_double(0)
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dcalc(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dcalc'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_spline2ddiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2ddiff.restype = ctypes.c_int32
def spline2ddiff(c, x, y):
    pass
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    __f = ctypes.c_double(0)
    __fx = ctypes.c_double(0)
    __fy = ctypes.c_double(0)
    __fxy = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2ddiff(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__f), ctypes.byref(__fx), ctypes.byref(__fy), ctypes.byref(__fxy))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2ddiff'")
        __r__f = __f.value
        __r__fx = __fx.value
        __r__fy = __fy.value
        __r__fxy = __fxy.value
        return (__r__f, __r__fx, __r__fy, __r__fxy)
    finally:
        pass


_lib_alglib.alglib_spline2dlintransxy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dlintransxy.restype = ctypes.c_int32
def spline2dlintransxy(c, ax, bx, ay, by):
    pass
    __c = c.ptr
    __ax = ctypes.c_double(ax)
    __bx = ctypes.c_double(bx)
    __ay = ctypes.c_double(ay)
    __by = ctypes.c_double(by)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dlintransxy(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__ax), ctypes.byref(__bx), ctypes.byref(__ay), ctypes.byref(__by))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dlintransxy'")
        return
    finally:
        pass


_lib_alglib.alglib_spline2dlintransf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dlintransf.restype = ctypes.c_int32
def spline2dlintransf(c, a, b):
    pass
    __c = c.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dlintransf(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dlintransf'")
        return
    finally:
        pass


_lib_alglib.alglib_spline2dcopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dcopy.restype = ctypes.c_int32
def spline2dcopy(c):
    pass
    __c = c.ptr
    __cc = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dcopy(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__cc))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dcopy'")
        __r__cc = spline2dinterpolant(__cc)
        return __r__cc
    finally:
        pass


_lib_alglib.alglib_spline2dresamplebicubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dresamplebicubic.restype = ctypes.c_int32
def spline2dresamplebicubic(a, oldheight, oldwidth, newheight, newwidth):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __oldheight = x_int()
    __oldheight.val = int(oldheight)
    if __oldheight.val!=oldheight:
        raise ValueError("Error while converting 'oldheight' parameter to 'x_int'")
    __oldwidth = x_int()
    __oldwidth.val = int(oldwidth)
    if __oldwidth.val!=oldwidth:
        raise ValueError("Error while converting 'oldwidth' parameter to 'x_int'")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __newheight = x_int()
    __newheight.val = int(newheight)
    if __newheight.val!=newheight:
        raise ValueError("Error while converting 'newheight' parameter to 'x_int'")
    __newwidth = x_int()
    __newwidth.val = int(newwidth)
    if __newwidth.val!=newwidth:
        raise ValueError("Error while converting 'newwidth' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dresamplebicubic(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__oldheight), ctypes.byref(__oldwidth), ctypes.byref(__b), ctypes.byref(__newheight), ctypes.byref(__newwidth))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dresamplebicubic'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_spline2dresamplebilinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dresamplebilinear.restype = ctypes.c_int32
def spline2dresamplebilinear(a, oldheight, oldwidth, newheight, newwidth):
    pass
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __oldheight = x_int()
    __oldheight.val = int(oldheight)
    if __oldheight.val!=oldheight:
        raise ValueError("Error while converting 'oldheight' parameter to 'x_int'")
    __oldwidth = x_int()
    __oldwidth.val = int(oldwidth)
    if __oldwidth.val!=oldwidth:
        raise ValueError("Error while converting 'oldwidth' parameter to 'x_int'")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __newheight = x_int()
    __newheight.val = int(newheight)
    if __newheight.val!=newheight:
        raise ValueError("Error while converting 'newheight' parameter to 'x_int'")
    __newwidth = x_int()
    __newwidth.val = int(newwidth)
    if __newwidth.val!=newwidth:
        raise ValueError("Error while converting 'newwidth' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dresamplebilinear(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__oldheight), ctypes.byref(__oldwidth), ctypes.byref(__b), ctypes.byref(__newheight), ctypes.byref(__newwidth))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dresamplebilinear'")
        __r__b = listlist_from_x(__b)
        return __r__b
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)


_lib_alglib.alglib_spline2dbuildbilinearv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dbuildbilinearv.restype = ctypes.c_int32
def spline2dbuildbilinearv(x, n, y, m, f, d):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dbuildbilinearv(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__f), ctypes.byref(__d), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dbuildbilinearv'")
        __r__c = spline2dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__f)


_lib_alglib.alglib_spline2dbuildbicubicv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dbuildbicubicv.restype = ctypes.c_int32
def spline2dbuildbicubicv(x, n, y, m, f, d):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dbuildbicubicv(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__f), ctypes.byref(__d), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dbuildbicubicv'")
        __r__c = spline2dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__f)


_lib_alglib.alglib_spline2dcalcvbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dcalcvbuf.restype = ctypes.c_int32
def spline2dcalcvbuf(c, x, y, f):
    pass
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dcalcvbuf(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dcalcvbuf'")
        __r__f = list_from_x(__f)
        return __r__f
    finally:
        x_vector_clear(__f)


_lib_alglib.alglib_spline2dcalcv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dcalcv.restype = ctypes.c_int32
def spline2dcalcv(c, x, y):
    pass
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    __f = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dcalcv(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dcalcv'")
        __r__f = list_from_x(__f)
        return __r__f
    finally:
        x_vector_clear(__f)


_lib_alglib.alglib_spline2dunpackv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dunpackv.restype = ctypes.c_int32
def spline2dunpackv(c):
    pass
    __c = c.ptr
    __m = x_int()
    __m.val = 0
    __n = x_int()
    __n.val = 0
    __d = x_int()
    __d.val = 0
    __tbl = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dunpackv(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__d), ctypes.byref(__tbl))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dunpackv'")
        __r__m = __m.val
        __r__n = __n.val
        __r__d = __d.val
        __r__tbl = listlist_from_x(__tbl)
        return (__r__m, __r__n, __r__d, __r__tbl)
    finally:
        x_matrix_clear(__tbl)


_lib_alglib.alglib_spline2dbuildbilinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dbuildbilinear.restype = ctypes.c_int32
def spline2dbuildbilinear(x, y, f, m, n):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(f):
        raise ValueError("'f' parameter can't be cast to real_matrix")
    __f = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_listlist(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dbuildbilinear(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__f), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dbuildbilinear'")
        __r__c = spline2dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_matrix_clear(__f)


_lib_alglib.alglib_spline2dbuildbicubic.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dbuildbicubic.restype = ctypes.c_int32
def spline2dbuildbicubic(x, y, f, m, n):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_matrix(f):
        raise ValueError("'f' parameter can't be cast to real_matrix")
    __f = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_listlist(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dbuildbicubic(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__f), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dbuildbicubic'")
        __r__c = spline2dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_matrix_clear(__f)


_lib_alglib.alglib_spline2dunpack.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline2dunpack.restype = ctypes.c_int32
def spline2dunpack(c):
    pass
    __c = c.ptr
    __m = x_int()
    __m.val = 0
    __n = x_int()
    __n.val = 0
    __tbl = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline2dunpack(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__m), ctypes.byref(__n), ctypes.byref(__tbl))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline2dunpack'")
        __r__m = __m.val
        __r__n = __n.val
        __r__tbl = listlist_from_x(__tbl)
        return (__r__m, __r__n, __r__tbl)
    finally:
        x_matrix_clear(__tbl)


_lib_alglib.x_obj_free_spline3dinterpolant.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_spline3dinterpolant.restype = None


class spline3dinterpolant(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_spline3dinterpolant(self.ptr)
_lib_alglib.alglib_spline3dcalc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dcalc.restype = ctypes.c_int32
def spline3dcalc(c, x, y, z):
    pass
    __result = ctypes.c_double(0)
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    __z = ctypes.c_double(z)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dcalc(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dcalc'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_spline3dlintransxyz.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dlintransxyz.restype = ctypes.c_int32
def spline3dlintransxyz(c, ax, bx, ay, by, az, bz):
    pass
    __c = c.ptr
    __ax = ctypes.c_double(ax)
    __bx = ctypes.c_double(bx)
    __ay = ctypes.c_double(ay)
    __by = ctypes.c_double(by)
    __az = ctypes.c_double(az)
    __bz = ctypes.c_double(bz)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dlintransxyz(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__ax), ctypes.byref(__bx), ctypes.byref(__ay), ctypes.byref(__by), ctypes.byref(__az), ctypes.byref(__bz))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dlintransxyz'")
        return
    finally:
        pass


_lib_alglib.alglib_spline3dlintransf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dlintransf.restype = ctypes.c_int32
def spline3dlintransf(c, a, b):
    pass
    __c = c.ptr
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dlintransf(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dlintransf'")
        return
    finally:
        pass


_lib_alglib.alglib_spline3dresampletrilinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dresampletrilinear.restype = ctypes.c_int32
def spline3dresampletrilinear(a, oldzcount, oldycount, oldxcount, newzcount, newycount, newxcount):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __oldzcount = x_int()
    __oldzcount.val = int(oldzcount)
    if __oldzcount.val!=oldzcount:
        raise ValueError("Error while converting 'oldzcount' parameter to 'x_int'")
    __oldycount = x_int()
    __oldycount.val = int(oldycount)
    if __oldycount.val!=oldycount:
        raise ValueError("Error while converting 'oldycount' parameter to 'x_int'")
    __oldxcount = x_int()
    __oldxcount.val = int(oldxcount)
    if __oldxcount.val!=oldxcount:
        raise ValueError("Error while converting 'oldxcount' parameter to 'x_int'")
    __newzcount = x_int()
    __newzcount.val = int(newzcount)
    if __newzcount.val!=newzcount:
        raise ValueError("Error while converting 'newzcount' parameter to 'x_int'")
    __newycount = x_int()
    __newycount.val = int(newycount)
    if __newycount.val!=newycount:
        raise ValueError("Error while converting 'newycount' parameter to 'x_int'")
    __newxcount = x_int()
    __newxcount.val = int(newxcount)
    if __newxcount.val!=newxcount:
        raise ValueError("Error while converting 'newxcount' parameter to 'x_int'")
    __b = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dresampletrilinear(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__oldzcount), ctypes.byref(__oldycount), ctypes.byref(__oldxcount), ctypes.byref(__newzcount), ctypes.byref(__newycount), ctypes.byref(__newxcount), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dresampletrilinear'")
        __r__b = list_from_x(__b)
        return __r__b
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_spline3dbuildtrilinearv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dbuildtrilinearv.restype = ctypes.c_int32
def spline3dbuildtrilinearv(x, n, y, m, z, l, f, d):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(z):
        raise ValueError("'z' parameter can't be cast to real_vector")
    __z = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __l = x_int()
    __l.val = int(l)
    if __l.val!=l:
        raise ValueError("Error while converting 'l' parameter to 'x_int'")
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __d = x_int()
    __d.val = int(d)
    if __d.val!=d:
        raise ValueError("Error while converting 'd' parameter to 'x_int'")
    __c = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        x_from_list(__z, z, DT_REAL, X_CREATE)
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dbuildtrilinearv(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__z), ctypes.byref(__l), ctypes.byref(__f), ctypes.byref(__d), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dbuildtrilinearv'")
        __r__c = spline3dinterpolant(__c)
        return __r__c
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)
        x_vector_clear(__z)
        x_vector_clear(__f)


_lib_alglib.alglib_spline3dcalcvbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dcalcvbuf.restype = ctypes.c_int32
def spline3dcalcvbuf(c, x, y, z, f):
    pass
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    __z = ctypes.c_double(z)
    if not is_real_vector(f):
        raise ValueError("'f' parameter can't be cast to real_vector")
    __f = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__f, f, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dcalcvbuf(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__z), ctypes.byref(__f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dcalcvbuf'")
        __r__f = list_from_x(__f)
        return __r__f
    finally:
        x_vector_clear(__f)


_lib_alglib.alglib_spline3dcalcv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dcalcv.restype = ctypes.c_int32
def spline3dcalcv(c, x, y, z):
    pass
    __c = c.ptr
    __x = ctypes.c_double(x)
    __y = ctypes.c_double(y)
    __z = ctypes.c_double(z)
    __f = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dcalcv(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__x), ctypes.byref(__y), ctypes.byref(__z), ctypes.byref(__f))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dcalcv'")
        __r__f = list_from_x(__f)
        return __r__f
    finally:
        x_vector_clear(__f)


_lib_alglib.alglib_spline3dunpackv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spline3dunpackv.restype = ctypes.c_int32
def spline3dunpackv(c):
    pass
    __c = c.ptr
    __n = x_int()
    __n.val = 0
    __m = x_int()
    __m.val = 0
    __l = x_int()
    __l.val = 0
    __d = x_int()
    __d.val = 0
    __stype = x_int()
    __stype.val = 0
    __tbl = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spline3dunpackv(ctypes.byref(_error_msg), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__l), ctypes.byref(__d), ctypes.byref(__stype), ctypes.byref(__tbl))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spline3dunpackv'")
        __r__n = __n.val
        __r__m = __m.val
        __r__l = __l.val
        __r__d = __d.val
        __r__stype = __stype.val
        __r__tbl = listlist_from_x(__tbl)
        return (__r__n, __r__m, __r__l, __r__d, __r__stype, __r__tbl)
    finally:
        x_matrix_clear(__tbl)


_lib_alglib.alglib_rmatrixludet.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixludet.restype = ctypes.c_int32
def rmatrixludet(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,pivots,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,pivots = functionargs
        if safe_rows("'rmatrixludet': incorrect parameters",a)!=safe_cols("'rmatrixludet': incorrect parameters",a) or safe_rows("'rmatrixludet': incorrect parameters",a)!=safe_len("'rmatrixludet': incorrect parameters",pivots):
            raise RuntimeError("Error while calling 'rmatrixludet': looks like one of arguments has wrong size")
        n = safe_rows("'rmatrixludet': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'rmatrixludet': function must have 2 or 3 parameters")
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(pivots):
        raise ValueError("'pivots' parameter can't be cast to int_vector")
    __pivots = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_list(__pivots, pivots, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixludet(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__pivots), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixludet'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)


_lib_alglib.alglib_rmatrixdet.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixdet.restype = ctypes.c_int32
def rmatrixdet(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_rows("'rmatrixdet': incorrect parameters",a)!=safe_cols("'rmatrixdet': incorrect parameters",a):
            raise RuntimeError("Error while calling 'rmatrixdet': looks like one of arguments has wrong size")
        n = safe_rows("'rmatrixdet': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'rmatrixdet': function must have 1 or 2 parameters")
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixdet(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixdet'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_cmatrixludet.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixludet.restype = ctypes.c_int32
def cmatrixludet(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,pivots,n = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        a,pivots = functionargs
        if safe_rows("'cmatrixludet': incorrect parameters",a)!=safe_cols("'cmatrixludet': incorrect parameters",a) or safe_rows("'cmatrixludet': incorrect parameters",a)!=safe_len("'cmatrixludet': incorrect parameters",pivots):
            raise RuntimeError("Error while calling 'cmatrixludet': looks like one of arguments has wrong size")
        n = safe_rows("'cmatrixludet': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'cmatrixludet': function must have 2 or 3 parameters")
    __result = x_complex(x=0,y=0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(pivots):
        raise ValueError("'pivots' parameter can't be cast to int_vector")
    __pivots = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        x_from_list(__pivots, pivots, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixludet(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__pivots), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixludet'")
        __r__result = complex(__result.x,__result.y)
        return __r__result
    finally:
        x_matrix_clear(__a)
        x_vector_clear(__pivots)


_lib_alglib.alglib_cmatrixdet.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_cmatrixdet.restype = ctypes.c_int32
def cmatrixdet(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_rows("'cmatrixdet': incorrect parameters",a)!=safe_cols("'cmatrixdet': incorrect parameters",a):
            raise RuntimeError("Error while calling 'cmatrixdet': looks like one of arguments has wrong size")
        n = safe_rows("'cmatrixdet': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'cmatrixdet': function must have 1 or 2 parameters")
    __result = x_complex(x=0,y=0)
    if not is_complex_matrix(a):
        raise ValueError("'a' parameter can't be cast to complex_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_COMPLEX, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_cmatrixdet(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'cmatrixdet'")
        __r__result = complex(__result.x,__result.y)
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_spdmatrixcholeskydet.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixcholeskydet.restype = ctypes.c_int32
def spdmatrixcholeskydet(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        a,n = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_rows("'spdmatrixcholeskydet': incorrect parameters",a)!=safe_cols("'spdmatrixcholeskydet': incorrect parameters",a):
            raise RuntimeError("Error while calling 'spdmatrixcholeskydet': looks like one of arguments has wrong size")
        n = safe_rows("'spdmatrixcholeskydet': incorrect parameters",a)
    else:
        raise RuntimeError("Error while calling 'spdmatrixcholeskydet': function must have 1 or 2 parameters")
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixcholeskydet(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixcholeskydet'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_spdmatrixdet.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spdmatrixdet.restype = ctypes.c_int32
def spdmatrixdet(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        a,n,isupper = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        a, = functionargs
        if safe_rows("'spdmatrixdet': incorrect parameters",a)!=safe_cols("'spdmatrixdet': incorrect parameters",a):
            raise RuntimeError("Error while calling 'spdmatrixdet': looks like one of arguments has wrong size")
        n = safe_rows("'spdmatrixdet': incorrect parameters",a)
        isupper = False
    else:
        raise RuntimeError("Error while calling 'spdmatrixdet': function must have 1 or 3 parameters")
    __result = ctypes.c_double(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to symmetric")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        if __friendly_form:
            if not x_is_symmetric(__a):
                raise ValueError("'a' parameter is not symmetric matrix")
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spdmatrixdet(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spdmatrixdet'")
        __r__result = __result.value
        return __r__result
    finally:
        x_matrix_clear(__a)


_lib_alglib.alglib_smatrixgevd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixgevd.restype = ctypes.c_int32
def smatrixgevd(a, n, isuppera, b, isupperb, zneeded, problemtype):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isuppera = ctypes.c_uint8(isuppera)
    if __isuppera.value!=0:
        __isuppera = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __isupperb = ctypes.c_uint8(isupperb)
    if __isupperb.value!=0:
        __isupperb = ctypes.c_uint8(1)
    __zneeded = x_int()
    __zneeded.val = int(zneeded)
    if __zneeded.val!=zneeded:
        raise ValueError("Error while converting 'zneeded' parameter to 'x_int'")
    __problemtype = x_int()
    __problemtype.val = int(problemtype)
    if __problemtype.val!=problemtype:
        raise ValueError("Error while converting 'problemtype' parameter to 'x_int'")
    __d = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __z = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixgevd(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isuppera), ctypes.byref(__b), ctypes.byref(__isupperb), ctypes.byref(__zneeded), ctypes.byref(__problemtype), ctypes.byref(__d), ctypes.byref(__z))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixgevd'")
        __r__result = __result.value!=0
        __r__d = list_from_x(__d)
        __r__z = listlist_from_x(__z)
        return (__r__result, __r__d, __r__z)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_vector_clear(__d)
        x_matrix_clear(__z)


_lib_alglib.alglib_smatrixgevdreduce.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_smatrixgevdreduce.restype = ctypes.c_int32
def smatrixgevdreduce(a, n, isuppera, b, isupperb, problemtype):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __isuppera = ctypes.c_uint8(isuppera)
    if __isuppera.value!=0:
        __isuppera = ctypes.c_uint8(1)
    if not is_real_matrix(b):
        raise ValueError("'b' parameter can't be cast to real_matrix")
    __b = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __isupperb = ctypes.c_uint8(isupperb)
    if __isupperb.value!=0:
        __isupperb = ctypes.c_uint8(1)
    __problemtype = x_int()
    __problemtype.val = int(problemtype)
    if __problemtype.val!=problemtype:
        raise ValueError("Error while converting 'problemtype' parameter to 'x_int'")
    __r = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __isupperr = ctypes.c_uint8(0)
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        x_from_listlist(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_smatrixgevdreduce(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__isuppera), ctypes.byref(__b), ctypes.byref(__isupperb), ctypes.byref(__problemtype), ctypes.byref(__r), ctypes.byref(__isupperr))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'smatrixgevdreduce'")
        __r__result = __result.value!=0
        __r__a = listlist_from_x(__a)
        __r__r = listlist_from_x(__r)
        __r__isupperr = __isupperr.value!=0
        return (__r__result, __r__a, __r__r, __r__isupperr)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__b)
        x_matrix_clear(__r)


_lib_alglib.alglib_rmatrixinvupdatesimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixinvupdatesimple.restype = ctypes.c_int32
def rmatrixinvupdatesimple(inva, n, updrow, updcolumn, updval):
    pass
    if not is_real_matrix(inva):
        raise ValueError("'inva' parameter can't be cast to real_matrix")
    __inva = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __updrow = x_int()
    __updrow.val = int(updrow)
    if __updrow.val!=updrow:
        raise ValueError("Error while converting 'updrow' parameter to 'x_int'")
    __updcolumn = x_int()
    __updcolumn.val = int(updcolumn)
    if __updcolumn.val!=updcolumn:
        raise ValueError("Error while converting 'updcolumn' parameter to 'x_int'")
    __updval = ctypes.c_double(updval)
    try:
        x_from_listlist(__inva, inva, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixinvupdatesimple(ctypes.byref(_error_msg), ctypes.byref(__inva), ctypes.byref(__n), ctypes.byref(__updrow), ctypes.byref(__updcolumn), ctypes.byref(__updval))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixinvupdatesimple'")
        __r__inva = listlist_from_x(__inva)
        return __r__inva
    finally:
        x_matrix_clear(__inva)


_lib_alglib.alglib_rmatrixinvupdaterow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixinvupdaterow.restype = ctypes.c_int32
def rmatrixinvupdaterow(inva, n, updrow, v):
    pass
    if not is_real_matrix(inva):
        raise ValueError("'inva' parameter can't be cast to real_matrix")
    __inva = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __updrow = x_int()
    __updrow.val = int(updrow)
    if __updrow.val!=updrow:
        raise ValueError("Error while converting 'updrow' parameter to 'x_int'")
    if not is_real_vector(v):
        raise ValueError("'v' parameter can't be cast to real_vector")
    __v = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__inva, inva, DT_REAL, X_CREATE)
        x_from_list(__v, v, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixinvupdaterow(ctypes.byref(_error_msg), ctypes.byref(__inva), ctypes.byref(__n), ctypes.byref(__updrow), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixinvupdaterow'")
        __r__inva = listlist_from_x(__inva)
        return __r__inva
    finally:
        x_matrix_clear(__inva)
        x_vector_clear(__v)


_lib_alglib.alglib_rmatrixinvupdatecolumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixinvupdatecolumn.restype = ctypes.c_int32
def rmatrixinvupdatecolumn(inva, n, updcolumn, u):
    pass
    if not is_real_matrix(inva):
        raise ValueError("'inva' parameter can't be cast to real_matrix")
    __inva = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __updcolumn = x_int()
    __updcolumn.val = int(updcolumn)
    if __updcolumn.val!=updcolumn:
        raise ValueError("Error while converting 'updcolumn' parameter to 'x_int'")
    if not is_real_vector(u):
        raise ValueError("'u' parameter can't be cast to real_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__inva, inva, DT_REAL, X_CREATE)
        x_from_list(__u, u, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixinvupdatecolumn(ctypes.byref(_error_msg), ctypes.byref(__inva), ctypes.byref(__n), ctypes.byref(__updcolumn), ctypes.byref(__u))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixinvupdatecolumn'")
        __r__inva = listlist_from_x(__inva)
        return __r__inva
    finally:
        x_matrix_clear(__inva)
        x_vector_clear(__u)


_lib_alglib.alglib_rmatrixinvupdateuv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixinvupdateuv.restype = ctypes.c_int32
def rmatrixinvupdateuv(inva, n, u, v):
    pass
    if not is_real_matrix(inva):
        raise ValueError("'inva' parameter can't be cast to real_matrix")
    __inva = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(u):
        raise ValueError("'u' parameter can't be cast to real_vector")
    __u = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(v):
        raise ValueError("'v' parameter can't be cast to real_vector")
    __v = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__inva, inva, DT_REAL, X_CREATE)
        x_from_list(__u, u, DT_REAL, X_CREATE)
        x_from_list(__v, v, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixinvupdateuv(ctypes.byref(_error_msg), ctypes.byref(__inva), ctypes.byref(__n), ctypes.byref(__u), ctypes.byref(__v))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixinvupdateuv'")
        __r__inva = listlist_from_x(__inva)
        return __r__inva
    finally:
        x_matrix_clear(__inva)
        x_vector_clear(__u)
        x_vector_clear(__v)


_lib_alglib.alglib_rmatrixschur.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_rmatrixschur.restype = ctypes.c_int32
def rmatrixschur(a, n):
    pass
    __result = ctypes.c_uint8(0)
    if not is_real_matrix(a):
        raise ValueError("'a' parameter can't be cast to real_matrix")
    __a = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __s = x_matrix(rows=0,cols=0,stride=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_listlist(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_rmatrixschur(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'rmatrixschur'")
        __r__result = __result.value!=0
        __r__a = listlist_from_x(__a)
        __r__s = listlist_from_x(__s)
        return (__r__result, __r__a, __r__s)
    finally:
        x_matrix_clear(__a)
        x_matrix_clear(__s)


_lib_alglib.x_obj_free_minasastate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minasastate.restype = None
_lib_alglib.x_minasastate_get_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_get_needfg.restype = None
_lib_alglib.x_minasastate_set_needfg.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_set_needfg.restype = None
_lib_alglib.x_minasastate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_get_xupdated.restype = None
_lib_alglib.x_minasastate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_set_xupdated.restype = None
_lib_alglib.x_minasastate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_get_f.restype = None
_lib_alglib.x_minasastate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_set_f.restype = None
_lib_alglib.x_minasastate_get_g.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_get_g.restype = None
_lib_alglib.x_minasastate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minasastate_get_x.restype = None


class minasastate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minasastate(self.ptr)


class x_minasareport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfev", x_int),
        ("terminationtype", x_int),
        ("activeconstraints", x_int)
        ]




class minasareport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfev = 0
        self.terminationtype = 0
        self.activeconstraints = 0


def x_minasareport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfev.val = 0
    x.terminationtype.val = 0
    x.activeconstraints.val = 0
    return




def x_minasareport_clear(x):
    x_minasareport_zero_fields(x)
    return




def x_from_minasareport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfev.val = int(v.nfev)
    x.terminationtype.val = int(v.terminationtype)
    x.activeconstraints.val = int(v.activeconstraints)
    return




def minasareport_from_x(x):
    r = minasareport()
    r.iterationscount = x.iterationscount.val
    r.nfev = x.nfev.val
    r.terminationtype = x.terminationtype.val
    r.activeconstraints = x.activeconstraints.val
    return r


_lib_alglib.alglib_minlbfgssetdefaultpreconditioner.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetdefaultpreconditioner.restype = ctypes.c_int32
def minlbfgssetdefaultpreconditioner(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetdefaultpreconditioner(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetdefaultpreconditioner'")
        return
    finally:
        pass


_lib_alglib.alglib_minlbfgssetcholeskypreconditioner.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minlbfgssetcholeskypreconditioner.restype = ctypes.c_int32
def minlbfgssetcholeskypreconditioner(state, p, isupper):
    pass
    __state = state.ptr
    if not is_real_matrix(p):
        raise ValueError("'p' parameter can't be cast to real_matrix")
    __p = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    try:
        x_from_listlist(__p, p, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minlbfgssetcholeskypreconditioner(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__p), ctypes.byref(__isupper))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minlbfgssetcholeskypreconditioner'")
        return
    finally:
        x_matrix_clear(__p)


_lib_alglib.alglib_minbleicsetbarrierwidth.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetbarrierwidth.restype = ctypes.c_int32
def minbleicsetbarrierwidth(state, mu):
    pass
    __state = state.ptr
    __mu = ctypes.c_double(mu)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetbarrierwidth(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__mu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetbarrierwidth'")
        return
    finally:
        pass


_lib_alglib.alglib_minbleicsetbarrierdecay.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minbleicsetbarrierdecay.restype = ctypes.c_int32
def minbleicsetbarrierdecay(state, mudecay):
    pass
    __state = state.ptr
    __mudecay = ctypes.c_double(mudecay)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minbleicsetbarrierdecay(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__mudecay))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minbleicsetbarrierdecay'")
        return
    finally:
        pass


_lib_alglib.alglib_minasacreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasacreate.restype = ctypes.c_int32
def minasacreate(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        n,x,bndl,bndu = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        x,bndl,bndu = functionargs
        if safe_len("'minasacreate': incorrect parameters",x)!=safe_len("'minasacreate': incorrect parameters",bndl) or safe_len("'minasacreate': incorrect parameters",x)!=safe_len("'minasacreate': incorrect parameters",bndu):
            raise RuntimeError("Error while calling 'minasacreate': looks like one of arguments has wrong size")
        n = safe_len("'minasacreate': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minasacreate': function must have 3 or 4 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasacreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__bndl), ctypes.byref(__bndu), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasacreate'")
        __r__state = minasastate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.alglib_minasasetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasasetcond.restype = ctypes.c_int32
def minasasetcond(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasasetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasasetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_minasasetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasasetxrep.restype = ctypes.c_int32
def minasasetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasasetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasasetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_minasasetalgorithm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasasetalgorithm.restype = ctypes.c_int32
def minasasetalgorithm(state, algotype):
    pass
    __state = state.ptr
    __algotype = x_int()
    __algotype.val = int(algotype)
    if __algotype.val!=algotype:
        raise ValueError("Error while converting 'algotype' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasasetalgorithm(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__algotype))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasasetalgorithm'")
        return
    finally:
        pass


_lib_alglib.alglib_minasasetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasasetstpmax.restype = ctypes.c_int32
def minasasetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasasetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasasetstpmax'")
        return
    finally:
        pass




def minasaoptimize_g(state, grad, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minasastate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_g  = x_vector()
    _lib_alglib.x_minasastate_get_g(state.ptr, ctypes.byref(_xc_g))
    _py_g = create_real_vector(_xc_g.cnt)
    while True:
        retval = _lib_alglib.alglib_minasaiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasaiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minasastate_get_needfg(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = grad(_py_x, _py_g, param)
            _lib_alglib.x_minasastate_set_f(state.ptr, ctypes.byref(_xc_f))
            x_from_list(_xc_g, _py_g, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minasastate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minasastate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minasaoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_minasaresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasaresults.restype = ctypes.c_int32
def minasaresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minasareport()
    x_minasareport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasaresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasaresults'")
        __r__x = list_from_x(__x)
        __r__rep = minasareport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minasareport_clear(__rep)


_lib_alglib.alglib_minasaresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasaresultsbuf.restype = ctypes.c_int32
def minasaresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minasareport()
    x_minasareport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minasareport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasaresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasaresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minasareport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minasareport_clear(__rep)


_lib_alglib.alglib_minasarestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minasarestartfrom.restype = ctypes.c_int32
def minasarestartfrom(state, x, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minasarestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minasarestartfrom'")
        return
    finally:
        x_vector_clear(__x)
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.x_obj_free_minnlcstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minnlcstate.restype = None
_lib_alglib.x_minnlcstate_get_needfi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_needfi.restype = None
_lib_alglib.x_minnlcstate_set_needfi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_set_needfi.restype = None
_lib_alglib.x_minnlcstate_get_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_needfij.restype = None
_lib_alglib.x_minnlcstate_set_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_set_needfij.restype = None
_lib_alglib.x_minnlcstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_xupdated.restype = None
_lib_alglib.x_minnlcstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_set_xupdated.restype = None
_lib_alglib.x_minnlcstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_f.restype = None
_lib_alglib.x_minnlcstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_set_f.restype = None
_lib_alglib.x_minnlcstate_get_fi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_fi.restype = None
_lib_alglib.x_minnlcstate_get_j.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_j.restype = None
_lib_alglib.x_minnlcstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnlcstate_get_x.restype = None


class minnlcstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minnlcstate(self.ptr)


class x_minnlcreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfev", x_int),
        ("varidx", x_int),
        ("funcidx", x_int),
        ("terminationtype", x_int),
        ("dbgphase0its", x_int)
        ]




class minnlcreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfev = 0
        self.varidx = 0
        self.funcidx = 0
        self.terminationtype = 0
        self.dbgphase0its = 0


def x_minnlcreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfev.val = 0
    x.varidx.val = 0
    x.funcidx.val = 0
    x.terminationtype.val = 0
    x.dbgphase0its.val = 0
    return




def x_minnlcreport_clear(x):
    x_minnlcreport_zero_fields(x)
    return




def x_from_minnlcreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfev.val = int(v.nfev)
    x.varidx.val = int(v.varidx)
    x.funcidx.val = int(v.funcidx)
    x.terminationtype.val = int(v.terminationtype)
    x.dbgphase0its.val = int(v.dbgphase0its)
    return




def minnlcreport_from_x(x):
    r = minnlcreport()
    r.iterationscount = x.iterationscount.val
    r.nfev = x.nfev.val
    r.varidx = x.varidx.val
    r.funcidx = x.funcidx.val
    r.terminationtype = x.terminationtype.val
    r.dbgphase0its = x.dbgphase0its.val
    return r


_lib_alglib.alglib_minnlccreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlccreate.restype = ctypes.c_int32
def minnlccreate(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        n,x = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'minnlccreate': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minnlccreate': function must have 1 or 2 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlccreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlccreate'")
        __r__state = minnlcstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minnlccreatef.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlccreatef.restype = ctypes.c_int32
def minnlccreatef(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,x,diffstep = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,diffstep = functionargs
        n = safe_len("'minnlccreatef': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minnlccreatef': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlccreatef(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlccreatef'")
        __r__state = minnlcstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minnlcsetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetbc.restype = ctypes.c_int32
def minnlcsetbc(state, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetbc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetbc'")
        return
    finally:
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.alglib_minnlcsetlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetlc.restype = ctypes.c_int32
def minnlcsetlc(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        state,c,ct,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        state,c,ct = functionargs
        if safe_rows("'minnlcsetlc': incorrect parameters",c)!=safe_len("'minnlcsetlc': incorrect parameters",ct):
            raise RuntimeError("Error while calling 'minnlcsetlc': looks like one of arguments has wrong size")
        k = safe_rows("'minnlcsetlc': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'minnlcsetlc': function must have 3 or 4 parameters")
    __state = state.ptr
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(ct):
        raise ValueError("'ct' parameter can't be cast to int_vector")
    __ct = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        x_from_list(__ct, ct, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetlc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__c), ctypes.byref(__ct), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetlc'")
        return
    finally:
        x_matrix_clear(__c)
        x_vector_clear(__ct)


_lib_alglib.alglib_minnlcsetnlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetnlc.restype = ctypes.c_int32
def minnlcsetnlc(state, nlec, nlic):
    pass
    __state = state.ptr
    __nlec = x_int()
    __nlec.val = int(nlec)
    if __nlec.val!=nlec:
        raise ValueError("Error while converting 'nlec' parameter to 'x_int'")
    __nlic = x_int()
    __nlic.val = int(nlic)
    if __nlic.val!=nlic:
        raise ValueError("Error while converting 'nlic' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetnlc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__nlec), ctypes.byref(__nlic))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetnlc'")
        return
    finally:
        pass


_lib_alglib.alglib_minnlcsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetcond.restype = ctypes.c_int32
def minnlcsetcond(state, epsg, epsf, epsx, maxits):
    pass
    __state = state.ptr
    __epsg = ctypes.c_double(epsg)
    __epsf = ctypes.c_double(epsf)
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsg), ctypes.byref(__epsf), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_minnlcsetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetscale.restype = ctypes.c_int32
def minnlcsetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_minnlcsetprecinexact.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetprecinexact.restype = ctypes.c_int32
def minnlcsetprecinexact(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetprecinexact(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetprecinexact'")
        return
    finally:
        pass


_lib_alglib.alglib_minnlcsetprecexactlowrank.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetprecexactlowrank.restype = ctypes.c_int32
def minnlcsetprecexactlowrank(state, updatefreq):
    pass
    __state = state.ptr
    __updatefreq = x_int()
    __updatefreq.val = int(updatefreq)
    if __updatefreq.val!=updatefreq:
        raise ValueError("Error while converting 'updatefreq' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetprecexactlowrank(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__updatefreq))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetprecexactlowrank'")
        return
    finally:
        pass


_lib_alglib.alglib_minnlcsetprecnone.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetprecnone.restype = ctypes.c_int32
def minnlcsetprecnone(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetprecnone(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetprecnone'")
        return
    finally:
        pass


_lib_alglib.alglib_minnlcsetalgoaul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetalgoaul.restype = ctypes.c_int32
def minnlcsetalgoaul(state, rho, itscnt):
    pass
    __state = state.ptr
    __rho = ctypes.c_double(rho)
    __itscnt = x_int()
    __itscnt.val = int(itscnt)
    if __itscnt.val!=itscnt:
        raise ValueError("Error while converting 'itscnt' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetalgoaul(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__rho), ctypes.byref(__itscnt))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetalgoaul'")
        return
    finally:
        pass


_lib_alglib.alglib_minnlcsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetxrep.restype = ctypes.c_int32
def minnlcsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetxrep'")
        return
    finally:
        pass




def minnlcoptimize_v(state, fvec, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minnlcstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_fi  = x_vector()
    _lib_alglib.x_minnlcstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    while True:
        retval = _lib_alglib.alglib_minnlciteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlciteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minnlcstate_get_needfi(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            fvec(_py_x, _py_fi, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minnlcstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minnlcstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minnlcoptimize' (some derivatives were not provided?)")
    return


def minnlcoptimize_j(state, jac, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minnlcstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_fi  = x_vector()
    _lib_alglib.x_minnlcstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    _xc_j  = x_matrix()
    _lib_alglib.x_minnlcstate_get_j(state.ptr, ctypes.byref(_xc_j))
    _py_j = create_real_matrix(_xc_j.rows,_xc_j.cols)
    while True:
        retval = _lib_alglib.alglib_minnlciteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlciteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minnlcstate_get_needfij(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            jac(_py_x, _py_fi, _py_j, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_j, _py_j, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minnlcstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minnlcstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minnlcoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_minnlcresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcresults.restype = ctypes.c_int32
def minnlcresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minnlcreport()
    x_minnlcreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcresults'")
        __r__x = list_from_x(__x)
        __r__rep = minnlcreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minnlcreport_clear(__rep)


_lib_alglib.alglib_minnlcresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcresultsbuf.restype = ctypes.c_int32
def minnlcresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minnlcreport()
    x_minnlcreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minnlcreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minnlcreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minnlcreport_clear(__rep)


_lib_alglib.alglib_minnlcrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcrestartfrom.restype = ctypes.c_int32
def minnlcrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcrestartfrom'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minnlcsetgradientcheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnlcsetgradientcheck.restype = ctypes.c_int32
def minnlcsetgradientcheck(state, teststep):
    pass
    __state = state.ptr
    __teststep = ctypes.c_double(teststep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnlcsetgradientcheck(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__teststep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnlcsetgradientcheck'")
        return
    finally:
        pass


_lib_alglib.x_obj_free_minnsstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_minnsstate.restype = None
_lib_alglib.x_minnsstate_get_needfi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_needfi.restype = None
_lib_alglib.x_minnsstate_set_needfi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_set_needfi.restype = None
_lib_alglib.x_minnsstate_get_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_needfij.restype = None
_lib_alglib.x_minnsstate_set_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_set_needfij.restype = None
_lib_alglib.x_minnsstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_xupdated.restype = None
_lib_alglib.x_minnsstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_set_xupdated.restype = None
_lib_alglib.x_minnsstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_f.restype = None
_lib_alglib.x_minnsstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_set_f.restype = None
_lib_alglib.x_minnsstate_get_fi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_fi.restype = None
_lib_alglib.x_minnsstate_get_j.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_j.restype = None
_lib_alglib.x_minnsstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_minnsstate_get_x.restype = None


class minnsstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_minnsstate(self.ptr)


class x_minnsreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfev", x_int),
        ("cerr", ctypes.c_double),
        ("lcerr", ctypes.c_double),
        ("nlcerr", ctypes.c_double),
        ("terminationtype", x_int),
        ("varidx", x_int),
        ("funcidx", x_int)
        ]




class minnsreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfev = 0
        self.cerr = 0
        self.lcerr = 0
        self.nlcerr = 0
        self.terminationtype = 0
        self.varidx = 0
        self.funcidx = 0


def x_minnsreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfev.val = 0
    x.cerr = 0
    x.lcerr = 0
    x.nlcerr = 0
    x.terminationtype.val = 0
    x.varidx.val = 0
    x.funcidx.val = 0
    return




def x_minnsreport_clear(x):
    x_minnsreport_zero_fields(x)
    return




def x_from_minnsreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfev.val = int(v.nfev)
    x.cerr = float(v.cerr)
    x.lcerr = float(v.lcerr)
    x.nlcerr = float(v.nlcerr)
    x.terminationtype.val = int(v.terminationtype)
    x.varidx.val = int(v.varidx)
    x.funcidx.val = int(v.funcidx)
    return




def minnsreport_from_x(x):
    r = minnsreport()
    r.iterationscount = x.iterationscount.val
    r.nfev = x.nfev.val
    r.cerr = x.cerr
    r.lcerr = x.lcerr
    r.nlcerr = x.nlcerr
    r.terminationtype = x.terminationtype.val
    r.varidx = x.varidx.val
    r.funcidx = x.funcidx.val
    return r


_lib_alglib.alglib_minnscreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnscreate.restype = ctypes.c_int32
def minnscreate(*functionargs):
    if len(functionargs)==2:
        __friendly_form = False
        n,x = functionargs
    elif len(functionargs)==1:
        __friendly_form = True
        x, = functionargs
        n = safe_len("'minnscreate': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minnscreate': function must have 1 or 2 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnscreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnscreate'")
        __r__state = minnsstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minnscreatef.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnscreatef.restype = ctypes.c_int32
def minnscreatef(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,x,diffstep = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        x,diffstep = functionargs
        n = safe_len("'minnscreatef': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'minnscreatef': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __diffstep = ctypes.c_double(diffstep)
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnscreatef(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__diffstep), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnscreatef'")
        __r__state = minnsstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_minnssetbc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetbc.restype = ctypes.c_int32
def minnssetbc(state, bndl, bndu):
    pass
    __state = state.ptr
    if not is_real_vector(bndl):
        raise ValueError("'bndl' parameter can't be cast to real_vector")
    __bndl = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_real_vector(bndu):
        raise ValueError("'bndu' parameter can't be cast to real_vector")
    __bndu = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__bndl, bndl, DT_REAL, X_CREATE)
        x_from_list(__bndu, bndu, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetbc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__bndl), ctypes.byref(__bndu))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetbc'")
        return
    finally:
        x_vector_clear(__bndl)
        x_vector_clear(__bndu)


_lib_alglib.alglib_minnssetlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetlc.restype = ctypes.c_int32
def minnssetlc(*functionargs):
    if len(functionargs)==4:
        __friendly_form = False
        state,c,ct,k = functionargs
    elif len(functionargs)==3:
        __friendly_form = True
        state,c,ct = functionargs
        if safe_rows("'minnssetlc': incorrect parameters",c)!=safe_len("'minnssetlc': incorrect parameters",ct):
            raise RuntimeError("Error while calling 'minnssetlc': looks like one of arguments has wrong size")
        k = safe_rows("'minnssetlc': incorrect parameters",c)
    else:
        raise RuntimeError("Error while calling 'minnssetlc': function must have 3 or 4 parameters")
    __state = state.ptr
    if not is_real_matrix(c):
        raise ValueError("'c' parameter can't be cast to real_matrix")
    __c = x_matrix(rows=0,cols=0,stride=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    if not is_int_vector(ct):
        raise ValueError("'ct' parameter can't be cast to int_vector")
    __ct = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    try:
        x_from_listlist(__c, c, DT_REAL, X_CREATE)
        x_from_list(__ct, ct, DT_INT, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetlc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__c), ctypes.byref(__ct), ctypes.byref(__k))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetlc'")
        return
    finally:
        x_matrix_clear(__c)
        x_vector_clear(__ct)


_lib_alglib.alglib_minnssetnlc.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetnlc.restype = ctypes.c_int32
def minnssetnlc(state, nlec, nlic):
    pass
    __state = state.ptr
    __nlec = x_int()
    __nlec.val = int(nlec)
    if __nlec.val!=nlec:
        raise ValueError("Error while converting 'nlec' parameter to 'x_int'")
    __nlic = x_int()
    __nlic.val = int(nlic)
    if __nlic.val!=nlic:
        raise ValueError("Error while converting 'nlic' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetnlc(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__nlec), ctypes.byref(__nlic))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetnlc'")
        return
    finally:
        pass


_lib_alglib.alglib_minnssetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetcond.restype = ctypes.c_int32
def minnssetcond(state, epsx, maxits):
    pass
    __state = state.ptr
    __epsx = ctypes.c_double(epsx)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsx), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_minnssetscale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetscale.restype = ctypes.c_int32
def minnssetscale(state, s):
    pass
    __state = state.ptr
    if not is_real_vector(s):
        raise ValueError("'s' parameter can't be cast to real_vector")
    __s = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__s, s, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetscale(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetscale'")
        return
    finally:
        x_vector_clear(__s)


_lib_alglib.alglib_minnssetalgoags.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetalgoags.restype = ctypes.c_int32
def minnssetalgoags(state, radius, penalty):
    pass
    __state = state.ptr
    __radius = ctypes.c_double(radius)
    __penalty = ctypes.c_double(penalty)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetalgoags(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__radius), ctypes.byref(__penalty))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetalgoags'")
        return
    finally:
        pass


_lib_alglib.alglib_minnssetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnssetxrep.restype = ctypes.c_int32
def minnssetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnssetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnssetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_minnsrequesttermination.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnsrequesttermination.restype = ctypes.c_int32
def minnsrequesttermination(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnsrequesttermination(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnsrequesttermination'")
        return
    finally:
        pass




def minnsoptimize_v(state, fvec, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minnsstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_fi  = x_vector()
    _lib_alglib.x_minnsstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    while True:
        retval = _lib_alglib.alglib_minnsiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnsiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minnsstate_get_needfi(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            fvec(_py_x, _py_fi, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minnsstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minnsstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minnsoptimize' (some derivatives were not provided?)")
    return


def minnsoptimize_j(state, jac, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_minnsstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_fi  = x_vector()
    _lib_alglib.x_minnsstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    _xc_j  = x_matrix()
    _lib_alglib.x_minnsstate_get_j(state.ptr, ctypes.byref(_xc_j))
    _py_j = create_real_matrix(_xc_j.rows,_xc_j.cols)
    while True:
        retval = _lib_alglib.alglib_minnsiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnsiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_minnsstate_get_needfij(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            jac(_py_x, _py_fi, _py_j, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_j, _py_j, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_minnsstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_minnsstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'minnsoptimize' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_minnsresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnsresults.restype = ctypes.c_int32
def minnsresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minnsreport()
    x_minnsreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnsresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnsresults'")
        __r__x = list_from_x(__x)
        __r__rep = minnsreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minnsreport_clear(__rep)


_lib_alglib.alglib_minnsresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnsresultsbuf.restype = ctypes.c_int32
def minnsresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_minnsreport()
    x_minnsreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_minnsreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnsresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnsresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = minnsreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_minnsreport_clear(__rep)


_lib_alglib.alglib_minnsrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_minnsrestartfrom.restype = ctypes.c_int32
def minnsrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_minnsrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'minnsrestartfrom'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.x_obj_free_lincgstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_lincgstate.restype = None


class lincgstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_lincgstate(self.ptr)


class x_lincgreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nmv", x_int),
        ("terminationtype", x_int),
        ("r2", ctypes.c_double)
        ]




class lincgreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nmv = 0
        self.terminationtype = 0
        self.r2 = 0


def x_lincgreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nmv.val = 0
    x.terminationtype.val = 0
    x.r2 = 0
    return




def x_lincgreport_clear(x):
    x_lincgreport_zero_fields(x)
    return




def x_from_lincgreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nmv.val = int(v.nmv)
    x.terminationtype.val = int(v.terminationtype)
    x.r2 = float(v.r2)
    return




def lincgreport_from_x(x):
    r = lincgreport()
    r.iterationscount = x.iterationscount.val
    r.nmv = x.nmv.val
    r.terminationtype = x.terminationtype.val
    r.r2 = x.r2
    return r


_lib_alglib.alglib_lincgcreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgcreate.restype = ctypes.c_int32
def lincgcreate(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __state = ctypes.c_void_p(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgcreate(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgcreate'")
        __r__state = lincgstate(__state)
        return __r__state
    finally:
        pass


_lib_alglib.alglib_lincgsetstartingpoint.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetstartingpoint.restype = ctypes.c_int32
def lincgsetstartingpoint(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetstartingpoint(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetstartingpoint'")
        return
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_lincgsetprecunit.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetprecunit.restype = ctypes.c_int32
def lincgsetprecunit(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetprecunit(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetprecunit'")
        return
    finally:
        pass


_lib_alglib.alglib_lincgsetprecdiag.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetprecdiag.restype = ctypes.c_int32
def lincgsetprecdiag(state):
    pass
    __state = state.ptr
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetprecdiag(ctypes.byref(_error_msg), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetprecdiag'")
        return
    finally:
        pass


_lib_alglib.alglib_lincgsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetcond.restype = ctypes.c_int32
def lincgsetcond(state, epsf, maxits):
    pass
    __state = state.ptr
    __epsf = ctypes.c_double(epsf)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsf), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_lincgsolvesparse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsolvesparse.restype = ctypes.c_int32
def lincgsolvesparse(state, a, isupper, b):
    pass
    __state = state.ptr
    __a = a.ptr
    __isupper = ctypes.c_uint8(isupper)
    if __isupper.value!=0:
        __isupper = ctypes.c_uint8(1)
    if not is_real_vector(b):
        raise ValueError("'b' parameter can't be cast to real_vector")
    __b = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__b, b, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsolvesparse(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__a), ctypes.byref(__isupper), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsolvesparse'")
        return
    finally:
        x_vector_clear(__b)


_lib_alglib.alglib_lincgresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgresults.restype = ctypes.c_int32
def lincgresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_lincgreport()
    x_lincgreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgresults'")
        __r__x = list_from_x(__x)
        __r__rep = lincgreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_lincgreport_clear(__rep)


_lib_alglib.alglib_lincgsetrestartfreq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetrestartfreq.restype = ctypes.c_int32
def lincgsetrestartfreq(state, srf):
    pass
    __state = state.ptr
    __srf = x_int()
    __srf.val = int(srf)
    if __srf.val!=srf:
        raise ValueError("Error while converting 'srf' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetrestartfreq(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__srf))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetrestartfreq'")
        return
    finally:
        pass


_lib_alglib.alglib_lincgsetrupdatefreq.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetrupdatefreq.restype = ctypes.c_int32
def lincgsetrupdatefreq(state, freq):
    pass
    __state = state.ptr
    __freq = x_int()
    __freq.val = int(freq)
    if __freq.val!=freq:
        raise ValueError("Error while converting 'freq' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetrupdatefreq(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__freq))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetrupdatefreq'")
        return
    finally:
        pass


_lib_alglib.alglib_lincgsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_lincgsetxrep.restype = ctypes.c_int32
def lincgsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_lincgsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'lincgsetxrep'")
        return
    finally:
        pass


_lib_alglib.x_obj_free_nleqstate.argtypes = [ctypes.c_void_p]
_lib_alglib.x_obj_free_nleqstate.restype = None
_lib_alglib.x_nleqstate_get_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_needf.restype = None
_lib_alglib.x_nleqstate_set_needf.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_set_needf.restype = None
_lib_alglib.x_nleqstate_get_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_needfij.restype = None
_lib_alglib.x_nleqstate_set_needfij.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_set_needfij.restype = None
_lib_alglib.x_nleqstate_get_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_xupdated.restype = None
_lib_alglib.x_nleqstate_set_xupdated.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_set_xupdated.restype = None
_lib_alglib.x_nleqstate_get_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_f.restype = None
_lib_alglib.x_nleqstate_set_f.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_set_f.restype = None
_lib_alglib.x_nleqstate_get_fi.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_fi.restype = None
_lib_alglib.x_nleqstate_get_j.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_j.restype = None
_lib_alglib.x_nleqstate_get_x.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.x_nleqstate_get_x.restype = None


class nleqstate(object):
    def __init__(self,ptr):
        self.ptr = ptr
    def __del__(self):
        _lib_alglib.x_obj_free_nleqstate(self.ptr)


class x_nleqreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("iterationscount", x_int),
        ("nfunc", x_int),
        ("njac", x_int),
        ("terminationtype", x_int)
        ]




class nleqreport(object):
    def __init__(self):
        self.iterationscount = 0
        self.nfunc = 0
        self.njac = 0
        self.terminationtype = 0


def x_nleqreport_zero_fields(x):
    x.iterationscount.val = 0
    x.nfunc.val = 0
    x.njac.val = 0
    x.terminationtype.val = 0
    return




def x_nleqreport_clear(x):
    x_nleqreport_zero_fields(x)
    return




def x_from_nleqreport(x,v):
    x.iterationscount.val = int(v.iterationscount)
    x.nfunc.val = int(v.nfunc)
    x.njac.val = int(v.njac)
    x.terminationtype.val = int(v.terminationtype)
    return




def nleqreport_from_x(x):
    r = nleqreport()
    r.iterationscount = x.iterationscount.val
    r.nfunc = x.nfunc.val
    r.njac = x.njac.val
    r.terminationtype = x.terminationtype.val
    return r


_lib_alglib.alglib_nleqcreatelm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqcreatelm.restype = ctypes.c_int32
def nleqcreatelm(*functionargs):
    if len(functionargs)==3:
        __friendly_form = False
        n,m,x = functionargs
    elif len(functionargs)==2:
        __friendly_form = True
        m,x = functionargs
        n = safe_len("'nleqcreatelm': incorrect parameters",x)
    else:
        raise RuntimeError("Error while calling 'nleqcreatelm': function must have 2 or 3 parameters")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __state = ctypes.c_void_p(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqcreatelm(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__m), ctypes.byref(__x), ctypes.byref(__state))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqcreatelm'")
        __r__state = nleqstate(__state)
        return __r__state
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_nleqsetcond.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqsetcond.restype = ctypes.c_int32
def nleqsetcond(state, epsf, maxits):
    pass
    __state = state.ptr
    __epsf = ctypes.c_double(epsf)
    __maxits = x_int()
    __maxits.val = int(maxits)
    if __maxits.val!=maxits:
        raise ValueError("Error while converting 'maxits' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqsetcond(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__epsf), ctypes.byref(__maxits))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqsetcond'")
        return
    finally:
        pass


_lib_alglib.alglib_nleqsetxrep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqsetxrep.restype = ctypes.c_int32
def nleqsetxrep(state, needxrep):
    pass
    __state = state.ptr
    __needxrep = ctypes.c_uint8(needxrep)
    if __needxrep.value!=0:
        __needxrep = ctypes.c_uint8(1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqsetxrep(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__needxrep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqsetxrep'")
        return
    finally:
        pass


_lib_alglib.alglib_nleqsetstpmax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqsetstpmax.restype = ctypes.c_int32
def nleqsetstpmax(state, stpmax):
    pass
    __state = state.ptr
    __stpmax = ctypes.c_double(stpmax)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqsetstpmax(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__stpmax))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqsetstpmax'")
        return
    finally:
        pass




def nleqsolve_fj(state, func, jac, rep = None, param = None):
    _xc_result = ctypes.c_uint8(0)
    _xc_msg = ctypes.c_char_p()
    _xc_x  = x_vector()
    _lib_alglib.x_nleqstate_get_x(state.ptr, ctypes.byref(_xc_x))
    _py_x = create_real_vector(_xc_x.cnt)
    _xc_flag = ctypes.c_uint8()
    _xc_f = ctypes.c_double()
    _xc_fi  = x_vector()
    _lib_alglib.x_nleqstate_get_fi(state.ptr, ctypes.byref(_xc_fi))
    _py_fi = create_real_vector(_xc_fi.cnt)
    _xc_j  = x_matrix()
    _lib_alglib.x_nleqstate_get_j(state.ptr, ctypes.byref(_xc_j))
    _py_j = create_real_matrix(_xc_j.rows,_xc_j.cols)
    while True:
        retval = _lib_alglib.alglib_nleqiteration(ctypes.byref(_xc_msg), ctypes.byref(_xc_result), ctypes.byref(state.ptr))
        if retval!=0:
            if retval==X_ASSERTION_FAILED:
                raise RuntimeError(_xc_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqiteration'")
        if not _xc_result:
            break
        _lib_alglib.x_nleqstate_get_needf(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            _xc_f.value = func(_py_x, param)
            _lib_alglib.x_nleqstate_set_f(state.ptr, ctypes.byref(_xc_f))
            continue
        _lib_alglib.x_nleqstate_get_needfij(state.ptr, ctypes.byref(_xc_flag))
        if  _xc_flag.value!=0:
            copy_x_to_list(_xc_x, _py_x)

            jac(_py_x, _py_fi, _py_j, param)
            x_from_list(_xc_fi, _py_fi, DT_REAL, X_REWRITE)
            x_from_listlist(_xc_j, _py_j, DT_REAL, X_REWRITE)
            continue
        _lib_alglib.x_nleqstate_get_xupdated(state.ptr, ctypes.byref(_xc_flag))
        if _xc_flag.value!=0 :
            if not (rep is None):
                copy_x_to_list(_xc_x, _py_x)
                _lib_alglib.x_nleqstate_get_f(state.ptr, ctypes.byref(_xc_f))
                rep(_py_x, _xc_f.value, param)
            continue
        raise RuntimeError("ALGLIB: error in 'nleqsolve' (some derivatives were not provided?)")
    return


_lib_alglib.alglib_nleqresults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqresults.restype = ctypes.c_int32
def nleqresults(state):
    pass
    __state = state.ptr
    __x = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_nleqreport()
    x_nleqreport_zero_fields(__rep)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqresults(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqresults'")
        __r__x = list_from_x(__x)
        __r__rep = nleqreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_nleqreport_clear(__rep)


_lib_alglib.alglib_nleqresultsbuf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqresultsbuf.restype = ctypes.c_int32
def nleqresultsbuf(state, x, rep):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_nleqreport()
    x_nleqreport_zero_fields(__rep)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_nleqreport(__rep, rep)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqresultsbuf(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqresultsbuf'")
        __r__x = list_from_x(__x)
        __r__rep = nleqreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__x)
        x_nleqreport_clear(__rep)


_lib_alglib.alglib_nleqrestartfrom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_nleqrestartfrom.restype = ctypes.c_int32
def nleqrestartfrom(state, x):
    pass
    __state = state.ptr
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_nleqrestartfrom(ctypes.byref(_error_msg), ctypes.byref(__state), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'nleqrestartfrom'")
        return
    finally:
        x_vector_clear(__x)




class x_polynomialsolverreport(ctypes.Structure):
    _pack_ = 8
    _fields_ = [
        ("maxerr", ctypes.c_double)
        ]




class polynomialsolverreport(object):
    def __init__(self):
        self.maxerr = 0


def x_polynomialsolverreport_zero_fields(x):
    x.maxerr = 0
    return




def x_polynomialsolverreport_clear(x):
    x_polynomialsolverreport_zero_fields(x)
    return




def x_from_polynomialsolverreport(x,v):
    x.maxerr = float(v.maxerr)
    return




def polynomialsolverreport_from_x(x):
    r = polynomialsolverreport()
    r.maxerr = x.maxerr
    return r


_lib_alglib.alglib_polynomialsolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_polynomialsolve.restype = ctypes.c_int32
def polynomialsolve(a, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = x_vector(cnt=0,datatype=DT_COMPLEX,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __rep = x_polynomialsolverreport()
    x_polynomialsolverreport_zero_fields(__rep)
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_polynomialsolve(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__x), ctypes.byref(__rep))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'polynomialsolve'")
        __r__x = list_from_x(__x)
        __r__rep = polynomialsolverreport_from_x(__rep)
        return (__r__x, __r__rep)
    finally:
        x_vector_clear(__a)
        x_vector_clear(__x)
        x_polynomialsolverreport_clear(__rep)


_lib_alglib.alglib_airy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_airy.restype = ctypes.c_int32
def airy(x):
    pass
    __x = ctypes.c_double(x)
    __ai = ctypes.c_double(0)
    __aip = ctypes.c_double(0)
    __bi = ctypes.c_double(0)
    __bip = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_airy(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__ai), ctypes.byref(__aip), ctypes.byref(__bi), ctypes.byref(__bip))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'airy'")
        __r__ai = __ai.value
        __r__aip = __aip.value
        __r__bi = __bi.value
        __r__bip = __bip.value
        return (__r__ai, __r__aip, __r__bi, __r__bip)
    finally:
        pass


_lib_alglib.alglib_besselj0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besselj0.restype = ctypes.c_int32
def besselj0(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besselj0(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besselj0'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besselj1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besselj1.restype = ctypes.c_int32
def besselj1(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besselj1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besselj1'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besseljn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besseljn.restype = ctypes.c_int32
def besseljn(n, x):
    pass
    __result = ctypes.c_double(0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besseljn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besseljn'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_bessely0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_bessely0.restype = ctypes.c_int32
def bessely0(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_bessely0(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'bessely0'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_bessely1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_bessely1.restype = ctypes.c_int32
def bessely1(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_bessely1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'bessely1'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besselyn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besselyn.restype = ctypes.c_int32
def besselyn(n, x):
    pass
    __result = ctypes.c_double(0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besselyn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besselyn'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besseli0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besseli0.restype = ctypes.c_int32
def besseli0(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besseli0(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besseli0'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besseli1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besseli1.restype = ctypes.c_int32
def besseli1(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besseli1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besseli1'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besselk0.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besselk0.restype = ctypes.c_int32
def besselk0(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besselk0(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besselk0'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besselk1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besselk1.restype = ctypes.c_int32
def besselk1(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besselk1(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besselk1'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_besselkn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_besselkn.restype = ctypes.c_int32
def besselkn(nn, x):
    pass
    __result = ctypes.c_double(0)
    __nn = x_int()
    __nn.val = int(nn)
    if __nn.val!=nn:
        raise ValueError("Error while converting 'nn' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_besselkn(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__nn), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'besselkn'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_beta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_beta.restype = ctypes.c_int32
def beta(a, b):
    pass
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_beta(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'beta'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_incompletebeta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_incompletebeta.restype = ctypes.c_int32
def incompletebeta(a, b, x):
    pass
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_incompletebeta(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'incompletebeta'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invincompletebeta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invincompletebeta.restype = ctypes.c_int32
def invincompletebeta(a, b, y):
    pass
    __result = ctypes.c_double(0)
    __a = ctypes.c_double(a)
    __b = ctypes.c_double(b)
    __y = ctypes.c_double(y)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invincompletebeta(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invincompletebeta'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_binomialdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_binomialdistribution.restype = ctypes.c_int32
def binomialdistribution(k, n, p):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_double(p)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_binomialdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'binomialdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_binomialcdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_binomialcdistribution.restype = ctypes.c_int32
def binomialcdistribution(k, n, p):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_double(p)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_binomialcdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'binomialcdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invbinomialdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invbinomialdistribution.restype = ctypes.c_int32
def invbinomialdistribution(k, n, y):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __y = ctypes.c_double(y)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invbinomialdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__n), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invbinomialdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_chebyshevcalculate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_chebyshevcalculate.restype = ctypes.c_int32
def chebyshevcalculate(r, n, x):
    pass
    __result = ctypes.c_double(0)
    __r = x_int()
    __r.val = int(r)
    if __r.val!=r:
        raise ValueError("Error while converting 'r' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_chebyshevcalculate(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__r), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'chebyshevcalculate'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_chebyshevsum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_chebyshevsum.restype = ctypes.c_int32
def chebyshevsum(c, r, n, x):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __r = x_int()
    __r.val = int(r)
    if __r.val!=r:
        raise ValueError("Error while converting 'r' parameter to 'x_int'")
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_chebyshevsum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__r), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'chebyshevsum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_chebyshevcoefficients.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_chebyshevcoefficients.restype = ctypes.c_int32
def chebyshevcoefficients(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_chebyshevcoefficients(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'chebyshevcoefficients'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_fromchebyshev.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fromchebyshev.restype = ctypes.c_int32
def fromchebyshev(a, n):
    pass
    if not is_real_vector(a):
        raise ValueError("'a' parameter can't be cast to real_vector")
    __a = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __b = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        x_from_list(__a, a, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fromchebyshev(ctypes.byref(_error_msg), ctypes.byref(__a), ctypes.byref(__n), ctypes.byref(__b))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fromchebyshev'")
        __r__b = list_from_x(__b)
        return __r__b
    finally:
        x_vector_clear(__a)
        x_vector_clear(__b)


_lib_alglib.alglib_chisquaredistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_chisquaredistribution.restype = ctypes.c_int32
def chisquaredistribution(v, x):
    pass
    __result = ctypes.c_double(0)
    __v = ctypes.c_double(v)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_chisquaredistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__v), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'chisquaredistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_chisquarecdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_chisquarecdistribution.restype = ctypes.c_int32
def chisquarecdistribution(v, x):
    pass
    __result = ctypes.c_double(0)
    __v = ctypes.c_double(v)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_chisquarecdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__v), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'chisquarecdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invchisquaredistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invchisquaredistribution.restype = ctypes.c_int32
def invchisquaredistribution(v, y):
    pass
    __result = ctypes.c_double(0)
    __v = ctypes.c_double(v)
    __y = ctypes.c_double(y)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invchisquaredistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__v), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invchisquaredistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_dawsonintegral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_dawsonintegral.restype = ctypes.c_int32
def dawsonintegral(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_dawsonintegral(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'dawsonintegral'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_ellipticintegralk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_ellipticintegralk.restype = ctypes.c_int32
def ellipticintegralk(m):
    pass
    __result = ctypes.c_double(0)
    __m = ctypes.c_double(m)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_ellipticintegralk(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__m))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'ellipticintegralk'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_ellipticintegralkhighprecision.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_ellipticintegralkhighprecision.restype = ctypes.c_int32
def ellipticintegralkhighprecision(m1):
    pass
    __result = ctypes.c_double(0)
    __m1 = ctypes.c_double(m1)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_ellipticintegralkhighprecision(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__m1))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'ellipticintegralkhighprecision'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_incompleteellipticintegralk.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_incompleteellipticintegralk.restype = ctypes.c_int32
def incompleteellipticintegralk(phi, m):
    pass
    __result = ctypes.c_double(0)
    __phi = ctypes.c_double(phi)
    __m = ctypes.c_double(m)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_incompleteellipticintegralk(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__phi), ctypes.byref(__m))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'incompleteellipticintegralk'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_ellipticintegrale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_ellipticintegrale.restype = ctypes.c_int32
def ellipticintegrale(m):
    pass
    __result = ctypes.c_double(0)
    __m = ctypes.c_double(m)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_ellipticintegrale(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__m))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'ellipticintegrale'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_incompleteellipticintegrale.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_incompleteellipticintegrale.restype = ctypes.c_int32
def incompleteellipticintegrale(phi, m):
    pass
    __result = ctypes.c_double(0)
    __phi = ctypes.c_double(phi)
    __m = ctypes.c_double(m)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_incompleteellipticintegrale(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__phi), ctypes.byref(__m))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'incompleteellipticintegrale'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_exponentialintegralei.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_exponentialintegralei.restype = ctypes.c_int32
def exponentialintegralei(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_exponentialintegralei(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'exponentialintegralei'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_exponentialintegralen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_exponentialintegralen.restype = ctypes.c_int32
def exponentialintegralen(x, n):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_exponentialintegralen(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x), ctypes.byref(__n))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'exponentialintegralen'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_fdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fdistribution.restype = ctypes.c_int32
def fdistribution(a, b, x):
    pass
    __result = ctypes.c_double(0)
    __a = x_int()
    __a.val = int(a)
    if __a.val!=a:
        raise ValueError("Error while converting 'a' parameter to 'x_int'")
    __b = x_int()
    __b.val = int(b)
    if __b.val!=b:
        raise ValueError("Error while converting 'b' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_fcdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fcdistribution.restype = ctypes.c_int32
def fcdistribution(a, b, x):
    pass
    __result = ctypes.c_double(0)
    __a = x_int()
    __a.val = int(a)
    if __a.val!=a:
        raise ValueError("Error while converting 'a' parameter to 'x_int'")
    __b = x_int()
    __b.val = int(b)
    if __b.val!=b:
        raise ValueError("Error while converting 'b' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fcdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fcdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invfdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invfdistribution.restype = ctypes.c_int32
def invfdistribution(a, b, y):
    pass
    __result = ctypes.c_double(0)
    __a = x_int()
    __a.val = int(a)
    if __a.val!=a:
        raise ValueError("Error while converting 'a' parameter to 'x_int'")
    __b = x_int()
    __b.val = int(b)
    if __b.val!=b:
        raise ValueError("Error while converting 'b' parameter to 'x_int'")
    __y = ctypes.c_double(y)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invfdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__a), ctypes.byref(__b), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invfdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_fresnelintegral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_fresnelintegral.restype = ctypes.c_int32
def fresnelintegral(x, c, s):
    pass
    __x = ctypes.c_double(x)
    __c = ctypes.c_double(c)
    __s = ctypes.c_double(s)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_fresnelintegral(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__c), ctypes.byref(__s))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'fresnelintegral'")
        __r__c = __c.value
        __r__s = __s.value
        return (__r__c, __r__s)
    finally:
        pass


_lib_alglib.alglib_hermitecalculate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hermitecalculate.restype = ctypes.c_int32
def hermitecalculate(n, x):
    pass
    __result = ctypes.c_double(0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hermitecalculate(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hermitecalculate'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_hermitesum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hermitesum.restype = ctypes.c_int32
def hermitesum(c, n, x):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hermitesum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hermitesum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_hermitecoefficients.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hermitecoefficients.restype = ctypes.c_int32
def hermitecoefficients(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hermitecoefficients(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hermitecoefficients'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_jacobianellipticfunctions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_jacobianellipticfunctions.restype = ctypes.c_int32
def jacobianellipticfunctions(u, m):
    pass
    __u = ctypes.c_double(u)
    __m = ctypes.c_double(m)
    __sn = ctypes.c_double(0)
    __cn = ctypes.c_double(0)
    __dn = ctypes.c_double(0)
    __ph = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_jacobianellipticfunctions(ctypes.byref(_error_msg), ctypes.byref(__u), ctypes.byref(__m), ctypes.byref(__sn), ctypes.byref(__cn), ctypes.byref(__dn), ctypes.byref(__ph))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'jacobianellipticfunctions'")
        __r__sn = __sn.value
        __r__cn = __cn.value
        __r__dn = __dn.value
        __r__ph = __ph.value
        return (__r__sn, __r__cn, __r__dn, __r__ph)
    finally:
        pass


_lib_alglib.alglib_laguerrecalculate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_laguerrecalculate.restype = ctypes.c_int32
def laguerrecalculate(n, x):
    pass
    __result = ctypes.c_double(0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_laguerrecalculate(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'laguerrecalculate'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_laguerresum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_laguerresum.restype = ctypes.c_int32
def laguerresum(c, n, x):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_laguerresum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'laguerresum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_laguerrecoefficients.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_laguerrecoefficients.restype = ctypes.c_int32
def laguerrecoefficients(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_laguerrecoefficients(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'laguerrecoefficients'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_legendrecalculate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_legendrecalculate.restype = ctypes.c_int32
def legendrecalculate(n, x):
    pass
    __result = ctypes.c_double(0)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_legendrecalculate(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'legendrecalculate'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_legendresum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_legendresum.restype = ctypes.c_int32
def legendresum(c, n, x):
    pass
    __result = ctypes.c_double(0)
    if not is_real_vector(c):
        raise ValueError("'c' parameter can't be cast to real_vector")
    __c = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __x = ctypes.c_double(x)
    try:
        x_from_list(__c, c, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_legendresum(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__c), ctypes.byref(__n), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'legendresum'")
        __r__result = __result.value
        return __r__result
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_legendrecoefficients.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_legendrecoefficients.restype = ctypes.c_int32
def legendrecoefficients(n):
    pass
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __c = x_vector(cnt=0,datatype=DT_REAL,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_legendrecoefficients(ctypes.byref(_error_msg), ctypes.byref(__n), ctypes.byref(__c))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'legendrecoefficients'")
        __r__c = list_from_x(__c)
        return __r__c
    finally:
        x_vector_clear(__c)


_lib_alglib.alglib_poissondistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_poissondistribution.restype = ctypes.c_int32
def poissondistribution(k, m):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = ctypes.c_double(m)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_poissondistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__m))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'poissondistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_poissoncdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_poissoncdistribution.restype = ctypes.c_int32
def poissoncdistribution(k, m):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __m = ctypes.c_double(m)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_poissoncdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__m))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'poissoncdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invpoissondistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invpoissondistribution.restype = ctypes.c_int32
def invpoissondistribution(k, y):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __y = ctypes.c_double(y)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invpoissondistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__y))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invpoissondistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_psi.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_psi.restype = ctypes.c_int32
def psi(x):
    pass
    __result = ctypes.c_double(0)
    __x = ctypes.c_double(x)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_psi(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__x))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'psi'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_studenttdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_studenttdistribution.restype = ctypes.c_int32
def studenttdistribution(k, t):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __t = ctypes.c_double(t)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_studenttdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__t))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'studenttdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_invstudenttdistribution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_invstudenttdistribution.restype = ctypes.c_int32
def invstudenttdistribution(k, p):
    pass
    __result = ctypes.c_double(0)
    __k = x_int()
    __k.val = int(k)
    if __k.val!=k:
        raise ValueError("Error while converting 'k' parameter to 'x_int'")
    __p = ctypes.c_double(p)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_invstudenttdistribution(ctypes.byref(_error_msg), ctypes.byref(__result), ctypes.byref(__k), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'invstudenttdistribution'")
        __r__result = __result.value
        return __r__result
    finally:
        pass


_lib_alglib.alglib_sinecosineintegrals.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_sinecosineintegrals.restype = ctypes.c_int32
def sinecosineintegrals(x):
    pass
    __x = ctypes.c_double(x)
    __si = ctypes.c_double(0)
    __ci = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_sinecosineintegrals(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__si), ctypes.byref(__ci))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'sinecosineintegrals'")
        __r__si = __si.value
        __r__ci = __ci.value
        return (__r__si, __r__ci)
    finally:
        pass


_lib_alglib.alglib_hyperbolicsinecosineintegrals.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_hyperbolicsinecosineintegrals.restype = ctypes.c_int32
def hyperbolicsinecosineintegrals(x):
    pass
    __x = ctypes.c_double(x)
    __shi = ctypes.c_double(0)
    __chi = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_hyperbolicsinecosineintegrals(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__shi), ctypes.byref(__chi))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'hyperbolicsinecosineintegrals'")
        __r__shi = __shi.value
        __r__chi = __chi.value
        return (__r__shi, __r__chi)
    finally:
        pass


_lib_alglib.alglib_pearsoncorrelationsignificance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_pearsoncorrelationsignificance.restype = ctypes.c_int32
def pearsoncorrelationsignificance(r, n):
    pass
    __r = ctypes.c_double(r)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_pearsoncorrelationsignificance(ctypes.byref(_error_msg), ctypes.byref(__r), ctypes.byref(__n), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'pearsoncorrelationsignificance'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        pass


_lib_alglib.alglib_spearmanrankcorrelationsignificance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_spearmanrankcorrelationsignificance.restype = ctypes.c_int32
def spearmanrankcorrelationsignificance(r, n):
    pass
    __r = ctypes.c_double(r)
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        pass
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_spearmanrankcorrelationsignificance(ctypes.byref(_error_msg), ctypes.byref(__r), ctypes.byref(__n), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'spearmanrankcorrelationsignificance'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        pass


_lib_alglib.alglib_jarqueberatest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_jarqueberatest.restype = ctypes.c_int32
def jarqueberatest(x, n):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __p = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_jarqueberatest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__p))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'jarqueberatest'")
        __r__p = __p.value
        return __r__p
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_mannwhitneyutest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_mannwhitneyutest.restype = ctypes.c_int32
def mannwhitneyutest(x, n, y, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_mannwhitneyutest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'mannwhitneyutest'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_onesamplesigntest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_onesamplesigntest.restype = ctypes.c_int32
def onesamplesigntest(x, n, median):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __median = ctypes.c_double(median)
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_onesamplesigntest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__median), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'onesamplesigntest'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_studentttest1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_studentttest1.restype = ctypes.c_int32
def studentttest1(x, n, mean):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __mean = ctypes.c_double(mean)
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_studentttest1(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__mean), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'studentttest1'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_studentttest2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_studentttest2.restype = ctypes.c_int32
def studentttest2(x, n, y, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_studentttest2(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'studentttest2'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_unequalvariancettest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_unequalvariancettest.restype = ctypes.c_int32
def unequalvariancettest(x, n, y, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_unequalvariancettest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'unequalvariancettest'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_ftest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_ftest.restype = ctypes.c_int32
def ftest(x, n, y, m):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    if not is_real_vector(y):
        raise ValueError("'y' parameter can't be cast to real_vector")
    __y = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __m = x_int()
    __m.val = int(m)
    if __m.val!=m:
        raise ValueError("Error while converting 'm' parameter to 'x_int'")
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        x_from_list(__y, y, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_ftest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__y), ctypes.byref(__m), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'ftest'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)
        x_vector_clear(__y)


_lib_alglib.alglib_onesamplevariancetest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_onesamplevariancetest.restype = ctypes.c_int32
def onesamplevariancetest(x, n, variance):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __variance = ctypes.c_double(variance)
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_onesamplevariancetest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__variance), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'onesamplevariancetest'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)


_lib_alglib.alglib_wilcoxonsignedranktest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
_lib_alglib.alglib_wilcoxonsignedranktest.restype = ctypes.c_int32
def wilcoxonsignedranktest(x, n, e):
    pass
    if not is_real_vector(x):
        raise ValueError("'x' parameter can't be cast to real_vector")
    __x = x_vector(cnt=0,datatype=0,owner=OWN_CALLER,last_action=0,ptr=x_multiptr(p_ptr=0))
    __n = x_int()
    __n.val = int(n)
    if __n.val!=n:
        raise ValueError("Error while converting 'n' parameter to 'x_int'")
    __e = ctypes.c_double(e)
    __bothtails = ctypes.c_double(0)
    __lefttail = ctypes.c_double(0)
    __righttail = ctypes.c_double(0)
    try:
        x_from_list(__x, x, DT_REAL, X_CREATE)
        _error_msg = ctypes.c_char_p(0)
        __x__retval =  _lib_alglib.alglib_wilcoxonsignedranktest(ctypes.byref(_error_msg), ctypes.byref(__x), ctypes.byref(__n), ctypes.byref(__e), ctypes.byref(__bothtails), ctypes.byref(__lefttail), ctypes.byref(__righttail))
        if __x__retval!=0:
            if __x__retval==X_ASSERTION_FAILED:
                raise RuntimeError(_error_msg.value)
            else:
                raise RuntimeError("Error while calling 'wilcoxonsignedranktest'")
        __r__bothtails = __bothtails.value
        __r__lefttail = __lefttail.value
        __r__righttail = __righttail.value
        return (__r__bothtails, __r__lefttail, __r__righttail)
    finally:
        x_vector_clear(__x)


