// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.

//-----------------------------------------------------------
//
// player.cpp
//
//   Implementation of Player class. The dialog window calls
//   the Player methods to configure endpoint audio devices
//   and play wave streams.
//
//-----------------------------------------------------------

#define INITGUID

#include <assert.h>
#include <propidl.h>
#include <functiondiscoverykeys.h>
#include "player.h"


#define EXIT_ON_ERROR(hres)  \
              if (FAILED(hres)) { goto Exit; }

#define SAFE_RELEASE(punk)  \
              if ((punk) != NULL)  \
                { (punk)->Release(); (punk) = NULL; }


// Event context GUID (generated by uuidgen.exe)
// { E6FAC30B-2E3D-484B-ACDA-7146DB4849C0 }
GUID g_EventContext =
{
    0XE6FAC30B,
    0X2E3D,
    0X484B,
    { 0XAC, 0XDA, 0X71, 0X46, 0XDB, 0X48, 0X49, 0XC0 }
};


//
// Local implementation of IAudioSessionEvents interface.
// WASAPI calls these methods to notify the Player when
// an audio session control or parameter changes.
//
class CAudioSessionEvents : public IAudioSessionEvents
{
    Player *m_pPlayer;
    HANDLE m_hDlg;
    EDataFlow m_dataFlow;
    LONG m_cRef;

public:
    CAudioSessionEvents(Player *pPlayer, HANDLE hDlg, EDataFlow dir)
    {
        assert(pPlayer != NULL);
        assert(hDlg != NULL);
        assert(dir == eRender || dir == eCapture);

        m_hDlg = hDlg;
        m_pPlayer = pPlayer;
        m_dataFlow = dir;
        m_cRef = 1;
    };

    ~CAudioSessionEvents() {};

    ULONG __stdcall AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    };

    ULONG __stdcall Release()
    {
        DWORD dwRef = InterlockedDecrement(&m_cRef);
        if (dwRef == 0)
        {
            delete this;
        }
        return dwRef;
    };

    HRESULT __stdcall QueryInterface(REFIID iid, VOID **pRetVal)
    {
        if (IID_IUnknown == iid)
        {
            AddRef();
            *pRetVal = (IUnknown*)this;
        }
        else if (__uuidof(IAudioSessionEvents) == iid)
        {
            AddRef();
            *pRetVal = (IAudioSessionEvents*)this;
        }
        else
        {
            *pRetVal = NULL;
            return(E_NOINTERFACE);
        }
        return(S_OK);
    };

    HRESULT __stdcall OnDisplayNameChanged(LPCWSTR NewDisplayName, LPCGUID EventContext)
    {
        return S_OK;
    };

    HRESULT __stdcall OnIconPathChanged(LPCWSTR NewIconPath, LPCGUID EventContext)
    {
        return S_OK;
    };

    HRESULT __stdcall OnSimpleVolumeChanged(float NewVolume, BOOL NewMute,
                                            LPCGUID EventContext)
    {
        if (m_dataFlow == eRender && m_pPlayer->m_pPlayerCallbacks != NULL &&
            memcmp(EventContext, &g_EventContext, sizeof(g_EventContext)) != 0)
        {
            m_pPlayer->m_pPlayerCallbacks->VolumeChangeCallback(NewVolume, NewMute);
        }
        return S_OK;
    };

    HRESULT __stdcall OnChannelVolumeChanged(DWORD ChannelCount,
                                             float NewChannelVolumeArray[],
                                             DWORD ChangedChannel,
                                             LPCGUID EventContext)
    {
        return S_OK;
    };

    HRESULT __stdcall OnGroupingParamChanged(LPCGUID NewGroupingParam,
                                             LPCGUID EventContext)
    {
        return S_OK;
    };

    HRESULT __stdcall OnStateChanged(AudioSessionState NewState)
    {
        return S_OK;
    };

    HRESULT __stdcall OnSessionDisconnected(AudioSessionDisconnectReason DisconnectReason)
    {
        if (m_pPlayer->m_pPlayerCallbacks != NULL)
        {
            if (m_dataFlow == eRender)
            {
                m_pPlayer->m_pPlayerCallbacks->RenderDisconnectCallback();
            }
            else
            {
                m_pPlayer->m_pPlayerCallbacks->CaptureDisconnectCallback();
            }
        }
        return S_OK;
    };
};

//
// Implementation of Player methods
//

Player::Player(HWND hDlg)
{
    assert(hDlg != NULL);

    m_hDlg = hDlg;
    m_ExclusiveMode = FALSE;
    m_RepeatMode = FALSE;
    m_audioSourceType = eNullSource;
    m_hThread = NULL;
    m_keepPlaying = FALSE;
    m_pRenderCollection = NULL;
    m_pCaptureCollection = NULL;
    m_pDeviceOut = NULL;
    m_pDeviceIn = NULL;
    m_pClientOut = NULL;
    m_pClientIn = NULL;
    m_pEventContext = &g_EventContext;
    m_pRenderSessionControl = NULL;
    m_pCaptureSessionControl = NULL;
    m_pRenderSessionEvents = new CAudioSessionEvents(this, hDlg, eRender);
    m_pCaptureSessionEvents = new CAudioSessionEvents(this, hDlg, eCapture);
    m_szFileName[0] = L'\0';

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CoCreateInstance(__uuidof(MMDeviceEnumerator), NULL,
                     CLSCTX_ALL, __uuidof(IMMDeviceEnumerator),
                     (void**)&m_pEnumerator);
}

Player::~Player()
{
    if (m_pRenderSessionControl != NULL)
    {
        m_pRenderSessionControl->UnregisterAudioSessionNotification(m_pRenderSessionEvents);
    }
    SAFE_RELEASE(m_pRenderSessionControl);
    if (m_pCaptureSessionControl != NULL)
    {
        m_pCaptureSessionControl->UnregisterAudioSessionNotification(m_pCaptureSessionEvents);
    }
    SAFE_RELEASE(m_pCaptureSessionControl);

    SAFE_RELEASE(m_pClientOut);
    SAFE_RELEASE(m_pClientIn);
    SAFE_RELEASE(m_pRenderCollection);
    SAFE_RELEASE(m_pCaptureCollection);
    SAFE_RELEASE(m_pDeviceOut);
    SAFE_RELEASE(m_pDeviceIn);
    SAFE_RELEASE(m_pEnumerator);
}

// Private method
void Player::_GetDeviceName(IMMDevice *pDevice, LPWSTR pszBuffer, int bufferLen)
{
    static const WCHAR szDefault[] = L"<Device not available>";

    HRESULT hr = E_FAIL;
    IPropertyStore *pProps = NULL;
    PROPVARIANT varName;

    // Initialize container for property value.
    PropVariantInit(&varName);

    assert(pszBuffer != NULL);
    assert(bufferLen > 0);

    if (pDevice != NULL)
    {
        hr = pDevice->OpenPropertyStore(STGM_READ, &pProps);
        if (hr == S_OK)
        {
            // Get the endpoint device's friendly-name property.
            hr = pProps->GetValue(PKEY_Device_FriendlyName, &varName);
        }
    }

    if (hr == S_OK)
    {
        // Found the device name.
        wcsncpy_s(pszBuffer, bufferLen, varName.pwszVal, _TRUNCATE);
    }
    else
    {
        // Failed to find the device name.
        wcsncpy_s(pszBuffer, bufferLen, szDefault, _TRUNCATE);
    }

    PropVariantClear(&varName);
    SAFE_RELEASE(pProps);

    return;
}

// Private method
void Player::_RegisterNotificationCallbacks(IMMDevice *pDevice, EDataFlow dir)
{
    HRESULT hr = S_OK;
    IAudioSessionManager *pManager = NULL;
    ISimpleAudioVolume *pVolume = NULL;
    float volume = 0.0;
    BOOL mute = FALSE;

    assert(dir == eRender || dir == eCapture);

    if (pDevice == NULL)
    {
        return;
    }
    hr = pDevice->Activate(__uuidof(IAudioSessionManager), CLSCTX_ALL,
                           NULL, (void**)&pManager);
    EXIT_ON_ERROR(hr)

    if (dir == eRender)
    {
        if (m_pRenderSessionControl != NULL)
        {
            // Ignore return error if notification interface not previously registered.
            m_pRenderSessionControl->UnregisterAudioSessionNotification(m_pRenderSessionEvents);
        }
        SAFE_RELEASE(m_pRenderSessionControl);
        hr = pManager->GetAudioSessionControl(NULL, FALSE, &m_pRenderSessionControl);
        EXIT_ON_ERROR(hr)

        hr = m_pRenderSessionControl->RegisterAudioSessionNotification(m_pRenderSessionEvents);
        EXIT_ON_ERROR(hr)

        hr = pManager->GetSimpleAudioVolume(NULL, FALSE, &pVolume);
        EXIT_ON_ERROR(hr)

        hr = pVolume->GetMasterVolume(&volume);
        EXIT_ON_ERROR(hr)

        hr = pVolume->GetMute(&mute);
        EXIT_ON_ERROR(hr)

        // Call the client's volume-change notification method to initialize
        // the volume and mute settings that appear in the user interface.
        m_pRenderSessionEvents->OnSimpleVolumeChanged(volume, mute, &GUID_NULL);
    }
    else  // dir == eCapture
    {
        if (m_pCaptureSessionControl != NULL)
        {
            // Ignore return error if notification interface not previously registered.
            m_pCaptureSessionControl->UnregisterAudioSessionNotification(m_pCaptureSessionEvents);
        }
        SAFE_RELEASE(m_pCaptureSessionControl);
        hr = pManager->GetAudioSessionControl(NULL, FALSE, &m_pCaptureSessionControl);
        EXIT_ON_ERROR(hr)

        hr = m_pCaptureSessionControl->RegisterAudioSessionNotification(m_pCaptureSessionEvents);
        EXIT_ON_ERROR(hr)
    }

Exit:
    SAFE_RELEASE(pManager);
    SAFE_RELEASE(pVolume);
}

//
// Public method
//   Creates a new list of endpoint rendering or capture
//   devices after deleting any previously created (and
//   possibly out-of-date) list of such devices. Parameter
//   dir specifies whether the list contains rendering or
//   capture devices.
//
void Player::RefreshDeviceList(EDataFlow dir)
{
    HRESULT hr = S_OK;
    IMMDeviceCollection *pCollection = NULL;

    assert(dir == eRender || dir == eCapture);

    hr = m_pEnumerator->EnumAudioEndpoints(dir, DEVICE_STATE_ACTIVE,
                                           &pCollection);
    assert(hr == S_OK);

    if (dir == eRender)
    {
        SAFE_RELEASE(m_pRenderCollection);
        m_pRenderCollection = pCollection;
    }
    else
    {
        SAFE_RELEASE(m_pCaptureCollection);
        m_pCaptureCollection = pCollection;
    }
}

//
// Public method
//   Gets a count of the endpoint rendering or capture
//   devices in the current list of such devices.
//
int Player::GetDeviceListCount(EDataFlow dir)
{
    HRESULT hr = S_OK;
    UINT count = 0;

    assert(dir == eRender || dir == eCapture);

    if (dir == eRender && m_pRenderCollection != NULL)
    {
        hr = m_pRenderCollection->GetCount(&count);
    }
    else if (m_pCaptureCollection != NULL)
    {
        hr = m_pCaptureCollection->GetCount(&count);
    }
    assert(hr == S_OK);
    return count;
}

//
// Public method
//   Gets the friendly name of an endpoint rendering or capture
//   device from the current list of such devices. The caller
//   uses an index into the list to identify the device.
//
void Player::GetListDeviceName(EDataFlow dir, int index,
                               LPWSTR szBuffer, int bufferLen)
{
    HRESULT hr = S_OK;
    IMMDevice *pDevice = NULL;

    assert(dir == eRender || dir == eCapture);

    if (dir == eRender && m_pRenderCollection != NULL)
    {
        hr = m_pRenderCollection->Item(index, &pDevice);
    }
    else if (m_pCaptureCollection != NULL)
    {
        hr = m_pCaptureCollection->Item(index, &pDevice);
    }
    assert(hr == S_OK);

    _GetDeviceName(pDevice, szBuffer, bufferLen);
    SAFE_RELEASE(pDevice);
}

//
// Public method
//   Selects an endpoint rendering or capture device from
//   the current list of such devices. The caller uses
//   an index into the list to identify the device.
//
BOOL Player::SelectDeviceFromList(EDataFlow dir, int index)
{
    HRESULT hr = S_OK;

    assert(dir == eRender || dir == eCapture);

    if (dir == eRender)
    {
        SAFE_RELEASE(m_pDeviceOut);
        hr = m_pRenderCollection->Item(index, &m_pDeviceOut);
        if (hr == S_OK)
        {
            _RegisterNotificationCallbacks(m_pDeviceOut, eRender);
        }
    }
    else
    {
        SAFE_RELEASE(m_pDeviceIn);
        hr = m_pCaptureCollection->Item(index, &m_pDeviceIn);
        if (hr == S_OK)
        {
            _RegisterNotificationCallbacks(m_pDeviceIn, eCapture);
        }
    }
    if (hr != S_OK)
    {
        return FALSE;
    }
    return TRUE;
}

//
// Public method
//   Selects an endpoint rendering or capture device based on
//   its assigned device role.
//
BOOL Player::SelectDefaultDevice(EDataFlow dir, ERole role)
{
    HRESULT hr = S_OK;

    assert(dir == eRender || dir == eCapture);

    if (dir == eRender)
    {
        SAFE_RELEASE(m_pDeviceOut);
        hr = m_pEnumerator->GetDefaultAudioEndpoint(dir, role, &m_pDeviceOut);
        if (hr == S_OK)
        {
            _RegisterNotificationCallbacks(m_pDeviceOut, eRender);
        }
    }
    else
    {
        SAFE_RELEASE(m_pDeviceIn);
        hr = m_pEnumerator->GetDefaultAudioEndpoint(dir, role, &m_pDeviceIn);
        if (hr == S_OK)
        {
            _RegisterNotificationCallbacks(m_pDeviceIn, eCapture);
        }
    }
    assert(hr == S_OK || hr == E_NOTFOUND);

    if (hr != S_OK)
    {
        return FALSE;
    }
    return TRUE;
}

//
// Public method
//   Gets the friendly name of the currently selected endpoint rendering
//   or capture device.
//
void Player::GetSelectedDeviceName(EDataFlow dir, LPWSTR szBuffer, int bufferLen)
{
    assert(dir == eRender || dir == eCapture);

    if (dir == eRender)
    {
        _GetDeviceName(m_pDeviceOut, szBuffer, bufferLen);
    }
    else
    {
        _GetDeviceName(m_pDeviceIn, szBuffer, bufferLen);
    }
}

//
// Public method
//   Specifies the name of a wave file to use as the audio source.
//
void Player::SetWaveFile(WCHAR *pszFileName)
{
    assert(pszFileName != NULL);
    assert(pszFileName[0] != L""[0]);

    wcsncpy_s(m_szFileName, _countof(m_szFileName), pszFileName, _TRUNCATE);
}

//
// Public method
//   Plays the stream from the specified audio source, which can be
//   either a tone generator or a wave file.
//
BOOL Player::Play(EAudioSourceType type)
{
    HRESULT hr = S_OK;
    PTHREAD_START_ROUTINE pPlayerThread = NULL;

    if (m_keepPlaying == TRUE || m_hThread != NULL)
    {
        return FALSE;  // Audio is already playing
    }
    if (m_pDeviceOut == NULL)
    {
        return FALSE;  // No rendering device
    }

    // The playback thread always releases m_pClientIn
    // and m_pClientOut before it exits.
    assert(m_pClientOut == NULL);
    assert(m_pClientIn == NULL);

    hr = m_pDeviceOut->Activate(__uuidof(IAudioClient), CLSCTX_ALL,
                                NULL, (void**)&m_pClientOut);
    if (hr != S_OK)
    {
        return FALSE;
    }

    // Determine which audio source the user selected.
    switch (type)
    {
    case eToneGenerator:
        pPlayerThread = PlayWaveStream;
        break;
    case eWaveFile:
        if (m_szFileName[0] == L""[0])
        {
            SAFE_RELEASE(m_pClientOut);
            return FALSE;  // No file name
        }
        pPlayerThread = PlayWaveStream;
        break;
    case eCaptureEndpoint:
        if (m_pDeviceIn == NULL)
        {
            SAFE_RELEASE(m_pClientOut);
            return FALSE;  // No capture device
        }
        SAFE_RELEASE(m_pClientIn);
        hr = m_pDeviceIn->Activate(__uuidof(IAudioClient), CLSCTX_ALL,
                                   NULL, (void**)&m_pClientIn);
        if (hr != S_OK)
        {
            SAFE_RELEASE(m_pClientOut);
            return FALSE;  // No capture client
        }
        pPlayerThread = PlayCaptureStream;
        break;
    default:
        assert(0);
    }

    m_audioSourceType = type;

    // The thread will exit when Stop() sets this variable to FALSE.
    m_keepPlaying = TRUE;

    // Play the stream from the audio source.
    m_hThread = CreateThread(NULL, 0, pPlayerThread, this, 0, NULL);
    if (m_hThread == NULL)
    {
        return FALSE;  // failed to create thread
    }

    return TRUE;
}

//
// Public method
//   Stops playing the stream. The method returns TRUE if it
//   succeeds in stopping the stream; otherwise, it returns FALSE.
//
BOOL Player::Stop()
{
    if (m_hThread == NULL)
    {
        return TRUE;  // Stream is already halted.
    }

    m_keepPlaying = FALSE;  // This value will stop the thread.

    DWORD retval = WaitForSingleObject(m_hThread, 2000);
    if (retval != WAIT_OBJECT_0)
    {
        return FALSE;  // failed to stop thread
    }

    // The thread releases m_pClientIn/Out.
    assert(m_pClientOut == NULL);
    assert(m_pClientIn == NULL);

    CloseHandle(m_hThread);
    m_hThread = NULL;
    return TRUE;  // succeeded in stopping thread
}

//
// Public method
//   Sets the volume level of the default audio session
//   of the currently selected endpoint rendering device.
//
void Player::SetVolume(float fVolume)
{
    HRESULT hr;
    IAudioSessionManager *pSessionMgr = NULL;
    ISimpleAudioVolume *pSimpleVol = NULL;

    if (m_pDeviceOut == NULL)
    {
        return;
    }

    hr = m_pDeviceOut->Activate(__uuidof(IAudioSessionManager),
                                CLSCTX_ALL, NULL, (void**)&pSessionMgr);
    // check hr
    hr = pSessionMgr->GetSimpleAudioVolume(NULL, FALSE, &pSimpleVol);
    // check hr
    hr = pSimpleVol->SetMasterVolume(fVolume, m_pEventContext);
    // check hr
    SAFE_RELEASE(pSessionMgr);
    SAFE_RELEASE(pSimpleVol);
}

//
// Public method
//   Sets the callbacks from the Player to the client.
//   The client implements the callback methods. The
//   Player calls the methods to notify the client when
//   certain Player events occur.
//
void Player::SetPlayerCallbacks(PlayerCallbacks *pCallbacks)
{
    assert(pCallbacks != NULL);
    m_pPlayerCallbacks = pCallbacks;
}

